# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
AppDef module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_appdef.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _AppDef.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_AppDef')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_AppDef')
    _AppDef = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_AppDef', [dirname(__file__)])
        except ImportError:
            import _AppDef
            return _AppDef
        try:
            _mod = imp.load_module('_AppDef', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _AppDef = swig_import_helper()
    del swig_import_helper
else:
    import _AppDef
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _AppDef.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_AppDef.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_AppDef.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_AppDef.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_AppDef.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_AppDef.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_AppDef.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_AppDef.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_AppDef.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_AppDef.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_AppDef.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_AppDef.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_AppDef.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_AppDef.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_AppDef.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_AppDef.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_AppDef.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _AppDef.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _AppDef.process_exception(error, method_name, class_name)
process_exception = _AppDef.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.math
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.gp
import OCC.Core.AppParCurves
import OCC.Core.TColgp
import OCC.Core.Approx
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.AppCont
import OCC.Core.FEmTool
import OCC.Core.PLib

def Handle_AppDef_SmoothCriterion_Create() -> "opencascade::handle< AppDef_SmoothCriterion >":
    return _AppDef.Handle_AppDef_SmoothCriterion_Create()
Handle_AppDef_SmoothCriterion_Create = _AppDef.Handle_AppDef_SmoothCriterion_Create

def Handle_AppDef_SmoothCriterion_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< AppDef_SmoothCriterion >":
    return _AppDef.Handle_AppDef_SmoothCriterion_DownCast(t)
Handle_AppDef_SmoothCriterion_DownCast = _AppDef.Handle_AppDef_SmoothCriterion_DownCast

def Handle_AppDef_SmoothCriterion_IsNull(t: 'opencascade::handle< AppDef_SmoothCriterion > const &') -> "bool":
    return _AppDef.Handle_AppDef_SmoothCriterion_IsNull(t)
Handle_AppDef_SmoothCriterion_IsNull = _AppDef.Handle_AppDef_SmoothCriterion_IsNull

def Handle_AppDef_LinearCriteria_Create() -> "opencascade::handle< AppDef_LinearCriteria >":
    return _AppDef.Handle_AppDef_LinearCriteria_Create()
Handle_AppDef_LinearCriteria_Create = _AppDef.Handle_AppDef_LinearCriteria_Create

def Handle_AppDef_LinearCriteria_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< AppDef_LinearCriteria >":
    return _AppDef.Handle_AppDef_LinearCriteria_DownCast(t)
Handle_AppDef_LinearCriteria_DownCast = _AppDef.Handle_AppDef_LinearCriteria_DownCast

def Handle_AppDef_LinearCriteria_IsNull(t: 'opencascade::handle< AppDef_LinearCriteria > const &') -> "bool":
    return _AppDef.Handle_AppDef_LinearCriteria_IsNull(t)
Handle_AppDef_LinearCriteria_IsNull = _AppDef.Handle_AppDef_LinearCriteria_IsNull

def Handle_AppDef_HArray1OfMultiPointConstraint_Create() -> "opencascade::handle< AppDef_HArray1OfMultiPointConstraint >":
    return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_Create()
Handle_AppDef_HArray1OfMultiPointConstraint_Create = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_Create

def Handle_AppDef_HArray1OfMultiPointConstraint_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< AppDef_HArray1OfMultiPointConstraint >":
    return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DownCast(t)
Handle_AppDef_HArray1OfMultiPointConstraint_DownCast = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DownCast

def Handle_AppDef_HArray1OfMultiPointConstraint_IsNull(t: 'opencascade::handle< AppDef_HArray1OfMultiPointConstraint > const &') -> "bool":
    return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_IsNull(t)
Handle_AppDef_HArray1OfMultiPointConstraint_IsNull = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_IsNull
class AppDef_Array1OfMultiPointConstraint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AppDef.AppDef_Array1OfMultiPointConstraint_swiginit(self, _AppDef.new_AppDef_Array1OfMultiPointConstraint(*args))
    __swig_destroy__ = _AppDef.delete_AppDef_Array1OfMultiPointConstraint

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

AppDef_Array1OfMultiPointConstraint.begin = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_begin, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.end = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_end, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.cbegin = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_cbegin, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.cend = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_cend, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Init = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Init, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Size = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Size, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Length = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Length, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.IsEmpty = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_IsEmpty, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Lower = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Lower, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Upper = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Upper, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.IsDeletable = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_IsDeletable, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.IsAllocated = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_IsAllocated, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Assign = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Assign, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Move = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Move, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Set = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Set, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.First = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_First, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.ChangeFirst = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_ChangeFirst, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Last = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Last, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.ChangeLast = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_ChangeLast, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Value = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Value, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.ChangeValue = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_ChangeValue, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.__call__ = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint___call__, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.SetValue = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_SetValue, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint.Resize = new_instancemethod(_AppDef.AppDef_Array1OfMultiPointConstraint_Resize, None, AppDef_Array1OfMultiPointConstraint)
AppDef_Array1OfMultiPointConstraint_swigregister = _AppDef.AppDef_Array1OfMultiPointConstraint_swigregister
AppDef_Array1OfMultiPointConstraint_swigregister(AppDef_Array1OfMultiPointConstraint)

class AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute
AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister
AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute)

class AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has <NbPol> control points.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute(*args))

    def CurveValue(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        * returns the MultiBSpCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_CurveValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the multiline.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FirstConstraint(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the multiline.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FunctionMatrix(self, *args)


    def Index(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Index(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiBSpCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiBSpCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_NewParameters(self, *args)


    def SetFirstLambda(self, *args) -> "void":
        """
        :param l1:
        	:type l1: float
        	:rtype: None
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetFirstLambda(self, *args)


    def SetLastLambda(self, *args) -> "void":
        """
        :param l2:
        	:type l2: float
        	:rtype: None
        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetLastLambda(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.CurveValue = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_CurveValue, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.DerivativeFunctionMatrix = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.Error = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Error, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.FirstConstraint = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FirstConstraint, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.FunctionMatrix = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FunctionMatrix, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.Index = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Index, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.LastConstraint = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_LastConstraint, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.MaxError2d = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError2d, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.MaxError3d = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError3d, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.NewParameters = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_NewParameters, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.SetFirstLambda = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetFirstLambda, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute.SetLastLambda = new_instancemethod(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetLastLambda, None, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)

class AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute(*args))

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.BSplineValue = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BSplineValue, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.BezierValue = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BezierValue, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.DerivativeFunctionMatrix = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.Distance = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Distance, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.Error = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Error, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.ErrorGradient = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_ErrorGradient, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.FirstLambda = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FirstLambda, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.FunctionMatrix = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FunctionMatrix, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.IsDone = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_IsDone, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.KIndex = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_KIndex, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.LastLambda = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_LastLambda, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.Perform = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Perform, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.Points = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Points, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute.Poles = new_instancemethod(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Poles, None, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)

class AppDef_BSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all. //! The multiplicities of the internal knots is set by default.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _AppDef.AppDef_BSplineCompute_swiginit(self, _AppDef.new_AppDef_BSplineCompute(*args))

    def ChangeValue(self, *args) -> "AppParCurves_MultiBSpCurve &":
        """
        * returns the result of the approximation.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_BSplineCompute_ChangeValue(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the tolerances 2d and 3d of the MultiBSpCurve.
        	:param tol3d:
        	:type tol3d: float
        	:param tol2d:
        	:type tol2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_Error(self, *args)


    def Init(self, *args) -> "void":
        """
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_Init(self, *args)


    def Interpol(self, *args) -> "void":
        """
        * Constructs an interpolation of the MultiLine <Line> The result will be a C2 curve of degree 3.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_Interpol(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        * returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.
        	:rtype: bool
        """
        return _AppDef.AppDef_BSplineCompute_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        * returns False if the status NoPointsAdded has been sent.
        	:rtype: bool
        """
        return _AppDef.AppDef_BSplineCompute_IsToleranceReached(self, *args)


    def Parameters(self, *args) -> "TColStd_Array1OfReal const &":
        """
        * returns the new parameters of the approximation corresponding to the points of the MultiBSpCurve.
        	:rtype: TColStd_Array1OfReal
        """
        return _AppDef.AppDef_BSplineCompute_Parameters(self, *args)


    def Perform(self, *args) -> "void":
        """
        * runs the algorithm after having initialized the fields.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        * changes the first and the last constraint points.
        	:param firstC:
        	:type firstC: AppParCurves_Constraint
        	:param lastC:
        	:type lastC: AppParCurves_Constraint
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_SetConstraints(self, *args)


    def SetContinuity(self, *args) -> "void":
        """
        * sets the continuity of the spline. if C = 2, the spline will be C2.
        	:param C:
        	:type C: int
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_SetContinuity(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        * changes the degrees of the approximation.
        	:param degreemin:
        	:type degreemin: int
        	:param degreemax:
        	:type degreemax: int
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_SetDegrees(self, *args)


    def SetKnots(self, *args) -> "void":
        """
        * The approximation will be done with the set of knots <Knots>. The multiplicities will be set with the degree and the desired continuity.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_SetKnots(self, *args)


    def SetKnotsAndMultiplicities(self, *args) -> "void":
        """
        * The approximation will be done with the set of knots <Knots> and the multiplicities <Mults>.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_SetKnotsAndMultiplicities(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        * The approximation will begin with the set of parameters <ThePar>.
        	:param ThePar:
        	:type ThePar: math_Vector
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_SetParameters(self, *args)


    def SetPeriodic(self, *args) -> "void":
        """
        * Sets periodic flag. If thePeriodic = Standard_True, algorith tries to build periodic multicurve using corresponding C1 boundary condition for first and last multipoints. Multiline must be closed.
        	:param thePeriodic:
        	:type thePeriodic: bool
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_SetPeriodic(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        * Changes the tolerances of the approximation.
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_BSplineCompute_SetTolerances(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_BSplineCompute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSplineCompute
AppDef_BSplineCompute.ChangeValue = new_instancemethod(_AppDef.AppDef_BSplineCompute_ChangeValue, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.Error = new_instancemethod(_AppDef.AppDef_BSplineCompute_Error, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.Init = new_instancemethod(_AppDef.AppDef_BSplineCompute_Init, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.Interpol = new_instancemethod(_AppDef.AppDef_BSplineCompute_Interpol, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.IsAllApproximated = new_instancemethod(_AppDef.AppDef_BSplineCompute_IsAllApproximated, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.IsToleranceReached = new_instancemethod(_AppDef.AppDef_BSplineCompute_IsToleranceReached, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.Parameters = new_instancemethod(_AppDef.AppDef_BSplineCompute_Parameters, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.Perform = new_instancemethod(_AppDef.AppDef_BSplineCompute_Perform, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.SetConstraints = new_instancemethod(_AppDef.AppDef_BSplineCompute_SetConstraints, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.SetContinuity = new_instancemethod(_AppDef.AppDef_BSplineCompute_SetContinuity, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.SetDegrees = new_instancemethod(_AppDef.AppDef_BSplineCompute_SetDegrees, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.SetKnots = new_instancemethod(_AppDef.AppDef_BSplineCompute_SetKnots, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.SetKnotsAndMultiplicities = new_instancemethod(_AppDef.AppDef_BSplineCompute_SetKnotsAndMultiplicities, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.SetParameters = new_instancemethod(_AppDef.AppDef_BSplineCompute_SetParameters, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.SetPeriodic = new_instancemethod(_AppDef.AppDef_BSplineCompute_SetPeriodic, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.SetTolerances = new_instancemethod(_AppDef.AppDef_BSplineCompute_SetTolerances, None, AppDef_BSplineCompute)
AppDef_BSplineCompute.Value = new_instancemethod(_AppDef.AppDef_BSplineCompute_Value, None, AppDef_BSplineCompute)
AppDef_BSplineCompute_swigregister = _AppDef.AppDef_BSplineCompute_swigregister
AppDef_BSplineCompute_swigregister(AppDef_BSplineCompute)

class AppDef_Compute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _AppDef.AppDef_Compute_swiginit(self, _AppDef.new_AppDef_Compute(*args))

    def ChangeValue(self, *args) -> "AppParCurves_MultiCurve &":
        """
        * returns the result of the approximation.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_Compute_ChangeValue(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the tolerances 2d and 3d of the <Index> MultiCurve.
        	:param Index:
        	:type Index: int
        	:param tol3d:
        	:type tol3d: float
        	:param tol2d:
        	:type tol2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_Compute_Error(self, *args)


    def Init(self, *args) -> "void":
        """
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        return _AppDef.AppDef_Compute_Init(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        * returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.
        	:rtype: bool
        """
        return _AppDef.AppDef_Compute_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        * returns False if the status NoPointsAdded has been sent.
        	:rtype: bool
        """
        return _AppDef.AppDef_Compute_IsToleranceReached(self, *args)


    def NbMultiCurves(self, *args) -> "Standard_Integer":
        """
        * Returns the number of MultiCurve doing the approximation of the MultiLine.
        	:rtype: int
        """
        return _AppDef.AppDef_Compute_NbMultiCurves(self, *args)


    def Parameters(self, *args) -> "TColStd_Array1OfReal const &":
        """
        * returns the new parameters of the approximation corresponding to the points of the multicurve <Index>.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: TColStd_Array1OfReal
        """
        return _AppDef.AppDef_Compute_Parameters(self, *args)


    def Parametrization(self, *args) -> "Approx_ParametrizationType":
        """
        * returns the type of parametrization
        	:rtype: Approx_ParametrizationType
        """
        return _AppDef.AppDef_Compute_Parametrization(self, *args)


    def Perform(self, *args) -> "void":
        """
        * runs the algorithm after having initialized the fields.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:rtype: None
        """
        return _AppDef.AppDef_Compute_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        * changes the first and the last constraint points.
        	:param firstC:
        	:type firstC: AppParCurves_Constraint
        	:param lastC:
        	:type lastC: AppParCurves_Constraint
        	:rtype: None
        """
        return _AppDef.AppDef_Compute_SetConstraints(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        * changes the degrees of the approximation.
        	:param degreemin:
        	:type degreemin: int
        	:param degreemax:
        	:type degreemax: int
        	:rtype: None
        """
        return _AppDef.AppDef_Compute_SetDegrees(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        * Changes the tolerances of the approximation.
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_Compute_SetTolerances(self, *args)


    def SplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_Compute_SplineValue(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the result of the approximation.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_Compute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Compute
AppDef_Compute.ChangeValue = new_instancemethod(_AppDef.AppDef_Compute_ChangeValue, None, AppDef_Compute)
AppDef_Compute.Error = new_instancemethod(_AppDef.AppDef_Compute_Error, None, AppDef_Compute)
AppDef_Compute.Init = new_instancemethod(_AppDef.AppDef_Compute_Init, None, AppDef_Compute)
AppDef_Compute.IsAllApproximated = new_instancemethod(_AppDef.AppDef_Compute_IsAllApproximated, None, AppDef_Compute)
AppDef_Compute.IsToleranceReached = new_instancemethod(_AppDef.AppDef_Compute_IsToleranceReached, None, AppDef_Compute)
AppDef_Compute.NbMultiCurves = new_instancemethod(_AppDef.AppDef_Compute_NbMultiCurves, None, AppDef_Compute)
AppDef_Compute.Parameters = new_instancemethod(_AppDef.AppDef_Compute_Parameters, None, AppDef_Compute)
AppDef_Compute.Parametrization = new_instancemethod(_AppDef.AppDef_Compute_Parametrization, None, AppDef_Compute)
AppDef_Compute.Perform = new_instancemethod(_AppDef.AppDef_Compute_Perform, None, AppDef_Compute)
AppDef_Compute.SetConstraints = new_instancemethod(_AppDef.AppDef_Compute_SetConstraints, None, AppDef_Compute)
AppDef_Compute.SetDegrees = new_instancemethod(_AppDef.AppDef_Compute_SetDegrees, None, AppDef_Compute)
AppDef_Compute.SetTolerances = new_instancemethod(_AppDef.AppDef_Compute_SetTolerances, None, AppDef_Compute)
AppDef_Compute.SplineValue = new_instancemethod(_AppDef.AppDef_Compute_SplineValue, None, AppDef_Compute)
AppDef_Compute.Value = new_instancemethod(_AppDef.AppDef_Compute_Value, None, AppDef_Compute)
AppDef_Compute_swigregister = _AppDef.AppDef_Compute_swigregister
AppDef_Compute_swigregister(AppDef_Compute)

class AppDef_Gradient_BFGSOfMyGradientOfCompute(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_Gradient_BFGSOfMyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_Gradient_BFGSOfMyGradientOfCompute(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfMyGradientOfCompute
AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister = _AppDef.AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister
AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister(AppDef_Gradient_BFGSOfMyGradientOfCompute)

class AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute
AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister
AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister(AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute)

class AppDef_Gradient_BFGSOfTheGradient(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_Gradient_BFGSOfTheGradient_swiginit(self, _AppDef.new_AppDef_Gradient_BFGSOfTheGradient(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfTheGradient
AppDef_Gradient_BFGSOfTheGradient_swigregister = _AppDef.AppDef_Gradient_BFGSOfTheGradient_swigregister
AppDef_Gradient_BFGSOfTheGradient_swigregister(AppDef_Gradient_BFGSOfTheGradient)

class AppDef_MultiLine(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * creates an undefined MultiLine.
        	:rtype: None
        * given the number NbMult of MultiPointConstraints of this MultiLine , it initializes all the fields.SetValue must be called in order for the values of the multipoint constraint to be taken into account. An exception is raised if NbMult < 0.
        	:param NbMult:
        	:type NbMult: int
        	:rtype: None
        * Constructs a MultiLine with an array of MultiPointConstraints.
        	:param tabMultiP:
        	:type tabMultiP: AppDef_Array1OfMultiPointConstraint
        	:rtype: None
        * The MultiLine constructed will have one line of 3d points without their tangencies.
        	:param tabP3d:
        	:type tabP3d: TColgp_Array1OfPnt
        	:rtype: None
        * The MultiLine constructed will have one line of 2d points without their tangencies.
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:rtype: None
        """
        _AppDef.AppDef_MultiLine_swiginit(self, _AppDef.new_AppDef_MultiLine(*args))

    def DumpToString(self) -> "std::string":
        """DumpToString(AppDef_MultiLine self) -> std::string"""
        return _AppDef.AppDef_MultiLine_DumpToString(self)


    def NbMultiPoints(self, *args) -> "Standard_Integer":
        """
        * returns the number of MultiPointConstraints of the MultiLine.
        	:rtype: int
        """
        return _AppDef.AppDef_MultiLine_NbMultiPoints(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * returns the number of Points from MultiPoints composing the MultiLine.
        	:rtype: int
        """
        return _AppDef.AppDef_MultiLine_NbPoints(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * It sets the MultiPointConstraint of range Index to the value MPoint. An exception is raised if Index < 0 or Index> MPoint. An exception is raised if the dimensions of the MultiPoints are different.
        	:param Index:
        	:type Index: int
        	:param MPoint:
        	:type MPoint: AppDef_MultiPointConstraint
        	:rtype: None
        """
        return _AppDef.AppDef_MultiLine_SetValue(self, *args)


    def Value(self, *args) -> "AppDef_MultiPointConstraint":
        """
        * returns the MultiPointConstraint of range Index An exception is raised if Index<0 or Index>MPoint.
        	:param Index:
        	:type Index: int
        	:rtype: AppDef_MultiPointConstraint
        """
        return _AppDef.AppDef_MultiLine_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MultiLine
AppDef_MultiLine.DumpToString = new_instancemethod(_AppDef.AppDef_MultiLine_DumpToString, None, AppDef_MultiLine)
AppDef_MultiLine.NbMultiPoints = new_instancemethod(_AppDef.AppDef_MultiLine_NbMultiPoints, None, AppDef_MultiLine)
AppDef_MultiLine.NbPoints = new_instancemethod(_AppDef.AppDef_MultiLine_NbPoints, None, AppDef_MultiLine)
AppDef_MultiLine.SetValue = new_instancemethod(_AppDef.AppDef_MultiLine_SetValue, None, AppDef_MultiLine)
AppDef_MultiLine.Value = new_instancemethod(_AppDef.AppDef_MultiLine_Value, None, AppDef_MultiLine)
AppDef_MultiLine_swigregister = _AppDef.AppDef_MultiLine_swigregister
AppDef_MultiLine_swigregister(AppDef_MultiLine)

class AppDef_MultiPointConstraint(OCC.Core.AppParCurves.AppParCurves_MultiPoint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * creates an undefined MultiPointConstraint.
        	:rtype: None
        * constructs a set of Points used to approximate a Multiline. These Points can be of 2 or 3 dimensions. Points will be initialized with SetPoint and SetPoint2d.
        	:param NbPoints:
        	:type NbPoints: int
        	:param NbPoints2d:
        	:type NbPoints2d: int
        	:rtype: None
        * creates a MultiPoint only composed of 3D points.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:rtype: None
        * creates a MultiPoint only composed of 2D points.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt2d
        	:rtype: None
        * constructs a set of Points used to approximate a Multiline. These Points can be of 2 or 3 dimensions. Points will be initialized with SetPoint and SetPoint2d.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:rtype: None
        * creates a MultiPointConstraint with a constraint of Curvature. An exception is raised if (length of <tabP> + length of <tabP2d> ) is different from (length of <tabVec> + length of <tabVec2d> ) or from (length of <tabCur> + length of <tabCur2d> )
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:param tabVec:
        	:type tabVec: TColgp_Array1OfVec
        	:param tabVec2d:
        	:type tabVec2d: TColgp_Array1OfVec2d
        	:param tabCur:
        	:type tabCur: TColgp_Array1OfVec
        	:param tabCur2d:
        	:type tabCur2d: TColgp_Array1OfVec2d
        	:rtype: None
        * creates a MultiPointConstraint with a constraint of Tangency. An exception is raised if (length of <tabP> + length of <tabP2d> ) is different from (length of <tabVec> + length of <tabVec2d> )
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:param tabVec:
        	:type tabVec: TColgp_Array1OfVec
        	:param tabVec2d:
        	:type tabVec2d: TColgp_Array1OfVec2d
        	:rtype: None
        * creates a MultiPointConstraint only composed of 3d points with constraints of curvature. An exception is raised if the length of tabP is different from the length of tabVec or from tabCur.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabVec:
        	:type tabVec: TColgp_Array1OfVec
        	:param tabCur:
        	:type tabCur: TColgp_Array1OfVec
        	:rtype: None
        * creates a MultiPointConstraint only composed of 3d points with constraints of tangency. An exception is raised if the length of tabP is different from the length of tabVec.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabVec:
        	:type tabVec: TColgp_Array1OfVec
        	:rtype: None
        * creates a MultiPointConstraint only composed of 2d points with constraints of tangency. An exception is raised if the length of tabP is different from the length of tabVec2d.
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:param tabVec2d:
        	:type tabVec2d: TColgp_Array1OfVec2d
        	:rtype: None
        * creates a MultiPointConstraint only composed of 2d points with constraints of curvature. An exception is raised if the length of tabP is different from the length of tabVec2d or from tabCur2d.
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:param tabVec2d:
        	:type tabVec2d: TColgp_Array1OfVec2d
        	:param tabCur2d:
        	:type tabCur2d: TColgp_Array1OfVec2d
        	:rtype: None
        """
        _AppDef.AppDef_MultiPointConstraint_swiginit(self, _AppDef.new_AppDef_MultiPointConstraint(*args))

    def Curv(self, *args) -> "gp_Vec":
        """
        * returns the normal vector at the point of range Index. An exception is raised if Index < 0 or if Index > number of 3d points.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Vec
        """
        return _AppDef.AppDef_MultiPointConstraint_Curv(self, *args)


    def Curv2d(self, *args) -> "gp_Vec2d":
        """
        * returns the normal vector at the point of range Index. An exception is raised if Index < 0 or if Index > number of 3d points.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Vec2d
        """
        return _AppDef.AppDef_MultiPointConstraint_Curv2d(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(AppDef_MultiPointConstraint self) -> std::string"""
        return _AppDef.AppDef_MultiPointConstraint_DumpToString(self)


    def IsCurvaturePoint(self, *args) -> "Standard_Boolean":
        """
        * returns True if the MultiPoint has a curvature value.
        	:rtype: bool
        """
        return _AppDef.AppDef_MultiPointConstraint_IsCurvaturePoint(self, *args)


    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        * returns True if the MultiPoint has a tangency value.
        	:rtype: bool
        """
        return _AppDef.AppDef_MultiPointConstraint_IsTangencyPoint(self, *args)


    def SetCurv(self, *args) -> "void":
        """
        * Vec sets the value of the normal vector at the point of index Index. The norm of the normal vector at the point of position Index is set to the normal curvature. An exception is raised if Index <0 or if Index > number of 3d points. An exception is raised if Curv has an incorrect number of dimensions.
        	:param Index:
        	:type Index: int
        	:param Curv:
        	:type Curv: gp_Vec
        	:rtype: None
        """
        return _AppDef.AppDef_MultiPointConstraint_SetCurv(self, *args)


    def SetCurv2d(self, *args) -> "void":
        """
        * Vec sets the value of the normal vector at the point of index Index. The norm of the normal vector at the point of position Index is set to the normal curvature. An exception is raised if Index <0 or if Index > number of 3d points. An exception is raised if Curv has an incorrect number of dimensions.
        	:param Index:
        	:type Index: int
        	:param Curv2d:
        	:type Curv2d: gp_Vec2d
        	:rtype: None
        """
        return _AppDef.AppDef_MultiPointConstraint_SetCurv2d(self, *args)


    def SetTang(self, *args) -> "void":
        """
        * sets the value of the tangency of the point of range Index. An exception is raised if Index <0 or if Index > number of 3d points. An exception is raised if Tang has an incorrect number of dimensions.
        	:param Index:
        	:type Index: int
        	:param Tang:
        	:type Tang: gp_Vec
        	:rtype: None
        """
        return _AppDef.AppDef_MultiPointConstraint_SetTang(self, *args)


    def SetTang2d(self, *args) -> "void":
        """
        * sets the value of the tangency of the point of range Index. An exception is raised if Index <number of 3d points or if Index > total number of Points An exception is raised if Tang has an incorrect number of dimensions.
        	:param Index:
        	:type Index: int
        	:param Tang2d:
        	:type Tang2d: gp_Vec2d
        	:rtype: None
        """
        return _AppDef.AppDef_MultiPointConstraint_SetTang2d(self, *args)


    def Tang(self, *args) -> "gp_Vec":
        """
        * returns the tangency value of the point of range Index. An exception is raised if Index < 0 or if Index > number of 3d points.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Vec
        """
        return _AppDef.AppDef_MultiPointConstraint_Tang(self, *args)


    def Tang2d(self, *args) -> "gp_Vec2d":
        """
        * returns the tangency value of the point of range Index. An exception is raised if Index < number of 3d points or if Index > total number of points.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Vec2d
        """
        return _AppDef.AppDef_MultiPointConstraint_Tang2d(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MultiPointConstraint
AppDef_MultiPointConstraint.Curv = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_Curv, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.Curv2d = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_Curv2d, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.DumpToString = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_DumpToString, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.IsCurvaturePoint = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_IsCurvaturePoint, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.IsTangencyPoint = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_IsTangencyPoint, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.SetCurv = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_SetCurv, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.SetCurv2d = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_SetCurv2d, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.SetTang = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_SetTang, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.SetTang2d = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_SetTang2d, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.Tang = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_Tang, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint.Tang2d = new_instancemethod(_AppDef.AppDef_MultiPointConstraint_Tang2d, None, AppDef_MultiPointConstraint)
AppDef_MultiPointConstraint_swigregister = _AppDef.AppDef_MultiPointConstraint_swigregister
AppDef_MultiPointConstraint_swigregister(AppDef_MultiPointConstraint)

class AppDef_MyBSplGradientOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 1
        	:type NbIterations: int
        	:rtype: None
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations:
        	:type NbIterations: int
        	:param lambda1:
        	:type lambda1: float
        	:param lambda2:
        	:type lambda2: float
        	:rtype: None
        """
        _AppDef.AppDef_MyBSplGradientOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_MyBSplGradientOfBSplineCompute(*args))

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        * returns all the BSpline curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MyBSplGradientOfBSplineCompute
AppDef_MyBSplGradientOfBSplineCompute.AverageError = new_instancemethod(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_AverageError, None, AppDef_MyBSplGradientOfBSplineCompute)
AppDef_MyBSplGradientOfBSplineCompute.Error = new_instancemethod(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_Error, None, AppDef_MyBSplGradientOfBSplineCompute)
AppDef_MyBSplGradientOfBSplineCompute.IsDone = new_instancemethod(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_IsDone, None, AppDef_MyBSplGradientOfBSplineCompute)
AppDef_MyBSplGradientOfBSplineCompute.MaxError2d = new_instancemethod(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError2d, None, AppDef_MyBSplGradientOfBSplineCompute)
AppDef_MyBSplGradientOfBSplineCompute.MaxError3d = new_instancemethod(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError3d, None, AppDef_MyBSplGradientOfBSplineCompute)
AppDef_MyBSplGradientOfBSplineCompute.Value = new_instancemethod(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_Value, None, AppDef_MyBSplGradientOfBSplineCompute)
AppDef_MyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_MyBSplGradientOfBSplineCompute_swigregister
AppDef_MyBSplGradientOfBSplineCompute_swigregister(AppDef_MyBSplGradientOfBSplineCompute)

class AppDef_MyGradientOfCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_MyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_MyGradientOfCompute(*args))

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_MyGradientOfCompute_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _AppDef.AppDef_MyGradientOfCompute_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_MyGradientOfCompute_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_MyGradientOfCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_MyGradientOfCompute_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_MyGradientOfCompute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MyGradientOfCompute
AppDef_MyGradientOfCompute.AverageError = new_instancemethod(_AppDef.AppDef_MyGradientOfCompute_AverageError, None, AppDef_MyGradientOfCompute)
AppDef_MyGradientOfCompute.Error = new_instancemethod(_AppDef.AppDef_MyGradientOfCompute_Error, None, AppDef_MyGradientOfCompute)
AppDef_MyGradientOfCompute.IsDone = new_instancemethod(_AppDef.AppDef_MyGradientOfCompute_IsDone, None, AppDef_MyGradientOfCompute)
AppDef_MyGradientOfCompute.MaxError2d = new_instancemethod(_AppDef.AppDef_MyGradientOfCompute_MaxError2d, None, AppDef_MyGradientOfCompute)
AppDef_MyGradientOfCompute.MaxError3d = new_instancemethod(_AppDef.AppDef_MyGradientOfCompute_MaxError3d, None, AppDef_MyGradientOfCompute)
AppDef_MyGradientOfCompute.Value = new_instancemethod(_AppDef.AppDef_MyGradientOfCompute_Value, None, AppDef_MyGradientOfCompute)
AppDef_MyGradientOfCompute_swigregister = _AppDef.AppDef_MyGradientOfCompute_swigregister
AppDef_MyGradientOfCompute_swigregister(AppDef_MyGradientOfCompute)

class AppDef_MyGradientbisOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_MyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_MyGradientbisOfBSplineCompute(*args))

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MyGradientbisOfBSplineCompute
AppDef_MyGradientbisOfBSplineCompute.AverageError = new_instancemethod(_AppDef.AppDef_MyGradientbisOfBSplineCompute_AverageError, None, AppDef_MyGradientbisOfBSplineCompute)
AppDef_MyGradientbisOfBSplineCompute.Error = new_instancemethod(_AppDef.AppDef_MyGradientbisOfBSplineCompute_Error, None, AppDef_MyGradientbisOfBSplineCompute)
AppDef_MyGradientbisOfBSplineCompute.IsDone = new_instancemethod(_AppDef.AppDef_MyGradientbisOfBSplineCompute_IsDone, None, AppDef_MyGradientbisOfBSplineCompute)
AppDef_MyGradientbisOfBSplineCompute.MaxError2d = new_instancemethod(_AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError2d, None, AppDef_MyGradientbisOfBSplineCompute)
AppDef_MyGradientbisOfBSplineCompute.MaxError3d = new_instancemethod(_AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError3d, None, AppDef_MyGradientbisOfBSplineCompute)
AppDef_MyGradientbisOfBSplineCompute.Value = new_instancemethod(_AppDef.AppDef_MyGradientbisOfBSplineCompute_Value, None, AppDef_MyGradientbisOfBSplineCompute)
AppDef_MyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_MyGradientbisOfBSplineCompute_swigregister
AppDef_MyGradientbisOfBSplineCompute_swigregister(AppDef_MyGradientbisOfBSplineCompute)

class AppDef_MyLineTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Curvature(*args) -> "Standard_Boolean":
        """
        * returns the 3d curvatures of the multipoint <MPointIndex> when only 3d points exist.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:rtype: bool
        * returns the 2d curvatures of the multipoint <MPointIndex> only when 2d points exist.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        * returns the 3d and 2d curvatures of the multipoint <MPointIndex>.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _AppDef.AppDef_MyLineTool_Curvature(*args)

    Curvature = staticmethod(Curvature)

    def FirstPoint(*args) -> "Standard_Integer":
        """
        * Returns the first index of multipoints of the MultiLine.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:rtype: int
        """
        return _AppDef.AppDef_MyLineTool_FirstPoint(*args)

    FirstPoint = staticmethod(FirstPoint)

    def LastPoint(*args) -> "Standard_Integer":
        """
        * Returns the last index of multipoints of the MultiLine.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:rtype: int
        """
        return _AppDef.AppDef_MyLineTool_LastPoint(*args)

    LastPoint = staticmethod(LastPoint)

    def MakeMLBetween(*args) -> "AppDef_MultiLine":
        """
        * Is never called in the algorithms. Nothing is done.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:param NbPMin:
        	:type NbPMin: int
        	:rtype: AppDef_MultiLine
        """
        return _AppDef.AppDef_MyLineTool_MakeMLBetween(*args)

    MakeMLBetween = staticmethod(MakeMLBetween)

    def MakeMLOneMorePoint(*args) -> "Standard_Boolean":
        """
        * Is never called in the algorithms. Nothing is done.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:param indbad:
        	:type indbad: int
        	:param OtherLine:
        	:type OtherLine: AppDef_MultiLine
        	:rtype: bool
        """
        return _AppDef.AppDef_MyLineTool_MakeMLOneMorePoint(*args)

    MakeMLOneMorePoint = staticmethod(MakeMLOneMorePoint)

    def NbP2d(*args) -> "Standard_Integer":
        """
        * Returns the number of 2d points of a MultiLine.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:rtype: int
        """
        return _AppDef.AppDef_MyLineTool_NbP2d(*args)

    NbP2d = staticmethod(NbP2d)

    def NbP3d(*args) -> "Standard_Integer":
        """
        * Returns the number of 3d points of a MultiLine.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:rtype: int
        """
        return _AppDef.AppDef_MyLineTool_NbP3d(*args)

    NbP3d = staticmethod(NbP3d)

    def Tangency(*args) -> "Standard_Boolean":
        """
        * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:rtype: bool
        * returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        * returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _AppDef.AppDef_MyLineTool_Tangency(*args)

    Tangency = staticmethod(Tangency)

    def Value(*args) -> "void":
        """
        * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:rtype: void
        * returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: void
        * returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: void
        """
        return _AppDef.AppDef_MyLineTool_Value(*args)

    Value = staticmethod(Value)

    def WhatStatus(*args) -> "Approx_Status":
        """
        * returns NoPointsAdded
        	:param ML:
        	:type ML: AppDef_MultiLine
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:rtype: Approx_Status
        """
        return _AppDef.AppDef_MyLineTool_WhatStatus(*args)

    WhatStatus = staticmethod(WhatStatus)

    __repr__ = _dumps_object


    def __init__(self):
        _AppDef.AppDef_MyLineTool_swiginit(self, _AppDef.new_AppDef_MyLineTool())
    __swig_destroy__ = _AppDef.delete_AppDef_MyLineTool
AppDef_MyLineTool_swigregister = _AppDef.AppDef_MyLineTool_swigregister
AppDef_MyLineTool_swigregister(AppDef_MyLineTool)

def AppDef_MyLineTool_Curvature(*args) -> "Standard_Boolean":
    """
    * returns the 3d curvatures of the multipoint <MPointIndex> when only 3d points exist.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:rtype: bool
    * returns the 2d curvatures of the multipoint <MPointIndex> only when 2d points exist.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    * returns the 3d and 2d curvatures of the multipoint <MPointIndex>.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    """
    return _AppDef.AppDef_MyLineTool_Curvature(*args)

def AppDef_MyLineTool_FirstPoint(*args) -> "Standard_Integer":
    """
    * Returns the first index of multipoints of the MultiLine.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:rtype: int
    """
    return _AppDef.AppDef_MyLineTool_FirstPoint(*args)

def AppDef_MyLineTool_LastPoint(*args) -> "Standard_Integer":
    """
    * Returns the last index of multipoints of the MultiLine.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:rtype: int
    """
    return _AppDef.AppDef_MyLineTool_LastPoint(*args)

def AppDef_MyLineTool_MakeMLBetween(*args) -> "AppDef_MultiLine":
    """
    * Is never called in the algorithms. Nothing is done.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:param NbPMin:
    	:type NbPMin: int
    	:rtype: AppDef_MultiLine
    """
    return _AppDef.AppDef_MyLineTool_MakeMLBetween(*args)

def AppDef_MyLineTool_MakeMLOneMorePoint(*args) -> "Standard_Boolean":
    """
    * Is never called in the algorithms. Nothing is done.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:param indbad:
    	:type indbad: int
    	:param OtherLine:
    	:type OtherLine: AppDef_MultiLine
    	:rtype: bool
    """
    return _AppDef.AppDef_MyLineTool_MakeMLOneMorePoint(*args)

def AppDef_MyLineTool_NbP2d(*args) -> "Standard_Integer":
    """
    * Returns the number of 2d points of a MultiLine.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:rtype: int
    """
    return _AppDef.AppDef_MyLineTool_NbP2d(*args)

def AppDef_MyLineTool_NbP3d(*args) -> "Standard_Integer":
    """
    * Returns the number of 3d points of a MultiLine.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:rtype: int
    """
    return _AppDef.AppDef_MyLineTool_NbP3d(*args)

def AppDef_MyLineTool_Tangency(*args) -> "Standard_Boolean":
    """
    * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:rtype: bool
    * returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    * returns the 3d and 2d points of the multipoint <MPointIndex>.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    """
    return _AppDef.AppDef_MyLineTool_Tangency(*args)

def AppDef_MyLineTool_Value(*args) -> "void":
    """
    * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabPt:
    	:type tabPt: TColgp_Array1OfPnt
    	:rtype: void
    * returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabPt2d:
    	:type tabPt2d: TColgp_Array1OfPnt2d
    	:rtype: void
    * returns the 3d and 2d points of the multipoint <MPointIndex>.
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabPt:
    	:type tabPt: TColgp_Array1OfPnt
    	:param tabPt2d:
    	:type tabPt2d: TColgp_Array1OfPnt2d
    	:rtype: void
    """
    return _AppDef.AppDef_MyLineTool_Value(*args)

def AppDef_MyLineTool_WhatStatus(*args) -> "Approx_Status":
    """
    * returns NoPointsAdded
    	:param ML:
    	:type ML: AppDef_MultiLine
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:rtype: Approx_Status
    """
    return _AppDef.AppDef_MyLineTool_WhatStatus(*args)

class AppDef_ParFunctionOfMyGradientOfCompute(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_ParFunctionOfMyGradientOfCompute(*args))

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the MultiCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfMyGradientOfCompute
AppDef_ParFunctionOfMyGradientOfCompute.CurveValue = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_CurveValue, None, AppDef_ParFunctionOfMyGradientOfCompute)
AppDef_ParFunctionOfMyGradientOfCompute.Error = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_Error, None, AppDef_ParFunctionOfMyGradientOfCompute)
AppDef_ParFunctionOfMyGradientOfCompute.FirstConstraint = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_FirstConstraint, None, AppDef_ParFunctionOfMyGradientOfCompute)
AppDef_ParFunctionOfMyGradientOfCompute.LastConstraint = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_LastConstraint, None, AppDef_ParFunctionOfMyGradientOfCompute)
AppDef_ParFunctionOfMyGradientOfCompute.MaxError2d = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError2d, None, AppDef_ParFunctionOfMyGradientOfCompute)
AppDef_ParFunctionOfMyGradientOfCompute.MaxError3d = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError3d, None, AppDef_ParFunctionOfMyGradientOfCompute)
AppDef_ParFunctionOfMyGradientOfCompute.NewParameters = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_NewParameters, None, AppDef_ParFunctionOfMyGradientOfCompute)
AppDef_ParFunctionOfMyGradientOfCompute_swigregister = _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_swigregister
AppDef_ParFunctionOfMyGradientOfCompute_swigregister(AppDef_ParFunctionOfMyGradientOfCompute)

class AppDef_ParFunctionOfMyGradientbisOfBSplineCompute(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_ParFunctionOfMyGradientbisOfBSplineCompute(*args))

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the MultiCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfMyGradientbisOfBSplineCompute
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute.CurveValue = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_CurveValue, None, AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute.Error = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_Error, None, AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute.FirstConstraint = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_FirstConstraint, None, AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute.LastConstraint = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_LastConstraint, None, AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute.MaxError2d = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError2d, None, AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute.MaxError3d = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError3d, None, AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute.NewParameters = new_instancemethod(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_NewParameters, None, AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)

class AppDef_ParFunctionOfTheGradient(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _AppDef.AppDef_ParFunctionOfTheGradient_swiginit(self, _AppDef.new_AppDef_ParFunctionOfTheGradient(*args))

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the MultiCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfTheGradient
AppDef_ParFunctionOfTheGradient.CurveValue = new_instancemethod(_AppDef.AppDef_ParFunctionOfTheGradient_CurveValue, None, AppDef_ParFunctionOfTheGradient)
AppDef_ParFunctionOfTheGradient.Error = new_instancemethod(_AppDef.AppDef_ParFunctionOfTheGradient_Error, None, AppDef_ParFunctionOfTheGradient)
AppDef_ParFunctionOfTheGradient.FirstConstraint = new_instancemethod(_AppDef.AppDef_ParFunctionOfTheGradient_FirstConstraint, None, AppDef_ParFunctionOfTheGradient)
AppDef_ParFunctionOfTheGradient.LastConstraint = new_instancemethod(_AppDef.AppDef_ParFunctionOfTheGradient_LastConstraint, None, AppDef_ParFunctionOfTheGradient)
AppDef_ParFunctionOfTheGradient.MaxError2d = new_instancemethod(_AppDef.AppDef_ParFunctionOfTheGradient_MaxError2d, None, AppDef_ParFunctionOfTheGradient)
AppDef_ParFunctionOfTheGradient.MaxError3d = new_instancemethod(_AppDef.AppDef_ParFunctionOfTheGradient_MaxError3d, None, AppDef_ParFunctionOfTheGradient)
AppDef_ParFunctionOfTheGradient.NewParameters = new_instancemethod(_AppDef.AppDef_ParFunctionOfTheGradient_NewParameters, None, AppDef_ParFunctionOfTheGradient)
AppDef_ParFunctionOfTheGradient_swigregister = _AppDef.AppDef_ParFunctionOfTheGradient_swigregister
AppDef_ParFunctionOfTheGradient_swigregister(AppDef_ParFunctionOfTheGradient)

class AppDef_ParLeastSquareOfMyGradientOfCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_ParLeastSquareOfMyGradientOfCompute(*args))

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfMyGradientOfCompute
AppDef_ParLeastSquareOfMyGradientOfCompute.BSplineValue = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BSplineValue, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.BezierValue = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BezierValue, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.DerivativeFunctionMatrix = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_DerivativeFunctionMatrix, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.Distance = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Distance, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.Error = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Error, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.ErrorGradient = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_ErrorGradient, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.FirstLambda = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FirstLambda, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.FunctionMatrix = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FunctionMatrix, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.IsDone = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_IsDone, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.KIndex = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_KIndex, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.LastLambda = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_LastLambda, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.Perform = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Perform, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.Points = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Points, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute.Poles = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Poles, None, AppDef_ParLeastSquareOfMyGradientOfCompute)
AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister
AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister(AppDef_ParLeastSquareOfMyGradientOfCompute)

class AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute(*args))

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.BSplineValue = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BSplineValue, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.BezierValue = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BezierValue, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.DerivativeFunctionMatrix = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_DerivativeFunctionMatrix, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.Distance = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Distance, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.Error = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Error, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.ErrorGradient = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_ErrorGradient, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.FirstLambda = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FirstLambda, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.FunctionMatrix = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FunctionMatrix, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.IsDone = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_IsDone, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.KIndex = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_KIndex, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.LastLambda = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_LastLambda, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.Perform = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Perform, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.Points = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Points, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute.Poles = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Poles, None, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)

class AppDef_ParLeastSquareOfTheGradient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_ParLeastSquareOfTheGradient_swiginit(self, _AppDef.new_AppDef_ParLeastSquareOfTheGradient(*args))

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfTheGradient
AppDef_ParLeastSquareOfTheGradient.BSplineValue = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_BSplineValue, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.BezierValue = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_BezierValue, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.DerivativeFunctionMatrix = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_DerivativeFunctionMatrix, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.Distance = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_Distance, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.Error = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_Error, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.ErrorGradient = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_ErrorGradient, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.FirstLambda = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_FirstLambda, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.FunctionMatrix = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_FunctionMatrix, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.IsDone = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_IsDone, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.KIndex = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_KIndex, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.LastLambda = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_LastLambda, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.Perform = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_Perform, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.Points = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_Points, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient.Poles = new_instancemethod(_AppDef.AppDef_ParLeastSquareOfTheGradient_Poles, None, AppDef_ParLeastSquareOfTheGradient)
AppDef_ParLeastSquareOfTheGradient_swigregister = _AppDef.AppDef_ParLeastSquareOfTheGradient_swigregister
AppDef_ParLeastSquareOfTheGradient_swigregister(AppDef_ParLeastSquareOfTheGradient)

class AppDef_ResConstraintOfMyGradientOfCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_ResConstraintOfMyGradientOfCompute(*args))

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        * Returns the derivative of the constraint matrix.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param DA:
        	:type DA: math_Matrix
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """:rtype: math_Matrix"""
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        * returns the duale variables of the system.
        	:rtype: math_Vector
        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_IsDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfMyGradientOfCompute
AppDef_ResConstraintOfMyGradientOfCompute.ConstraintDerivative = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintDerivative, None, AppDef_ResConstraintOfMyGradientOfCompute)
AppDef_ResConstraintOfMyGradientOfCompute.ConstraintMatrix = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintMatrix, None, AppDef_ResConstraintOfMyGradientOfCompute)
AppDef_ResConstraintOfMyGradientOfCompute.Duale = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_Duale, None, AppDef_ResConstraintOfMyGradientOfCompute)
AppDef_ResConstraintOfMyGradientOfCompute.InverseMatrix = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_InverseMatrix, None, AppDef_ResConstraintOfMyGradientOfCompute)
AppDef_ResConstraintOfMyGradientOfCompute.IsDone = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_IsDone, None, AppDef_ResConstraintOfMyGradientOfCompute)
AppDef_ResConstraintOfMyGradientOfCompute_swigregister = _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_swigregister
AppDef_ResConstraintOfMyGradientOfCompute_swigregister(AppDef_ResConstraintOfMyGradientOfCompute)

class AppDef_ResConstraintOfMyGradientbisOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_ResConstraintOfMyGradientbisOfBSplineCompute(*args))

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        * Returns the derivative of the constraint matrix.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param DA:
        	:type DA: math_Matrix
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """:rtype: math_Matrix"""
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        * returns the duale variables of the system.
        	:rtype: math_Vector
        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_IsDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfMyGradientbisOfBSplineCompute
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute.ConstraintDerivative = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintDerivative, None, AppDef_ResConstraintOfMyGradientbisOfBSplineCompute)
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute.ConstraintMatrix = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintMatrix, None, AppDef_ResConstraintOfMyGradientbisOfBSplineCompute)
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute.Duale = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_Duale, None, AppDef_ResConstraintOfMyGradientbisOfBSplineCompute)
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute.InverseMatrix = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_InverseMatrix, None, AppDef_ResConstraintOfMyGradientbisOfBSplineCompute)
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute.IsDone = new_instancemethod(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_IsDone, None, AppDef_ResConstraintOfMyGradientbisOfBSplineCompute)
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ResConstraintOfMyGradientbisOfBSplineCompute)

class AppDef_ResConstraintOfTheGradient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _AppDef.AppDef_ResConstraintOfTheGradient_swiginit(self, _AppDef.new_AppDef_ResConstraintOfTheGradient(*args))

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        * Returns the derivative of the constraint matrix.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param DA:
        	:type DA: math_Matrix
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """:rtype: math_Matrix"""
        return _AppDef.AppDef_ResConstraintOfTheGradient_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        * returns the duale variables of the system.
        	:rtype: math_Vector
        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_IsDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfTheGradient
AppDef_ResConstraintOfTheGradient.ConstraintDerivative = new_instancemethod(_AppDef.AppDef_ResConstraintOfTheGradient_ConstraintDerivative, None, AppDef_ResConstraintOfTheGradient)
AppDef_ResConstraintOfTheGradient.ConstraintMatrix = new_instancemethod(_AppDef.AppDef_ResConstraintOfTheGradient_ConstraintMatrix, None, AppDef_ResConstraintOfTheGradient)
AppDef_ResConstraintOfTheGradient.Duale = new_instancemethod(_AppDef.AppDef_ResConstraintOfTheGradient_Duale, None, AppDef_ResConstraintOfTheGradient)
AppDef_ResConstraintOfTheGradient.InverseMatrix = new_instancemethod(_AppDef.AppDef_ResConstraintOfTheGradient_InverseMatrix, None, AppDef_ResConstraintOfTheGradient)
AppDef_ResConstraintOfTheGradient.IsDone = new_instancemethod(_AppDef.AppDef_ResConstraintOfTheGradient_IsDone, None, AppDef_ResConstraintOfTheGradient)
AppDef_ResConstraintOfTheGradient_swigregister = _AppDef.AppDef_ResConstraintOfTheGradient_swigregister
AppDef_ResConstraintOfTheGradient_swigregister(AppDef_ResConstraintOfTheGradient)

class AppDef_SmoothCriterion(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AssemblyTable(self, *args) -> "opencascade::handle< FEmTool_HAssemblyTable >":
        """:rtype: opencascade::handle<FEmTool_HAssemblyTable>"""
        return _AppDef.AppDef_SmoothCriterion_AssemblyTable(self, *args)


    def DependenceTable(self, *args) -> "opencascade::handle< TColStd_HArray2OfInteger >":
        """:rtype: opencascade::handle<TColStd_HArray2OfInteger>"""
        return _AppDef.AppDef_SmoothCriterion_DependenceTable(self, *args)


    def ErrorValues(self, *args) -> "void":
        """
        :param MaxError:
        	:type MaxError: float
        	:param QuadraticError:
        	:type QuadraticError: float
        	:param AverageError:
        	:type AverageError: float
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_ErrorValues(self, *args)


    def EstLength(self, *args) -> "Standard_Real &":
        """:rtype: float"""
        return _AppDef.AppDef_SmoothCriterion_EstLength(self, *args)


    def GetCurve(self, *args) -> "void":
        """
        :param C:
        	:type C: FEmTool_Curve
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_GetCurve(self, *args)


    def GetEstimation(self, *args) -> "void":
        """
        :param E1:
        	:type E1: float
        	:param E2:
        	:type E2: float
        	:param E3:
        	:type E3: float
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_GetEstimation(self, *args)


    def GetWeight(self, *args) -> "void":
        """
        :param QuadraticWeight:
        	:type QuadraticWeight: float
        	:param QualityWeight:
        	:type QualityWeight: float
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_GetWeight(self, *args)


    def Gradient(self, *args) -> "void":
        """
        :param Element:
        	:type Element: int
        	:param Dimension:
        	:type Dimension: int
        	:param G:
        	:type G: math_Vector
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_Gradient(self, *args)


    def Hessian(self, *args) -> "void":
        """
        :param Element:
        	:type Element: int
        	:param Dimension1:
        	:type Dimension1: int
        	:param Dimension2:
        	:type Dimension2: int
        	:param H:
        	:type H: math_Matrix
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_Hessian(self, *args)


    def InputVector(self, *args) -> "void":
        """
        * Convert the assembly Vector in an Curve;
        	:param X:
        	:type X: math_Vector
        	:param AssTable:
        	:type AssTable: FEmTool_HAssemblyTable
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_InputVector(self, *args)


    def QualityValues(self, *args) -> "Standard_Integer":
        """
        :param J1min:
        	:type J1min: float
        	:param J2min:
        	:type J2min: float
        	:param J3min:
        	:type J3min: float
        	:param J1:
        	:type J1: float
        	:param J2:
        	:type J2: float
        	:param J3:
        	:type J3: float
        	:rtype: int
        """
        return _AppDef.AppDef_SmoothCriterion_QualityValues(self, *args)


    def SetCurve(self, *args) -> "void":
        """
        :param C:
        	:type C: FEmTool_Curve
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_SetCurve(self, *args)


    def SetEstimation(self, *args) -> "void":
        """
        :param E1:
        	:type E1: float
        	:param E2:
        	:type E2: float
        	:param E3:
        	:type E3: float
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_SetEstimation(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        :param Parameters:
        	:type Parameters: TColStd_HArray1OfReal
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_SetParameters(self, *args)


    def SetWeight(self, *args) -> "void":
        """
        :param QuadraticWeight:
        	:type QuadraticWeight: float
        	:param QualityWeight:
        	:type QualityWeight: float
        	:param percentJ1:
        	:type percentJ1: float
        	:param percentJ2:
        	:type percentJ2: float
        	:param percentJ3:
        	:type percentJ3: float
        	:rtype: void
        :param Weight:
        	:type Weight: TColStd_Array1OfReal
        	:rtype: void
        """
        return _AppDef.AppDef_SmoothCriterion_SetWeight(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_AppDef_SmoothCriterion_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_SmoothCriterion
AppDef_SmoothCriterion.AssemblyTable = new_instancemethod(_AppDef.AppDef_SmoothCriterion_AssemblyTable, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.DependenceTable = new_instancemethod(_AppDef.AppDef_SmoothCriterion_DependenceTable, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.ErrorValues = new_instancemethod(_AppDef.AppDef_SmoothCriterion_ErrorValues, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.EstLength = new_instancemethod(_AppDef.AppDef_SmoothCriterion_EstLength, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.GetCurve = new_instancemethod(_AppDef.AppDef_SmoothCriterion_GetCurve, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.GetEstimation = new_instancemethod(_AppDef.AppDef_SmoothCriterion_GetEstimation, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.GetWeight = new_instancemethod(_AppDef.AppDef_SmoothCriterion_GetWeight, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.Gradient = new_instancemethod(_AppDef.AppDef_SmoothCriterion_Gradient, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.Hessian = new_instancemethod(_AppDef.AppDef_SmoothCriterion_Hessian, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.InputVector = new_instancemethod(_AppDef.AppDef_SmoothCriterion_InputVector, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.QualityValues = new_instancemethod(_AppDef.AppDef_SmoothCriterion_QualityValues, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.SetCurve = new_instancemethod(_AppDef.AppDef_SmoothCriterion_SetCurve, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.SetEstimation = new_instancemethod(_AppDef.AppDef_SmoothCriterion_SetEstimation, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.SetParameters = new_instancemethod(_AppDef.AppDef_SmoothCriterion_SetParameters, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion.SetWeight = new_instancemethod(_AppDef.AppDef_SmoothCriterion_SetWeight, None, AppDef_SmoothCriterion)
AppDef_SmoothCriterion_swigregister = _AppDef.AppDef_SmoothCriterion_swigregister
AppDef_SmoothCriterion_swigregister(AppDef_SmoothCriterion)

class AppDef_TheFunction(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _AppDef.AppDef_TheFunction_swiginit(self, _AppDef.new_AppDef_TheFunction(*args))

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the MultiCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_TheFunction_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _AppDef.AppDef_TheFunction_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_TheFunction_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _AppDef.AppDef_TheFunction_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_TheFunction_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _AppDef.AppDef_TheFunction_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _AppDef.AppDef_TheFunction_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheFunction
AppDef_TheFunction.CurveValue = new_instancemethod(_AppDef.AppDef_TheFunction_CurveValue, None, AppDef_TheFunction)
AppDef_TheFunction.Error = new_instancemethod(_AppDef.AppDef_TheFunction_Error, None, AppDef_TheFunction)
AppDef_TheFunction.FirstConstraint = new_instancemethod(_AppDef.AppDef_TheFunction_FirstConstraint, None, AppDef_TheFunction)
AppDef_TheFunction.LastConstraint = new_instancemethod(_AppDef.AppDef_TheFunction_LastConstraint, None, AppDef_TheFunction)
AppDef_TheFunction.MaxError2d = new_instancemethod(_AppDef.AppDef_TheFunction_MaxError2d, None, AppDef_TheFunction)
AppDef_TheFunction.MaxError3d = new_instancemethod(_AppDef.AppDef_TheFunction_MaxError3d, None, AppDef_TheFunction)
AppDef_TheFunction.NewParameters = new_instancemethod(_AppDef.AppDef_TheFunction_NewParameters, None, AppDef_TheFunction)
AppDef_TheFunction_swigregister = _AppDef.AppDef_TheFunction_swigregister
AppDef_TheFunction_swigregister(AppDef_TheFunction)

class AppDef_TheGradient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_TheGradient_swiginit(self, _AppDef.new_AppDef_TheGradient(*args))

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_TheGradient_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _AppDef.AppDef_TheGradient_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_TheGradient_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_TheGradient_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_TheGradient_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_TheGradient_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheGradient
AppDef_TheGradient.AverageError = new_instancemethod(_AppDef.AppDef_TheGradient_AverageError, None, AppDef_TheGradient)
AppDef_TheGradient.Error = new_instancemethod(_AppDef.AppDef_TheGradient_Error, None, AppDef_TheGradient)
AppDef_TheGradient.IsDone = new_instancemethod(_AppDef.AppDef_TheGradient_IsDone, None, AppDef_TheGradient)
AppDef_TheGradient.MaxError2d = new_instancemethod(_AppDef.AppDef_TheGradient_MaxError2d, None, AppDef_TheGradient)
AppDef_TheGradient.MaxError3d = new_instancemethod(_AppDef.AppDef_TheGradient_MaxError3d, None, AppDef_TheGradient)
AppDef_TheGradient.Value = new_instancemethod(_AppDef.AppDef_TheGradient_Value, None, AppDef_TheGradient)
AppDef_TheGradient_swigregister = _AppDef.AppDef_TheGradient_swigregister
AppDef_TheGradient_swigregister(AppDef_TheGradient)

class AppDef_TheLeastSquares(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_TheLeastSquares_swiginit(self, _AppDef.new_AppDef_TheLeastSquares(*args))

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_TheLeastSquares_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _AppDef.AppDef_TheLeastSquares_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_TheLeastSquares_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_TheLeastSquares_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_TheLeastSquares_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _AppDef.AppDef_TheLeastSquares_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_TheLeastSquares_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_TheLeastSquares_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_TheLeastSquares_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _AppDef.AppDef_TheLeastSquares_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _AppDef.AppDef_TheLeastSquares_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _AppDef.AppDef_TheLeastSquares_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_TheLeastSquares_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_TheLeastSquares_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheLeastSquares
AppDef_TheLeastSquares.BSplineValue = new_instancemethod(_AppDef.AppDef_TheLeastSquares_BSplineValue, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.BezierValue = new_instancemethod(_AppDef.AppDef_TheLeastSquares_BezierValue, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.DerivativeFunctionMatrix = new_instancemethod(_AppDef.AppDef_TheLeastSquares_DerivativeFunctionMatrix, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.Distance = new_instancemethod(_AppDef.AppDef_TheLeastSquares_Distance, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.Error = new_instancemethod(_AppDef.AppDef_TheLeastSquares_Error, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.ErrorGradient = new_instancemethod(_AppDef.AppDef_TheLeastSquares_ErrorGradient, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.FirstLambda = new_instancemethod(_AppDef.AppDef_TheLeastSquares_FirstLambda, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.FunctionMatrix = new_instancemethod(_AppDef.AppDef_TheLeastSquares_FunctionMatrix, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.IsDone = new_instancemethod(_AppDef.AppDef_TheLeastSquares_IsDone, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.KIndex = new_instancemethod(_AppDef.AppDef_TheLeastSquares_KIndex, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.LastLambda = new_instancemethod(_AppDef.AppDef_TheLeastSquares_LastLambda, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.Perform = new_instancemethod(_AppDef.AppDef_TheLeastSquares_Perform, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.Points = new_instancemethod(_AppDef.AppDef_TheLeastSquares_Points, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares.Poles = new_instancemethod(_AppDef.AppDef_TheLeastSquares_Poles, None, AppDef_TheLeastSquares)
AppDef_TheLeastSquares_swigregister = _AppDef.AppDef_TheLeastSquares_swigregister
AppDef_TheLeastSquares_swigregister(AppDef_TheLeastSquares)

class AppDef_TheResol(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _AppDef.AppDef_TheResol_swiginit(self, _AppDef.new_AppDef_TheResol(*args))

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        * Returns the derivative of the constraint matrix.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param DA:
        	:type DA: math_Matrix
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_TheResol_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """:rtype: math_Matrix"""
        return _AppDef.AppDef_TheResol_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        * returns the duale variables of the system.
        	:rtype: math_Vector
        """
        return _AppDef.AppDef_TheResol_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.
        	:rtype: math_Matrix
        """
        return _AppDef.AppDef_TheResol_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _AppDef.AppDef_TheResol_IsDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheResol
AppDef_TheResol.ConstraintDerivative = new_instancemethod(_AppDef.AppDef_TheResol_ConstraintDerivative, None, AppDef_TheResol)
AppDef_TheResol.ConstraintMatrix = new_instancemethod(_AppDef.AppDef_TheResol_ConstraintMatrix, None, AppDef_TheResol)
AppDef_TheResol.Duale = new_instancemethod(_AppDef.AppDef_TheResol_Duale, None, AppDef_TheResol)
AppDef_TheResol.InverseMatrix = new_instancemethod(_AppDef.AppDef_TheResol_InverseMatrix, None, AppDef_TheResol)
AppDef_TheResol.IsDone = new_instancemethod(_AppDef.AppDef_TheResol_IsDone, None, AppDef_TheResol)
AppDef_TheResol_swigregister = _AppDef.AppDef_TheResol_swigregister
AppDef_TheResol_swigregister(AppDef_TheResol)

class AppDef_Variational(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. Initialization of the fields. warning : Nc0 : number of PassagePoint consraints Nc2 : number of TangencyPoint constraints Nc3 : number of CurvaturePoint constraints if ((MaxDegree-Continuity)*MaxSegment -Nc0 - 2*Nc1 -3*Nc2) is negative The problem is over-constrained. //! Limitation : The MultiLine from AppDef has to be composed by only one Line ( Dimension 2 or 3).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param MaxDegree: default value is 14
        	:type MaxDegree: int
        	:param MaxSegment: default value is 100
        	:type MaxSegment: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param WithMinMax: default value is Standard_False
        	:type WithMinMax: bool
        	:param WithCutting: default value is Standard_True
        	:type WithCutting: bool
        	:param Tolerance: default value is 1.0
        	:type Tolerance: float
        	:param NbIterations: default value is 2
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_Variational_swiginit(self, _AppDef.new_AppDef_Variational(*args))

    def Approximate(self, *args) -> "void":
        """
        * Makes the approximation with the current fields.
        	:rtype: None
        """
        return _AppDef.AppDef_Variational_Approximate(self, *args)


    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the MultiLine from AppDef and the approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_Variational_AverageError(self, *args)


    def Continuity(self, *args) -> "GeomAbs_Shape":
        """
        * returns the Continuity used in the approximation
        	:rtype: GeomAbs_Shape
        """
        return _AppDef.AppDef_Variational_Continuity(self, *args)


    def Criterium(self, *args) -> "void":
        """
        * returns the values of the quality criterium.
        	:param VFirstOrder:
        	:type VFirstOrder: float
        	:param VSecondOrder:
        	:type VSecondOrder: float
        	:param VThirdOrder:
        	:type VThirdOrder: float
        	:rtype: None
        """
        return _AppDef.AppDef_Variational_Criterium(self, *args)


    def CriteriumWeight(self, *args) -> "void":
        """
        * returns the Weights (as percent) associed to the criterium used in the optimization.
        	:param Percent1:
        	:type Percent1: float
        	:param Percent2:
        	:type Percent2: float
        	:param Percent3:
        	:type Percent3: float
        	:rtype: None
        """
        return _AppDef.AppDef_Variational_CriteriumWeight(self, *args)


    def Distance(self, *args) -> "void":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:param mat:
        	:type mat: math_Matrix
        	:rtype: None
        """
        return _AppDef.AppDef_Variational_Distance(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(AppDef_Variational self) -> std::string"""
        return _AppDef.AppDef_Variational_DumpToString(self)


    def IsCreated(self, *args) -> "Standard_Boolean":
        """
        * returns True if the creation is done and correspond to the current fields.
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_IsCreated(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if the approximation is ok and correspond to the current fields.
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_IsDone(self, *args)


    def IsOverConstrained(self, *args) -> "Standard_Boolean":
        """
        * returns True if the problem is overconstrained in this case, approximation cannot be done.
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_IsOverConstrained(self, *args)


    def Knots(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal > const &":
        """
        * returns the knots uses to the approximations
        	:rtype: opencascade::handle<TColStd_HArray1OfReal>
        """
        return _AppDef.AppDef_Variational_Knots(self, *args)


    def MaxDegree(self, *args) -> "Standard_Integer":
        """
        * returns the Maximum Degree used in the approximation
        	:rtype: int
        """
        return _AppDef.AppDef_Variational_MaxDegree(self, *args)


    def MaxError(self, *args) -> "Standard_Real":
        """
        * returns the maximum of the distances between the points of the multiline and the approximation curves.
        	:rtype: float
        """
        return _AppDef.AppDef_Variational_MaxError(self, *args)


    def MaxErrorIndex(self, *args) -> "Standard_Integer":
        """
        * returns the index of the MultiPoint of ErrorMax
        	:rtype: int
        """
        return _AppDef.AppDef_Variational_MaxErrorIndex(self, *args)


    def MaxSegment(self, *args) -> "Standard_Integer":
        """
        * returns the Maximum of segment used in the approximation
        	:rtype: int
        """
        return _AppDef.AppDef_Variational_MaxSegment(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * returns the number of iterations used in the approximation.
        	:rtype: int
        """
        return _AppDef.AppDef_Variational_NbIterations(self, *args)


    def Parameters(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal > const &":
        """
        * returns the parameters uses to the approximations
        	:rtype: opencascade::handle<TColStd_HArray1OfReal>
        """
        return _AppDef.AppDef_Variational_Parameters(self, *args)


    def QuadraticError(self, *args) -> "Standard_Real":
        """
        * returns the quadratic average of the distances between the points of the multiline and the approximation curves.
        	:rtype: float
        """
        return _AppDef.AppDef_Variational_QuadraticError(self, *args)


    def SetConstraints(self, *args) -> "Standard_Boolean":
        """
        * Define the constraints to approximate If this value is incompatible with the others fields this method modify nothing and returns false
        	:param aConstrainst:
        	:type aConstrainst: AppParCurves_HArray1OfConstraintCouple
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_SetConstraints(self, *args)


    def SetContinuity(self, *args) -> "Standard_Boolean":
        """
        * Define the Continuity used in the approximation If this value is incompatible with the others fields this method modify nothing and returns false
        	:param C:
        	:type C: GeomAbs_Shape
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_SetContinuity(self, *args)


    def SetCriteriumWeight(self, *args) -> "void":
        """
        * define the Weights (as percent) associed to the criterium used in the optimization. //! if Percent <= 0
        	:param Percent1:
        	:type Percent1: float
        	:param Percent2:
        	:type Percent2: float
        	:param Percent3:
        	:type Percent3: float
        	:rtype: None
        * define the Weight (as percent) associed to the criterium Order used in the optimization : Others weights are updated. if Percent < 0 if Order < 1 or Order > 3
        	:param Order:
        	:type Order: int
        	:param Percent:
        	:type Percent: float
        	:rtype: None
        """
        return _AppDef.AppDef_Variational_SetCriteriumWeight(self, *args)


    def SetKnots(self, *args) -> "Standard_Boolean":
        """
        * Defines the knots used by the approximations If this value is incompatible with the others fields this method modify nothing and returns false
        	:param knots:
        	:type knots: TColStd_HArray1OfReal
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_SetKnots(self, *args)


    def SetMaxDegree(self, *args) -> "Standard_Boolean":
        """
        * Define the Maximum Degree used in the approximation If this value is incompatible with the others fields this method modify nothing and returns false
        	:param Degree:
        	:type Degree: int
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_SetMaxDegree(self, *args)


    def SetMaxSegment(self, *args) -> "Standard_Boolean":
        """
        * Define the maximum number of segments used in the approximation If this value is incompatible with the others fields this method modify nothing and returns false
        	:param NbSegment:
        	:type NbSegment: int
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_SetMaxSegment(self, *args)


    def SetNbIterations(self, *args) -> "void":
        """
        * define the number of iterations used in the approximation. if Iter < 1
        	:param Iter:
        	:type Iter: int
        	:rtype: None
        """
        return _AppDef.AppDef_Variational_SetNbIterations(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        * Defines the parameters used by the approximations.
        	:param param:
        	:type param: TColStd_HArray1OfReal
        	:rtype: None
        """
        return _AppDef.AppDef_Variational_SetParameters(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * define the tolerance used in the approximation.
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _AppDef.AppDef_Variational_SetTolerance(self, *args)


    def SetWithCutting(self, *args) -> "Standard_Boolean":
        """
        * Define if the approximation can insert new Knots or not. If this value is incompatible with the others fields this method modify nothing and returns false
        	:param Cutting:
        	:type Cutting: bool
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_SetWithCutting(self, *args)


    def SetWithMinMax(self, *args) -> "void":
        """
        * Define if the approximation search to minimize the maximum Error or not.
        	:param MinMax:
        	:type MinMax: bool
        	:rtype: None
        """
        return _AppDef.AppDef_Variational_SetWithMinMax(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * returns the tolerance used in the approximation.
        	:rtype: float
        """
        return _AppDef.AppDef_Variational_Tolerance(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        * returns all the BSpline curves approximating the MultiLine from AppDef SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _AppDef.AppDef_Variational_Value(self, *args)


    def WithCutting(self, *args) -> "Standard_Boolean":
        """
        * returns if the approximation can insert new Knots or not.
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_WithCutting(self, *args)


    def WithMinMax(self, *args) -> "Standard_Boolean":
        """
        * returns if the approximation search to minimize the maximum Error or not.
        	:rtype: bool
        """
        return _AppDef.AppDef_Variational_WithMinMax(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Variational
AppDef_Variational.Approximate = new_instancemethod(_AppDef.AppDef_Variational_Approximate, None, AppDef_Variational)
AppDef_Variational.AverageError = new_instancemethod(_AppDef.AppDef_Variational_AverageError, None, AppDef_Variational)
AppDef_Variational.Continuity = new_instancemethod(_AppDef.AppDef_Variational_Continuity, None, AppDef_Variational)
AppDef_Variational.Criterium = new_instancemethod(_AppDef.AppDef_Variational_Criterium, None, AppDef_Variational)
AppDef_Variational.CriteriumWeight = new_instancemethod(_AppDef.AppDef_Variational_CriteriumWeight, None, AppDef_Variational)
AppDef_Variational.Distance = new_instancemethod(_AppDef.AppDef_Variational_Distance, None, AppDef_Variational)
AppDef_Variational.DumpToString = new_instancemethod(_AppDef.AppDef_Variational_DumpToString, None, AppDef_Variational)
AppDef_Variational.IsCreated = new_instancemethod(_AppDef.AppDef_Variational_IsCreated, None, AppDef_Variational)
AppDef_Variational.IsDone = new_instancemethod(_AppDef.AppDef_Variational_IsDone, None, AppDef_Variational)
AppDef_Variational.IsOverConstrained = new_instancemethod(_AppDef.AppDef_Variational_IsOverConstrained, None, AppDef_Variational)
AppDef_Variational.Knots = new_instancemethod(_AppDef.AppDef_Variational_Knots, None, AppDef_Variational)
AppDef_Variational.MaxDegree = new_instancemethod(_AppDef.AppDef_Variational_MaxDegree, None, AppDef_Variational)
AppDef_Variational.MaxError = new_instancemethod(_AppDef.AppDef_Variational_MaxError, None, AppDef_Variational)
AppDef_Variational.MaxErrorIndex = new_instancemethod(_AppDef.AppDef_Variational_MaxErrorIndex, None, AppDef_Variational)
AppDef_Variational.MaxSegment = new_instancemethod(_AppDef.AppDef_Variational_MaxSegment, None, AppDef_Variational)
AppDef_Variational.NbIterations = new_instancemethod(_AppDef.AppDef_Variational_NbIterations, None, AppDef_Variational)
AppDef_Variational.Parameters = new_instancemethod(_AppDef.AppDef_Variational_Parameters, None, AppDef_Variational)
AppDef_Variational.QuadraticError = new_instancemethod(_AppDef.AppDef_Variational_QuadraticError, None, AppDef_Variational)
AppDef_Variational.SetConstraints = new_instancemethod(_AppDef.AppDef_Variational_SetConstraints, None, AppDef_Variational)
AppDef_Variational.SetContinuity = new_instancemethod(_AppDef.AppDef_Variational_SetContinuity, None, AppDef_Variational)
AppDef_Variational.SetCriteriumWeight = new_instancemethod(_AppDef.AppDef_Variational_SetCriteriumWeight, None, AppDef_Variational)
AppDef_Variational.SetKnots = new_instancemethod(_AppDef.AppDef_Variational_SetKnots, None, AppDef_Variational)
AppDef_Variational.SetMaxDegree = new_instancemethod(_AppDef.AppDef_Variational_SetMaxDegree, None, AppDef_Variational)
AppDef_Variational.SetMaxSegment = new_instancemethod(_AppDef.AppDef_Variational_SetMaxSegment, None, AppDef_Variational)
AppDef_Variational.SetNbIterations = new_instancemethod(_AppDef.AppDef_Variational_SetNbIterations, None, AppDef_Variational)
AppDef_Variational.SetParameters = new_instancemethod(_AppDef.AppDef_Variational_SetParameters, None, AppDef_Variational)
AppDef_Variational.SetTolerance = new_instancemethod(_AppDef.AppDef_Variational_SetTolerance, None, AppDef_Variational)
AppDef_Variational.SetWithCutting = new_instancemethod(_AppDef.AppDef_Variational_SetWithCutting, None, AppDef_Variational)
AppDef_Variational.SetWithMinMax = new_instancemethod(_AppDef.AppDef_Variational_SetWithMinMax, None, AppDef_Variational)
AppDef_Variational.Tolerance = new_instancemethod(_AppDef.AppDef_Variational_Tolerance, None, AppDef_Variational)
AppDef_Variational.Value = new_instancemethod(_AppDef.AppDef_Variational_Value, None, AppDef_Variational)
AppDef_Variational.WithCutting = new_instancemethod(_AppDef.AppDef_Variational_WithCutting, None, AppDef_Variational)
AppDef_Variational.WithMinMax = new_instancemethod(_AppDef.AppDef_Variational_WithMinMax, None, AppDef_Variational)
AppDef_Variational_swigregister = _AppDef.AppDef_Variational_swigregister
AppDef_Variational_swigregister(AppDef_Variational)

class AppDef_LinearCriteria(AppDef_SmoothCriterion):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: None
        """
        _AppDef.AppDef_LinearCriteria_swiginit(self, _AppDef.new_AppDef_LinearCriteria(*args))

    def GetEstLength(self) -> "Standard_Real":
        """GetEstLength(AppDef_LinearCriteria self) -> Standard_Real"""
        return _AppDef.AppDef_LinearCriteria_GetEstLength(self)


    def SetEstLength(self, value: 'Standard_Real') -> "void":
        """SetEstLength(AppDef_LinearCriteria self, Standard_Real value)"""
        return _AppDef.AppDef_LinearCriteria_SetEstLength(self, value)


    def SetWeight(self, *args) -> "void":
        """
        :param QuadraticWeight:
        	:type QuadraticWeight: float
        	:param QualityWeight:
        	:type QualityWeight: float
        	:param percentJ1:
        	:type percentJ1: float
        	:param percentJ2:
        	:type percentJ2: float
        	:param percentJ3:
        	:type percentJ3: float
        	:rtype: None
        :param Weight:
        	:type Weight: TColStd_Array1OfReal
        	:rtype: None
        """
        return _AppDef.AppDef_LinearCriteria_SetWeight(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_AppDef_LinearCriteria_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_LinearCriteria
AppDef_LinearCriteria.GetEstLength = new_instancemethod(_AppDef.AppDef_LinearCriteria_GetEstLength, None, AppDef_LinearCriteria)
AppDef_LinearCriteria.SetEstLength = new_instancemethod(_AppDef.AppDef_LinearCriteria_SetEstLength, None, AppDef_LinearCriteria)
AppDef_LinearCriteria.SetWeight = new_instancemethod(_AppDef.AppDef_LinearCriteria_SetWeight, None, AppDef_LinearCriteria)
AppDef_LinearCriteria_swigregister = _AppDef.AppDef_LinearCriteria_swigregister
AppDef_LinearCriteria_swigregister(AppDef_LinearCriteria)

class AppDef_HArray1OfMultiPointConstraint(AppDef_Array1OfMultiPointConstraint, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AppDef.AppDef_HArray1OfMultiPointConstraint_swiginit(self, _AppDef.new_AppDef_HArray1OfMultiPointConstraint(*args))


    @staticmethod
    def DownCast(t):
      return Handle_AppDef_HArray1OfMultiPointConstraint_DownCast(t)

    __swig_destroy__ = _AppDef.delete_AppDef_HArray1OfMultiPointConstraint
AppDef_HArray1OfMultiPointConstraint.Array1 = new_instancemethod(_AppDef.AppDef_HArray1OfMultiPointConstraint_Array1, None, AppDef_HArray1OfMultiPointConstraint)
AppDef_HArray1OfMultiPointConstraint.ChangeArray1 = new_instancemethod(_AppDef.AppDef_HArray1OfMultiPointConstraint_ChangeArray1, None, AppDef_HArray1OfMultiPointConstraint)
AppDef_HArray1OfMultiPointConstraint_swigregister = _AppDef.AppDef_HArray1OfMultiPointConstraint_swigregister
AppDef_HArray1OfMultiPointConstraint_swigregister(AppDef_HArray1OfMultiPointConstraint)



