# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Approx module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_approx.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Approx.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Approx')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Approx')
    _Approx = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Approx', [dirname(__file__)])
        except ImportError:
            import _Approx
            return _Approx
        try:
            _mod = imp.load_module('_Approx', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Approx = swig_import_helper()
    del swig_import_helper
else:
    import _Approx
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Approx.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Approx.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Approx.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Approx.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Approx.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Approx.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Approx.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Approx.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Approx.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Approx.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Approx.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Approx.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Approx.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Approx.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Approx.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Approx.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Approx.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Approx.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _Approx.process_exception(error, method_name, class_name)
process_exception = _Approx.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.AppCont
import OCC.Core.AppParCurves
Approx_PointsAdded = _Approx.Approx_PointsAdded
Approx_NoPointsAdded = _Approx.Approx_NoPointsAdded
Approx_NoApproximation = _Approx.Approx_NoApproximation
Approx_ChordLength = _Approx.Approx_ChordLength
Approx_Centripetal = _Approx.Approx_Centripetal
Approx_IsoParametric = _Approx.Approx_IsoParametric

def Handle_Approx_CurvlinFunc_Create() -> "opencascade::handle< Approx_CurvlinFunc >":
    return _Approx.Handle_Approx_CurvlinFunc_Create()
Handle_Approx_CurvlinFunc_Create = _Approx.Handle_Approx_CurvlinFunc_Create

def Handle_Approx_CurvlinFunc_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Approx_CurvlinFunc >":
    return _Approx.Handle_Approx_CurvlinFunc_DownCast(t)
Handle_Approx_CurvlinFunc_DownCast = _Approx.Handle_Approx_CurvlinFunc_DownCast

def Handle_Approx_CurvlinFunc_IsNull(t: 'opencascade::handle< Approx_CurvlinFunc > const &') -> "bool":
    return _Approx.Handle_Approx_CurvlinFunc_IsNull(t)
Handle_Approx_CurvlinFunc_IsNull = _Approx.Handle_Approx_CurvlinFunc_IsNull

def Handle_Approx_SweepFunction_Create() -> "opencascade::handle< Approx_SweepFunction >":
    return _Approx.Handle_Approx_SweepFunction_Create()
Handle_Approx_SweepFunction_Create = _Approx.Handle_Approx_SweepFunction_Create

def Handle_Approx_SweepFunction_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Approx_SweepFunction >":
    return _Approx.Handle_Approx_SweepFunction_DownCast(t)
Handle_Approx_SweepFunction_DownCast = _Approx.Handle_Approx_SweepFunction_DownCast

def Handle_Approx_SweepFunction_IsNull(t: 'opencascade::handle< Approx_SweepFunction > const &') -> "bool":
    return _Approx.Handle_Approx_SweepFunction_IsNull(t)
Handle_Approx_SweepFunction_IsNull = _Approx.Handle_Approx_SweepFunction_IsNull

def Handle_Approx_HArray1OfGTrsf2d_Create() -> "opencascade::handle< Approx_HArray1OfGTrsf2d >":
    return _Approx.Handle_Approx_HArray1OfGTrsf2d_Create()
Handle_Approx_HArray1OfGTrsf2d_Create = _Approx.Handle_Approx_HArray1OfGTrsf2d_Create

def Handle_Approx_HArray1OfGTrsf2d_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Approx_HArray1OfGTrsf2d >":
    return _Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast(t)
Handle_Approx_HArray1OfGTrsf2d_DownCast = _Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast

def Handle_Approx_HArray1OfGTrsf2d_IsNull(t: 'opencascade::handle< Approx_HArray1OfGTrsf2d > const &') -> "bool":
    return _Approx.Handle_Approx_HArray1OfGTrsf2d_IsNull(t)
Handle_Approx_HArray1OfGTrsf2d_IsNull = _Approx.Handle_Approx_HArray1OfGTrsf2d_IsNull

def Handle_Approx_HArray1OfAdHSurface_Create() -> "opencascade::handle< Approx_HArray1OfAdHSurface >":
    return _Approx.Handle_Approx_HArray1OfAdHSurface_Create()
Handle_Approx_HArray1OfAdHSurface_Create = _Approx.Handle_Approx_HArray1OfAdHSurface_Create

def Handle_Approx_HArray1OfAdHSurface_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Approx_HArray1OfAdHSurface >":
    return _Approx.Handle_Approx_HArray1OfAdHSurface_DownCast(t)
Handle_Approx_HArray1OfAdHSurface_DownCast = _Approx.Handle_Approx_HArray1OfAdHSurface_DownCast

def Handle_Approx_HArray1OfAdHSurface_IsNull(t: 'opencascade::handle< Approx_HArray1OfAdHSurface > const &') -> "bool":
    return _Approx.Handle_Approx_HArray1OfAdHSurface_IsNull(t)
Handle_Approx_HArray1OfAdHSurface_IsNull = _Approx.Handle_Approx_HArray1OfAdHSurface_IsNull
class Approx_SequenceOfHArray1OfReal(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Approx_SequenceOfHArray1OfReal_swiginit(self, _Approx.new_Approx_SequenceOfHArray1OfReal(*args))
    delNode = staticmethod(_Approx.Approx_SequenceOfHArray1OfReal_delNode)
    __swig_destroy__ = _Approx.delete_Approx_SequenceOfHArray1OfReal
Approx_SequenceOfHArray1OfReal.begin = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_begin, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.end = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_end, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.cbegin = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_cbegin, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.cend = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_cend, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Size = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Size, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Length = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Length, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Lower = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Lower, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Upper = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Upper, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.IsEmpty = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_IsEmpty, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Reverse = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Reverse, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Exchange = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Exchange, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Clear = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Clear, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Assign = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Assign, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Set = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Set, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Remove = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Remove, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Append = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Append, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Prepend = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Prepend, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.InsertBefore = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_InsertBefore, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.InsertAfter = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_InsertAfter, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Split = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Split, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.First = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_First, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.ChangeFirst = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_ChangeFirst, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Last = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Last, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.ChangeLast = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_ChangeLast, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Value = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Value, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.ChangeValue = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_ChangeValue, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.__call__ = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal___call__, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.SetValue = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_SetValue, None, Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal_swigregister = _Approx.Approx_SequenceOfHArray1OfReal_swigregister
Approx_SequenceOfHArray1OfReal_swigregister(Approx_SequenceOfHArray1OfReal)

def Approx_SequenceOfHArray1OfReal_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _Approx.Approx_SequenceOfHArray1OfReal_delNode(theNode, theAl)
Approx_SequenceOfHArray1OfReal_delNode = _Approx.Approx_SequenceOfHArray1OfReal_delNode

class Approx_Array1OfGTrsf2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Approx_Array1OfGTrsf2d_swiginit(self, _Approx.new_Approx_Array1OfGTrsf2d(*args))
    __swig_destroy__ = _Approx.delete_Approx_Array1OfGTrsf2d

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

Approx_Array1OfGTrsf2d.begin = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_begin, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.end = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_end, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.cbegin = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_cbegin, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.cend = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_cend, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Init = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Init, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Size = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Size, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Length = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Length, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.IsEmpty = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_IsEmpty, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Lower = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Lower, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Upper = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Upper, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.IsDeletable = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_IsDeletable, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.IsAllocated = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_IsAllocated, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Assign = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Assign, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Move = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Move, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Set = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Set, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.First = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_First, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.ChangeFirst = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_ChangeFirst, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Last = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Last, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.ChangeLast = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_ChangeLast, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Value = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Value, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.ChangeValue = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_ChangeValue, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.__call__ = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d___call__, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.SetValue = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_SetValue, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Resize = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Resize, None, Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d_swigregister = _Approx.Approx_Array1OfGTrsf2d_swigregister
Approx_Array1OfGTrsf2d_swigregister(Approx_Array1OfGTrsf2d)

class Approx_Array1OfAdHSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Approx_Array1OfAdHSurface_swiginit(self, _Approx.new_Approx_Array1OfAdHSurface(*args))
    __swig_destroy__ = _Approx.delete_Approx_Array1OfAdHSurface

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

Approx_Array1OfAdHSurface.begin = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_begin, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.end = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_end, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.cbegin = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_cbegin, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.cend = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_cend, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Init = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Init, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Size = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Size, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Length = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Length, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.IsEmpty = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_IsEmpty, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Lower = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Lower, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Upper = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Upper, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.IsDeletable = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_IsDeletable, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.IsAllocated = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_IsAllocated, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Assign = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Assign, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Move = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Move, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Set = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Set, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.First = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_First, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.ChangeFirst = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_ChangeFirst, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Last = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Last, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.ChangeLast = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_ChangeLast, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Value = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Value, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.ChangeValue = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_ChangeValue, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.__call__ = new_instancemethod(_Approx.Approx_Array1OfAdHSurface___call__, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.SetValue = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_SetValue, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Resize = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Resize, None, Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface_swigregister = _Approx.Approx_Array1OfAdHSurface_swigregister
Approx_Array1OfAdHSurface_swigregister(Approx_Array1OfAdHSurface)

class Approx_Curve2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C2D:
        	:type C2D: Adaptor2d_HCurve2d
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param TolU:
        	:type TolU: float
        	:param TolV:
        	:type TolV: float
        	:param Continuity:
        	:type Continuity: GeomAbs_Shape
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param MaxSegments:
        	:type MaxSegments: int
        	:rtype: None
        """
        _Approx.Approx_Curve2d_swiginit(self, _Approx.new_Approx_Curve2d(*args))

    def Curve(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """:rtype: opencascade::handle<Geom2d_BSplineCurve>"""
        return _Approx.Approx_Curve2d_Curve(self, *args)


    def HasResult(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Approx.Approx_Curve2d_HasResult(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Approx.Approx_Curve2d_IsDone(self, *args)


    def MaxError2dU(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Approx.Approx_Curve2d_MaxError2dU(self, *args)


    def MaxError2dV(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Approx.Approx_Curve2d_MaxError2dV(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_Curve2d
Approx_Curve2d.Curve = new_instancemethod(_Approx.Approx_Curve2d_Curve, None, Approx_Curve2d)
Approx_Curve2d.HasResult = new_instancemethod(_Approx.Approx_Curve2d_HasResult, None, Approx_Curve2d)
Approx_Curve2d.IsDone = new_instancemethod(_Approx.Approx_Curve2d_IsDone, None, Approx_Curve2d)
Approx_Curve2d.MaxError2dU = new_instancemethod(_Approx.Approx_Curve2d_MaxError2dU, None, Approx_Curve2d)
Approx_Curve2d.MaxError2dV = new_instancemethod(_Approx.Approx_Curve2d_MaxError2dV, None, Approx_Curve2d)
Approx_Curve2d_swigregister = _Approx.Approx_Curve2d_swigregister
Approx_Curve2d_swigregister(Approx_Curve2d)

class Approx_Curve3d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Approximation of a curve with respect of the requiered tolerance Tol3D.
        	:param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param Tol3d:
        	:type Tol3d: float
        	:param Order:
        	:type Order: GeomAbs_Shape
        	:param MaxSegments:
        	:type MaxSegments: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:rtype: None
        """
        _Approx.Approx_Curve3d_swiginit(self, _Approx.new_Approx_Curve3d(*args))

    def Curve(self, *args) -> "opencascade::handle< Geom_BSplineCurve >":
        """:rtype: opencascade::handle<Geom_BSplineCurve>"""
        return _Approx.Approx_Curve3d_Curve(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(Approx_Curve3d self) -> std::string"""
        return _Approx.Approx_Curve3d_DumpToString(self)


    def HasResult(self, *args) -> "Standard_Boolean":
        """
        * returns Standard_True if the approximation did come out with a result that is not NECESSARELY within the required tolerance
        	:rtype: bool
        """
        return _Approx.Approx_Curve3d_HasResult(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns Standard_True if the approximation has been done within requiered tolerance
        	:rtype: bool
        """
        return _Approx.Approx_Curve3d_IsDone(self, *args)


    def MaxError(self, *args) -> "Standard_Real":
        """
        * returns the Maximum Error (>0 when an approximation has been done, 0 if no approximation)
        	:rtype: float
        """
        return _Approx.Approx_Curve3d_MaxError(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_Curve3d
Approx_Curve3d.Curve = new_instancemethod(_Approx.Approx_Curve3d_Curve, None, Approx_Curve3d)
Approx_Curve3d.DumpToString = new_instancemethod(_Approx.Approx_Curve3d_DumpToString, None, Approx_Curve3d)
Approx_Curve3d.HasResult = new_instancemethod(_Approx.Approx_Curve3d_HasResult, None, Approx_Curve3d)
Approx_Curve3d.IsDone = new_instancemethod(_Approx.Approx_Curve3d_IsDone, None, Approx_Curve3d)
Approx_Curve3d.MaxError = new_instancemethod(_Approx.Approx_Curve3d_MaxError, None, Approx_Curve3d)
Approx_Curve3d_swigregister = _Approx.Approx_Curve3d_swigregister
Approx_Curve3d_swigregister(Approx_Curve3d)

class Approx_CurveOnSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C2D:
        	:type C2D: Adaptor2d_HCurve2d
        	:param Surf:
        	:type Surf: Adaptor3d_HSurface
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Tol:
        	:type Tol: float
        	:param Continuity:
        	:type Continuity: GeomAbs_Shape
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param MaxSegments:
        	:type MaxSegments: int
        	:param Only3d: default value is Standard_False
        	:type Only3d: bool
        	:param Only2d: default value is Standard_False
        	:type Only2d: bool
        	:rtype: None
        """
        _Approx.Approx_CurveOnSurface_swiginit(self, _Approx.new_Approx_CurveOnSurface(*args))

    def Curve2d(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """:rtype: opencascade::handle<Geom2d_BSplineCurve>"""
        return _Approx.Approx_CurveOnSurface_Curve2d(self, *args)


    def Curve3d(self, *args) -> "opencascade::handle< Geom_BSplineCurve >":
        """:rtype: opencascade::handle<Geom_BSplineCurve>"""
        return _Approx.Approx_CurveOnSurface_Curve3d(self, *args)


    def HasResult(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Approx.Approx_CurveOnSurface_HasResult(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Approx.Approx_CurveOnSurface_IsDone(self, *args)


    def MaxError2dU(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Approx.Approx_CurveOnSurface_MaxError2dU(self, *args)


    def MaxError2dV(self, *args) -> "Standard_Real":
        """
        * returns the maximum errors relativly to the U component or the V component of the 2d Curve
        	:rtype: float
        """
        return _Approx.Approx_CurveOnSurface_MaxError2dV(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Approx.Approx_CurveOnSurface_MaxError3d(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_CurveOnSurface
Approx_CurveOnSurface.Curve2d = new_instancemethod(_Approx.Approx_CurveOnSurface_Curve2d, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.Curve3d = new_instancemethod(_Approx.Approx_CurveOnSurface_Curve3d, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.HasResult = new_instancemethod(_Approx.Approx_CurveOnSurface_HasResult, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.IsDone = new_instancemethod(_Approx.Approx_CurveOnSurface_IsDone, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.MaxError2dU = new_instancemethod(_Approx.Approx_CurveOnSurface_MaxError2dU, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.MaxError2dV = new_instancemethod(_Approx.Approx_CurveOnSurface_MaxError2dV, None, Approx_CurveOnSurface)
Approx_CurveOnSurface.MaxError3d = new_instancemethod(_Approx.Approx_CurveOnSurface_MaxError3d, None, Approx_CurveOnSurface)
Approx_CurveOnSurface_swigregister = _Approx.Approx_CurveOnSurface_swigregister
Approx_CurveOnSurface_swigregister(Approx_CurveOnSurface)

class Approx_CurvilinearParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * case of a free 3D curve
        	:param C3D:
        	:type C3D: Adaptor3d_HCurve
        	:param Tol:
        	:type Tol: float
        	:param Order:
        	:type Order: GeomAbs_Shape
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param MaxSegments:
        	:type MaxSegments: int
        	:rtype: None
        * case of a curve on one surface
        	:param C2D:
        	:type C2D: Adaptor2d_HCurve2d
        	:param Surf:
        	:type Surf: Adaptor3d_HSurface
        	:param Tol:
        	:type Tol: float
        	:param Order:
        	:type Order: GeomAbs_Shape
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param MaxSegments:
        	:type MaxSegments: int
        	:rtype: None
        * case of a curve on two surfaces
        	:param C2D1:
        	:type C2D1: Adaptor2d_HCurve2d
        	:param Surf1:
        	:type Surf1: Adaptor3d_HSurface
        	:param C2D2:
        	:type C2D2: Adaptor2d_HCurve2d
        	:param Surf2:
        	:type Surf2: Adaptor3d_HSurface
        	:param Tol:
        	:type Tol: float
        	:param Order:
        	:type Order: GeomAbs_Shape
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param MaxSegments:
        	:type MaxSegments: int
        	:rtype: None
        """
        _Approx.Approx_CurvilinearParameter_swiginit(self, _Approx.new_Approx_CurvilinearParameter(*args))

    def Curve2d1(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        * returns the BsplineCurve representing the reparametrized 2D curve on the first surface (case of a curve on one or two surfaces)
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _Approx.Approx_CurvilinearParameter_Curve2d1(self, *args)


    def Curve2d2(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        * returns the BsplineCurve representing the reparametrized 2D curve on the second surface (case of a curve on two surfaces)
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _Approx.Approx_CurvilinearParameter_Curve2d2(self, *args)


    def Curve3d(self, *args) -> "opencascade::handle< Geom_BSplineCurve >":
        """
        * returns the Bspline curve corresponding to the reparametrized 3D curve
        	:rtype: opencascade::handle<Geom_BSplineCurve>
        """
        return _Approx.Approx_CurvilinearParameter_Curve3d(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(Approx_CurvilinearParameter self) -> std::string"""
        return _Approx.Approx_CurvilinearParameter_DumpToString(self)


    def HasResult(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Approx.Approx_CurvilinearParameter_HasResult(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Approx.Approx_CurvilinearParameter_IsDone(self, *args)


    def MaxError2d1(self, *args) -> "Standard_Real":
        """
        * returns the maximum error on the first reparametrized 2D curve
        	:rtype: float
        """
        return _Approx.Approx_CurvilinearParameter_MaxError2d1(self, *args)


    def MaxError2d2(self, *args) -> "Standard_Real":
        """
        * returns the maximum error on the second reparametrized 2D curve
        	:rtype: float
        """
        return _Approx.Approx_CurvilinearParameter_MaxError2d2(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum error on the reparametrized 3D curve
        	:rtype: float
        """
        return _Approx.Approx_CurvilinearParameter_MaxError3d(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_CurvilinearParameter
Approx_CurvilinearParameter.Curve2d1 = new_instancemethod(_Approx.Approx_CurvilinearParameter_Curve2d1, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.Curve2d2 = new_instancemethod(_Approx.Approx_CurvilinearParameter_Curve2d2, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.Curve3d = new_instancemethod(_Approx.Approx_CurvilinearParameter_Curve3d, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.DumpToString = new_instancemethod(_Approx.Approx_CurvilinearParameter_DumpToString, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.HasResult = new_instancemethod(_Approx.Approx_CurvilinearParameter_HasResult, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.IsDone = new_instancemethod(_Approx.Approx_CurvilinearParameter_IsDone, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.MaxError2d1 = new_instancemethod(_Approx.Approx_CurvilinearParameter_MaxError2d1, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.MaxError2d2 = new_instancemethod(_Approx.Approx_CurvilinearParameter_MaxError2d2, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter.MaxError3d = new_instancemethod(_Approx.Approx_CurvilinearParameter_MaxError3d, None, Approx_CurvilinearParameter)
Approx_CurvilinearParameter_swigregister = _Approx.Approx_CurvilinearParameter_swigregister
Approx_CurvilinearParameter_swigregister(Approx_CurvilinearParameter)

class Approx_CurvlinFunc(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        :param C2D:
        	:type C2D: Adaptor2d_HCurve2d
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        :param C2D1:
        	:type C2D1: Adaptor2d_HCurve2d
        	:param C2D2:
        	:type C2D2: Adaptor2d_HCurve2d
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _Approx.Approx_CurvlinFunc_swiginit(self, _Approx.new_Approx_CurvlinFunc(*args))

    def EvalCase1(self, *args) -> "Standard_Boolean":
        """
        * if myCase != 1
        	:param S:
        	:type S: float
        	:param Order:
        	:type Order: int
        	:param Result:
        	:type Result: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Approx.Approx_CurvlinFunc_EvalCase1(self, *args)


    def EvalCase2(self, *args) -> "Standard_Boolean":
        """
        * if myCase != 2
        	:param S:
        	:type S: float
        	:param Order:
        	:type Order: int
        	:param Result:
        	:type Result: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Approx.Approx_CurvlinFunc_EvalCase2(self, *args)


    def EvalCase3(self, *args) -> "Standard_Boolean":
        """
        * if myCase != 3
        	:param S:
        	:type S: float
        	:param Order:
        	:type Order: int
        	:param Result:
        	:type Result: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Approx.Approx_CurvlinFunc_EvalCase3(self, *args)


    def FirstParameter(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Approx.Approx_CurvlinFunc_FirstParameter(self, *args)


    def GetLength(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Approx.Approx_CurvlinFunc_GetLength(self, *args)


    def GetSParameter(self, *args) -> "Standard_Real":
        """
        * returns original parameter correponding S.
        	:param U:
        	:type U: float
        	:rtype: float
        """
        return _Approx.Approx_CurvlinFunc_GetSParameter(self, *args)


    def GetUParameter(self, *args) -> "Standard_Real":
        """
        * returns original parameter correponding S. if Case == 1 computation is performed on myC2D1 and mySurf1, otherwise it is done on myC2D2 and mySurf2.
        	:param C:
        	:type C: Adaptor3d_Curve
        	:param S:
        	:type S: float
        	:param NumberOfCurve:
        	:type NumberOfCurve: int
        	:rtype: float
        """
        return _Approx.Approx_CurvlinFunc_GetUParameter(self, *args)


    def Intervals(self, *args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: None
        """
        return _Approx.Approx_CurvlinFunc_Intervals(self, *args)


    def LastParameter(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Approx.Approx_CurvlinFunc_LastParameter(self, *args)


    def Length(self, *args) -> "Standard_Real":
        """
        * Computes length of the curve.
        	:rtype: None
        * Computes length of the curve segment.
        	:param C:
        	:type C: Adaptor3d_Curve
        	:param FirstU:
        	:type FirstU: float
        	:param LasrU:
        	:type LasrU: float
        	:rtype: float
        """
        return _Approx.Approx_CurvlinFunc_Length(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _Approx.Approx_CurvlinFunc_NbIntervals(self, *args)


    def SetTol(self, *args) -> "void":
        """
        * ---Purpose Update the tolerance to used
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _Approx.Approx_CurvlinFunc_SetTol(self, *args)


    def Trim(self, *args) -> "void":
        """
        * if First < 0 or Last > 1
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _Approx.Approx_CurvlinFunc_Trim(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Approx_CurvlinFunc_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_CurvlinFunc
Approx_CurvlinFunc.EvalCase1 = new_instancemethod(_Approx.Approx_CurvlinFunc_EvalCase1, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.EvalCase2 = new_instancemethod(_Approx.Approx_CurvlinFunc_EvalCase2, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.EvalCase3 = new_instancemethod(_Approx.Approx_CurvlinFunc_EvalCase3, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.FirstParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_FirstParameter, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.GetLength = new_instancemethod(_Approx.Approx_CurvlinFunc_GetLength, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.GetSParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_GetSParameter, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.GetUParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_GetUParameter, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.Intervals = new_instancemethod(_Approx.Approx_CurvlinFunc_Intervals, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.LastParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_LastParameter, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.Length = new_instancemethod(_Approx.Approx_CurvlinFunc_Length, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.NbIntervals = new_instancemethod(_Approx.Approx_CurvlinFunc_NbIntervals, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.SetTol = new_instancemethod(_Approx.Approx_CurvlinFunc_SetTol, None, Approx_CurvlinFunc)
Approx_CurvlinFunc.Trim = new_instancemethod(_Approx.Approx_CurvlinFunc_Trim, None, Approx_CurvlinFunc)
Approx_CurvlinFunc_swigregister = _Approx.Approx_CurvlinFunc_swigregister
Approx_CurvlinFunc_swigregister(Approx_CurvlinFunc)

class Approx_FitAndDivide(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True.
        	:param Line:
        	:type Line: AppCont_Function
        	:param degreemin: default value is 3
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-5
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-5
        	:type Tolerance2d: float
        	:param cutting: default value is Standard_False
        	:type cutting: bool
        	:param FirstC: default value is AppParCurves_TangencyPoint
        	:type FirstC: AppParCurves_Constraint
        	:param LastC: default value is AppParCurves_TangencyPoint
        	:type LastC: AppParCurves_Constraint
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 3
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-05
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-05
        	:type Tolerance2d: float
        	:param cutting: default value is Standard_False
        	:type cutting: bool
        	:param FirstC: default value is AppParCurves_TangencyPoint
        	:type FirstC: AppParCurves_Constraint
        	:param LastC: default value is AppParCurves_TangencyPoint
        	:type LastC: AppParCurves_Constraint
        	:rtype: None
        """
        _Approx.Approx_FitAndDivide_swiginit(self, _Approx.new_Approx_FitAndDivide(*args))

    def Error(self, *args) -> "void":
        """
        * returns the tolerances 2d and 3d of the <Index> MultiCurve.
        	:param Index:
        	:type Index: int
        	:param tol3d:
        	:type tol3d: float
        	:param tol2d:
        	:type tol2d: float
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide_Error(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        * returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.
        	:rtype: bool
        """
        return _Approx.Approx_FitAndDivide_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        * returns False if the status NoPointsAdded has been sent.
        	:rtype: bool
        """
        return _Approx.Approx_FitAndDivide_IsToleranceReached(self, *args)


    def NbMultiCurves(self, *args) -> "Standard_Integer":
        """
        * Returns the number of MultiCurve doing the approximation of the MultiLine.
        	:rtype: int
        """
        return _Approx.Approx_FitAndDivide_NbMultiCurves(self, *args)


    def Parameters(self, *args) -> "void":
        """
        :param Index:
        	:type Index: int
        	:param firstp:
        	:type firstp: float
        	:param lastp:
        	:type lastp: float
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide_Parameters(self, *args)


    def Perform(self, *args) -> "void":
        """
        * runs the algorithm after having initialized the fields.
        	:param Line:
        	:type Line: AppCont_Function
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        * Changes the constraints of the approximation.
        	:param FirstC:
        	:type FirstC: AppParCurves_Constraint
        	:param LastC:
        	:type LastC: AppParCurves_Constraint
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide_SetConstraints(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        * changes the degrees of the approximation.
        	:param degreemin:
        	:type degreemin: int
        	:param degreemax:
        	:type degreemax: int
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide_SetDegrees(self, *args)


    def SetInvOrder(self, *args) -> "void":
        """
        * Set inverse order of degree selection: if theInvOrdr = true, current degree is chosen by inverse order - from maxdegree to mindegree. By default inverse order is used.
        	:param theInvOrder:
        	:type theInvOrder: bool
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide_SetInvOrder(self, *args)


    def SetMaxSegments(self, *args) -> "void":
        """
        * Changes the max number of segments, which is allowed for cutting.
        	:param theMaxSegments:
        	:type theMaxSegments: int
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide_SetMaxSegments(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        * Changes the tolerances of the approximation.
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide_SetTolerances(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the approximation MultiCurve of range <Index>.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: AppParCurves_MultiCurve
        """
        return _Approx.Approx_FitAndDivide_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_FitAndDivide
Approx_FitAndDivide.Error = new_instancemethod(_Approx.Approx_FitAndDivide_Error, None, Approx_FitAndDivide)
Approx_FitAndDivide.IsAllApproximated = new_instancemethod(_Approx.Approx_FitAndDivide_IsAllApproximated, None, Approx_FitAndDivide)
Approx_FitAndDivide.IsToleranceReached = new_instancemethod(_Approx.Approx_FitAndDivide_IsToleranceReached, None, Approx_FitAndDivide)
Approx_FitAndDivide.NbMultiCurves = new_instancemethod(_Approx.Approx_FitAndDivide_NbMultiCurves, None, Approx_FitAndDivide)
Approx_FitAndDivide.Parameters = new_instancemethod(_Approx.Approx_FitAndDivide_Parameters, None, Approx_FitAndDivide)
Approx_FitAndDivide.Perform = new_instancemethod(_Approx.Approx_FitAndDivide_Perform, None, Approx_FitAndDivide)
Approx_FitAndDivide.SetConstraints = new_instancemethod(_Approx.Approx_FitAndDivide_SetConstraints, None, Approx_FitAndDivide)
Approx_FitAndDivide.SetDegrees = new_instancemethod(_Approx.Approx_FitAndDivide_SetDegrees, None, Approx_FitAndDivide)
Approx_FitAndDivide.SetInvOrder = new_instancemethod(_Approx.Approx_FitAndDivide_SetInvOrder, None, Approx_FitAndDivide)
Approx_FitAndDivide.SetMaxSegments = new_instancemethod(_Approx.Approx_FitAndDivide_SetMaxSegments, None, Approx_FitAndDivide)
Approx_FitAndDivide.SetTolerances = new_instancemethod(_Approx.Approx_FitAndDivide_SetTolerances, None, Approx_FitAndDivide)
Approx_FitAndDivide.Value = new_instancemethod(_Approx.Approx_FitAndDivide_Value, None, Approx_FitAndDivide)
Approx_FitAndDivide_swigregister = _Approx.Approx_FitAndDivide_swigregister
Approx_FitAndDivide_swigregister(Approx_FitAndDivide)

class Approx_FitAndDivide2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True.
        	:param Line:
        	:type Line: AppCont_Function
        	:param degreemin: default value is 3
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-5
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-5
        	:type Tolerance2d: float
        	:param cutting: default value is Standard_False
        	:type cutting: bool
        	:param FirstC: default value is AppParCurves_TangencyPoint
        	:type FirstC: AppParCurves_Constraint
        	:param LastC: default value is AppParCurves_TangencyPoint
        	:type LastC: AppParCurves_Constraint
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 3
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-05
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-05
        	:type Tolerance2d: float
        	:param cutting: default value is Standard_False
        	:type cutting: bool
        	:param FirstC: default value is AppParCurves_TangencyPoint
        	:type FirstC: AppParCurves_Constraint
        	:param LastC: default value is AppParCurves_TangencyPoint
        	:type LastC: AppParCurves_Constraint
        	:rtype: None
        """
        _Approx.Approx_FitAndDivide2d_swiginit(self, _Approx.new_Approx_FitAndDivide2d(*args))

    def Error(self, *args) -> "void":
        """
        * returns the tolerances 2d and 3d of the <Index> MultiCurve.
        	:param Index:
        	:type Index: int
        	:param tol3d:
        	:type tol3d: float
        	:param tol2d:
        	:type tol2d: float
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide2d_Error(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        * returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.
        	:rtype: bool
        """
        return _Approx.Approx_FitAndDivide2d_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        * returns False if the status NoPointsAdded has been sent.
        	:rtype: bool
        """
        return _Approx.Approx_FitAndDivide2d_IsToleranceReached(self, *args)


    def NbMultiCurves(self, *args) -> "Standard_Integer":
        """
        * Returns the number of MultiCurve doing the approximation of the MultiLine.
        	:rtype: int
        """
        return _Approx.Approx_FitAndDivide2d_NbMultiCurves(self, *args)


    def Parameters(self, *args) -> "void":
        """
        :param Index:
        	:type Index: int
        	:param firstp:
        	:type firstp: float
        	:param lastp:
        	:type lastp: float
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide2d_Parameters(self, *args)


    def Perform(self, *args) -> "void":
        """
        * runs the algorithm after having initialized the fields.
        	:param Line:
        	:type Line: AppCont_Function
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide2d_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        * Changes the constraints of the approximation.
        	:param FirstC:
        	:type FirstC: AppParCurves_Constraint
        	:param LastC:
        	:type LastC: AppParCurves_Constraint
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide2d_SetConstraints(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        * changes the degrees of the approximation.
        	:param degreemin:
        	:type degreemin: int
        	:param degreemax:
        	:type degreemax: int
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide2d_SetDegrees(self, *args)


    def SetInvOrder(self, *args) -> "void":
        """
        * Set inverse order of degree selection: if theInvOrdr = true, current degree is chosen by inverse order - from maxdegree to mindegree. By default inverse order is used.
        	:param theInvOrder:
        	:type theInvOrder: bool
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide2d_SetInvOrder(self, *args)


    def SetMaxSegments(self, *args) -> "void":
        """
        * Changes the max number of segments, which is allowed for cutting.
        	:param theMaxSegments:
        	:type theMaxSegments: int
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide2d_SetMaxSegments(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        * Changes the tolerances of the approximation.
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:rtype: None
        """
        return _Approx.Approx_FitAndDivide2d_SetTolerances(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the approximation MultiCurve of range <Index>.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: AppParCurves_MultiCurve
        """
        return _Approx.Approx_FitAndDivide2d_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_FitAndDivide2d
Approx_FitAndDivide2d.Error = new_instancemethod(_Approx.Approx_FitAndDivide2d_Error, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.IsAllApproximated = new_instancemethod(_Approx.Approx_FitAndDivide2d_IsAllApproximated, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.IsToleranceReached = new_instancemethod(_Approx.Approx_FitAndDivide2d_IsToleranceReached, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.NbMultiCurves = new_instancemethod(_Approx.Approx_FitAndDivide2d_NbMultiCurves, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.Parameters = new_instancemethod(_Approx.Approx_FitAndDivide2d_Parameters, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.Perform = new_instancemethod(_Approx.Approx_FitAndDivide2d_Perform, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetConstraints = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetConstraints, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetDegrees = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetDegrees, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetInvOrder = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetInvOrder, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetMaxSegments = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetMaxSegments, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetTolerances = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetTolerances, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d.Value = new_instancemethod(_Approx.Approx_FitAndDivide2d_Value, None, Approx_FitAndDivide2d)
Approx_FitAndDivide2d_swigregister = _Approx.Approx_FitAndDivide2d_swigregister
Approx_FitAndDivide2d_swigregister(Approx_FitAndDivide2d)

class Approx_MCurvesToBSpCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Append(self, *args) -> "void":
        """
        :param MC:
        	:type MC: AppParCurves_MultiCurve
        	:rtype: None
        """
        return _Approx.Approx_MCurvesToBSpCurve_Append(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _Approx.Approx_MCurvesToBSpCurve_swiginit(self, _Approx.new_Approx_MCurvesToBSpCurve(*args))

    def ChangeValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * return the composite MultiCurves as a MultiBSpCurve.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _Approx.Approx_MCurvesToBSpCurve_ChangeValue(self, *args)


    def Perform(self, *args) -> "void":
        """
        :rtype: None
        :param TheSeq:
        	:type TheSeq: AppParCurves_SequenceOfMultiCurve
        	:rtype: None
        """
        return _Approx.Approx_MCurvesToBSpCurve_Perform(self, *args)


    def Reset(self, *args) -> "void":
        """:rtype: None"""
        return _Approx.Approx_MCurvesToBSpCurve_Reset(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * return the composite MultiCurves as a MultiBSpCurve.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _Approx.Approx_MCurvesToBSpCurve_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_MCurvesToBSpCurve
Approx_MCurvesToBSpCurve.Append = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Append, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.ChangeValue = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_ChangeValue, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.Perform = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Perform, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.Reset = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Reset, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.Value = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Value, None, Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve_swigregister = _Approx.Approx_MCurvesToBSpCurve_swigregister
Approx_MCurvesToBSpCurve_swigregister(Approx_MCurvesToBSpCurve)

class Approx_SameParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Warning: the C3D and C2D must have the same parametric domain.
        	:param C3D:
        	:type C3D: Geom_Curve
        	:param C2D:
        	:type C2D: Geom2d_Curve
        	:param S:
        	:type S: Geom_Surface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        :param C3D:
        	:type C3D: Adaptor3d_HCurve
        	:param C2D:
        	:type C2D: Geom2d_Curve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Warning: the C3D and C2D must have the same parametric domain.
        	:param C3D:
        	:type C3D: Adaptor3d_HCurve
        	:param C2D:
        	:type C2D: Adaptor2d_HCurve2d
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _Approx.Approx_SameParameter_swiginit(self, _Approx.new_Approx_SameParameter(*args))

    def Curve2d(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        * Returns the 2D curve that has the same parameter as the 3D curve once evaluated on the surface up to the specified tolerance
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _Approx.Approx_SameParameter_Curve2d(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Approx.Approx_SameParameter_IsDone(self, *args)


    def IsSameParameter(self, *args) -> "Standard_Boolean":
        """
        * Tells whether the original data had already the same parameter up to the tolerance : in that case nothing is done.
        	:rtype: bool
        """
        return _Approx.Approx_SameParameter_IsSameParameter(self, *args)


    def TolReached(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Approx.Approx_SameParameter_TolReached(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_SameParameter
Approx_SameParameter.Curve2d = new_instancemethod(_Approx.Approx_SameParameter_Curve2d, None, Approx_SameParameter)
Approx_SameParameter.IsDone = new_instancemethod(_Approx.Approx_SameParameter_IsDone, None, Approx_SameParameter)
Approx_SameParameter.IsSameParameter = new_instancemethod(_Approx.Approx_SameParameter_IsSameParameter, None, Approx_SameParameter)
Approx_SameParameter.TolReached = new_instancemethod(_Approx.Approx_SameParameter_TolReached, None, Approx_SameParameter)
Approx_SameParameter_swigregister = _Approx.Approx_SameParameter_swigregister
Approx_SameParameter_swigregister(Approx_SameParameter)

class Approx_SweepApproximation(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Func:
        	:type Func: Approx_SweepFunction
        	:rtype: None
        """
        _Approx.Approx_SweepApproximation_swiginit(self, _Approx.new_Approx_SweepApproximation(*args))

    def Average2dError(self, *args) -> "Standard_Real":
        """
        * returns the average error of the <Index> 2d curve approximation.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _Approx.Approx_SweepApproximation_Average2dError(self, *args)


    def AverageErrorOnSurf(self, *args) -> "Standard_Real":
        """
        * returns the average error in the suface approximation.
        	:rtype: float
        """
        return _Approx.Approx_SweepApproximation_AverageErrorOnSurf(self, *args)


    def Curve2d(self, *args) -> "void":
        """
        :param Index:
        	:type Index: int
        	:param TPoles:
        	:type TPoles: TColgp_Array1OfPnt2d
        	:param TKnots:
        	:type TKnots: TColStd_Array1OfReal
        	:param TMults:
        	:type TMults: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _Approx.Approx_SweepApproximation_Curve2d(self, *args)


    def Curve2dPoles(self, *args) -> "TColgp_Array1OfPnt2d const &":
        """
        :param Index:
        	:type Index: int
        	:rtype: TColgp_Array1OfPnt2d
        """
        return _Approx.Approx_SweepApproximation_Curve2dPoles(self, *args)


    def Curves2dDegree(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Approx.Approx_SweepApproximation_Curves2dDegree(self, *args)


    def Curves2dKnots(self, *args) -> "TColStd_Array1OfReal const &":
        """:rtype: TColStd_Array1OfReal"""
        return _Approx.Approx_SweepApproximation_Curves2dKnots(self, *args)


    def Curves2dMults(self, *args) -> "TColStd_Array1OfInteger const &":
        """:rtype: TColStd_Array1OfInteger"""
        return _Approx.Approx_SweepApproximation_Curves2dMults(self, *args)


    def Curves2dShape(self, *args) -> "void":
        """
        :param Degree:
        	:type Degree: int
        	:param NbPoles:
        	:type NbPoles: int
        	:param NbKnots:
        	:type NbKnots: int
        	:rtype: None
        """
        return _Approx.Approx_SweepApproximation_Curves2dShape(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(Approx_SweepApproximation self) -> std::string"""
        return _Approx.Approx_SweepApproximation_DumpToString(self)


    def Eval(self, *args) -> "Standard_Integer":
        """
        * The EvaluatorFunction from AdvApprox;
        	:param Parameter:
        	:type Parameter: float
        	:param DerivativeRequest:
        	:type DerivativeRequest: int
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Result:
        	:type Result: float
        	:rtype: int
        """
        return _Approx.Approx_SweepApproximation_Eval(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns if we have an result
        	:rtype: bool
        """
        return _Approx.Approx_SweepApproximation_IsDone(self, *args)


    def Max2dError(self, *args) -> "Standard_Real":
        """
        * returns the maximum error of the <Index> 2d curve approximation.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _Approx.Approx_SweepApproximation_Max2dError(self, *args)


    def MaxErrorOnSurf(self, *args) -> "Standard_Real":
        """
        * returns the maximum error in the suface approximation.
        	:rtype: float
        """
        return _Approx.Approx_SweepApproximation_MaxErrorOnSurf(self, *args)


    def NbCurves2d(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Approx.Approx_SweepApproximation_NbCurves2d(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Perform the Approximation [First, Last] : Approx_SweepApproximation.cdl Tol3d : Tolerance to surface approximation Tol2d : Tolerance used to perform curve approximation Normaly the 2d curve are approximated with a tolerance given by the resolution on support surfaces, but if this tolerance is too large Tol2d is used. TolAngular : Tolerance (in radian) to control the angle beetween tangents on the section law and tangent of iso-v on approximed surface Continuity : The continuity in v waiting on the surface Degmax : The maximum degree in v requiered on the surface Segmax : The maximum number of span in v requiered on the surface Warning : The continuity ci can be obtained only if Ft is Ci
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Tol3d:
        	:type Tol3d: float
        	:param BoundTol:
        	:type BoundTol: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param TolAngular:
        	:type TolAngular: float
        	:param Continuity: default value is GeomAbs_C0
        	:type Continuity: GeomAbs_Shape
        	:param Degmax: default value is 11
        	:type Degmax: int
        	:param Segmax: default value is 50
        	:type Segmax: int
        	:rtype: None
        """
        return _Approx.Approx_SweepApproximation_Perform(self, *args)


    def SurfPoles(self, *args) -> "TColgp_Array2OfPnt const &":
        """:rtype: TColgp_Array2OfPnt"""
        return _Approx.Approx_SweepApproximation_SurfPoles(self, *args)


    def SurfShape(self, *args) -> "void":
        """
        :param UDegree:
        	:type UDegree: int
        	:param VDegree:
        	:type VDegree: int
        	:param NbUPoles:
        	:type NbUPoles: int
        	:param NbVPoles:
        	:type NbVPoles: int
        	:param NbUKnots:
        	:type NbUKnots: int
        	:param NbVKnots:
        	:type NbVKnots: int
        	:rtype: None
        """
        return _Approx.Approx_SweepApproximation_SurfShape(self, *args)


    def SurfUKnots(self, *args) -> "TColStd_Array1OfReal const &":
        """:rtype: TColStd_Array1OfReal"""
        return _Approx.Approx_SweepApproximation_SurfUKnots(self, *args)


    def SurfUMults(self, *args) -> "TColStd_Array1OfInteger const &":
        """:rtype: TColStd_Array1OfInteger"""
        return _Approx.Approx_SweepApproximation_SurfUMults(self, *args)


    def SurfVKnots(self, *args) -> "TColStd_Array1OfReal const &":
        """:rtype: TColStd_Array1OfReal"""
        return _Approx.Approx_SweepApproximation_SurfVKnots(self, *args)


    def SurfVMults(self, *args) -> "TColStd_Array1OfInteger const &":
        """:rtype: TColStd_Array1OfInteger"""
        return _Approx.Approx_SweepApproximation_SurfVMults(self, *args)


    def SurfWeights(self, *args) -> "TColStd_Array2OfReal const &":
        """:rtype: TColStd_Array2OfReal"""
        return _Approx.Approx_SweepApproximation_SurfWeights(self, *args)


    def Surface(self, *args) -> "void":
        """
        :param TPoles:
        	:type TPoles: TColgp_Array2OfPnt
        	:param TWeights:
        	:type TWeights: TColStd_Array2OfReal
        	:param TUKnots:
        	:type TUKnots: TColStd_Array1OfReal
        	:param TVKnots:
        	:type TVKnots: TColStd_Array1OfReal
        	:param TUMults:
        	:type TUMults: TColStd_Array1OfInteger
        	:param TVMults:
        	:type TVMults: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _Approx.Approx_SweepApproximation_Surface(self, *args)


    def TolCurveOnSurf(self, *args) -> "Standard_Real":
        """
        * returns the maximum 3d error of the <Index> 2d curve approximation on the Surface.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _Approx.Approx_SweepApproximation_TolCurveOnSurf(self, *args)


    def UDegree(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Approx.Approx_SweepApproximation_UDegree(self, *args)


    def VDegree(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Approx.Approx_SweepApproximation_VDegree(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_SweepApproximation
Approx_SweepApproximation.Average2dError = new_instancemethod(_Approx.Approx_SweepApproximation_Average2dError, None, Approx_SweepApproximation)
Approx_SweepApproximation.AverageErrorOnSurf = new_instancemethod(_Approx.Approx_SweepApproximation_AverageErrorOnSurf, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curve2d = new_instancemethod(_Approx.Approx_SweepApproximation_Curve2d, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curve2dPoles = new_instancemethod(_Approx.Approx_SweepApproximation_Curve2dPoles, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dDegree = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dDegree, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dKnots = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dKnots, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dMults = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dMults, None, Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dShape = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dShape, None, Approx_SweepApproximation)
Approx_SweepApproximation.DumpToString = new_instancemethod(_Approx.Approx_SweepApproximation_DumpToString, None, Approx_SweepApproximation)
Approx_SweepApproximation.Eval = new_instancemethod(_Approx.Approx_SweepApproximation_Eval, None, Approx_SweepApproximation)
Approx_SweepApproximation.IsDone = new_instancemethod(_Approx.Approx_SweepApproximation_IsDone, None, Approx_SweepApproximation)
Approx_SweepApproximation.Max2dError = new_instancemethod(_Approx.Approx_SweepApproximation_Max2dError, None, Approx_SweepApproximation)
Approx_SweepApproximation.MaxErrorOnSurf = new_instancemethod(_Approx.Approx_SweepApproximation_MaxErrorOnSurf, None, Approx_SweepApproximation)
Approx_SweepApproximation.NbCurves2d = new_instancemethod(_Approx.Approx_SweepApproximation_NbCurves2d, None, Approx_SweepApproximation)
Approx_SweepApproximation.Perform = new_instancemethod(_Approx.Approx_SweepApproximation_Perform, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfPoles = new_instancemethod(_Approx.Approx_SweepApproximation_SurfPoles, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfShape = new_instancemethod(_Approx.Approx_SweepApproximation_SurfShape, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfUKnots = new_instancemethod(_Approx.Approx_SweepApproximation_SurfUKnots, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfUMults = new_instancemethod(_Approx.Approx_SweepApproximation_SurfUMults, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfVKnots = new_instancemethod(_Approx.Approx_SweepApproximation_SurfVKnots, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfVMults = new_instancemethod(_Approx.Approx_SweepApproximation_SurfVMults, None, Approx_SweepApproximation)
Approx_SweepApproximation.SurfWeights = new_instancemethod(_Approx.Approx_SweepApproximation_SurfWeights, None, Approx_SweepApproximation)
Approx_SweepApproximation.Surface = new_instancemethod(_Approx.Approx_SweepApproximation_Surface, None, Approx_SweepApproximation)
Approx_SweepApproximation.TolCurveOnSurf = new_instancemethod(_Approx.Approx_SweepApproximation_TolCurveOnSurf, None, Approx_SweepApproximation)
Approx_SweepApproximation.UDegree = new_instancemethod(_Approx.Approx_SweepApproximation_UDegree, None, Approx_SweepApproximation)
Approx_SweepApproximation.VDegree = new_instancemethod(_Approx.Approx_SweepApproximation_VDegree, None, Approx_SweepApproximation)
Approx_SweepApproximation_swigregister = _Approx.Approx_SweepApproximation_swigregister
Approx_SweepApproximation_swigregister(Approx_SweepApproximation)

class Approx_SweepFunction(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BarycentreOfSurf(self, *args) -> "gp_Pnt":
        """
        * Get the barycentre of Surface. An very poor estimation is sufficent. This information is usefull to perform well conditioned rational approximation. Warning: Used only if <self> IsRational
        	:rtype: gp_Pnt
        """
        return _Approx.Approx_SweepFunction_BarycentreOfSurf(self, *args)


    def D0(self, *args) -> "Standard_Boolean":
        """
        * compute the section for v = param
        	:param Param:
        	:type Param: float
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Approx.Approx_SweepFunction_D0(self, *args)


    def D1(self, *args) -> "Standard_Boolean":
        """
        * compute the first derivative in v direction of the section for v = param Warning : It used only for C1 or C2 aproximation
        	:param Param:
        	:type Param: float
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Approx.Approx_SweepFunction_D1(self, *args)


    def D2(self, *args) -> "Standard_Boolean":
        """
        * compute the second derivative in v direction of the section for v = param Warning : It used only for C2 aproximation
        	:param Param:
        	:type Param: float
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param D2Poles2d:
        	:type D2Poles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:param D2Weigths:
        	:type D2Weigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Approx.Approx_SweepFunction_D2(self, *args)


    def GetMinimalWeight(self, *args) -> "void":
        """
        * Compute the minimal value of weight for each poles in all sections. This information is usefull to control error in rational approximation. Warning: Used only if <self> IsRational
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        """
        return _Approx.Approx_SweepFunction_GetMinimalWeight(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        * Returns the tolerance to reach in approximation to satisfy. BoundTol error at the Boundary AngleTol tangent error at the Boundary (in radian) SurfTol error inside the surface.
        	:param BoundTol:
        	:type BoundTol: float
        	:param SurfTol:
        	:type SurfTol: float
        	:param AngleTol:
        	:type AngleTol: float
        	:param Tol3d:
        	:type Tol3d: TColStd_Array1OfReal
        	:rtype: void
        """
        return _Approx.Approx_SweepFunction_GetTolerance(self, *args)


    def Intervals(self, *args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: void
        """
        return _Approx.Approx_SweepFunction_Intervals(self, *args)


    def IsRational(self, *args) -> "Standard_Boolean":
        """
        * Returns if the sections are rationnal or not
        	:rtype: bool
        """
        return _Approx.Approx_SweepFunction_IsRational(self, *args)


    def Knots(self, *args) -> "void":
        """
        * get the Knots of the section
        	:param TKnots:
        	:type TKnots: TColStd_Array1OfReal
        	:rtype: void
        """
        return _Approx.Approx_SweepFunction_Knots(self, *args)


    def MaximalSection(self, *args) -> "Standard_Real":
        """
        * Returns the length of the greater section. This information is usefull to G1's control. Warning: With an little value, approximation can be slower.
        	:rtype: float
        """
        return _Approx.Approx_SweepFunction_MaximalSection(self, *args)


    def Mults(self, *args) -> "void":
        """
        * get the Multplicities of the section
        	:param TMults:
        	:type TMults: TColStd_Array1OfInteger
        	:rtype: void
        """
        return _Approx.Approx_SweepFunction_Mults(self, *args)


    def Nb2dCurves(self, *args) -> "Standard_Integer":
        """
        * get the number of 2d curves to approximate.
        	:rtype: int
        """
        return _Approx.Approx_SweepFunction_Nb2dCurves(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _Approx.Approx_SweepFunction_NbIntervals(self, *args)


    def Resolution(self, *args) -> "void":
        """
        * Returns the resolutions in the sub-space 2d <Index> This information is usfull to find an good tolerance in 2d approximation.
        	:param Index:
        	:type Index: int
        	:param Tol:
        	:type Tol: float
        	:param TolU:
        	:type TolU: float
        	:param TolV:
        	:type TolV: float
        	:rtype: void
        """
        return _Approx.Approx_SweepFunction_Resolution(self, *args)


    def SectionShape(self, *args) -> "void":
        """
        * get the format of an section
        	:param NbPoles:
        	:type NbPoles: int
        	:param NbKnots:
        	:type NbKnots: int
        	:param Degree:
        	:type Degree: int
        	:rtype: void
        """
        return _Approx.Approx_SweepFunction_SectionShape(self, *args)


    def SetInterval(self, *args) -> "void":
        """
        * Sets the bounds of the parametric interval on the fonction This determines the derivatives in these values if the function is not Cn.
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _Approx.Approx_SweepFunction_SetInterval(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Is usefull, if (me) have to run numerical algorithm to perform D0, D1 or D2
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:rtype: void
        """
        return _Approx.Approx_SweepFunction_SetTolerance(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Approx_SweepFunction_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Approx.delete_Approx_SweepFunction
Approx_SweepFunction.BarycentreOfSurf = new_instancemethod(_Approx.Approx_SweepFunction_BarycentreOfSurf, None, Approx_SweepFunction)
Approx_SweepFunction.D0 = new_instancemethod(_Approx.Approx_SweepFunction_D0, None, Approx_SweepFunction)
Approx_SweepFunction.D1 = new_instancemethod(_Approx.Approx_SweepFunction_D1, None, Approx_SweepFunction)
Approx_SweepFunction.D2 = new_instancemethod(_Approx.Approx_SweepFunction_D2, None, Approx_SweepFunction)
Approx_SweepFunction.GetMinimalWeight = new_instancemethod(_Approx.Approx_SweepFunction_GetMinimalWeight, None, Approx_SweepFunction)
Approx_SweepFunction.GetTolerance = new_instancemethod(_Approx.Approx_SweepFunction_GetTolerance, None, Approx_SweepFunction)
Approx_SweepFunction.Intervals = new_instancemethod(_Approx.Approx_SweepFunction_Intervals, None, Approx_SweepFunction)
Approx_SweepFunction.IsRational = new_instancemethod(_Approx.Approx_SweepFunction_IsRational, None, Approx_SweepFunction)
Approx_SweepFunction.Knots = new_instancemethod(_Approx.Approx_SweepFunction_Knots, None, Approx_SweepFunction)
Approx_SweepFunction.MaximalSection = new_instancemethod(_Approx.Approx_SweepFunction_MaximalSection, None, Approx_SweepFunction)
Approx_SweepFunction.Mults = new_instancemethod(_Approx.Approx_SweepFunction_Mults, None, Approx_SweepFunction)
Approx_SweepFunction.Nb2dCurves = new_instancemethod(_Approx.Approx_SweepFunction_Nb2dCurves, None, Approx_SweepFunction)
Approx_SweepFunction.NbIntervals = new_instancemethod(_Approx.Approx_SweepFunction_NbIntervals, None, Approx_SweepFunction)
Approx_SweepFunction.Resolution = new_instancemethod(_Approx.Approx_SweepFunction_Resolution, None, Approx_SweepFunction)
Approx_SweepFunction.SectionShape = new_instancemethod(_Approx.Approx_SweepFunction_SectionShape, None, Approx_SweepFunction)
Approx_SweepFunction.SetInterval = new_instancemethod(_Approx.Approx_SweepFunction_SetInterval, None, Approx_SweepFunction)
Approx_SweepFunction.SetTolerance = new_instancemethod(_Approx.Approx_SweepFunction_SetTolerance, None, Approx_SweepFunction)
Approx_SweepFunction_swigregister = _Approx.Approx_SweepFunction_swigregister
Approx_SweepFunction_swigregister(Approx_SweepFunction)

class Approx_HArray1OfGTrsf2d(Approx_Array1OfGTrsf2d, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Approx_HArray1OfGTrsf2d_swiginit(self, _Approx.new_Approx_HArray1OfGTrsf2d(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Approx_HArray1OfGTrsf2d_DownCast(t)

    __swig_destroy__ = _Approx.delete_Approx_HArray1OfGTrsf2d
Approx_HArray1OfGTrsf2d.Array1 = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Array1, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.ChangeArray1 = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_ChangeArray1, None, Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d_swigregister = _Approx.Approx_HArray1OfGTrsf2d_swigregister
Approx_HArray1OfGTrsf2d_swigregister(Approx_HArray1OfGTrsf2d)

class Approx_HArray1OfAdHSurface(Approx_Array1OfAdHSurface, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Approx.Approx_HArray1OfAdHSurface_swiginit(self, _Approx.new_Approx_HArray1OfAdHSurface(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Approx_HArray1OfAdHSurface_DownCast(t)

    __swig_destroy__ = _Approx.delete_Approx_HArray1OfAdHSurface
Approx_HArray1OfAdHSurface.Array1 = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Array1, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.ChangeArray1 = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_ChangeArray1, None, Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface_swigregister = _Approx.Approx_HArray1OfAdHSurface_swigregister
Approx_HArray1OfAdHSurface_swigregister(Approx_HArray1OfAdHSurface)



