# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BRepApprox module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_brepapprox.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BRepApprox.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepApprox')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepApprox')
    _BRepApprox = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepApprox', [dirname(__file__)])
        except ImportError:
            import _BRepApprox
            return _BRepApprox
        try:
            _mod = imp.load_module('_BRepApprox', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepApprox = swig_import_helper()
    del swig_import_helper
else:
    import _BRepApprox
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepApprox.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BRepApprox.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BRepApprox.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BRepApprox.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BRepApprox.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BRepApprox.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BRepApprox.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BRepApprox.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BRepApprox.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BRepApprox.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BRepApprox.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BRepApprox.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BRepApprox.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BRepApprox.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BRepApprox.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BRepApprox.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BRepApprox.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BRepApprox.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _BRepApprox.process_exception(error, method_name, class_name)
process_exception = _BRepApprox.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Approx
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.AppCont
import OCC.Core.AppParCurves
import OCC.Core.IntSurf
import OCC.Core.BRepAdaptor
import OCC.Core.TopoDS
import OCC.Core.TopLoc
import OCC.Core.GeomAdaptor
import OCC.Core.Geom2dAdaptor
import OCC.Core.IntImp
import OCC.Core.ApproxInt

def Handle_BRepApprox_ApproxLine_Create() -> "opencascade::handle< BRepApprox_ApproxLine >":
    return _BRepApprox.Handle_BRepApprox_ApproxLine_Create()
Handle_BRepApprox_ApproxLine_Create = _BRepApprox.Handle_BRepApprox_ApproxLine_Create

def Handle_BRepApprox_ApproxLine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< BRepApprox_ApproxLine >":
    return _BRepApprox.Handle_BRepApprox_ApproxLine_DownCast(t)
Handle_BRepApprox_ApproxLine_DownCast = _BRepApprox.Handle_BRepApprox_ApproxLine_DownCast

def Handle_BRepApprox_ApproxLine_IsNull(t: 'opencascade::handle< BRepApprox_ApproxLine > const &') -> "bool":
    return _BRepApprox.Handle_BRepApprox_ApproxLine_IsNull(t)
Handle_BRepApprox_ApproxLine_IsNull = _BRepApprox.Handle_BRepApprox_ApproxLine_IsNull
class BRepApprox_Approx(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _BRepApprox.BRepApprox_Approx_swiginit(self, _BRepApprox.new_BRepApprox_Approx(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _BRepApprox.BRepApprox_Approx_IsDone(self, *args)


    def NbMultiCurves(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _BRepApprox.BRepApprox_Approx_NbMultiCurves(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        :param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param DegMin:
        	:type DegMin: int
        	:param DegMax:
        	:type DegMax: int
        	:param NbIterMax:
        	:type NbIterMax: int
        	:param NbPntMax: default value is 30
        	:type NbPntMax: int
        	:param ApproxWithTangency: default value is Standard_True
        	:type ApproxWithTangency: bool
        	:param Parametrization: default value is Approx_ChordLength
        	:type Parametrization: Approx_ParametrizationType
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_Approx_SetParameters(self, *args)


    def TolReached2d(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _BRepApprox.BRepApprox_Approx_TolReached2d(self, *args)


    def TolReached3d(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _BRepApprox.BRepApprox_Approx_TolReached3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        :param Index:
        	:type Index: int
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _BRepApprox.BRepApprox_Approx_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_Approx
BRepApprox_Approx.IsDone = new_instancemethod(_BRepApprox.BRepApprox_Approx_IsDone, None, BRepApprox_Approx)
BRepApprox_Approx.NbMultiCurves = new_instancemethod(_BRepApprox.BRepApprox_Approx_NbMultiCurves, None, BRepApprox_Approx)
BRepApprox_Approx.SetParameters = new_instancemethod(_BRepApprox.BRepApprox_Approx_SetParameters, None, BRepApprox_Approx)
BRepApprox_Approx.TolReached2d = new_instancemethod(_BRepApprox.BRepApprox_Approx_TolReached2d, None, BRepApprox_Approx)
BRepApprox_Approx.TolReached3d = new_instancemethod(_BRepApprox.BRepApprox_Approx_TolReached3d, None, BRepApprox_Approx)
BRepApprox_Approx.Value = new_instancemethod(_BRepApprox.BRepApprox_Approx_Value, None, BRepApprox_Approx)
BRepApprox_Approx_swigregister = _BRepApprox.BRepApprox_Approx_swigregister
BRepApprox_Approx_swigregister(BRepApprox_Approx)

class BRepApprox_ApproxLine(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param CurveXYZ:
        	:type CurveXYZ: Geom_BSplineCurve
        	:param CurveUV1:
        	:type CurveUV1: Geom2d_BSplineCurve
        	:param CurveUV2:
        	:type CurveUV2: Geom2d_BSplineCurve
        	:rtype: None
        * theTang variable has been entered only for compatibility with the alias IntPatch_WLine. They are not used in this class.
        	:param lin:
        	:type lin: IntSurf_LineOn2S
        	:param theTang: default value is Standard_False
        	:type theTang: bool
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ApproxLine_swiginit(self, _BRepApprox.new_BRepApprox_ApproxLine(*args))

    def NbPnts(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _BRepApprox.BRepApprox_ApproxLine_NbPnts(self, *args)


    def Point(self, *args) -> "IntSurf_PntOn2S":
        """
        :param Index:
        	:type Index: int
        	:rtype: IntSurf_PntOn2S
        """
        return _BRepApprox.BRepApprox_ApproxLine_Point(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_BRepApprox_ApproxLine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ApproxLine
BRepApprox_ApproxLine.NbPnts = new_instancemethod(_BRepApprox.BRepApprox_ApproxLine_NbPnts, None, BRepApprox_ApproxLine)
BRepApprox_ApproxLine.Point = new_instancemethod(_BRepApprox.BRepApprox_ApproxLine_Point, None, BRepApprox_ApproxLine)
BRepApprox_ApproxLine_swigregister = _BRepApprox.BRepApprox_ApproxLine_swigregister
BRepApprox_ApproxLine_swigregister(BRepApprox_ApproxLine)

class BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox
BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_swigregister
BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has <NbPol> control points.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox(*args))

    def CurveValue(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        * returns the MultiBSpCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_CurveValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the multiline.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_DerivativeFunctionMatrix(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_FirstConstraint(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the multiline.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_FunctionMatrix(self, *args)


    def Index(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Index(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiBSpCurve.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiBSpCurve.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_NewParameters(self, *args)


    def SetFirstLambda(self, *args) -> "void":
        """
        :param l1:
        	:type l1: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_SetFirstLambda(self, *args)


    def SetLastLambda(self, *args) -> "void":
        """
        :param l2:
        	:type l2: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_SetLastLambda(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.CurveValue = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_CurveValue, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.DerivativeFunctionMatrix = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_DerivativeFunctionMatrix, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Error, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.FirstConstraint = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_FirstConstraint, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.FunctionMatrix = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_FunctionMatrix, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.Index = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Index, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.LastConstraint = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_LastConstraint, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.MaxError2d = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_MaxError2d, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.MaxError3d = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_MaxError3d, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.NewParameters = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_NewParameters, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.SetFirstLambda = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_SetFirstLambda, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox.SetLastLambda = new_instancemethod(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_SetLastLambda, None, BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_swigregister
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox(*args))

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.BSplineValue = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_BSplineValue, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.BezierValue = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_BezierValue, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.DerivativeFunctionMatrix = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_DerivativeFunctionMatrix, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.Distance = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Distance, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Error, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.ErrorGradient = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_ErrorGradient, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.FirstLambda = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_FirstLambda, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.FunctionMatrix = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_FunctionMatrix, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.IsDone = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_IsDone, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.KIndex = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_KIndex, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.LastLambda = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_LastLambda, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.Perform = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Perform, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.Points = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Points, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox.Poles = new_instancemethod(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Poles, None, BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_swigregister
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox
BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox
BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_MyBSplGradientOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_AverageError(self, *args)


    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 1
        	:type NbIterations: int
        	:rtype: None
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations:
        	:type NbIterations: int
        	:param lambda1:
        	:type lambda1: float
        	:param lambda2:
        	:type lambda2: float
        	:rtype: None
        """
        _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox(*args))

    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        * returns all the BSpline curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.AverageError = new_instancemethod(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_AverageError, None, BRepApprox_MyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_Error, None, BRepApprox_MyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.IsDone = new_instancemethod(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_IsDone, None, BRepApprox_MyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.MaxError2d = new_instancemethod(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_MaxError2d, None, BRepApprox_MyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.MaxError3d = new_instancemethod(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_MaxError3d, None, BRepApprox_MyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox.Value = new_instancemethod(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_Value, None, BRepApprox_MyBSplGradientOfTheComputeLineOfApprox)
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_swigregister
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_MyGradientOfTheComputeLineBezierOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_AverageError(self, *args)


    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox(*args))

    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiCurve
        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.AverageError = new_instancemethod(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_AverageError, None, BRepApprox_MyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_Error, None, BRepApprox_MyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.IsDone = new_instancemethod(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_IsDone, None, BRepApprox_MyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.MaxError2d = new_instancemethod(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_MaxError2d, None, BRepApprox_MyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.MaxError3d = new_instancemethod(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_MaxError3d, None, BRepApprox_MyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox.Value = new_instancemethod(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_Value, None, BRepApprox_MyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_MyGradientbisOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_AverageError(self, *args)


    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_MyGradientbisOfTheComputeLineOfApprox(*args))

    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiCurve
        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_MyGradientbisOfTheComputeLineOfApprox
BRepApprox_MyGradientbisOfTheComputeLineOfApprox.AverageError = new_instancemethod(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_AverageError, None, BRepApprox_MyGradientbisOfTheComputeLineOfApprox)
BRepApprox_MyGradientbisOfTheComputeLineOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_Error, None, BRepApprox_MyGradientbisOfTheComputeLineOfApprox)
BRepApprox_MyGradientbisOfTheComputeLineOfApprox.IsDone = new_instancemethod(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_IsDone, None, BRepApprox_MyGradientbisOfTheComputeLineOfApprox)
BRepApprox_MyGradientbisOfTheComputeLineOfApprox.MaxError2d = new_instancemethod(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_MaxError2d, None, BRepApprox_MyGradientbisOfTheComputeLineOfApprox)
BRepApprox_MyGradientbisOfTheComputeLineOfApprox.MaxError3d = new_instancemethod(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_MaxError3d, None, BRepApprox_MyGradientbisOfTheComputeLineOfApprox)
BRepApprox_MyGradientbisOfTheComputeLineOfApprox.Value = new_instancemethod(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_Value, None, BRepApprox_MyGradientbisOfTheComputeLineOfApprox)
BRepApprox_MyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_MyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_MyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox(*args))

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the MultiCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiCurve
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.CurveValue = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_CurveValue, None, BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_Error, None, BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.FirstConstraint = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_FirstConstraint, None, BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.LastConstraint = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_LastConstraint, None, BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.MaxError2d = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_MaxError2d, None, BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.MaxError3d = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_MaxError3d, None, BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox.NewParameters = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_NewParameters, None, BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox(*args))

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the MultiCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiCurve
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.CurveValue = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_CurveValue, None, BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_Error, None, BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.FirstConstraint = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_FirstConstraint, None, BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.LastConstraint = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_LastConstraint, None, BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.MaxError2d = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_MaxError2d, None, BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.MaxError3d = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_MaxError3d, None, BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox.NewParameters = new_instancemethod(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_NewParameters, None, BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox(*args))

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.BSplineValue = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_BSplineValue, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.BezierValue = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_BezierValue, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.DerivativeFunctionMatrix = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_DerivativeFunctionMatrix, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.Distance = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Distance, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Error, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.ErrorGradient = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_ErrorGradient, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.FirstLambda = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_FirstLambda, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.FunctionMatrix = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_FunctionMatrix, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.IsDone = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_IsDone, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.KIndex = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_KIndex, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.LastLambda = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_LastLambda, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.Perform = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Perform, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.Points = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Points, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox.Poles = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Poles, None, BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox(*args))

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.BSplineValue = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_BSplineValue, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.BezierValue = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_BezierValue, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.DerivativeFunctionMatrix = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_DerivativeFunctionMatrix, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.Distance = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Distance, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Error, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.ErrorGradient = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_ErrorGradient, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.FirstLambda = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_FirstLambda, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.FunctionMatrix = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_FunctionMatrix, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.IsDone = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_IsDone, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.KIndex = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_KIndex, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.LastLambda = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_LastLambda, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.Perform = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Perform, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.Points = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Points, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox.Poles = new_instancemethod(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Poles, None, BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox(*args))

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        * Returns the derivative of the constraint matrix.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param DA:
        	:type DA: math_Matrix
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """:rtype: math_Matrix"""
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        * returns the duale variables of the system.
        	:rtype: math_Vector
        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_IsDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox
BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.ConstraintDerivative = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_ConstraintDerivative, None, BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.ConstraintMatrix = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_ConstraintMatrix, None, BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.Duale = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_Duale, None, BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.InverseMatrix = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_InverseMatrix, None, BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox.IsDone = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_IsDone, None, BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox)
BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox(*args))

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        * Returns the derivative of the constraint matrix.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param DA:
        	:type DA: math_Matrix
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """:rtype: math_Matrix"""
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        * returns the duale variables of the system.
        	:rtype: math_Vector
        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.
        	:rtype: math_Matrix
        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_IsDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox
BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.ConstraintDerivative = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_ConstraintDerivative, None, BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.ConstraintMatrix = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_ConstraintMatrix, None, BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.Duale = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_Duale, None, BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.InverseMatrix = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_InverseMatrix, None, BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox.IsDone = new_instancemethod(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_IsDone, None, BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox)
BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_TheComputeLineBezierOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheComputeLineBezierOfApprox(*args))

    def ChangeValue(self, *args) -> "AppParCurves_MultiCurve &":
        """
        * returns the result of the approximation.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: AppParCurves_MultiCurve
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_ChangeValue(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the tolerances 2d and 3d of the <Index> MultiCurve.
        	:param Index:
        	:type Index: int
        	:param tol3d:
        	:type tol3d: float
        	:param tol2d:
        	:type tol2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Error(self, *args)


    def Init(self, *args) -> "void":
        """
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Init(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        * returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        * returns False if the status NoPointsAdded has been sent.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_IsToleranceReached(self, *args)


    def NbMultiCurves(self, *args) -> "Standard_Integer":
        """
        * Returns the number of MultiCurve doing the approximation of the MultiLine.
        	:rtype: int
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_NbMultiCurves(self, *args)


    def Parameters(self, *args) -> "TColStd_Array1OfReal const &":
        """
        * returns the new parameters of the approximation corresponding to the points of the multicurve <Index>.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: TColStd_Array1OfReal
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Parameters(self, *args)


    def Parametrization(self, *args) -> "Approx_ParametrizationType":
        """
        * returns the type of parametrization
        	:rtype: Approx_ParametrizationType
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Parametrization(self, *args)


    def Perform(self, *args) -> "void":
        """
        * runs the algorithm after having initialized the fields.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        * changes the first and the last constraint points.
        	:param firstC:
        	:type firstC: AppParCurves_Constraint
        	:param lastC:
        	:type lastC: AppParCurves_Constraint
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetConstraints(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        * changes the degrees of the approximation.
        	:param degreemin:
        	:type degreemin: int
        	:param degreemax:
        	:type degreemax: int
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetDegrees(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        * Changes the tolerances of the approximation.
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetTolerances(self, *args)


    def SplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SplineValue(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the result of the approximation.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: AppParCurves_MultiCurve
        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheComputeLineBezierOfApprox
BRepApprox_TheComputeLineBezierOfApprox.ChangeValue = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_ChangeValue, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Error, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.Init = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Init, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.IsAllApproximated = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_IsAllApproximated, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.IsToleranceReached = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_IsToleranceReached, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.NbMultiCurves = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_NbMultiCurves, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.Parameters = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Parameters, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.Parametrization = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Parametrization, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.Perform = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Perform, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.SetConstraints = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetConstraints, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.SetDegrees = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetDegrees, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.SetTolerances = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetTolerances, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.SplineValue = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SplineValue, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox.Value = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Value, None, BRepApprox_TheComputeLineBezierOfApprox)
BRepApprox_TheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_swigregister
BRepApprox_TheComputeLineBezierOfApprox_swigregister(BRepApprox_TheComputeLineBezierOfApprox)

class BRepApprox_TheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all. //! The multiplicities of the internal knots is set by default.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheComputeLineOfApprox(*args))

    def ChangeValue(self, *args) -> "AppParCurves_MultiBSpCurve &":
        """
        * returns the result of the approximation.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_ChangeValue(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the tolerances 2d and 3d of the MultiBSpCurve.
        	:param tol3d:
        	:type tol3d: float
        	:param tol2d:
        	:type tol2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Error(self, *args)


    def Init(self, *args) -> "void":
        """
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Init(self, *args)


    def Interpol(self, *args) -> "void":
        """
        * Constructs an interpolation of the MultiLine <Line> The result will be a C2 curve of degree 3.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Interpol(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        * returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        * returns False if the status NoPointsAdded has been sent.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_IsToleranceReached(self, *args)


    def Parameters(self, *args) -> "TColStd_Array1OfReal const &":
        """
        * returns the new parameters of the approximation corresponding to the points of the MultiBSpCurve.
        	:rtype: TColStd_Array1OfReal
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Parameters(self, *args)


    def Perform(self, *args) -> "void":
        """
        * runs the algorithm after having initialized the fields.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        * changes the first and the last constraint points.
        	:param firstC:
        	:type firstC: AppParCurves_Constraint
        	:param lastC:
        	:type lastC: AppParCurves_Constraint
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetConstraints(self, *args)


    def SetContinuity(self, *args) -> "void":
        """
        * sets the continuity of the spline. if C = 2, the spline will be C2.
        	:param C:
        	:type C: int
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetContinuity(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        * changes the degrees of the approximation.
        	:param degreemin:
        	:type degreemin: int
        	:param degreemax:
        	:type degreemax: int
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetDegrees(self, *args)


    def SetKnots(self, *args) -> "void":
        """
        * The approximation will be done with the set of knots <Knots>. The multiplicities will be set with the degree and the desired continuity.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetKnots(self, *args)


    def SetKnotsAndMultiplicities(self, *args) -> "void":
        """
        * The approximation will be done with the set of knots <Knots> and the multiplicities <Mults>.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetKnotsAndMultiplicities(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        * The approximation will begin with the set of parameters <ThePar>.
        	:param ThePar:
        	:type ThePar: math_Vector
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetParameters(self, *args)


    def SetPeriodic(self, *args) -> "void":
        """
        * Sets periodic flag. If thePeriodic = Standard_True, algorith tries to build periodic multicurve using corresponding C1 boundary condition for first and last multipoints. Multiline must be closed.
        	:param thePeriodic:
        	:type thePeriodic: bool
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetPeriodic(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        * Changes the tolerances of the approximation.
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetTolerances(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheComputeLineOfApprox
BRepApprox_TheComputeLineOfApprox.ChangeValue = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_ChangeValue, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.Error = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Error, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.Init = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Init, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.Interpol = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Interpol, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.IsAllApproximated = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_IsAllApproximated, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.IsToleranceReached = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_IsToleranceReached, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.Parameters = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Parameters, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.Perform = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Perform, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.SetConstraints = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetConstraints, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.SetContinuity = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetContinuity, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.SetDegrees = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetDegrees, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.SetKnots = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetKnots, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.SetKnotsAndMultiplicities = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetKnotsAndMultiplicities, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.SetParameters = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetParameters, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.SetPeriodic = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetPeriodic, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.SetTolerances = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetTolerances, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox.Value = new_instancemethod(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Value, None, BRepApprox_TheComputeLineOfApprox)
BRepApprox_TheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_TheComputeLineOfApprox_swigregister
BRepApprox_TheComputeLineOfApprox_swigregister(BRepApprox_TheComputeLineOfApprox)

class BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AuxillarSurface1(self, *args) -> "BRepAdaptor_Surface const &":
        """:rtype: BRepAdaptor_Surface"""
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_AuxillarSurface1(self, *args)


    def AuxillarSurface2(self, *args) -> "BRepAdaptor_Surface const &":
        """:rtype: BRepAdaptor_Surface"""
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_AuxillarSurface2(self, *args)


    def __init__(self, *args):
        """
        :param S1:
        	:type S1: BRepAdaptor_Surface
        	:param S2:
        	:type S2: BRepAdaptor_Surface
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox(*args))

    def ComputeParameters(self, *args) -> "void":
        """
        :param ChoixIso:
        	:type ChoixIso: IntImp_ConstIsoparametric
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param UVap:
        	:type UVap: math_Vector
        	:param BornInf:
        	:type BornInf: math_Vector
        	:param BornSup:
        	:type BornSup: math_Vector
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_ComputeParameters(self, *args)


    def Direction(self, *args) -> "gp_Dir":
        """:rtype: gp_Dir"""
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Direction(self, *args)


    def DirectionOnS1(self, *args) -> "gp_Dir2d":
        """:rtype: gp_Dir2d"""
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS1(self, *args)


    def DirectionOnS2(self, *args) -> "gp_Dir2d":
        """:rtype: gp_Dir2d"""
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS2(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        :param UVap:
        	:type UVap: math_Vector
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param BestChoix:
        	:type BestChoix: IntImp_ConstIsoparametric
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_IsTangent(self, *args)


    def Point(self, *args) -> "gp_Pnt":
        """:rtype: gp_Pnt"""
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        * returns somme des fi*fi
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Root(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.AuxillarSurface1 = new_instancemethod(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_AuxillarSurface1, None, BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.AuxillarSurface2 = new_instancemethod(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_AuxillarSurface2, None, BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.ComputeParameters = new_instancemethod(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_ComputeParameters, None, BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.Direction = new_instancemethod(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Direction, None, BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.DirectionOnS1 = new_instancemethod(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS1, None, BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.DirectionOnS2 = new_instancemethod(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS2, None, BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.IsTangent = new_instancemethod(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_IsTangent, None, BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.Point = new_instancemethod(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Point, None, BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox.Root = new_instancemethod(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Root, None, BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)

class BRepApprox_TheImpPrmSvSurfacesOfApprox(OCC.Core.ApproxInt.ApproxInt_SvSurfaces):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Surf1:
        	:type Surf1: BRepAdaptor_Surface
        	:param Surf2:
        	:type Surf2: IntSurf_Quadric
        	:rtype: None
        :param Surf1:
        	:type Surf1: IntSurf_Quadric
        	:param Surf2:
        	:type Surf2: BRepAdaptor_Surface
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheImpPrmSvSurfacesOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheImpPrmSvSurfacesOfApprox
BRepApprox_TheImpPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_swigregister
BRepApprox_TheImpPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheImpPrmSvSurfacesOfApprox)

class BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * compute the solution point with the close point
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param S1:
        	:type S1: BRepAdaptor_Surface
        	:param S2:
        	:type S2: BRepAdaptor_Surface
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None
        * initialize the parameters to compute the solution point it 's possible to write to optimize: IntImp_Int2S inter(S1,S2,Func,TolTangency); math_FunctionSetRoot rsnld(inter.Function()); while ...{ Param(1)=... Param(2)=... param(3)=... inter.Perform(Param,rsnld); }
        	:param S1:
        	:type S1: BRepAdaptor_Surface
        	:param S2:
        	:type S2: BRepAdaptor_Surface
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox(*args))

    def ChangePoint(self, *args) -> "IntSurf_PntOn2S &":
        """
        * return the intersection point which is enable for changing.
        	:rtype: IntSurf_PntOn2S
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_ChangePoint(self, *args)


    def Direction(self, *args) -> "gp_Dir const":
        """
        * Returns the tangent at the intersection line.
        	:rtype: gp_Dir
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Direction(self, *args)


    def DirectionOnS1(self, *args) -> "gp_Dir2d const":
        """
        * Returns the tangent at the intersection line in the parametric space of the first surface.
        	:rtype: gp_Dir2d
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS1(self, *args)


    def DirectionOnS2(self, *args) -> "gp_Dir2d const":
        """
        * Returns the tangent at the intersection line in the parametric space of the second surface.
        	:rtype: gp_Dir2d
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS2(self, *args)


    def Function(self, *args) -> "BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox &":
        """
        * return the math function which is used to compute the intersection
        	:rtype: BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Function(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the creation completed without failure.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns True when there is no solution to the problem.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsEmpty(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the surfaces are tangent at the intersection point.
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsTangent(self, *args)


    def Perform(self, *args) -> "IntImp_ConstIsoparametric":
        """
        * returns the best constant isoparametric to find the next intersection's point +stores the solution point (the solution point is found with the close point to intersect the isoparametric with the other patch; the choice of the isoparametic is calculated)
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param Rsnld:
        	:type Rsnld: math_FunctionSetRoot
        	:rtype: IntImp_ConstIsoparametric
        * returns the best constant isoparametric to find the next intersection's point +stores the solution point (the solution point is found with the close point to intersect the isoparametric with the other patch; the choice of the isoparametic is given by ChoixIso)
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param Rsnld:
        	:type Rsnld: math_FunctionSetRoot
        	:param ChoixIso:
        	:type ChoixIso: IntImp_ConstIsoparametric
        	:rtype: IntImp_ConstIsoparametric
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Perform(self, *args)


    def Point(self, *args) -> "IntSurf_PntOn2S const &":
        """
        * Returns the intersection point.
        	:rtype: IntSurf_PntOn2S
        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Point(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.ChangePoint = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_ChangePoint, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.Direction = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Direction, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.DirectionOnS1 = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS1, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.DirectionOnS2 = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS2, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.Function = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Function, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.IsDone = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsDone, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.IsEmpty = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsEmpty, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.IsTangent = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsTangent, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.Perform = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Perform, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox.Point = new_instancemethod(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Point, None, BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)

class BRepApprox_TheMultiLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        * The class SvSurfaces is used when the approximation algorithm needs some extra points on the line <line>. A New line is then created which shares the same surfaces and functions. SvSurfaces is a deferred class which allows several implementations of this algorithm with different surfaces (bi-parametric ones, or implicit and biparametric ones)
        	:param line:
        	:type line: BRepApprox_ApproxLine
        	:param PtrSvSurfaces:
        	:type PtrSvSurfaces: Standard_Address
        	:param NbP3d:
        	:type NbP3d: int
        	:param NbP2d:
        	:type NbP2d: int
        	:param ApproxU1V1:
        	:type ApproxU1V1: bool
        	:param ApproxU2V2:
        	:type ApproxU2V2: bool
        	:param xo:
        	:type xo: float
        	:param yo:
        	:type yo: float
        	:param zo:
        	:type zo: float
        	:param u1o:
        	:type u1o: float
        	:param v1o:
        	:type v1o: float
        	:param u2o:
        	:type u2o: float
        	:param v2o:
        	:type v2o: float
        	:param P2DOnFirst:
        	:type P2DOnFirst: bool
        	:param IndMin: default value is 0
        	:type IndMin: int
        	:param IndMax: default value is 0
        	:type IndMax: int
        	:rtype: None
        * No Extra points will be added on the current line
        	:param line:
        	:type line: BRepApprox_ApproxLine
        	:param NbP3d:
        	:type NbP3d: int
        	:param NbP2d:
        	:type NbP2d: int
        	:param ApproxU1V1:
        	:type ApproxU1V1: bool
        	:param ApproxU2V2:
        	:type ApproxU2V2: bool
        	:param xo:
        	:type xo: float
        	:param yo:
        	:type yo: float
        	:param zo:
        	:type zo: float
        	:param u1o:
        	:type u1o: float
        	:param v1o:
        	:type v1o: float
        	:param u2o:
        	:type u2o: float
        	:param v2o:
        	:type v2o: float
        	:param P2DOnFirst:
        	:type P2DOnFirst: bool
        	:param IndMin: default value is 0
        	:type IndMin: int
        	:param IndMax: default value is 0
        	:type IndMax: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheMultiLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheMultiLineOfApprox(*args))

    def Dump(self, *args) -> "void":
        """
        * Dump of the current multi-line.
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_Dump(self, *args)


    def FirstPoint(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_FirstPoint(self, *args)


    def LastPoint(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_LastPoint(self, *args)


    def MakeMLBetween(self, *args) -> "BRepApprox_TheMultiLineOfApprox":
        """
        * Tries to make a sub-line between <Low> and <High> points of this line by adding <NbPointsToInsert> new points
        	:param Low:
        	:type Low: int
        	:param High:
        	:type High: int
        	:param NbPointsToInsert:
        	:type NbPointsToInsert: int
        	:rtype: BRepApprox_TheMultiLineOfApprox
        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_MakeMLBetween(self, *args)


    def MakeMLOneMorePoint(self, *args) -> "Standard_Boolean":
        """
        * Tries to make a sub-line between <Low> and <High> points of this line by adding one more point between (indbad-1)-th and indbad-th points
        	:param Low:
        	:type Low: int
        	:param High:
        	:type High: int
        	:param indbad:
        	:type indbad: int
        	:param OtherLine:
        	:type OtherLine: BRepApprox_TheMultiLineOfApprox
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_MakeMLOneMorePoint(self, *args)


    def NbP2d(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 2d points of a TheLine.
        	:rtype: int
        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_NbP2d(self, *args)


    def NbP3d(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 3d points of a TheLine.
        	:rtype: int
        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_NbP3d(self, *args)


    def Tangency(self, *args) -> "Standard_Boolean":
        """
        * Returns the 3d tangency points of the multipoint <MPointIndex> only when 3d points exist.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:rtype: bool
        * Returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        * Returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_Tangency(self, *args)


    def Value(self, *args) -> "void":
        """
        * Returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:rtype: None
        * Returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: None
        * Returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_Value(self, *args)


    def WhatStatus(self, *args) -> "Approx_Status":
        """:rtype: Approx_Status"""
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_WhatStatus(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheMultiLineOfApprox
BRepApprox_TheMultiLineOfApprox.Dump = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_Dump, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox.FirstPoint = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_FirstPoint, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox.LastPoint = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_LastPoint, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox.MakeMLBetween = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_MakeMLBetween, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox.MakeMLOneMorePoint = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_MakeMLOneMorePoint, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox.NbP2d = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_NbP2d, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox.NbP3d = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_NbP3d, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox.Tangency = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_Tangency, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox.Value = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_Value, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox.WhatStatus = new_instancemethod(_BRepApprox.BRepApprox_TheMultiLineOfApprox_WhatStatus, None, BRepApprox_TheMultiLineOfApprox)
BRepApprox_TheMultiLineOfApprox_swigregister = _BRepApprox.BRepApprox_TheMultiLineOfApprox_swigregister
BRepApprox_TheMultiLineOfApprox_swigregister(BRepApprox_TheMultiLineOfApprox)

class BRepApprox_TheMultiLineToolOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Curvature(*args) -> "Standard_Boolean":
        """
        * returns the 3d curvature of the multipoint <MPointIndex> when only 3d points exist.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:rtype: bool
        * returns the 2d curvature points of the multipoint <MPointIndex> only when 2d points exist.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        * returns the 3d and 2d curvature of the multipoint <MPointIndex>.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Curvature(*args)

    Curvature = staticmethod(Curvature)

    def Dump(*args) -> "void":
        """
        * Dump of the current multi-line.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Dump(*args)

    Dump = staticmethod(Dump)

    def FirstPoint(*args) -> "Standard_Integer":
        """
        * Returns the number of multipoints of the TheMultiLine.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:rtype: int
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_FirstPoint(*args)

    FirstPoint = staticmethod(FirstPoint)

    def LastPoint(*args) -> "Standard_Integer":
        """
        * Returns the number of multipoints of the TheMultiLine.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:rtype: int
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_LastPoint(*args)

    LastPoint = staticmethod(LastPoint)

    def MakeMLBetween(*args) -> "BRepApprox_TheMultiLineOfApprox":
        """
        * Is called if WhatStatus returned 'PointsAdded'.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:param NbPMin:
        	:type NbPMin: int
        	:rtype: BRepApprox_TheMultiLineOfApprox
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween(*args)

    MakeMLBetween = staticmethod(MakeMLBetween)

    def MakeMLOneMorePoint(*args) -> "Standard_Boolean":
        """
        * Is called when the Bezier curve contains a loop
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:param indbad:
        	:type indbad: int
        	:param OtherLine:
        	:type OtherLine: BRepApprox_TheMultiLineOfApprox
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint(*args)

    MakeMLOneMorePoint = staticmethod(MakeMLOneMorePoint)

    def NbP2d(*args) -> "Standard_Integer":
        """
        * Returns the number of 2d points of a TheMultiLine.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:rtype: int
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP2d(*args)

    NbP2d = staticmethod(NbP2d)

    def NbP3d(*args) -> "Standard_Integer":
        """
        * Returns the number of 3d points of a TheMultiLine.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:rtype: int
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP3d(*args)

    NbP3d = staticmethod(NbP3d)

    def Tangency(*args) -> "Standard_Boolean":
        """
        * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:rtype: bool
        * returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        * returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Tangency(*args)

    Tangency = staticmethod(Tangency)

    def Value(*args) -> "void":
        """
        * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:rtype: None
        * returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: None
        * returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Value(*args)

    Value = staticmethod(Value)

    def WhatStatus(*args) -> "Approx_Status":
        """
        :param ML:
        	:type ML: BRepApprox_TheMultiLineOfApprox
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:rtype: Approx_Status
        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_WhatStatus(*args)

    WhatStatus = staticmethod(WhatStatus)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheMultiLineToolOfApprox())
    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheMultiLineToolOfApprox
BRepApprox_TheMultiLineToolOfApprox_swigregister = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_swigregister
BRepApprox_TheMultiLineToolOfApprox_swigregister(BRepApprox_TheMultiLineToolOfApprox)

def BRepApprox_TheMultiLineToolOfApprox_Curvature(*args) -> "Standard_Boolean":
    """
    * returns the 3d curvature of the multipoint <MPointIndex> when only 3d points exist.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:rtype: bool
    * returns the 2d curvature points of the multipoint <MPointIndex> only when 2d points exist.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    * returns the 3d and 2d curvature of the multipoint <MPointIndex>.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Curvature(*args)

def BRepApprox_TheMultiLineToolOfApprox_Dump(*args) -> "void":
    """
    * Dump of the current multi-line.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:rtype: None
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Dump(*args)

def BRepApprox_TheMultiLineToolOfApprox_FirstPoint(*args) -> "Standard_Integer":
    """
    * Returns the number of multipoints of the TheMultiLine.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:rtype: int
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_FirstPoint(*args)

def BRepApprox_TheMultiLineToolOfApprox_LastPoint(*args) -> "Standard_Integer":
    """
    * Returns the number of multipoints of the TheMultiLine.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:rtype: int
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_LastPoint(*args)

def BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween(*args) -> "BRepApprox_TheMultiLineOfApprox":
    """
    * Is called if WhatStatus returned 'PointsAdded'.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:param NbPMin:
    	:type NbPMin: int
    	:rtype: BRepApprox_TheMultiLineOfApprox
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween(*args)

def BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint(*args) -> "Standard_Boolean":
    """
    * Is called when the Bezier curve contains a loop
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:param indbad:
    	:type indbad: int
    	:param OtherLine:
    	:type OtherLine: BRepApprox_TheMultiLineOfApprox
    	:rtype: bool
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint(*args)

def BRepApprox_TheMultiLineToolOfApprox_NbP2d(*args) -> "Standard_Integer":
    """
    * Returns the number of 2d points of a TheMultiLine.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:rtype: int
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP2d(*args)

def BRepApprox_TheMultiLineToolOfApprox_NbP3d(*args) -> "Standard_Integer":
    """
    * Returns the number of 3d points of a TheMultiLine.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:rtype: int
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP3d(*args)

def BRepApprox_TheMultiLineToolOfApprox_Tangency(*args) -> "Standard_Boolean":
    """
    * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:rtype: bool
    * returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    * returns the 3d and 2d points of the multipoint <MPointIndex>.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Tangency(*args)

def BRepApprox_TheMultiLineToolOfApprox_Value(*args) -> "void":
    """
    * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabPt:
    	:type tabPt: TColgp_Array1OfPnt
    	:rtype: None
    * returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabPt2d:
    	:type tabPt2d: TColgp_Array1OfPnt2d
    	:rtype: None
    * returns the 3d and 2d points of the multipoint <MPointIndex>.
    	:param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabPt:
    	:type tabPt: TColgp_Array1OfPnt
    	:param tabPt2d:
    	:type tabPt2d: TColgp_Array1OfPnt2d
    	:rtype: None
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Value(*args)

def BRepApprox_TheMultiLineToolOfApprox_WhatStatus(*args) -> "Approx_Status":
    """
    :param ML:
    	:type ML: BRepApprox_TheMultiLineOfApprox
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:rtype: Approx_Status
    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_WhatStatus(*args)

class BRepApprox_ThePrmPrmSvSurfacesOfApprox(OCC.Core.ApproxInt.ApproxInt_SvSurfaces):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Surf1:
        	:type Surf1: BRepAdaptor_Surface
        	:param Surf2:
        	:type Surf2: BRepAdaptor_Surface
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ThePrmPrmSvSurfacesOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ThePrmPrmSvSurfacesOfApprox
BRepApprox_ThePrmPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_swigregister
BRepApprox_ThePrmPrmSvSurfacesOfApprox_swigregister(BRepApprox_ThePrmPrmSvSurfacesOfApprox)

class BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param PS:
        	:type PS: BRepAdaptor_Surface
        	:param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        :param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox(*args))

    def Direction2d(self, *args) -> "gp_Dir2d const":
        """:rtype: gp_Dir2d"""
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Direction2d(self, *args)


    def Direction3d(self, *args) -> "gp_Vec const":
        """:rtype: gp_Vec"""
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Direction3d(self, *args)


    def ISurface(self, *args) -> "IntSurf_Quadric const &":
        """:rtype: IntSurf_Quadric"""
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_ISurface(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_IsTangent(self, *args)


    def PSurface(self, *args) -> "BRepAdaptor_Surface const &":
        """:rtype: BRepAdaptor_Surface"""
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_PSurface(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Root(self, *args)


    def Set(self, *args) -> "void":
        """
        :param PS:
        	:type PS: BRepAdaptor_Surface
        	:rtype: None
        :param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Set(self, *args)


    def SetImplicitSurface(self, *args) -> "void":
        """
        :param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_SetImplicitSurface(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * Returns the value Tol so that if Abs(Func.Root())<Tol the function is considered null.
        	:rtype: float
        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Tolerance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.Direction2d = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Direction2d, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.Direction3d = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Direction3d, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.ISurface = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_ISurface, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.IsTangent = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_IsTangent, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.PSurface = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_PSurface, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.Point = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Point, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.Root = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Root, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.Set = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Set, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.SetImplicitSurface = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_SetImplicitSurface, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox.Tolerance = new_instancemethod(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Tolerance, None, BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_swigregister
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)



