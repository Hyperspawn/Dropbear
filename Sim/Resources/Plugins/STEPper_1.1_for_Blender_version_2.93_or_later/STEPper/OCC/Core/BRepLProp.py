# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BRepLProp module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_breplprop.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BRepLProp.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepLProp')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepLProp')
    _BRepLProp = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepLProp', [dirname(__file__)])
        except ImportError:
            import _BRepLProp
            return _BRepLProp
        try:
            _mod = imp.load_module('_BRepLProp', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepLProp = swig_import_helper()
    del swig_import_helper
else:
    import _BRepLProp
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepLProp.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BRepLProp.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BRepLProp.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BRepLProp.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BRepLProp.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BRepLProp.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BRepLProp.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BRepLProp.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BRepLProp.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BRepLProp.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BRepLProp.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BRepLProp.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BRepLProp.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BRepLProp.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BRepLProp.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BRepLProp.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BRepLProp.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BRepLProp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _BRepLProp.process_exception(error, method_name, class_name)
process_exception = _BRepLProp.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.BRepAdaptor
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.TopoDS
import OCC.Core.TopLoc
import OCC.Core.GeomAdaptor
import OCC.Core.Geom2dAdaptor
class breplprop(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Continuity(*args) -> "GeomAbs_Shape":
        """
        * Computes the regularity at the junction between C1 and C2. The point u1 on C1 and the point u2 on C2 must be confused. tl and ta are the linear and angular tolerance used two compare the derivative.
        	:param C1:
        	:type C1: BRepAdaptor_Curve
        	:param C2:
        	:type C2: BRepAdaptor_Curve
        	:param u1:
        	:type u1: float
        	:param u2:
        	:type u2: float
        	:param tl:
        	:type tl: float
        	:param ta:
        	:type ta: float
        	:rtype: GeomAbs_Shape
        * The same as preciding but using the standard tolerances from package Precision.
        	:param C1:
        	:type C1: BRepAdaptor_Curve
        	:param C2:
        	:type C2: BRepAdaptor_Curve
        	:param u1:
        	:type u1: float
        	:param u2:
        	:type u2: float
        	:rtype: GeomAbs_Shape
        """
        return _BRepLProp.breplprop_Continuity(*args)

    Continuity = staticmethod(Continuity)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepLProp.breplprop_swiginit(self, _BRepLProp.new_breplprop())
    __swig_destroy__ = _BRepLProp.delete_breplprop
breplprop_swigregister = _BRepLProp.breplprop_swigregister
breplprop_swigregister(breplprop)

def breplprop_Continuity(*args) -> "GeomAbs_Shape":
    """
    * Computes the regularity at the junction between C1 and C2. The point u1 on C1 and the point u2 on C2 must be confused. tl and ta are the linear and angular tolerance used two compare the derivative.
    	:param C1:
    	:type C1: BRepAdaptor_Curve
    	:param C2:
    	:type C2: BRepAdaptor_Curve
    	:param u1:
    	:type u1: float
    	:param u2:
    	:type u2: float
    	:param tl:
    	:type tl: float
    	:param ta:
    	:type ta: float
    	:rtype: GeomAbs_Shape
    * The same as preciding but using the standard tolerances from package Precision.
    	:param C1:
    	:type C1: BRepAdaptor_Curve
    	:param C2:
    	:type C2: BRepAdaptor_Curve
    	:param u1:
    	:type u1: float
    	:param u2:
    	:type u2: float
    	:rtype: GeomAbs_Shape
    """
    return _BRepLProp.breplprop_Continuity(*args)

class BRepLProp_CLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the local properties of the curve <C> The current point and the derivatives are computed at the same time, which allows an optimization of the computation time. <N> indicates the maximum number of derivations to be done (0, 1, 2 or 3). For example, to compute only the tangent, N should be equal to 1. <Resolution> is the linear tolerance (it is used to test if a vector is null).
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        * Same as previous constructor but here the parameter is set to the value <U>. All the computations done will be related to <C> and <U>.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        * Same as previous constructor but here the parameter is set to the value <U> and the curve is set with SetCurve. the curve can have a empty constructor All the computations done will be related to <C> and <U> when the functions 'set' will be done.
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        """
        _BRepLProp.BRepLProp_CLProps_swiginit(self, _BRepLProp.new_BRepLProp_CLProps(*args))

    def CentreOfCurvature(self, *args) -> "void":
        """
        * Returns the centre of curvature <P>.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_CLProps_CentreOfCurvature(self, *args)


    def Curvature(self, *args) -> "Standard_Real":
        """
        * Returns the curvature.
        	:rtype: float
        """
        return _BRepLProp.BRepLProp_CLProps_Curvature(self, *args)


    def D1(self, *args) -> "gp_Vec const":
        """
        * Returns the first derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _BRepLProp.BRepLProp_CLProps_D1(self, *args)


    def D2(self, *args) -> "gp_Vec const":
        """
        * Returns the second derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _BRepLProp.BRepLProp_CLProps_D2(self, *args)


    def D3(self, *args) -> "gp_Vec const":
        """
        * Returns the third derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _BRepLProp.BRepLProp_CLProps_D3(self, *args)


    def IsTangentDefined(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the tangent is defined. For example, the tangent is not defined if the three first derivatives are all null.
        	:rtype: bool
        """
        return _BRepLProp.BRepLProp_CLProps_IsTangentDefined(self, *args)


    def Normal(self, *args) -> "void":
        """
        * Returns the normal direction <N>.
        	:param N:
        	:type N: gp_Dir
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_CLProps_Normal(self, *args)


    def SetCurve(self, *args) -> "void":
        """
        * Initializes the local properties of the curve for the new curve.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_CLProps_SetCurve(self, *args)


    def SetParameter(self, *args) -> "void":
        """
        * Initializes the local properties of the curve for the parameter value <U>.
        	:param U:
        	:type U: float
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_CLProps_SetParameter(self, *args)


    def Tangent(self, *args) -> "void":
        """
        * output the tangent direction <D>
        	:param D:
        	:type D: gp_Dir
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_CLProps_Tangent(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        * Returns the Point.
        	:rtype: gp_Pnt
        """
        return _BRepLProp.BRepLProp_CLProps_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepLProp.delete_BRepLProp_CLProps
BRepLProp_CLProps.CentreOfCurvature = new_instancemethod(_BRepLProp.BRepLProp_CLProps_CentreOfCurvature, None, BRepLProp_CLProps)
BRepLProp_CLProps.Curvature = new_instancemethod(_BRepLProp.BRepLProp_CLProps_Curvature, None, BRepLProp_CLProps)
BRepLProp_CLProps.D1 = new_instancemethod(_BRepLProp.BRepLProp_CLProps_D1, None, BRepLProp_CLProps)
BRepLProp_CLProps.D2 = new_instancemethod(_BRepLProp.BRepLProp_CLProps_D2, None, BRepLProp_CLProps)
BRepLProp_CLProps.D3 = new_instancemethod(_BRepLProp.BRepLProp_CLProps_D3, None, BRepLProp_CLProps)
BRepLProp_CLProps.IsTangentDefined = new_instancemethod(_BRepLProp.BRepLProp_CLProps_IsTangentDefined, None, BRepLProp_CLProps)
BRepLProp_CLProps.Normal = new_instancemethod(_BRepLProp.BRepLProp_CLProps_Normal, None, BRepLProp_CLProps)
BRepLProp_CLProps.SetCurve = new_instancemethod(_BRepLProp.BRepLProp_CLProps_SetCurve, None, BRepLProp_CLProps)
BRepLProp_CLProps.SetParameter = new_instancemethod(_BRepLProp.BRepLProp_CLProps_SetParameter, None, BRepLProp_CLProps)
BRepLProp_CLProps.Tangent = new_instancemethod(_BRepLProp.BRepLProp_CLProps_Tangent, None, BRepLProp_CLProps)
BRepLProp_CLProps.Value = new_instancemethod(_BRepLProp.BRepLProp_CLProps_Value, None, BRepLProp_CLProps)
BRepLProp_CLProps_swigregister = _BRepLProp.BRepLProp_CLProps_swigregister
BRepLProp_CLProps_swigregister(BRepLProp_CLProps)

class BRepLProp_CurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Continuity(*args) -> "Standard_Integer":
        """
        * returns the order of continuity of the curve <C>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable. returns 3 : first, second and third are computable.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: int
        """
        return _BRepLProp.BRepLProp_CurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D1(*args) -> "void":
        """
        * Computes the point <P> and first derivative <V1> of parameter <U> on the curve <C>.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:rtype: void
        """
        return _BRepLProp.BRepLProp_CurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Computes the point <P>, the first derivative <V1> and second derivative <V2> of parameter <U> on the curve <C>.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: void
        """
        return _BRepLProp.BRepLProp_CurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        * Computes the point <P>, the first derivative <V1>, the second derivative <V2> and third derivative <V3> of parameter <U> on the curve <C>.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:param V3:
        	:type V3: gp_Vec
        	:rtype: void
        """
        return _BRepLProp.BRepLProp_CurveTool_D3(*args)

    D3 = staticmethod(D3)

    def FirstParameter(*args) -> "Standard_Real":
        """
        * returns the first parameter bound of the curve.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: float
        """
        return _BRepLProp.BRepLProp_CurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args) -> "Standard_Real":
        """
        * returns the last parameter bound of the curve. FirstParameter must be less than LastParamenter.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: float
        """
        return _BRepLProp.BRepLProp_CurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Value(*args) -> "void":
        """
        * Computes the point <P> of parameter <U> on the curve <C>.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:rtype: void
        """
        return _BRepLProp.BRepLProp_CurveTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepLProp.BRepLProp_CurveTool_swiginit(self, _BRepLProp.new_BRepLProp_CurveTool())
    __swig_destroy__ = _BRepLProp.delete_BRepLProp_CurveTool
BRepLProp_CurveTool_swigregister = _BRepLProp.BRepLProp_CurveTool_swigregister
BRepLProp_CurveTool_swigregister(BRepLProp_CurveTool)

def BRepLProp_CurveTool_Continuity(*args) -> "Standard_Integer":
    """
    * returns the order of continuity of the curve <C>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable. returns 3 : first, second and third are computable.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: int
    """
    return _BRepLProp.BRepLProp_CurveTool_Continuity(*args)

def BRepLProp_CurveTool_D1(*args) -> "void":
    """
    * Computes the point <P> and first derivative <V1> of parameter <U> on the curve <C>.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:rtype: void
    """
    return _BRepLProp.BRepLProp_CurveTool_D1(*args)

def BRepLProp_CurveTool_D2(*args) -> "void":
    """
    * Computes the point <P>, the first derivative <V1> and second derivative <V2> of parameter <U> on the curve <C>.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:rtype: void
    """
    return _BRepLProp.BRepLProp_CurveTool_D2(*args)

def BRepLProp_CurveTool_D3(*args) -> "void":
    """
    * Computes the point <P>, the first derivative <V1>, the second derivative <V2> and third derivative <V3> of parameter <U> on the curve <C>.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:param V3:
    	:type V3: gp_Vec
    	:rtype: void
    """
    return _BRepLProp.BRepLProp_CurveTool_D3(*args)

def BRepLProp_CurveTool_FirstParameter(*args) -> "Standard_Real":
    """
    * returns the first parameter bound of the curve.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: float
    """
    return _BRepLProp.BRepLProp_CurveTool_FirstParameter(*args)

def BRepLProp_CurveTool_LastParameter(*args) -> "Standard_Real":
    """
    * returns the last parameter bound of the curve. FirstParameter must be less than LastParamenter.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: float
    """
    return _BRepLProp.BRepLProp_CurveTool_LastParameter(*args)

def BRepLProp_CurveTool_Value(*args) -> "void":
    """
    * Computes the point <P> of parameter <U> on the curve <C>.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:rtype: void
    """
    return _BRepLProp.BRepLProp_CurveTool_Value(*args)

class BRepLProp_SLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Initializes the local properties of the surface <S> for the parameter values (<U>, <V>). The current point and the derivatives are computed at the same time, which allows an optimization of the computation time. <N> indicates the maximum number of derivations to be done (0, 1, or 2). For example, to compute only the tangent, N should be equal to 1. <Resolution> is the linear tolerance (it is used to test if a vector is null).
        	:param S:
        	:type S: BRepAdaptor_Surface
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        * idem as previous constructor but without setting the value of parameters <U> and <V>.
        	:param S:
        	:type S: BRepAdaptor_Surface
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        * idem as previous constructor but without setting the value of parameters <U> and <V> and the surface. the surface can have an empty constructor.
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        """
        _BRepLProp.BRepLProp_SLProps_swiginit(self, _BRepLProp.new_BRepLProp_SLProps(*args))

    def CurvatureDirections(self, *args) -> "void":
        """
        * Returns the direction of the maximum and minimum curvature <MaxD> and <MinD>
        	:param MaxD:
        	:type MaxD: gp_Dir
        	:param MinD:
        	:type MinD: gp_Dir
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_SLProps_CurvatureDirections(self, *args)


    def D1U(self, *args) -> "gp_Vec const":
        """
        * Returns the first U derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _BRepLProp.BRepLProp_SLProps_D1U(self, *args)


    def D1V(self, *args) -> "gp_Vec const":
        """
        * Returns the first V derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _BRepLProp.BRepLProp_SLProps_D1V(self, *args)


    def D2U(self, *args) -> "gp_Vec const":
        """
        * Returns the second U derivatives The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _BRepLProp.BRepLProp_SLProps_D2U(self, *args)


    def D2V(self, *args) -> "gp_Vec const":
        """
        * Returns the second V derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _BRepLProp.BRepLProp_SLProps_D2V(self, *args)


    def DUV(self, *args) -> "gp_Vec const":
        """
        * Returns the second UV cross-derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _BRepLProp.BRepLProp_SLProps_DUV(self, *args)


    def GaussianCurvature(self, *args) -> "Standard_Real":
        """
        * Returns the Gaussian curvature
        	:rtype: float
        """
        return _BRepLProp.BRepLProp_SLProps_GaussianCurvature(self, *args)


    def IsCurvatureDefined(self, *args) -> "Standard_Boolean":
        """
        * returns True if the curvature is defined.
        	:rtype: bool
        """
        return _BRepLProp.BRepLProp_SLProps_IsCurvatureDefined(self, *args)


    def IsNormalDefined(self, *args) -> "Standard_Boolean":
        """
        * Tells if the normal is defined.
        	:rtype: bool
        """
        return _BRepLProp.BRepLProp_SLProps_IsNormalDefined(self, *args)


    def IsTangentUDefined(self, *args) -> "Standard_Boolean":
        """
        * returns True if the U tangent is defined. For example, the tangent is not defined if the two first U derivatives are null.
        	:rtype: bool
        """
        return _BRepLProp.BRepLProp_SLProps_IsTangentUDefined(self, *args)


    def IsTangentVDefined(self, *args) -> "Standard_Boolean":
        """
        * returns if the V tangent is defined. For example, the tangent is not defined if the two first V derivatives are null.
        	:rtype: bool
        """
        return _BRepLProp.BRepLProp_SLProps_IsTangentVDefined(self, *args)


    def IsUmbilic(self, *args) -> "Standard_Boolean":
        """
        * returns True if the point is umbilic (i.e. if the curvature is constant).
        	:rtype: bool
        """
        return _BRepLProp.BRepLProp_SLProps_IsUmbilic(self, *args)


    def MaxCurvature(self, *args) -> "Standard_Real":
        """
        * Returns the maximum curvature
        	:rtype: float
        """
        return _BRepLProp.BRepLProp_SLProps_MaxCurvature(self, *args)


    def MeanCurvature(self, *args) -> "Standard_Real":
        """
        * Returns the mean curvature.
        	:rtype: float
        """
        return _BRepLProp.BRepLProp_SLProps_MeanCurvature(self, *args)


    def MinCurvature(self, *args) -> "Standard_Real":
        """
        * Returns the minimum curvature
        	:rtype: float
        """
        return _BRepLProp.BRepLProp_SLProps_MinCurvature(self, *args)


    def Normal(self, *args) -> "gp_Dir const":
        """
        * Returns the normal direction.
        	:rtype: gp_Dir
        """
        return _BRepLProp.BRepLProp_SLProps_Normal(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        * Initializes the local properties of the surface S for the new parameter values (<U>, <V>).
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_SLProps_SetParameters(self, *args)


    def SetSurface(self, *args) -> "void":
        """
        * Initializes the local properties of the surface S for the new surface.
        	:param S:
        	:type S: BRepAdaptor_Surface
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_SLProps_SetSurface(self, *args)


    def TangentU(self, *args) -> "void":
        """
        * Returns the tangent direction <D> on the iso-V.
        	:param D:
        	:type D: gp_Dir
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_SLProps_TangentU(self, *args)


    def TangentV(self, *args) -> "void":
        """
        * Returns the tangent direction <D> on the iso-V.
        	:param D:
        	:type D: gp_Dir
        	:rtype: None
        """
        return _BRepLProp.BRepLProp_SLProps_TangentV(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        * Returns the point.
        	:rtype: gp_Pnt
        """
        return _BRepLProp.BRepLProp_SLProps_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepLProp.delete_BRepLProp_SLProps
BRepLProp_SLProps.CurvatureDirections = new_instancemethod(_BRepLProp.BRepLProp_SLProps_CurvatureDirections, None, BRepLProp_SLProps)
BRepLProp_SLProps.D1U = new_instancemethod(_BRepLProp.BRepLProp_SLProps_D1U, None, BRepLProp_SLProps)
BRepLProp_SLProps.D1V = new_instancemethod(_BRepLProp.BRepLProp_SLProps_D1V, None, BRepLProp_SLProps)
BRepLProp_SLProps.D2U = new_instancemethod(_BRepLProp.BRepLProp_SLProps_D2U, None, BRepLProp_SLProps)
BRepLProp_SLProps.D2V = new_instancemethod(_BRepLProp.BRepLProp_SLProps_D2V, None, BRepLProp_SLProps)
BRepLProp_SLProps.DUV = new_instancemethod(_BRepLProp.BRepLProp_SLProps_DUV, None, BRepLProp_SLProps)
BRepLProp_SLProps.GaussianCurvature = new_instancemethod(_BRepLProp.BRepLProp_SLProps_GaussianCurvature, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsCurvatureDefined = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsCurvatureDefined, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsNormalDefined = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsNormalDefined, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsTangentUDefined = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsTangentUDefined, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsTangentVDefined = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsTangentVDefined, None, BRepLProp_SLProps)
BRepLProp_SLProps.IsUmbilic = new_instancemethod(_BRepLProp.BRepLProp_SLProps_IsUmbilic, None, BRepLProp_SLProps)
BRepLProp_SLProps.MaxCurvature = new_instancemethod(_BRepLProp.BRepLProp_SLProps_MaxCurvature, None, BRepLProp_SLProps)
BRepLProp_SLProps.MeanCurvature = new_instancemethod(_BRepLProp.BRepLProp_SLProps_MeanCurvature, None, BRepLProp_SLProps)
BRepLProp_SLProps.MinCurvature = new_instancemethod(_BRepLProp.BRepLProp_SLProps_MinCurvature, None, BRepLProp_SLProps)
BRepLProp_SLProps.Normal = new_instancemethod(_BRepLProp.BRepLProp_SLProps_Normal, None, BRepLProp_SLProps)
BRepLProp_SLProps.SetParameters = new_instancemethod(_BRepLProp.BRepLProp_SLProps_SetParameters, None, BRepLProp_SLProps)
BRepLProp_SLProps.SetSurface = new_instancemethod(_BRepLProp.BRepLProp_SLProps_SetSurface, None, BRepLProp_SLProps)
BRepLProp_SLProps.TangentU = new_instancemethod(_BRepLProp.BRepLProp_SLProps_TangentU, None, BRepLProp_SLProps)
BRepLProp_SLProps.TangentV = new_instancemethod(_BRepLProp.BRepLProp_SLProps_TangentV, None, BRepLProp_SLProps)
BRepLProp_SLProps.Value = new_instancemethod(_BRepLProp.BRepLProp_SLProps_Value, None, BRepLProp_SLProps)
BRepLProp_SLProps_swigregister = _BRepLProp.BRepLProp_SLProps_swigregister
BRepLProp_SLProps_swigregister(BRepLProp_SLProps)

class BRepLProp_SurfaceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounds(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
        """
        * returns the bounds of the Surface.
        	:param S:
        	:type S: BRepAdaptor_Surface
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:rtype: void
        """
        return _BRepLProp.BRepLProp_SurfaceTool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def Continuity(*args) -> "Standard_Integer":
        """
        * returns the order of continuity of the Surface <S>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable.
        	:param S:
        	:type S: BRepAdaptor_Surface
        	:rtype: int
        """
        return _BRepLProp.BRepLProp_SurfaceTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D1(*args) -> "void":
        """
        * Computes the point <P> and first derivative <D1*> of parameter <U> and <V> on the Surface <S>.
        	:param S:
        	:type S: BRepAdaptor_Surface
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param P:
        	:type P: gp_Pnt
        	:param D1U:
        	:type D1U: gp_Vec
        	:param D1V:
        	:type D1V: gp_Vec
        	:rtype: void
        """
        return _BRepLProp.BRepLProp_SurfaceTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Computes the point <P>, the first derivative <D1*> and second derivative <D2*> of parameter <U> and <V> on the Surface <S>.
        	:param S:
        	:type S: BRepAdaptor_Surface
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param P:
        	:type P: gp_Pnt
        	:param D1U:
        	:type D1U: gp_Vec
        	:param D1V:
        	:type D1V: gp_Vec
        	:param D2U:
        	:type D2U: gp_Vec
        	:param D2V:
        	:type D2V: gp_Vec
        	:param DUV:
        	:type DUV: gp_Vec
        	:rtype: void
        """
        return _BRepLProp.BRepLProp_SurfaceTool_D2(*args)

    D2 = staticmethod(D2)

    def DN(*args) -> "gp_Vec":
        """
        :param S:
        	:type S: BRepAdaptor_Surface
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param IU:
        	:type IU: int
        	:param IV:
        	:type IV: int
        	:rtype: gp_Vec
        """
        return _BRepLProp.BRepLProp_SurfaceTool_DN(*args)

    DN = staticmethod(DN)

    def Value(*args) -> "void":
        """
        * Computes the point <P> of parameter <U> and <V> on the Surface <S>.
        	:param S:
        	:type S: BRepAdaptor_Surface
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param P:
        	:type P: gp_Pnt
        	:rtype: void
        """
        return _BRepLProp.BRepLProp_SurfaceTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepLProp.BRepLProp_SurfaceTool_swiginit(self, _BRepLProp.new_BRepLProp_SurfaceTool())
    __swig_destroy__ = _BRepLProp.delete_BRepLProp_SurfaceTool
BRepLProp_SurfaceTool_swigregister = _BRepLProp.BRepLProp_SurfaceTool_swigregister
BRepLProp_SurfaceTool_swigregister(BRepLProp_SurfaceTool)

def BRepLProp_SurfaceTool_Bounds(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
    """
    * returns the bounds of the Surface.
    	:param S:
    	:type S: BRepAdaptor_Surface
    	:param U1:
    	:type U1: float
    	:param V1:
    	:type V1: float
    	:param U2:
    	:type U2: float
    	:param V2:
    	:type V2: float
    	:rtype: void
    """
    return _BRepLProp.BRepLProp_SurfaceTool_Bounds(*args)

def BRepLProp_SurfaceTool_Continuity(*args) -> "Standard_Integer":
    """
    * returns the order of continuity of the Surface <S>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable.
    	:param S:
    	:type S: BRepAdaptor_Surface
    	:rtype: int
    """
    return _BRepLProp.BRepLProp_SurfaceTool_Continuity(*args)

def BRepLProp_SurfaceTool_D1(*args) -> "void":
    """
    * Computes the point <P> and first derivative <D1*> of parameter <U> and <V> on the Surface <S>.
    	:param S:
    	:type S: BRepAdaptor_Surface
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param P:
    	:type P: gp_Pnt
    	:param D1U:
    	:type D1U: gp_Vec
    	:param D1V:
    	:type D1V: gp_Vec
    	:rtype: void
    """
    return _BRepLProp.BRepLProp_SurfaceTool_D1(*args)

def BRepLProp_SurfaceTool_D2(*args) -> "void":
    """
    * Computes the point <P>, the first derivative <D1*> and second derivative <D2*> of parameter <U> and <V> on the Surface <S>.
    	:param S:
    	:type S: BRepAdaptor_Surface
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param P:
    	:type P: gp_Pnt
    	:param D1U:
    	:type D1U: gp_Vec
    	:param D1V:
    	:type D1V: gp_Vec
    	:param D2U:
    	:type D2U: gp_Vec
    	:param D2V:
    	:type D2V: gp_Vec
    	:param DUV:
    	:type DUV: gp_Vec
    	:rtype: void
    """
    return _BRepLProp.BRepLProp_SurfaceTool_D2(*args)

def BRepLProp_SurfaceTool_DN(*args) -> "gp_Vec":
    """
    :param S:
    	:type S: BRepAdaptor_Surface
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param IU:
    	:type IU: int
    	:param IV:
    	:type IV: int
    	:rtype: gp_Vec
    """
    return _BRepLProp.BRepLProp_SurfaceTool_DN(*args)

def BRepLProp_SurfaceTool_Value(*args) -> "void":
    """
    * Computes the point <P> of parameter <U> and <V> on the Surface <S>.
    	:param S:
    	:type S: BRepAdaptor_Surface
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param P:
    	:type P: gp_Pnt
    	:rtype: void
    """
    return _BRepLProp.BRepLProp_SurfaceTool_Value(*args)



