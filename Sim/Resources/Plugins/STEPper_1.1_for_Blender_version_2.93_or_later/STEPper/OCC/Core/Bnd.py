# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Bnd module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_bnd.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Bnd.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Bnd')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Bnd')
    _Bnd = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Bnd', [dirname(__file__)])
        except ImportError:
            import _Bnd
            return _Bnd
        try:
            _mod = imp.load_module('_Bnd', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Bnd = swig_import_helper()
    del swig_import_helper
else:
    import _Bnd
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Bnd.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Bnd.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Bnd.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Bnd.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Bnd.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Bnd.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Bnd.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Bnd.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Bnd.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Bnd.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Bnd.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Bnd.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Bnd.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Bnd.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Bnd.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Bnd.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Bnd.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Bnd.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _Bnd.process_exception(error, method_name, class_name)
process_exception = _Bnd.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.TColgp
import OCC.Core.BVH

def Handle_Bnd_HArray1OfBox_Create() -> "opencascade::handle< Bnd_HArray1OfBox >":
    return _Bnd.Handle_Bnd_HArray1OfBox_Create()
Handle_Bnd_HArray1OfBox_Create = _Bnd.Handle_Bnd_HArray1OfBox_Create

def Handle_Bnd_HArray1OfBox_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Bnd_HArray1OfBox >":
    return _Bnd.Handle_Bnd_HArray1OfBox_DownCast(t)
Handle_Bnd_HArray1OfBox_DownCast = _Bnd.Handle_Bnd_HArray1OfBox_DownCast

def Handle_Bnd_HArray1OfBox_IsNull(t: 'opencascade::handle< Bnd_HArray1OfBox > const &') -> "bool":
    return _Bnd.Handle_Bnd_HArray1OfBox_IsNull(t)
Handle_Bnd_HArray1OfBox_IsNull = _Bnd.Handle_Bnd_HArray1OfBox_IsNull

def Handle_Bnd_HArray1OfSphere_Create() -> "opencascade::handle< Bnd_HArray1OfSphere >":
    return _Bnd.Handle_Bnd_HArray1OfSphere_Create()
Handle_Bnd_HArray1OfSphere_Create = _Bnd.Handle_Bnd_HArray1OfSphere_Create

def Handle_Bnd_HArray1OfSphere_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Bnd_HArray1OfSphere >":
    return _Bnd.Handle_Bnd_HArray1OfSphere_DownCast(t)
Handle_Bnd_HArray1OfSphere_DownCast = _Bnd.Handle_Bnd_HArray1OfSphere_DownCast

def Handle_Bnd_HArray1OfSphere_IsNull(t: 'opencascade::handle< Bnd_HArray1OfSphere > const &') -> "bool":
    return _Bnd.Handle_Bnd_HArray1OfSphere_IsNull(t)
Handle_Bnd_HArray1OfSphere_IsNull = _Bnd.Handle_Bnd_HArray1OfSphere_IsNull

def Handle_Bnd_HArray1OfBox2d_Create() -> "opencascade::handle< Bnd_HArray1OfBox2d >":
    return _Bnd.Handle_Bnd_HArray1OfBox2d_Create()
Handle_Bnd_HArray1OfBox2d_Create = _Bnd.Handle_Bnd_HArray1OfBox2d_Create

def Handle_Bnd_HArray1OfBox2d_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Bnd_HArray1OfBox2d >":
    return _Bnd.Handle_Bnd_HArray1OfBox2d_DownCast(t)
Handle_Bnd_HArray1OfBox2d_DownCast = _Bnd.Handle_Bnd_HArray1OfBox2d_DownCast

def Handle_Bnd_HArray1OfBox2d_IsNull(t: 'opencascade::handle< Bnd_HArray1OfBox2d > const &') -> "bool":
    return _Bnd.Handle_Bnd_HArray1OfBox2d_IsNull(t)
Handle_Bnd_HArray1OfBox2d_IsNull = _Bnd.Handle_Bnd_HArray1OfBox2d_IsNull
class Bnd_Array1OfSphere(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Bnd.Bnd_Array1OfSphere_swiginit(self, _Bnd.new_Bnd_Array1OfSphere(*args))
    __swig_destroy__ = _Bnd.delete_Bnd_Array1OfSphere

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

Bnd_Array1OfSphere.begin = new_instancemethod(_Bnd.Bnd_Array1OfSphere_begin, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.end = new_instancemethod(_Bnd.Bnd_Array1OfSphere_end, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.cbegin = new_instancemethod(_Bnd.Bnd_Array1OfSphere_cbegin, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.cend = new_instancemethod(_Bnd.Bnd_Array1OfSphere_cend, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Init = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Init, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Size = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Size, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Length = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Length, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.IsEmpty = new_instancemethod(_Bnd.Bnd_Array1OfSphere_IsEmpty, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Lower = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Lower, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Upper = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Upper, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.IsDeletable = new_instancemethod(_Bnd.Bnd_Array1OfSphere_IsDeletable, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.IsAllocated = new_instancemethod(_Bnd.Bnd_Array1OfSphere_IsAllocated, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Assign = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Assign, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Move = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Move, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Set = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Set, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.First = new_instancemethod(_Bnd.Bnd_Array1OfSphere_First, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.ChangeFirst = new_instancemethod(_Bnd.Bnd_Array1OfSphere_ChangeFirst, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Last = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Last, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.ChangeLast = new_instancemethod(_Bnd.Bnd_Array1OfSphere_ChangeLast, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Value = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Value, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.ChangeValue = new_instancemethod(_Bnd.Bnd_Array1OfSphere_ChangeValue, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.__call__ = new_instancemethod(_Bnd.Bnd_Array1OfSphere___call__, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.SetValue = new_instancemethod(_Bnd.Bnd_Array1OfSphere_SetValue, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere.Resize = new_instancemethod(_Bnd.Bnd_Array1OfSphere_Resize, None, Bnd_Array1OfSphere)
Bnd_Array1OfSphere_swigregister = _Bnd.Bnd_Array1OfSphere_swigregister
Bnd_Array1OfSphere_swigregister(Bnd_Array1OfSphere)

class Bnd_Array1OfBox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Bnd.Bnd_Array1OfBox_swiginit(self, _Bnd.new_Bnd_Array1OfBox(*args))
    __swig_destroy__ = _Bnd.delete_Bnd_Array1OfBox

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

Bnd_Array1OfBox.begin = new_instancemethod(_Bnd.Bnd_Array1OfBox_begin, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.end = new_instancemethod(_Bnd.Bnd_Array1OfBox_end, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.cbegin = new_instancemethod(_Bnd.Bnd_Array1OfBox_cbegin, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.cend = new_instancemethod(_Bnd.Bnd_Array1OfBox_cend, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Init = new_instancemethod(_Bnd.Bnd_Array1OfBox_Init, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Size = new_instancemethod(_Bnd.Bnd_Array1OfBox_Size, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Length = new_instancemethod(_Bnd.Bnd_Array1OfBox_Length, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.IsEmpty = new_instancemethod(_Bnd.Bnd_Array1OfBox_IsEmpty, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Lower = new_instancemethod(_Bnd.Bnd_Array1OfBox_Lower, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Upper = new_instancemethod(_Bnd.Bnd_Array1OfBox_Upper, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.IsDeletable = new_instancemethod(_Bnd.Bnd_Array1OfBox_IsDeletable, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.IsAllocated = new_instancemethod(_Bnd.Bnd_Array1OfBox_IsAllocated, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Assign = new_instancemethod(_Bnd.Bnd_Array1OfBox_Assign, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Move = new_instancemethod(_Bnd.Bnd_Array1OfBox_Move, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Set = new_instancemethod(_Bnd.Bnd_Array1OfBox_Set, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.First = new_instancemethod(_Bnd.Bnd_Array1OfBox_First, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.ChangeFirst = new_instancemethod(_Bnd.Bnd_Array1OfBox_ChangeFirst, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Last = new_instancemethod(_Bnd.Bnd_Array1OfBox_Last, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.ChangeLast = new_instancemethod(_Bnd.Bnd_Array1OfBox_ChangeLast, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Value = new_instancemethod(_Bnd.Bnd_Array1OfBox_Value, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.ChangeValue = new_instancemethod(_Bnd.Bnd_Array1OfBox_ChangeValue, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.__call__ = new_instancemethod(_Bnd.Bnd_Array1OfBox___call__, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.SetValue = new_instancemethod(_Bnd.Bnd_Array1OfBox_SetValue, None, Bnd_Array1OfBox)
Bnd_Array1OfBox.Resize = new_instancemethod(_Bnd.Bnd_Array1OfBox_Resize, None, Bnd_Array1OfBox)
Bnd_Array1OfBox_swigregister = _Bnd.Bnd_Array1OfBox_swigregister
Bnd_Array1OfBox_swigregister(Bnd_Array1OfBox)

class Bnd_Array1OfBox2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Bnd.Bnd_Array1OfBox2d_swiginit(self, _Bnd.new_Bnd_Array1OfBox2d(*args))
    __swig_destroy__ = _Bnd.delete_Bnd_Array1OfBox2d

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

Bnd_Array1OfBox2d.begin = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_begin, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.end = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_end, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.cbegin = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_cbegin, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.cend = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_cend, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Init = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Init, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Size = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Size, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Length = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Length, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.IsEmpty = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_IsEmpty, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Lower = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Lower, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Upper = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Upper, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.IsDeletable = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_IsDeletable, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.IsAllocated = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_IsAllocated, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Assign = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Assign, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Move = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Move, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Set = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Set, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.First = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_First, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.ChangeFirst = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_ChangeFirst, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Last = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Last, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.ChangeLast = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_ChangeLast, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Value = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Value, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.ChangeValue = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_ChangeValue, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.__call__ = new_instancemethod(_Bnd.Bnd_Array1OfBox2d___call__, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.SetValue = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_SetValue, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d.Resize = new_instancemethod(_Bnd.Bnd_Array1OfBox2d_Resize, None, Bnd_Array1OfBox2d)
Bnd_Array1OfBox2d_swigregister = _Bnd.Bnd_Array1OfBox2d_swigregister
Bnd_Array1OfBox2d_swigregister(Bnd_Array1OfBox2d)

class Bnd_SeqOfBox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Bnd.Bnd_SeqOfBox_swiginit(self, _Bnd.new_Bnd_SeqOfBox(*args))
    delNode = staticmethod(_Bnd.Bnd_SeqOfBox_delNode)
    __swig_destroy__ = _Bnd.delete_Bnd_SeqOfBox
Bnd_SeqOfBox.begin = new_instancemethod(_Bnd.Bnd_SeqOfBox_begin, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.end = new_instancemethod(_Bnd.Bnd_SeqOfBox_end, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.cbegin = new_instancemethod(_Bnd.Bnd_SeqOfBox_cbegin, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.cend = new_instancemethod(_Bnd.Bnd_SeqOfBox_cend, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Size = new_instancemethod(_Bnd.Bnd_SeqOfBox_Size, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Length = new_instancemethod(_Bnd.Bnd_SeqOfBox_Length, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Lower = new_instancemethod(_Bnd.Bnd_SeqOfBox_Lower, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Upper = new_instancemethod(_Bnd.Bnd_SeqOfBox_Upper, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.IsEmpty = new_instancemethod(_Bnd.Bnd_SeqOfBox_IsEmpty, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Reverse = new_instancemethod(_Bnd.Bnd_SeqOfBox_Reverse, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Exchange = new_instancemethod(_Bnd.Bnd_SeqOfBox_Exchange, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Clear = new_instancemethod(_Bnd.Bnd_SeqOfBox_Clear, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Assign = new_instancemethod(_Bnd.Bnd_SeqOfBox_Assign, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Set = new_instancemethod(_Bnd.Bnd_SeqOfBox_Set, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Remove = new_instancemethod(_Bnd.Bnd_SeqOfBox_Remove, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Append = new_instancemethod(_Bnd.Bnd_SeqOfBox_Append, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Prepend = new_instancemethod(_Bnd.Bnd_SeqOfBox_Prepend, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.InsertBefore = new_instancemethod(_Bnd.Bnd_SeqOfBox_InsertBefore, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.InsertAfter = new_instancemethod(_Bnd.Bnd_SeqOfBox_InsertAfter, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Split = new_instancemethod(_Bnd.Bnd_SeqOfBox_Split, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.First = new_instancemethod(_Bnd.Bnd_SeqOfBox_First, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.ChangeFirst = new_instancemethod(_Bnd.Bnd_SeqOfBox_ChangeFirst, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Last = new_instancemethod(_Bnd.Bnd_SeqOfBox_Last, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.ChangeLast = new_instancemethod(_Bnd.Bnd_SeqOfBox_ChangeLast, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.Value = new_instancemethod(_Bnd.Bnd_SeqOfBox_Value, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.ChangeValue = new_instancemethod(_Bnd.Bnd_SeqOfBox_ChangeValue, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.__call__ = new_instancemethod(_Bnd.Bnd_SeqOfBox___call__, None, Bnd_SeqOfBox)
Bnd_SeqOfBox.SetValue = new_instancemethod(_Bnd.Bnd_SeqOfBox_SetValue, None, Bnd_SeqOfBox)
Bnd_SeqOfBox_swigregister = _Bnd.Bnd_SeqOfBox_swigregister
Bnd_SeqOfBox_swigregister(Bnd_SeqOfBox)

def Bnd_SeqOfBox_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _Bnd.Bnd_SeqOfBox_delNode(theNode, theAl)
Bnd_SeqOfBox_delNode = _Bnd.Bnd_SeqOfBox_delNode

class Bnd_B2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Update the box by a point.
        	:param thePnt:
        	:type thePnt: gp_XY
        	:rtype: None
        * Update the box by a point.
        	:param thePnt:
        	:type thePnt: gp_Pnt2d
        	:rtype: None
        * Update the box by another box.
        	:param theBox:
        	:type theBox: Bnd_B2d
        	:rtype: None
        """
        return _Bnd.Bnd_B2d_Add(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Constructor.
        	:param theCenter:
        	:type theCenter: gp_XY
        	:param theHSize:
        	:type theHSize: gp_XY
        	:rtype: None
        """
        _Bnd.Bnd_B2d_swiginit(self, _Bnd.new_Bnd_B2d(*args))

    def Clear(self, *args) -> "void":
        """
        * Reset the box data.
        	:rtype: None
        """
        return _Bnd.Bnd_B2d_Clear(self, *args)


    def CornerMax(self, *args) -> "gp_XY":
        """
        * Query a box corner: (Center + HSize). You must make sure that the box is NOT VOID (see IsVoid()), otherwise the method returns irrelevant result.
        	:rtype: gp_XY
        """
        return _Bnd.Bnd_B2d_CornerMax(self, *args)


    def CornerMin(self, *args) -> "gp_XY":
        """
        * Query a box corner: (Center - HSize). You must make sure that the box is NOT VOID (see IsVoid()), otherwise the method returns irrelevant result.
        	:rtype: gp_XY
        """
        return _Bnd.Bnd_B2d_CornerMin(self, *args)


    def Enlarge(self, *args) -> "void":
        """
        * Extend the Box by the absolute value of theDiff.
        	:param theDiff:
        	:type theDiff: float
        	:rtype: None
        """
        return _Bnd.Bnd_B2d_Enlarge(self, *args)


    def IsIn(self, *args) -> "Standard_Boolean":
        """
        * Check that the box 'this' is inside the given box 'theBox'. Returns True if 'this' box is fully inside 'theBox'.
        	:param theBox:
        	:type theBox: Bnd_B2d
        	:rtype: bool
        * Check that the box 'this' is inside the given box 'theBox' transformed by 'theTrsf'. Returns True if 'this' box is fully inside the transformed 'theBox'.
        	:param theBox:
        	:type theBox: Bnd_B2d
        	:param theTrsf:
        	:type theTrsf: gp_Trsf2d
        	:rtype: bool
        """
        return _Bnd.Bnd_B2d_IsIn(self, *args)


    def IsOut(self, *args) -> "Standard_Boolean":
        """
        * Check the given point for the inclusion in the Box. Returns True if the point is outside.
        	:param thePnt:
        	:type thePnt: gp_XY
        	:rtype: bool
        * Check a circle for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theCenter:
        	:type theCenter: gp_XY
        	:param theRadius:
        	:type theRadius: float
        	:param isCircleHollow: default value is Standard_False
        	:type isCircleHollow: bool
        	:rtype: bool
        * Check the given box for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B2d
        	:rtype: bool
        * Check the given box oriented by the given transformation for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B2d
        	:param theTrsf:
        	:type theTrsf: gp_Trsf2d
        	:rtype: bool
        * Check the given Line for the intersection with the current box. Returns True if there is no intersection.
        	:param theLine:
        	:type theLine: gp_Ax2d
        	:rtype: bool
        * Check the Segment defined by the couple of input points for the intersection with the current box. Returns True if there is no intersection.
        	:param theP0:
        	:type theP0: gp_XY
        	:param theP1:
        	:type theP1: gp_XY
        	:rtype: bool
        """
        return _Bnd.Bnd_B2d_IsOut(self, *args)


    def IsVoid(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the box is void (non-initialized).
        	:rtype: bool
        """
        return _Bnd.Bnd_B2d_IsVoid(self, *args)


    def Limit(self, *args) -> "Standard_Boolean":
        """
        * Limit the Box by the internals of theOtherBox. Returns True if the limitation takes place, otherwise False indicating that the boxes do not intersect.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B2d
        	:rtype: bool
        """
        return _Bnd.Bnd_B2d_Limit(self, *args)


    def SetCenter(self, *args) -> "void":
        """
        * Set the Center coordinates
        	:param theCenter:
        	:type theCenter: gp_XY
        	:rtype: None
        """
        return _Bnd.Bnd_B2d_SetCenter(self, *args)


    def SetHSize(self, *args) -> "void":
        """
        * Set the HSize (half-diagonal) coordinates. All components of theHSize must be non-negative.
        	:param theHSize:
        	:type theHSize: gp_XY
        	:rtype: None
        """
        return _Bnd.Bnd_B2d_SetHSize(self, *args)


    def SquareExtent(self, *args) -> "Standard_Real":
        """
        * Query the square diagonal. If the box is VOID (see method IsVoid()) then a very big real value is returned.
        	:rtype: float
        """
        return _Bnd.Bnd_B2d_SquareExtent(self, *args)


    def Transformed(self, *args) -> "Bnd_B2d":
        """
        * Transform the bounding box with the given transformation. The resulting box will be larger if theTrsf contains rotation.
        	:param theTrsf:
        	:type theTrsf: gp_Trsf2d
        	:rtype: Bnd_B2d
        """
        return _Bnd.Bnd_B2d_Transformed(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_B2d
Bnd_B2d.Add = new_instancemethod(_Bnd.Bnd_B2d_Add, None, Bnd_B2d)
Bnd_B2d.Clear = new_instancemethod(_Bnd.Bnd_B2d_Clear, None, Bnd_B2d)
Bnd_B2d.CornerMax = new_instancemethod(_Bnd.Bnd_B2d_CornerMax, None, Bnd_B2d)
Bnd_B2d.CornerMin = new_instancemethod(_Bnd.Bnd_B2d_CornerMin, None, Bnd_B2d)
Bnd_B2d.Enlarge = new_instancemethod(_Bnd.Bnd_B2d_Enlarge, None, Bnd_B2d)
Bnd_B2d.IsIn = new_instancemethod(_Bnd.Bnd_B2d_IsIn, None, Bnd_B2d)
Bnd_B2d.IsOut = new_instancemethod(_Bnd.Bnd_B2d_IsOut, None, Bnd_B2d)
Bnd_B2d.IsVoid = new_instancemethod(_Bnd.Bnd_B2d_IsVoid, None, Bnd_B2d)
Bnd_B2d.Limit = new_instancemethod(_Bnd.Bnd_B2d_Limit, None, Bnd_B2d)
Bnd_B2d.SetCenter = new_instancemethod(_Bnd.Bnd_B2d_SetCenter, None, Bnd_B2d)
Bnd_B2d.SetHSize = new_instancemethod(_Bnd.Bnd_B2d_SetHSize, None, Bnd_B2d)
Bnd_B2d.SquareExtent = new_instancemethod(_Bnd.Bnd_B2d_SquareExtent, None, Bnd_B2d)
Bnd_B2d.Transformed = new_instancemethod(_Bnd.Bnd_B2d_Transformed, None, Bnd_B2d)
Bnd_B2d_swigregister = _Bnd.Bnd_B2d_swigregister
Bnd_B2d_swigregister(Bnd_B2d)

class Bnd_B2f(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Update the box by a point.
        	:param thePnt:
        	:type thePnt: gp_XY
        	:rtype: None
        * Update the box by a point.
        	:param thePnt:
        	:type thePnt: gp_Pnt2d
        	:rtype: None
        * Update the box by another box.
        	:param theBox:
        	:type theBox: Bnd_B2f
        	:rtype: None
        """
        return _Bnd.Bnd_B2f_Add(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Constructor.
        	:param theCenter:
        	:type theCenter: gp_XY
        	:param theHSize:
        	:type theHSize: gp_XY
        	:rtype: None
        """
        _Bnd.Bnd_B2f_swiginit(self, _Bnd.new_Bnd_B2f(*args))

    def Clear(self, *args) -> "void":
        """
        * Reset the box data.
        	:rtype: None
        """
        return _Bnd.Bnd_B2f_Clear(self, *args)


    def CornerMax(self, *args) -> "gp_XY":
        """
        * Query a box corner: (Center + HSize). You must make sure that the box is NOT VOID (see IsVoid()), otherwise the method returns irrelevant result.
        	:rtype: gp_XY
        """
        return _Bnd.Bnd_B2f_CornerMax(self, *args)


    def CornerMin(self, *args) -> "gp_XY":
        """
        * Query a box corner: (Center - HSize). You must make sure that the box is NOT VOID (see IsVoid()), otherwise the method returns irrelevant result.
        	:rtype: gp_XY
        """
        return _Bnd.Bnd_B2f_CornerMin(self, *args)


    def Enlarge(self, *args) -> "void":
        """
        * Extend the Box by the absolute value of theDiff.
        	:param theDiff:
        	:type theDiff: float
        	:rtype: None
        """
        return _Bnd.Bnd_B2f_Enlarge(self, *args)


    def IsIn(self, *args) -> "Standard_Boolean":
        """
        * Check that the box 'this' is inside the given box 'theBox'. Returns True if 'this' box is fully inside 'theBox'.
        	:param theBox:
        	:type theBox: Bnd_B2f
        	:rtype: bool
        * Check that the box 'this' is inside the given box 'theBox' transformed by 'theTrsf'. Returns True if 'this' box is fully inside the transformed 'theBox'.
        	:param theBox:
        	:type theBox: Bnd_B2f
        	:param theTrsf:
        	:type theTrsf: gp_Trsf2d
        	:rtype: bool
        """
        return _Bnd.Bnd_B2f_IsIn(self, *args)


    def IsOut(self, *args) -> "Standard_Boolean":
        """
        * Check the given point for the inclusion in the Box. Returns True if the point is outside.
        	:param thePnt:
        	:type thePnt: gp_XY
        	:rtype: bool
        * Check a circle for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theCenter:
        	:type theCenter: gp_XY
        	:param theRadius:
        	:type theRadius: float
        	:param isCircleHollow: default value is Standard_False
        	:type isCircleHollow: bool
        	:rtype: bool
        * Check the given box for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B2f
        	:rtype: bool
        * Check the given box oriented by the given transformation for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B2f
        	:param theTrsf:
        	:type theTrsf: gp_Trsf2d
        	:rtype: bool
        * Check the given Line for the intersection with the current box. Returns True if there is no intersection.
        	:param theLine:
        	:type theLine: gp_Ax2d
        	:rtype: bool
        * Check the Segment defined by the couple of input points for the intersection with the current box. Returns True if there is no intersection.
        	:param theP0:
        	:type theP0: gp_XY
        	:param theP1:
        	:type theP1: gp_XY
        	:rtype: bool
        """
        return _Bnd.Bnd_B2f_IsOut(self, *args)


    def IsVoid(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the box is void (non-initialized).
        	:rtype: bool
        """
        return _Bnd.Bnd_B2f_IsVoid(self, *args)


    def Limit(self, *args) -> "Standard_Boolean":
        """
        * Limit the Box by the internals of theOtherBox. Returns True if the limitation takes place, otherwise False indicating that the boxes do not intersect.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B2f
        	:rtype: bool
        """
        return _Bnd.Bnd_B2f_Limit(self, *args)


    def SetCenter(self, *args) -> "void":
        """
        * Set the Center coordinates
        	:param theCenter:
        	:type theCenter: gp_XY
        	:rtype: None
        """
        return _Bnd.Bnd_B2f_SetCenter(self, *args)


    def SetHSize(self, *args) -> "void":
        """
        * Set the HSize (half-diagonal) coordinates. All components of theHSize must be non-negative.
        	:param theHSize:
        	:type theHSize: gp_XY
        	:rtype: None
        """
        return _Bnd.Bnd_B2f_SetHSize(self, *args)


    def SquareExtent(self, *args) -> "Standard_Real":
        """
        * Query the square diagonal. If the box is VOID (see method IsVoid()) then a very big real value is returned.
        	:rtype: float
        """
        return _Bnd.Bnd_B2f_SquareExtent(self, *args)


    def Transformed(self, *args) -> "Bnd_B2f":
        """
        * Transform the bounding box with the given transformation. The resulting box will be larger if theTrsf contains rotation.
        	:param theTrsf:
        	:type theTrsf: gp_Trsf2d
        	:rtype: Bnd_B2f
        """
        return _Bnd.Bnd_B2f_Transformed(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_B2f
Bnd_B2f.Add = new_instancemethod(_Bnd.Bnd_B2f_Add, None, Bnd_B2f)
Bnd_B2f.Clear = new_instancemethod(_Bnd.Bnd_B2f_Clear, None, Bnd_B2f)
Bnd_B2f.CornerMax = new_instancemethod(_Bnd.Bnd_B2f_CornerMax, None, Bnd_B2f)
Bnd_B2f.CornerMin = new_instancemethod(_Bnd.Bnd_B2f_CornerMin, None, Bnd_B2f)
Bnd_B2f.Enlarge = new_instancemethod(_Bnd.Bnd_B2f_Enlarge, None, Bnd_B2f)
Bnd_B2f.IsIn = new_instancemethod(_Bnd.Bnd_B2f_IsIn, None, Bnd_B2f)
Bnd_B2f.IsOut = new_instancemethod(_Bnd.Bnd_B2f_IsOut, None, Bnd_B2f)
Bnd_B2f.IsVoid = new_instancemethod(_Bnd.Bnd_B2f_IsVoid, None, Bnd_B2f)
Bnd_B2f.Limit = new_instancemethod(_Bnd.Bnd_B2f_Limit, None, Bnd_B2f)
Bnd_B2f.SetCenter = new_instancemethod(_Bnd.Bnd_B2f_SetCenter, None, Bnd_B2f)
Bnd_B2f.SetHSize = new_instancemethod(_Bnd.Bnd_B2f_SetHSize, None, Bnd_B2f)
Bnd_B2f.SquareExtent = new_instancemethod(_Bnd.Bnd_B2f_SquareExtent, None, Bnd_B2f)
Bnd_B2f.Transformed = new_instancemethod(_Bnd.Bnd_B2f_Transformed, None, Bnd_B2f)
Bnd_B2f_swigregister = _Bnd.Bnd_B2f_swigregister
Bnd_B2f_swigregister(Bnd_B2f)

class Bnd_B3d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Update the box by a point.
        	:param thePnt:
        	:type thePnt: gp_XYZ
        	:rtype: None
        * Update the box by a point.
        	:param thePnt:
        	:type thePnt: gp_Pnt
        	:rtype: None
        * Update the box by another box.
        	:param theBox:
        	:type theBox: Bnd_B3d
        	:rtype: None
        """
        return _Bnd.Bnd_B3d_Add(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Constructor.
        	:param theCenter:
        	:type theCenter: gp_XYZ
        	:param theHSize:
        	:type theHSize: gp_XYZ
        	:rtype: None
        """
        _Bnd.Bnd_B3d_swiginit(self, _Bnd.new_Bnd_B3d(*args))

    def Clear(self, *args) -> "void":
        """
        * Reset the box data.
        	:rtype: None
        """
        return _Bnd.Bnd_B3d_Clear(self, *args)


    def CornerMax(self, *args) -> "gp_XYZ":
        """
        * Query the upper corner: (Center + HSize). You must make sure that the box is NOT VOID (see IsVoid()), otherwise the method returns irrelevant result.
        	:rtype: gp_XYZ
        """
        return _Bnd.Bnd_B3d_CornerMax(self, *args)


    def CornerMin(self, *args) -> "gp_XYZ":
        """
        * Query the lower corner: (Center - HSize). You must make sure that the box is NOT VOID (see IsVoid()), otherwise the method returns irrelevant result.
        	:rtype: gp_XYZ
        """
        return _Bnd.Bnd_B3d_CornerMin(self, *args)


    def Enlarge(self, *args) -> "void":
        """
        * Extend the Box by the absolute value of theDiff.
        	:param theDiff:
        	:type theDiff: float
        	:rtype: None
        """
        return _Bnd.Bnd_B3d_Enlarge(self, *args)


    def IsIn(self, *args) -> "Standard_Boolean":
        """
        * Check that the box 'this' is inside the given box 'theBox'. Returns True if 'this' box is fully inside 'theBox'.
        	:param theBox:
        	:type theBox: Bnd_B3d
        	:rtype: bool
        * Check that the box 'this' is inside the given box 'theBox' transformed by 'theTrsf'. Returns True if 'this' box is fully inside the transformed 'theBox'.
        	:param theBox:
        	:type theBox: Bnd_B3d
        	:param theTrsf:
        	:type theTrsf: gp_Trsf
        	:rtype: bool
        """
        return _Bnd.Bnd_B3d_IsIn(self, *args)


    def IsOut(self, *args) -> "Standard_Boolean":
        """
        * Check the given point for the inclusion in the Box. Returns True if the point is outside.
        	:param thePnt:
        	:type thePnt: gp_XYZ
        	:rtype: bool
        * Check a sphere for the intersection with the current box. Returns True if there is no intersection between boxes. If the parameter 'IsSphereHollow' is True, then the intersection is not reported for a box that is completely inside the sphere (otherwise this method would report an intersection).
        	:param theCenter:
        	:type theCenter: gp_XYZ
        	:param theRadius:
        	:type theRadius: float
        	:param isSphereHollow: default value is Standard_False
        	:type isSphereHollow: bool
        	:rtype: bool
        * Check the given box for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B3d
        	:rtype: bool
        * Check the given box oriented by the given transformation for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B3d
        	:param theTrsf:
        	:type theTrsf: gp_Trsf
        	:rtype: bool
        * Check the given Line for the intersection with the current box. Returns True if there is no intersection. isRay==True means intersection check with the positive half-line theOverthickness is the addition to the size of the current box (may be negative). If positive, it can be treated as the thickness of the line 'theLine' or the radius of the cylinder along 'theLine'
        	:param theLine:
        	:type theLine: gp_Ax1
        	:param isRay: default value is Standard_False
        	:type isRay: bool
        	:param theOverthickness: default value is 0.0
        	:type theOverthickness: float
        	:rtype: bool
        * Check the given Plane for the intersection with the current box. Returns True if there is no intersection.
        	:param thePlane:
        	:type thePlane: gp_Ax3
        	:rtype: bool
        """
        return _Bnd.Bnd_B3d_IsOut(self, *args)


    def IsVoid(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the box is void (non-initialized).
        	:rtype: bool
        """
        return _Bnd.Bnd_B3d_IsVoid(self, *args)


    def Limit(self, *args) -> "Standard_Boolean":
        """
        * Limit the Box by the internals of theOtherBox. Returns True if the limitation takes place, otherwise False indicating that the boxes do not intersect.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B3d
        	:rtype: bool
        """
        return _Bnd.Bnd_B3d_Limit(self, *args)


    def SetCenter(self, *args) -> "void":
        """
        * Set the Center coordinates
        	:param theCenter:
        	:type theCenter: gp_XYZ
        	:rtype: None
        """
        return _Bnd.Bnd_B3d_SetCenter(self, *args)


    def SetHSize(self, *args) -> "void":
        """
        * Set the HSize (half-diagonal) coordinates. All components of theHSize must be non-negative.
        	:param theHSize:
        	:type theHSize: gp_XYZ
        	:rtype: None
        """
        return _Bnd.Bnd_B3d_SetHSize(self, *args)


    def SquareExtent(self, *args) -> "Standard_Real":
        """
        * Query the square diagonal. If the box is VOID (see method IsVoid()) then a very big real value is returned.
        	:rtype: float
        """
        return _Bnd.Bnd_B3d_SquareExtent(self, *args)


    def Transformed(self, *args) -> "Bnd_B3d":
        """
        * Transform the bounding box with the given transformation. The resulting box will be larger if theTrsf contains rotation.
        	:param theTrsf:
        	:type theTrsf: gp_Trsf
        	:rtype: Bnd_B3d
        """
        return _Bnd.Bnd_B3d_Transformed(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_B3d
Bnd_B3d.Add = new_instancemethod(_Bnd.Bnd_B3d_Add, None, Bnd_B3d)
Bnd_B3d.Clear = new_instancemethod(_Bnd.Bnd_B3d_Clear, None, Bnd_B3d)
Bnd_B3d.CornerMax = new_instancemethod(_Bnd.Bnd_B3d_CornerMax, None, Bnd_B3d)
Bnd_B3d.CornerMin = new_instancemethod(_Bnd.Bnd_B3d_CornerMin, None, Bnd_B3d)
Bnd_B3d.Enlarge = new_instancemethod(_Bnd.Bnd_B3d_Enlarge, None, Bnd_B3d)
Bnd_B3d.IsIn = new_instancemethod(_Bnd.Bnd_B3d_IsIn, None, Bnd_B3d)
Bnd_B3d.IsOut = new_instancemethod(_Bnd.Bnd_B3d_IsOut, None, Bnd_B3d)
Bnd_B3d.IsVoid = new_instancemethod(_Bnd.Bnd_B3d_IsVoid, None, Bnd_B3d)
Bnd_B3d.Limit = new_instancemethod(_Bnd.Bnd_B3d_Limit, None, Bnd_B3d)
Bnd_B3d.SetCenter = new_instancemethod(_Bnd.Bnd_B3d_SetCenter, None, Bnd_B3d)
Bnd_B3d.SetHSize = new_instancemethod(_Bnd.Bnd_B3d_SetHSize, None, Bnd_B3d)
Bnd_B3d.SquareExtent = new_instancemethod(_Bnd.Bnd_B3d_SquareExtent, None, Bnd_B3d)
Bnd_B3d.Transformed = new_instancemethod(_Bnd.Bnd_B3d_Transformed, None, Bnd_B3d)
Bnd_B3d_swigregister = _Bnd.Bnd_B3d_swigregister
Bnd_B3d_swigregister(Bnd_B3d)

class Bnd_B3f(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Update the box by a point.
        	:param thePnt:
        	:type thePnt: gp_XYZ
        	:rtype: None
        * Update the box by a point.
        	:param thePnt:
        	:type thePnt: gp_Pnt
        	:rtype: None
        * Update the box by another box.
        	:param theBox:
        	:type theBox: Bnd_B3f
        	:rtype: None
        """
        return _Bnd.Bnd_B3f_Add(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Constructor.
        	:param theCenter:
        	:type theCenter: gp_XYZ
        	:param theHSize:
        	:type theHSize: gp_XYZ
        	:rtype: None
        """
        _Bnd.Bnd_B3f_swiginit(self, _Bnd.new_Bnd_B3f(*args))

    def Clear(self, *args) -> "void":
        """
        * Reset the box data.
        	:rtype: None
        """
        return _Bnd.Bnd_B3f_Clear(self, *args)


    def CornerMax(self, *args) -> "gp_XYZ":
        """
        * Query the upper corner: (Center + HSize). You must make sure that the box is NOT VOID (see IsVoid()), otherwise the method returns irrelevant result.
        	:rtype: gp_XYZ
        """
        return _Bnd.Bnd_B3f_CornerMax(self, *args)


    def CornerMin(self, *args) -> "gp_XYZ":
        """
        * Query the lower corner: (Center - HSize). You must make sure that the box is NOT VOID (see IsVoid()), otherwise the method returns irrelevant result.
        	:rtype: gp_XYZ
        """
        return _Bnd.Bnd_B3f_CornerMin(self, *args)


    def Enlarge(self, *args) -> "void":
        """
        * Extend the Box by the absolute value of theDiff.
        	:param theDiff:
        	:type theDiff: float
        	:rtype: None
        """
        return _Bnd.Bnd_B3f_Enlarge(self, *args)


    def IsIn(self, *args) -> "Standard_Boolean":
        """
        * Check that the box 'this' is inside the given box 'theBox'. Returns True if 'this' box is fully inside 'theBox'.
        	:param theBox:
        	:type theBox: Bnd_B3f
        	:rtype: bool
        * Check that the box 'this' is inside the given box 'theBox' transformed by 'theTrsf'. Returns True if 'this' box is fully inside the transformed 'theBox'.
        	:param theBox:
        	:type theBox: Bnd_B3f
        	:param theTrsf:
        	:type theTrsf: gp_Trsf
        	:rtype: bool
        """
        return _Bnd.Bnd_B3f_IsIn(self, *args)


    def IsOut(self, *args) -> "Standard_Boolean":
        """
        * Check the given point for the inclusion in the Box. Returns True if the point is outside.
        	:param thePnt:
        	:type thePnt: gp_XYZ
        	:rtype: bool
        * Check a sphere for the intersection with the current box. Returns True if there is no intersection between boxes. If the parameter 'IsSphereHollow' is True, then the intersection is not reported for a box that is completely inside the sphere (otherwise this method would report an intersection).
        	:param theCenter:
        	:type theCenter: gp_XYZ
        	:param theRadius:
        	:type theRadius: float
        	:param isSphereHollow: default value is Standard_False
        	:type isSphereHollow: bool
        	:rtype: bool
        * Check the given box for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B3f
        	:rtype: bool
        * Check the given box oriented by the given transformation for the intersection with the current box. Returns True if there is no intersection between boxes.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B3f
        	:param theTrsf:
        	:type theTrsf: gp_Trsf
        	:rtype: bool
        * Check the given Line for the intersection with the current box. Returns True if there is no intersection. isRay==True means intersection check with the positive half-line theOverthickness is the addition to the size of the current box (may be negative). If positive, it can be treated as the thickness of the line 'theLine' or the radius of the cylinder along 'theLine'
        	:param theLine:
        	:type theLine: gp_Ax1
        	:param isRay: default value is Standard_False
        	:type isRay: bool
        	:param theOverthickness: default value is 0.0
        	:type theOverthickness: float
        	:rtype: bool
        * Check the given Plane for the intersection with the current box. Returns True if there is no intersection.
        	:param thePlane:
        	:type thePlane: gp_Ax3
        	:rtype: bool
        """
        return _Bnd.Bnd_B3f_IsOut(self, *args)


    def IsVoid(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the box is void (non-initialized).
        	:rtype: bool
        """
        return _Bnd.Bnd_B3f_IsVoid(self, *args)


    def Limit(self, *args) -> "Standard_Boolean":
        """
        * Limit the Box by the internals of theOtherBox. Returns True if the limitation takes place, otherwise False indicating that the boxes do not intersect.
        	:param theOtherBox:
        	:type theOtherBox: Bnd_B3f
        	:rtype: bool
        """
        return _Bnd.Bnd_B3f_Limit(self, *args)


    def SetCenter(self, *args) -> "void":
        """
        * Set the Center coordinates
        	:param theCenter:
        	:type theCenter: gp_XYZ
        	:rtype: None
        """
        return _Bnd.Bnd_B3f_SetCenter(self, *args)


    def SetHSize(self, *args) -> "void":
        """
        * Set the HSize (half-diagonal) coordinates. All components of theHSize must be non-negative.
        	:param theHSize:
        	:type theHSize: gp_XYZ
        	:rtype: None
        """
        return _Bnd.Bnd_B3f_SetHSize(self, *args)


    def SquareExtent(self, *args) -> "Standard_Real":
        """
        * Query the square diagonal. If the box is VOID (see method IsVoid()) then a very big real value is returned.
        	:rtype: float
        """
        return _Bnd.Bnd_B3f_SquareExtent(self, *args)


    def Transformed(self, *args) -> "Bnd_B3f":
        """
        * Transform the bounding box with the given transformation. The resulting box will be larger if theTrsf contains rotation.
        	:param theTrsf:
        	:type theTrsf: gp_Trsf
        	:rtype: Bnd_B3f
        """
        return _Bnd.Bnd_B3f_Transformed(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_B3f
Bnd_B3f.Add = new_instancemethod(_Bnd.Bnd_B3f_Add, None, Bnd_B3f)
Bnd_B3f.Clear = new_instancemethod(_Bnd.Bnd_B3f_Clear, None, Bnd_B3f)
Bnd_B3f.CornerMax = new_instancemethod(_Bnd.Bnd_B3f_CornerMax, None, Bnd_B3f)
Bnd_B3f.CornerMin = new_instancemethod(_Bnd.Bnd_B3f_CornerMin, None, Bnd_B3f)
Bnd_B3f.Enlarge = new_instancemethod(_Bnd.Bnd_B3f_Enlarge, None, Bnd_B3f)
Bnd_B3f.IsIn = new_instancemethod(_Bnd.Bnd_B3f_IsIn, None, Bnd_B3f)
Bnd_B3f.IsOut = new_instancemethod(_Bnd.Bnd_B3f_IsOut, None, Bnd_B3f)
Bnd_B3f.IsVoid = new_instancemethod(_Bnd.Bnd_B3f_IsVoid, None, Bnd_B3f)
Bnd_B3f.Limit = new_instancemethod(_Bnd.Bnd_B3f_Limit, None, Bnd_B3f)
Bnd_B3f.SetCenter = new_instancemethod(_Bnd.Bnd_B3f_SetCenter, None, Bnd_B3f)
Bnd_B3f.SetHSize = new_instancemethod(_Bnd.Bnd_B3f_SetHSize, None, Bnd_B3f)
Bnd_B3f.SquareExtent = new_instancemethod(_Bnd.Bnd_B3f_SquareExtent, None, Bnd_B3f)
Bnd_B3f.Transformed = new_instancemethod(_Bnd.Bnd_B3f_Transformed, None, Bnd_B3f)
Bnd_B3f_swigregister = _Bnd.Bnd_B3f_swigregister
Bnd_B3f_swigregister(Bnd_B3f)

class Bnd_BoundSortBox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds the bounding box theBox at position boxIndex in the array of boxes to be sorted by this comparison algorithm. This function is used only in conjunction with the third syntax described in the synopsis of Initialize. //! Exceptions: //! - Standard_OutOfRange if boxIndex is not in the range [ 1,nbComponents ] where nbComponents is the maximum number of bounding boxes declared for this comparison algorithm at initialization. //! - Standard_MultiplyDefined if a box already exists at position boxIndex in the array of boxes to be sorted by this comparison algorithm.
        	:param theBox:
        	:type theBox: Bnd_Box
        	:param boxIndex:
        	:type boxIndex: int
        	:rtype: None
        """
        return _Bnd.Bnd_BoundSortBox_Add(self, *args)


    def __init__(self, *args):
        """
        * Constructs an empty comparison algorithm for bounding boxes. The bounding boxes are then defined using the Initialize function.
        	:rtype: None
        """
        _Bnd.Bnd_BoundSortBox_swiginit(self, _Bnd.new_Bnd_BoundSortBox(*args))

    def Compare(self, *args) -> "TColStd_ListOfInteger const &":
        """
        * Compares the bounding box theBox, with the set of bounding boxes to be sorted by this comparison algorithm, and returns the list of intersecting bounding boxes as a list of indexes on the array of bounding boxes used by this algorithm.
        	:param theBox:
        	:type theBox: Bnd_Box
        	:rtype: TColStd_ListOfInteger
        * Compares the plane P with the set of bounding boxes to be sorted by this comparison algorithm, and returns the list of intersecting bounding boxes as a list of indexes on the array of bounding boxes used by this algorithm.
        	:param P:
        	:type P: gp_Pln
        	:rtype: TColStd_ListOfInteger
        """
        return _Bnd.Bnd_BoundSortBox_Compare(self, *args)


    def Destroy(self, *args) -> "void":
        """:rtype: None"""
        return _Bnd.Bnd_BoundSortBox_Destroy(self, *args)


    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _Bnd.Bnd_BoundSortBox_Dump(self, *args)


    def Initialize(self, *args) -> "void":
        """
        * Initializes this comparison algorithm with - the set of bounding boxes SetOfBox.
        	:param CompleteBox:
        	:type CompleteBox: Bnd_Box
        	:param SetOfBox:
        	:type SetOfBox: Bnd_HArray1OfBox
        	:rtype: None
        * Initializes this comparison algorithm with - the set of bounding boxes SetOfBox, where CompleteBox is given as the global bounding box of SetOfBox.
        	:param SetOfBox:
        	:type SetOfBox: Bnd_HArray1OfBox
        	:rtype: None
        * Initializes this comparison algorithm, giving it only - the maximum number nbComponents of the bounding boxes to be managed. Use the Add function to define the array of bounding boxes to be sorted by this algorithm.
        	:param CompleteBox:
        	:type CompleteBox: Bnd_Box
        	:param nbComponents:
        	:type nbComponents: int
        	:rtype: None
        """
        return _Bnd.Bnd_BoundSortBox_Initialize(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_BoundSortBox
Bnd_BoundSortBox.Add = new_instancemethod(_Bnd.Bnd_BoundSortBox_Add, None, Bnd_BoundSortBox)
Bnd_BoundSortBox.Compare = new_instancemethod(_Bnd.Bnd_BoundSortBox_Compare, None, Bnd_BoundSortBox)
Bnd_BoundSortBox.Destroy = new_instancemethod(_Bnd.Bnd_BoundSortBox_Destroy, None, Bnd_BoundSortBox)
Bnd_BoundSortBox.Dump = new_instancemethod(_Bnd.Bnd_BoundSortBox_Dump, None, Bnd_BoundSortBox)
Bnd_BoundSortBox.Initialize = new_instancemethod(_Bnd.Bnd_BoundSortBox_Initialize, None, Bnd_BoundSortBox)
Bnd_BoundSortBox_swigregister = _Bnd.Bnd_BoundSortBox_swigregister
Bnd_BoundSortBox_swigregister(Bnd_BoundSortBox)

class Bnd_BoundSortBox2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds the 2D bounding box theBox at position boxIndex in the array of boxes to be sorted by this comparison algorithm. This function is used only in conjunction with the third syntax described in the synopsis of Initialize. Exceptions - Standard_OutOfRange if boxIndex is not in the range [ 1,nbComponents ] where nbComponents is the maximum number of bounding boxes declared for this comparison algorithm at initialization. - Standard_MultiplyDefined if a box still exists at position boxIndex in the array of boxes to be sorted by this comparison algorithm.
        	:param theBox:
        	:type theBox: Bnd_Box2d
        	:param boxIndex:
        	:type boxIndex: int
        	:rtype: None
        """
        return _Bnd.Bnd_BoundSortBox2d_Add(self, *args)


    def __init__(self, *args):
        """
        * Constructs an empty comparison algorithm for 2D bounding boxes. The bounding boxes are then defined using the Initialize function.
        	:rtype: None
        """
        _Bnd.Bnd_BoundSortBox2d_swiginit(self, _Bnd.new_Bnd_BoundSortBox2d(*args))

    def Compare(self, *args) -> "TColStd_ListOfInteger const &":
        """
        * Compares the 2D bounding box theBox with the set of bounding boxes to be sorted by this comparison algorithm, and returns the list of intersecting bounding boxes as a list of indexes on the array of bounding boxes used by this algorithm.
        	:param theBox:
        	:type theBox: Bnd_Box2d
        	:rtype: TColStd_ListOfInteger
        """
        return _Bnd.Bnd_BoundSortBox2d_Compare(self, *args)


    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _Bnd.Bnd_BoundSortBox2d_Dump(self, *args)


    def Initialize(self, *args) -> "void":
        """
        * Initializes this comparison algorithm with - the set of 2D bounding boxes SetOfBox
        	:param CompleteBox:
        	:type CompleteBox: Bnd_Box2d
        	:param SetOfBox:
        	:type SetOfBox: Bnd_HArray1OfBox2d
        	:rtype: None
        * Initializes this comparison algorithm with - the set of 2D bounding boxes SetOfBox, where CompleteBox is given as the global bounding box of SetOfBox.
        	:param SetOfBox:
        	:type SetOfBox: Bnd_HArray1OfBox2d
        	:rtype: None
        * Initializes this comparison algorithm, giving it only - the maximum number nbComponents, and - the global bounding box CompleteBox, of the 2D bounding boxes to be managed. Use the Add function to define the array of bounding boxes to be sorted by this algorithm.
        	:param CompleteBox:
        	:type CompleteBox: Bnd_Box2d
        	:param nbComponents:
        	:type nbComponents: int
        	:rtype: None
        """
        return _Bnd.Bnd_BoundSortBox2d_Initialize(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_BoundSortBox2d
Bnd_BoundSortBox2d.Add = new_instancemethod(_Bnd.Bnd_BoundSortBox2d_Add, None, Bnd_BoundSortBox2d)
Bnd_BoundSortBox2d.Compare = new_instancemethod(_Bnd.Bnd_BoundSortBox2d_Compare, None, Bnd_BoundSortBox2d)
Bnd_BoundSortBox2d.Dump = new_instancemethod(_Bnd.Bnd_BoundSortBox2d_Dump, None, Bnd_BoundSortBox2d)
Bnd_BoundSortBox2d.Initialize = new_instancemethod(_Bnd.Bnd_BoundSortBox2d_Initialize, None, Bnd_BoundSortBox2d)
Bnd_BoundSortBox2d_swigregister = _Bnd.Bnd_BoundSortBox2d_swigregister
Bnd_BoundSortBox2d_swigregister(Bnd_BoundSortBox2d)

class Bnd_Box(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds the box <Other> to <self>.
        	:param Other:
        	:type Other: Bnd_Box
        	:rtype: None
        * Adds a Pnt to the box.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        * Extends <self> from the Pnt <P> in the direction <D>.
        	:param P:
        	:type P: gp_Pnt
        	:param D:
        	:type D: gp_Dir
        	:rtype: None
        * Extends the Box in the given Direction, i.e. adds an half-line. The box may become infinite in 1,2 or 3 directions.
        	:param D:
        	:type D: gp_Dir
        	:rtype: None
        """
        return _Bnd.Bnd_Box_Add(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty Box. The constructed box is qualified Void. Its gap is null.
        	:rtype: None
        * Creates a bounding box, it contains: - minimum/maximum point of bouning box, The constructed box is qualified Void. Its gap is null.
        	:param theMin:
        	:type theMin: gp_Pnt
        	:param theMax:
        	:type theMax: gp_Pnt
        	:rtype: None
        """
        _Bnd.Bnd_Box_swiginit(self, _Bnd.new_Bnd_Box(*args))

    def CornerMax(self, *args) -> "gp_Pnt":
        """
        * Returns the upper corner of this bounding box. The gap is included. If this bounding box is infinite (i.e. 'open'), returned values may be equal to +/- Precision::Infinite(). Standard_ConstructionError exception will be thrown if the box is void. if IsVoid()
        	:rtype: gp_Pnt
        """
        return _Bnd.Bnd_Box_CornerMax(self, *args)


    def CornerMin(self, *args) -> "gp_Pnt":
        """
        * Returns the lower corner of this bounding box. The gap is included. If this bounding box is infinite (i.e. 'open'), returned values may be equal to +/- Precision::Infinite(). Standard_ConstructionError exception will be thrown if the box is void. if IsVoid()
        	:rtype: gp_Pnt
        """
        return _Bnd.Bnd_Box_CornerMin(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        * Computes the minimum distance between two boxes.
        	:param Other:
        	:type Other: Bnd_Box
        	:rtype: float
        """
        return _Bnd.Bnd_Box_Distance(self, *args)


    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _Bnd.Bnd_Box_Dump(self, *args)


    def DumpJsonToString(self, depth: 'int'=-1) -> "std::string":
        """
        DumpJsonToString(Bnd_Box self, int depth=-1) -> std::string
        DumpJsonToString(Bnd_Box self) -> std::string
        """
        return _Bnd.Bnd_Box_DumpJsonToString(self, depth)


    def Enlarge(self, *args) -> "void":
        """
        * Enlarges the box with a tolerance value. (minvalues-Abs(<tol>) and maxvalues+Abs(<tol>)) This means that the minimum values of its X, Y and Z intervals of definition, when they are finite, are reduced by the absolute value of Tol, while the maximum values are increased by the same amount.
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _Bnd.Bnd_Box_Enlarge(self, *args)


    def FinitePart(self, *args) -> "Bnd_Box":
        """
        * Returns a finite part of an infinite bounding box (returns self if this is already finite box). This can be a Void box in case if its sides has been defined as infinite (Open) without adding any finite points. WARNING! This method relies on Open flags, the infinite points added using Add() method will be returned as is.
        	:rtype: Bnd_Box
        """
        return _Bnd.Bnd_Box_FinitePart(self, *args)


    def Get(self, *args) -> "void":
        """
        * Returns the bounds of this bounding box. The gap is included. If this bounding box is infinite (i.e. 'open'), returned values may be equal to +/- Precision::Infinite(). Standard_ConstructionError exception will be thrown if the box is void. if IsVoid()
        	:param theXmin:
        	:type theXmin: float
        	:param theYmin:
        	:type theYmin: float
        	:param theZmin:
        	:type theZmin: float
        	:param theXmax:
        	:type theXmax: float
        	:param theYmax:
        	:type theYmax: float
        	:param theZmax:
        	:type theZmax: float
        	:rtype: None
        """
        return _Bnd.Bnd_Box_Get(self, *args)


    def GetGap(self, *args) -> "Standard_Real":
        """
        * Returns the gap of this bounding box.
        	:rtype: float
        """
        return _Bnd.Bnd_Box_GetGap(self, *args)


    def HasFinitePart(self, *args) -> "Standard_Boolean":
        """
        * Returns True if this box has finite part.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_HasFinitePart(self, *args)


    def IsOpen(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box has at least one open direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsOpen(self, *args)


    def IsOpenXmax(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Xmax direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsOpenXmax(self, *args)


    def IsOpenXmin(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Xmin direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsOpenXmin(self, *args)


    def IsOpenYmax(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Ymax direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsOpenYmax(self, *args)


    def IsOpenYmin(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Ymix direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsOpenYmin(self, *args)


    def IsOpenZmax(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Zmax direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsOpenZmax(self, *args)


    def IsOpenZmin(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Zmin direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsOpenZmin(self, *args)


    def IsOut(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the Pnt is out the box.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: bool
        * Returns False if the line intersects the box.
        	:param L:
        	:type L: gp_Lin
        	:rtype: bool
        * Returns False if the plane intersects the box.
        	:param P:
        	:type P: gp_Pln
        	:rtype: bool
        * Returns False if the <Box> intersects or is inside <self>.
        	:param Other:
        	:type Other: Bnd_Box
        	:rtype: bool
        * Returns False if the transformed <Box> intersects or is inside <self>.
        	:param Other:
        	:type Other: Bnd_Box
        	:param T:
        	:type T: gp_Trsf
        	:rtype: bool
        * Returns False if the transformed <Box> intersects or is inside the transformed box <self>.
        	:param T1:
        	:type T1: gp_Trsf
        	:param Other:
        	:type Other: Bnd_Box
        	:param T2:
        	:type T2: gp_Trsf
        	:rtype: bool
        * Returns False if the flat band lying between two parallel lines represented by their reference points <P1>, <P2> and direction <D> intersects the box.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:param D:
        	:type D: gp_Dir
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsOut(self, *args)


    def IsThin(self, *args) -> "Standard_Boolean":
        """
        * Returns true if IsXThin, IsYThin and IsZThin are all true, i.e. if the box is thin in all three dimensions.
        	:param tol:
        	:type tol: float
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsThin(self, *args)


    def IsVoid(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is empty (Void flag).
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsVoid(self, *args)


    def IsWhole(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is infinite in all 6 directions (WholeSpace flag).
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsWhole(self, *args)


    def IsXThin(self, *args) -> "Standard_Boolean":
        """
        * true if xmax-xmin < tol.
        	:param tol:
        	:type tol: float
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsXThin(self, *args)


    def IsYThin(self, *args) -> "Standard_Boolean":
        """
        * true if ymax-ymin < tol.
        	:param tol:
        	:type tol: float
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsYThin(self, *args)


    def IsZThin(self, *args) -> "Standard_Boolean":
        """
        * true if zmax-zmin < tol.
        	:param tol:
        	:type tol: float
        	:rtype: bool
        """
        return _Bnd.Bnd_Box_IsZThin(self, *args)


    def OpenXmax(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Xmax direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box_OpenXmax(self, *args)


    def OpenXmin(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Xmin direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box_OpenXmin(self, *args)


    def OpenYmax(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Ymax direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box_OpenYmax(self, *args)


    def OpenYmin(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Ymin direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box_OpenYmin(self, *args)


    def OpenZmax(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Zmax direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box_OpenZmax(self, *args)


    def OpenZmin(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Zmin direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box_OpenZmin(self, *args)


    def Set(self, *args) -> "void":
        """
        * Sets this bounding box so that it bounds - the point P. This involves first setting this bounding box to be void and then adding the point P.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        * Sets this bounding box so that it bounds the half-line defined by point P and direction D, i.e. all points M defined by M=P+u*D, where u is greater than or equal to 0, are inside the bounding volume. This involves first setting this box to be void and then adding the half-line.
        	:param P:
        	:type P: gp_Pnt
        	:param D:
        	:type D: gp_Dir
        	:rtype: None
        """
        return _Bnd.Bnd_Box_Set(self, *args)


    def SetGap(self, *args) -> "void":
        """
        * Set the gap of this bounding box to abs(Tol).
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _Bnd.Bnd_Box_SetGap(self, *args)


    def SetVoid(self, *args) -> "void":
        """
        * Sets this bounding box so that it is empty. All points are outside a void box.
        	:rtype: None
        """
        return _Bnd.Bnd_Box_SetVoid(self, *args)


    def SetWhole(self, *args) -> "void":
        """
        * Sets this bounding box so that it covers the whole of 3D space. It is infinitely long in all directions.
        	:rtype: None
        """
        return _Bnd.Bnd_Box_SetWhole(self, *args)


    def SquareExtent(self, *args) -> "Standard_Real":
        """
        * Computes the squared diagonal of me.
        	:rtype: float
        """
        return _Bnd.Bnd_Box_SquareExtent(self, *args)


    def Transformed(self, *args) -> "Bnd_Box":
        """
        * Returns a bounding box which is the result of applying the transformation T to this bounding box. Warning Applying a geometric transformation (for example, a rotation) to a bounding box generally increases its dimensions. This is not optimal for algorithms which use it.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: Bnd_Box
        """
        return _Bnd.Bnd_Box_Transformed(self, *args)


    def Update(self, *args) -> "void":
        """
        * Enlarges this bounding box, if required, so that it contains at least: - interval [ aXmin,aXmax ] in the 'X Direction', - interval [ aYmin,aYmax ] in the 'Y Direction', - interval [ aZmin,aZmax ] in the 'Z Direction';
        	:param aXmin:
        	:type aXmin: float
        	:param aYmin:
        	:type aYmin: float
        	:param aZmin:
        	:type aZmin: float
        	:param aXmax:
        	:type aXmax: float
        	:param aYmax:
        	:type aYmax: float
        	:param aZmax:
        	:type aZmax: float
        	:rtype: None
        * Adds a point of coordinates (X,Y,Z) to this bounding box.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        return _Bnd.Bnd_Box_Update(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_Box
Bnd_Box.Add = new_instancemethod(_Bnd.Bnd_Box_Add, None, Bnd_Box)
Bnd_Box.CornerMax = new_instancemethod(_Bnd.Bnd_Box_CornerMax, None, Bnd_Box)
Bnd_Box.CornerMin = new_instancemethod(_Bnd.Bnd_Box_CornerMin, None, Bnd_Box)
Bnd_Box.Distance = new_instancemethod(_Bnd.Bnd_Box_Distance, None, Bnd_Box)
Bnd_Box.Dump = new_instancemethod(_Bnd.Bnd_Box_Dump, None, Bnd_Box)
Bnd_Box.DumpJsonToString = new_instancemethod(_Bnd.Bnd_Box_DumpJsonToString, None, Bnd_Box)
Bnd_Box.Enlarge = new_instancemethod(_Bnd.Bnd_Box_Enlarge, None, Bnd_Box)
Bnd_Box.FinitePart = new_instancemethod(_Bnd.Bnd_Box_FinitePart, None, Bnd_Box)
Bnd_Box.Get = new_instancemethod(_Bnd.Bnd_Box_Get, None, Bnd_Box)
Bnd_Box.GetGap = new_instancemethod(_Bnd.Bnd_Box_GetGap, None, Bnd_Box)
Bnd_Box.HasFinitePart = new_instancemethod(_Bnd.Bnd_Box_HasFinitePart, None, Bnd_Box)
Bnd_Box.IsOpen = new_instancemethod(_Bnd.Bnd_Box_IsOpen, None, Bnd_Box)
Bnd_Box.IsOpenXmax = new_instancemethod(_Bnd.Bnd_Box_IsOpenXmax, None, Bnd_Box)
Bnd_Box.IsOpenXmin = new_instancemethod(_Bnd.Bnd_Box_IsOpenXmin, None, Bnd_Box)
Bnd_Box.IsOpenYmax = new_instancemethod(_Bnd.Bnd_Box_IsOpenYmax, None, Bnd_Box)
Bnd_Box.IsOpenYmin = new_instancemethod(_Bnd.Bnd_Box_IsOpenYmin, None, Bnd_Box)
Bnd_Box.IsOpenZmax = new_instancemethod(_Bnd.Bnd_Box_IsOpenZmax, None, Bnd_Box)
Bnd_Box.IsOpenZmin = new_instancemethod(_Bnd.Bnd_Box_IsOpenZmin, None, Bnd_Box)
Bnd_Box.IsOut = new_instancemethod(_Bnd.Bnd_Box_IsOut, None, Bnd_Box)
Bnd_Box.IsThin = new_instancemethod(_Bnd.Bnd_Box_IsThin, None, Bnd_Box)
Bnd_Box.IsVoid = new_instancemethod(_Bnd.Bnd_Box_IsVoid, None, Bnd_Box)
Bnd_Box.IsWhole = new_instancemethod(_Bnd.Bnd_Box_IsWhole, None, Bnd_Box)
Bnd_Box.IsXThin = new_instancemethod(_Bnd.Bnd_Box_IsXThin, None, Bnd_Box)
Bnd_Box.IsYThin = new_instancemethod(_Bnd.Bnd_Box_IsYThin, None, Bnd_Box)
Bnd_Box.IsZThin = new_instancemethod(_Bnd.Bnd_Box_IsZThin, None, Bnd_Box)
Bnd_Box.OpenXmax = new_instancemethod(_Bnd.Bnd_Box_OpenXmax, None, Bnd_Box)
Bnd_Box.OpenXmin = new_instancemethod(_Bnd.Bnd_Box_OpenXmin, None, Bnd_Box)
Bnd_Box.OpenYmax = new_instancemethod(_Bnd.Bnd_Box_OpenYmax, None, Bnd_Box)
Bnd_Box.OpenYmin = new_instancemethod(_Bnd.Bnd_Box_OpenYmin, None, Bnd_Box)
Bnd_Box.OpenZmax = new_instancemethod(_Bnd.Bnd_Box_OpenZmax, None, Bnd_Box)
Bnd_Box.OpenZmin = new_instancemethod(_Bnd.Bnd_Box_OpenZmin, None, Bnd_Box)
Bnd_Box.Set = new_instancemethod(_Bnd.Bnd_Box_Set, None, Bnd_Box)
Bnd_Box.SetGap = new_instancemethod(_Bnd.Bnd_Box_SetGap, None, Bnd_Box)
Bnd_Box.SetVoid = new_instancemethod(_Bnd.Bnd_Box_SetVoid, None, Bnd_Box)
Bnd_Box.SetWhole = new_instancemethod(_Bnd.Bnd_Box_SetWhole, None, Bnd_Box)
Bnd_Box.SquareExtent = new_instancemethod(_Bnd.Bnd_Box_SquareExtent, None, Bnd_Box)
Bnd_Box.Transformed = new_instancemethod(_Bnd.Bnd_Box_Transformed, None, Bnd_Box)
Bnd_Box.Update = new_instancemethod(_Bnd.Bnd_Box_Update, None, Bnd_Box)
Bnd_Box_swigregister = _Bnd.Bnd_Box_swigregister
Bnd_Box_swigregister(Bnd_Box)

class Bnd_Box2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds the 2d box <Other> to <self>.
        	:param Other:
        	:type Other: Bnd_Box2d
        	:rtype: None
        * Adds the 2d point.
        	:param thePnt:
        	:type thePnt: gp_Pnt2d
        	:rtype: None
        * Extends bounding box from thePnt in the direction theDir.
        	:param thePnt:
        	:type thePnt: gp_Pnt2d
        	:param theDir:
        	:type theDir: gp_Dir2d
        	:rtype: None
        * Extends the Box in the given Direction, i.e. adds a half-line. The box may become infinite in 1 or 2 directions.
        	:param D:
        	:type D: gp_Dir2d
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_Add(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty 2D bounding box. The constructed box is qualified Void. Its gap is null.
        	:rtype: None
        """
        _Bnd.Bnd_Box2d_swiginit(self, _Bnd.new_Bnd_Box2d(*args))

    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _Bnd.Bnd_Box2d_Dump(self, *args)


    def Enlarge(self, *args) -> "void":
        """
        * Enlarges the box with a tolerance value. This means that the minimum values of its X and Y intervals of definition, when they are finite, are reduced by the absolute value of Tol, while the maximum values are increased by the same amount.
        	:param theTol:
        	:type theTol: float
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_Enlarge(self, *args)


    def Get(self, *args) -> "void":
        """
        * Returns the bounds of this 2D bounding box. The gap is included. If this bounding box is infinite (i.e. 'open'), returned values may be equal to +/- Precision::Infinite(). if IsVoid()
        	:param aXmin:
        	:type aXmin: float
        	:param aYmin:
        	:type aYmin: float
        	:param aXmax:
        	:type aXmax: float
        	:param aYmax:
        	:type aYmax: float
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_Get(self, *args)


    def GetGap(self, *args) -> "Standard_Real":
        """
        * Returns the gap of this 2D bounding box.
        	:rtype: float
        """
        return _Bnd.Bnd_Box2d_GetGap(self, *args)


    def IsOpenXmax(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Xmax direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box2d_IsOpenXmax(self, *args)


    def IsOpenXmin(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Xmin direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box2d_IsOpenXmin(self, *args)


    def IsOpenYmax(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Ymax direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box2d_IsOpenYmax(self, *args)


    def IsOpenYmin(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is open in the Ymin direction.
        	:rtype: bool
        """
        return _Bnd.Bnd_Box2d_IsOpenYmin(self, *args)


    def IsOut(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the 2d pnt <P> is out <self>.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: bool
        * Returns True if <Box2d> is out <self>.
        	:param Other:
        	:type Other: Bnd_Box2d
        	:rtype: bool
        * Returns True if transformed <Box2d> is out <self>.
        	:param theOther:
        	:type theOther: Bnd_Box2d
        	:param theTrsf:
        	:type theTrsf: gp_Trsf2d
        	:rtype: bool
        * Compares a transformed bounding with a transformed bounding. The default implementation is to make a copy of <self> and <Other>, to transform them and to test.
        	:param T1:
        	:type T1: gp_Trsf2d
        	:param Other:
        	:type Other: Bnd_Box2d
        	:param T2:
        	:type T2: gp_Trsf2d
        	:rtype: bool
        """
        return _Bnd.Bnd_Box2d_IsOut(self, *args)


    def IsVoid(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this 2D bounding box is empty (Void flag).
        	:rtype: bool
        """
        return _Bnd.Bnd_Box2d_IsVoid(self, *args)


    def IsWhole(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this bounding box is infinite in all 4 directions (Whole Space flag).
        	:rtype: bool
        """
        return _Bnd.Bnd_Box2d_IsWhole(self, *args)


    def OpenXmax(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Xmax direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_OpenXmax(self, *args)


    def OpenXmin(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Xmin direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_OpenXmin(self, *args)


    def OpenYmax(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Ymax direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_OpenYmax(self, *args)


    def OpenYmin(self, *args) -> "void":
        """
        * The Box will be infinitely long in the Ymin direction.
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_OpenYmin(self, *args)


    def Set(self, *args) -> "void":
        """
        * Sets this 2D bounding box so that it bounds the point P. This involves first setting this bounding box to be void and then adding the point PThe rectangle bounds the point <P>.
        	:param thePnt:
        	:type thePnt: gp_Pnt2d
        	:rtype: None
        * Sets this 2D bounding box so that it bounds the half-line defined by point P and direction D, i.e. all points M defined by M=P+u*D, where u is greater than or equal to 0, are inside the bounding area. This involves first setting this 2D box to be void and then adding the half-line.
        	:param thePnt:
        	:type thePnt: gp_Pnt2d
        	:param theDir:
        	:type theDir: gp_Dir2d
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_Set(self, *args)


    def SetGap(self, *args) -> "void":
        """
        * Set the gap of this 2D bounding box to abs(Tol).
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_SetGap(self, *args)


    def SetVoid(self, *args) -> "void":
        """
        * Sets this 2D bounding box so that it is empty. All points are outside a void box.
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_SetVoid(self, *args)


    def SetWhole(self, *args) -> "void":
        """
        * Sets this bounding box so that it covers the whole 2D space, i.e. it is infinite in all directions.
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_SetWhole(self, *args)


    def SquareExtent(self, *args) -> "Standard_Real":
        """
        * Computes the squared diagonal of me.
        	:rtype: float
        """
        return _Bnd.Bnd_Box2d_SquareExtent(self, *args)


    def Transformed(self, *args) -> "Bnd_Box2d":
        """
        * Returns a bounding box which is the result of applying the transformation T to this bounding box. Warning Applying a geometric transformation (for example, a rotation) to a bounding box generally increases its dimensions. This is not optimal for algorithms which use it.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: Bnd_Box2d
        """
        return _Bnd.Bnd_Box2d_Transformed(self, *args)


    def Update(self, *args) -> "void":
        """
        * Enlarges this 2D bounding box, if required, so that it contains at least: - interval [ aXmin,aXmax ] in the 'X Direction', - interval [ aYmin,aYmax ] in the 'Y Direction'
        	:param aXmin:
        	:type aXmin: float
        	:param aYmin:
        	:type aYmin: float
        	:param aXmax:
        	:type aXmax: float
        	:param aYmax:
        	:type aYmax: float
        	:rtype: None
        * Adds a point of coordinates (X,Y) to this bounding box.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _Bnd.Bnd_Box2d_Update(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_Box2d
Bnd_Box2d.Add = new_instancemethod(_Bnd.Bnd_Box2d_Add, None, Bnd_Box2d)
Bnd_Box2d.Dump = new_instancemethod(_Bnd.Bnd_Box2d_Dump, None, Bnd_Box2d)
Bnd_Box2d.Enlarge = new_instancemethod(_Bnd.Bnd_Box2d_Enlarge, None, Bnd_Box2d)
Bnd_Box2d.Get = new_instancemethod(_Bnd.Bnd_Box2d_Get, None, Bnd_Box2d)
Bnd_Box2d.GetGap = new_instancemethod(_Bnd.Bnd_Box2d_GetGap, None, Bnd_Box2d)
Bnd_Box2d.IsOpenXmax = new_instancemethod(_Bnd.Bnd_Box2d_IsOpenXmax, None, Bnd_Box2d)
Bnd_Box2d.IsOpenXmin = new_instancemethod(_Bnd.Bnd_Box2d_IsOpenXmin, None, Bnd_Box2d)
Bnd_Box2d.IsOpenYmax = new_instancemethod(_Bnd.Bnd_Box2d_IsOpenYmax, None, Bnd_Box2d)
Bnd_Box2d.IsOpenYmin = new_instancemethod(_Bnd.Bnd_Box2d_IsOpenYmin, None, Bnd_Box2d)
Bnd_Box2d.IsOut = new_instancemethod(_Bnd.Bnd_Box2d_IsOut, None, Bnd_Box2d)
Bnd_Box2d.IsVoid = new_instancemethod(_Bnd.Bnd_Box2d_IsVoid, None, Bnd_Box2d)
Bnd_Box2d.IsWhole = new_instancemethod(_Bnd.Bnd_Box2d_IsWhole, None, Bnd_Box2d)
Bnd_Box2d.OpenXmax = new_instancemethod(_Bnd.Bnd_Box2d_OpenXmax, None, Bnd_Box2d)
Bnd_Box2d.OpenXmin = new_instancemethod(_Bnd.Bnd_Box2d_OpenXmin, None, Bnd_Box2d)
Bnd_Box2d.OpenYmax = new_instancemethod(_Bnd.Bnd_Box2d_OpenYmax, None, Bnd_Box2d)
Bnd_Box2d.OpenYmin = new_instancemethod(_Bnd.Bnd_Box2d_OpenYmin, None, Bnd_Box2d)
Bnd_Box2d.Set = new_instancemethod(_Bnd.Bnd_Box2d_Set, None, Bnd_Box2d)
Bnd_Box2d.SetGap = new_instancemethod(_Bnd.Bnd_Box2d_SetGap, None, Bnd_Box2d)
Bnd_Box2d.SetVoid = new_instancemethod(_Bnd.Bnd_Box2d_SetVoid, None, Bnd_Box2d)
Bnd_Box2d.SetWhole = new_instancemethod(_Bnd.Bnd_Box2d_SetWhole, None, Bnd_Box2d)
Bnd_Box2d.SquareExtent = new_instancemethod(_Bnd.Bnd_Box2d_SquareExtent, None, Bnd_Box2d)
Bnd_Box2d.Transformed = new_instancemethod(_Bnd.Bnd_Box2d_Transformed, None, Bnd_Box2d)
Bnd_Box2d.Update = new_instancemethod(_Bnd.Bnd_Box2d_Update, None, Bnd_Box2d)
Bnd_Box2d_swigregister = _Bnd.Bnd_Box2d_swigregister
Bnd_Box2d_swigregister(Bnd_Box2d)

class Bnd_OBB(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Rebuilds this in order to include all previous objects (which it was created from) and theOther.
        	:param theOther:
        	:type theOther: Bnd_OBB
        	:rtype: None
        * Rebuilds this in order to include all previous objects (which it was created from) and theP.
        	:param theP:
        	:type theP: gp_Pnt
        	:rtype: None
        """
        return _Bnd.Bnd_OBB_Add(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        * Constructor taking all defining parameters
        	:param theCenter:
        	:type theCenter: gp_Pnt
        	:param theXDirection:
        	:type theXDirection: gp_Dir
        	:param theYDirection:
        	:type theYDirection: gp_Dir
        	:param theZDirection:
        	:type theZDirection: gp_Dir
        	:param theHXSize:
        	:type theHXSize: float
        	:param theHYSize:
        	:type theHYSize: float
        	:param theHZSize:
        	:type theHZSize: float
        	:rtype: None
        * Constructor to create OBB from AABB.
        	:param theBox:
        	:type theBox: Bnd_Box
        	:rtype: None
        """
        _Bnd.Bnd_OBB_swiginit(self, _Bnd.new_Bnd_OBB(*args))

    def Center(self, *args) -> "gp_XYZ const":
        """
        * Returns the center of OBB
        	:rtype: gp_XYZ
        """
        return _Bnd.Bnd_OBB_Center(self, *args)


    def DumpJsonToString(self, depth: 'int'=-1) -> "std::string":
        """
        DumpJsonToString(Bnd_OBB self, int depth=-1) -> std::string
        DumpJsonToString(Bnd_OBB self) -> std::string
        """
        return _Bnd.Bnd_OBB_DumpJsonToString(self, depth)


    def Enlarge(self, *args) -> "void":
        """
        * Enlarges the box with the given value
        	:param theGapAdd:
        	:type theGapAdd: float
        	:rtype: None
        """
        return _Bnd.Bnd_OBB_Enlarge(self, *args)


    def GetVertex(self, *args) -> "Standard_Boolean":
        """
        * Returns the array of vertices in <this>. The local coordinate of the vertex depending on the index of the array are follow: Index == 0: (-XHSize(), -YHSize(), -ZHSize()) Index == 1: ( XHSize(), -YHSize(), -ZHSize()) Index == 2: (-XHSize(), YHSize(), -ZHSize()) Index == 3: ( XHSize(), YHSize(), -ZHSize()) Index == 4: (-XHSize(), -YHSize(), ZHSize()) Index == 5: ( XHSize(), -YHSize(), ZHSize()) Index == 6: (-XHSize(), YHSize(), ZHSize()) Index == 7: ( XHSize(), YHSize(), ZHSize()).
        	:param theP:
        	:type theP: gp_Pnt
        	:rtype: bool
        """
        return _Bnd.Bnd_OBB_GetVertex(self, *args)


    def IsAABox(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the box is axes aligned
        	:rtype: bool
        """
        return _Bnd.Bnd_OBB_IsAABox(self, *args)


    def IsCompletelyInside(self, *args) -> "Standard_Boolean":
        """
        * Check if the theOther is completely inside *this.
        	:param theOther:
        	:type theOther: Bnd_OBB
        	:rtype: bool
        """
        return _Bnd.Bnd_OBB_IsCompletelyInside(self, *args)


    def IsOut(self, *args) -> "Standard_Boolean":
        """
        * Check if the box do not interfere the other box.
        	:param theOther:
        	:type theOther: Bnd_OBB
        	:rtype: bool
        * Check if the point is inside of <this>.
        	:param theP:
        	:type theP: gp_Pnt
        	:rtype: bool
        """
        return _Bnd.Bnd_OBB_IsOut(self, *args)


    def IsVoid(self, *args) -> "Standard_Boolean":
        """
        * Checks if the box is empty.
        	:rtype: bool
        """
        return _Bnd.Bnd_OBB_IsVoid(self, *args)


    def Position(self, *args) -> "gp_Ax3":
        """
        * Returns the local coordinates system of this oriented box. So that applying it to axis-aligned box ((-XHSize, -YHSize, -ZHSize), (XHSize, YHSize, ZHSize)) will produce this oriented box. @code gp_Trsf aLoc; aLoc.SetTransformation (theOBB.Position(), gp::XOY()); @endcode
        	:rtype: gp_Ax3
        """
        return _Bnd.Bnd_OBB_Position(self, *args)


    def ReBuild(self, *args) -> "void":
        """
        * Creates new OBB covering every point in theListOfPoints. Tolerance of every such point is set by *theListOfTolerances array. If this array is not void (not null-pointer) then the resulted Bnd_OBB will be enlarged using tolerances of points lying on the box surface. <theIsOptimal> flag defines the mode in which the OBB will be built. Constructing Optimal box takes more time, but the resulting box is usually more tight. In case of construction of Optimal OBB more possible axes are checked.
        	:param theListOfPoints:
        	:type theListOfPoints: TColgp_Array1OfPnt
        	:param theListOfTolerances: default value is 0
        	:type theListOfTolerances: TColStd_Array1OfReal *
        	:param theIsOptimal: default value is Standard_False
        	:type theIsOptimal: bool
        	:rtype: None
        """
        return _Bnd.Bnd_OBB_ReBuild(self, *args)


    def SetAABox(self, *args) -> "void":
        """
        * Sets the flag for axes aligned box
        	:param theFlag:
        	:type theFlag: bool
        	:rtype: None
        """
        return _Bnd.Bnd_OBB_SetAABox(self, *args)


    def SetCenter(self, *args) -> "void":
        """
        * Sets the center of OBB
        	:param theCenter:
        	:type theCenter: gp_Pnt
        	:rtype: None
        """
        return _Bnd.Bnd_OBB_SetCenter(self, *args)


    def SetVoid(self, *args) -> "void":
        """
        * Clears this box
        	:rtype: None
        """
        return _Bnd.Bnd_OBB_SetVoid(self, *args)


    def SetXComponent(self, *args) -> "void":
        """
        * Sets the X component of OBB - direction and size
        	:param theXDirection:
        	:type theXDirection: gp_Dir
        	:param theHXSize:
        	:type theHXSize: float
        	:rtype: None
        """
        return _Bnd.Bnd_OBB_SetXComponent(self, *args)


    def SetYComponent(self, *args) -> "void":
        """
        * Sets the Y component of OBB - direction and size
        	:param theYDirection:
        	:type theYDirection: gp_Dir
        	:param theHYSize:
        	:type theHYSize: float
        	:rtype: None
        """
        return _Bnd.Bnd_OBB_SetYComponent(self, *args)


    def SetZComponent(self, *args) -> "void":
        """
        * Sets the Z component of OBB - direction and size
        	:param theZDirection:
        	:type theZDirection: gp_Dir
        	:param theHZSize:
        	:type theHZSize: float
        	:rtype: None
        """
        return _Bnd.Bnd_OBB_SetZComponent(self, *args)


    def SquareExtent(self, *args) -> "Standard_Real":
        """
        * Returns square diagonal of this box
        	:rtype: float
        """
        return _Bnd.Bnd_OBB_SquareExtent(self, *args)


    def XDirection(self, *args) -> "gp_XYZ const":
        """
        * Returns the X Direction of OBB
        	:rtype: gp_XYZ
        """
        return _Bnd.Bnd_OBB_XDirection(self, *args)


    def XHSize(self, *args) -> "Standard_Real":
        """
        * Returns the X Dimension of OBB
        	:rtype: float
        """
        return _Bnd.Bnd_OBB_XHSize(self, *args)


    def YDirection(self, *args) -> "gp_XYZ const":
        """
        * Returns the Y Direction of OBB
        	:rtype: gp_XYZ
        """
        return _Bnd.Bnd_OBB_YDirection(self, *args)


    def YHSize(self, *args) -> "Standard_Real":
        """
        * Returns the Y Dimension of OBB
        	:rtype: float
        """
        return _Bnd.Bnd_OBB_YHSize(self, *args)


    def ZDirection(self, *args) -> "gp_XYZ const":
        """
        * Returns the Z Direction of OBB
        	:rtype: gp_XYZ
        """
        return _Bnd.Bnd_OBB_ZDirection(self, *args)


    def ZHSize(self, *args) -> "Standard_Real":
        """
        * Returns the Z Dimension of OBB
        	:rtype: float
        """
        return _Bnd.Bnd_OBB_ZHSize(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_OBB
Bnd_OBB.Add = new_instancemethod(_Bnd.Bnd_OBB_Add, None, Bnd_OBB)
Bnd_OBB.Center = new_instancemethod(_Bnd.Bnd_OBB_Center, None, Bnd_OBB)
Bnd_OBB.DumpJsonToString = new_instancemethod(_Bnd.Bnd_OBB_DumpJsonToString, None, Bnd_OBB)
Bnd_OBB.Enlarge = new_instancemethod(_Bnd.Bnd_OBB_Enlarge, None, Bnd_OBB)
Bnd_OBB.GetVertex = new_instancemethod(_Bnd.Bnd_OBB_GetVertex, None, Bnd_OBB)
Bnd_OBB.IsAABox = new_instancemethod(_Bnd.Bnd_OBB_IsAABox, None, Bnd_OBB)
Bnd_OBB.IsCompletelyInside = new_instancemethod(_Bnd.Bnd_OBB_IsCompletelyInside, None, Bnd_OBB)
Bnd_OBB.IsOut = new_instancemethod(_Bnd.Bnd_OBB_IsOut, None, Bnd_OBB)
Bnd_OBB.IsVoid = new_instancemethod(_Bnd.Bnd_OBB_IsVoid, None, Bnd_OBB)
Bnd_OBB.Position = new_instancemethod(_Bnd.Bnd_OBB_Position, None, Bnd_OBB)
Bnd_OBB.ReBuild = new_instancemethod(_Bnd.Bnd_OBB_ReBuild, None, Bnd_OBB)
Bnd_OBB.SetAABox = new_instancemethod(_Bnd.Bnd_OBB_SetAABox, None, Bnd_OBB)
Bnd_OBB.SetCenter = new_instancemethod(_Bnd.Bnd_OBB_SetCenter, None, Bnd_OBB)
Bnd_OBB.SetVoid = new_instancemethod(_Bnd.Bnd_OBB_SetVoid, None, Bnd_OBB)
Bnd_OBB.SetXComponent = new_instancemethod(_Bnd.Bnd_OBB_SetXComponent, None, Bnd_OBB)
Bnd_OBB.SetYComponent = new_instancemethod(_Bnd.Bnd_OBB_SetYComponent, None, Bnd_OBB)
Bnd_OBB.SetZComponent = new_instancemethod(_Bnd.Bnd_OBB_SetZComponent, None, Bnd_OBB)
Bnd_OBB.SquareExtent = new_instancemethod(_Bnd.Bnd_OBB_SquareExtent, None, Bnd_OBB)
Bnd_OBB.XDirection = new_instancemethod(_Bnd.Bnd_OBB_XDirection, None, Bnd_OBB)
Bnd_OBB.XHSize = new_instancemethod(_Bnd.Bnd_OBB_XHSize, None, Bnd_OBB)
Bnd_OBB.YDirection = new_instancemethod(_Bnd.Bnd_OBB_YDirection, None, Bnd_OBB)
Bnd_OBB.YHSize = new_instancemethod(_Bnd.Bnd_OBB_YHSize, None, Bnd_OBB)
Bnd_OBB.ZDirection = new_instancemethod(_Bnd.Bnd_OBB_ZDirection, None, Bnd_OBB)
Bnd_OBB.ZHSize = new_instancemethod(_Bnd.Bnd_OBB_ZHSize, None, Bnd_OBB)
Bnd_OBB_swigregister = _Bnd.Bnd_OBB_swigregister
Bnd_OBB_swigregister(Bnd_OBB)

class Bnd_Range(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Extends <this> to include theParameter
        	:param theParameter:
        	:type theParameter: float
        	:rtype: None
        * Extends this range to include both ranges. @sa use method ::Union() to check if two ranges overlap method merging
        	:param theRange:
        	:type theRange: Bnd_Range
        	:rtype: None
        """
        return _Bnd.Bnd_Range_Add(self, *args)


    def __init__(self, *args):
        """
        * Default constructor. Creates VOID range.
        	:rtype: None
        * Constructor. Never creates VOID range.
        	:param theMin:
        	:type theMin: float
        	:param theMax:
        	:type theMax: float
        	:rtype: None
        """
        _Bnd.Bnd_Range_swiginit(self, _Bnd.new_Bnd_Range(*args))

    def Common(self, *args) -> "void":
        """
        * Replaces <this> with common-part of <this> and theOther
        	:param theOther:
        	:type theOther: Bnd_Range
        	:rtype: None
        """
        return _Bnd.Bnd_Range_Common(self, *args)


    def Delta(self, *args) -> "Standard_Real":
        """
        * Returns range value (MAX-MIN). Returns negative value for VOID range.
        	:rtype: float
        """
        return _Bnd.Bnd_Range_Delta(self, *args)


    def DumpJsonToString(self, depth: 'int'=-1) -> "std::string":
        """
        DumpJsonToString(Bnd_Range self, int depth=-1) -> std::string
        DumpJsonToString(Bnd_Range self) -> std::string
        """
        return _Bnd.Bnd_Range_DumpJsonToString(self, depth)


    def Enlarge(self, *args) -> "void":
        """
        * Extends this to the given value (in both side)
        	:param theDelta:
        	:type theDelta: float
        	:rtype: None
        """
        return _Bnd.Bnd_Range_Enlarge(self, *args)


    def GetBounds(self, *args) -> "Standard_Boolean":
        """
        * Obtain first and last boundary of <this>. If <this> is VOID the method returns false.
        	:param theFirstPar:
        	:type theFirstPar: float
        	:param theLastPar:
        	:type theLastPar: float
        	:rtype: bool
        """
        return _Bnd.Bnd_Range_GetBounds(self, *args)


    def GetIntermediatePoint(self, *args) -> "Standard_Boolean":
        """
        * Obtain theParameter satisfied to the equation (theParameter-MIN)/(MAX-MIN) == theLambda. * theLambda == 0 --> MIN boundary will be returned; * theLambda == 0.5 --> Middle point will be returned; * theLambda == 1 --> MAX boundary will be returned; * theLambda < 0 --> the value less than MIN will be returned; * theLambda > 1 --> the value greater than MAX will be returned. If <this> is VOID the method returns false.
        	:param theLambda:
        	:type theLambda: float
        	:param theParameter:
        	:type theParameter: float
        	:rtype: bool
        """
        return _Bnd.Bnd_Range_GetIntermediatePoint(self, *args)


    def GetMax(self, *args) -> "Standard_Boolean":
        """
        * Obtain MAX boundary of <this>. If <this> is VOID the method returns false.
        	:param thePar:
        	:type thePar: float
        	:rtype: bool
        """
        return _Bnd.Bnd_Range_GetMax(self, *args)


    def GetMin(self, *args) -> "Standard_Boolean":
        """
        * Obtain MIN boundary of <this>. If <this> is VOID the method returns false.
        	:param thePar:
        	:type thePar: float
        	:rtype: bool
        """
        return _Bnd.Bnd_Range_GetMin(self, *args)


    def IsIntersected(self, *args) -> "Standard_Integer":
        """
        * Checks if <this> intersects values like theVal+k*thePeriod, where k is an integer number (k = 0, +/-1, +/-2, ...). Returns: 0 - if <this> does not intersect the theVal+k*thePeriod. 1 - if <this> intersects theVal+k*thePeriod. 2 - if myFirst or/and myLast are equal to theVal+k*thePeriod. //! ATTENTION!!! If (myFirst == myLast) then this function will return only either 0 or 2.
        	:param theVal:
        	:type theVal: float
        	:param thePeriod: default value is 0.0
        	:type thePeriod: float
        	:rtype: int
        """
        return _Bnd.Bnd_Range_IsIntersected(self, *args)


    def IsOut(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the value is out of this range.
        	:param theValue:
        	:type theValue: float
        	:rtype: bool
        * Returns True if the given range is out of this range.
        	:param theRange:
        	:type theRange: Bnd_Range
        	:rtype: bool
        """
        return _Bnd.Bnd_Range_IsOut(self, *args)


    def IsVoid(self, *args) -> "Standard_Boolean":
        """
        * Is <this> initialized.
        	:rtype: bool
        """
        return _Bnd.Bnd_Range_IsVoid(self, *args)


    def SetVoid(self, *args) -> "void":
        """
        * Initializes <this> by default parameters. Makes <this> VOID.
        	:rtype: None
        """
        return _Bnd.Bnd_Range_SetVoid(self, *args)


    def Shift(self, *args) -> "void":
        """
        * Shifts <*this> by theVal
        	:param theVal:
        	:type theVal: float
        	:rtype: None
        """
        return _Bnd.Bnd_Range_Shift(self, *args)


    def Shifted(self, *args) -> "Bnd_Range":
        """
        * Returns the copy of <*this> shifted by theVal
        	:param theVal:
        	:type theVal: float
        	:rtype: Bnd_Range
        """
        return _Bnd.Bnd_Range_Shifted(self, *args)


    def Split(self, *args) -> "void":
        """
        * Splits <this> to several sub-ranges by theVal value (e.g. range [3, 15] will be split by theVal==5 to the two ranges: [3, 5] and [5, 15]). New ranges will be pushed to theList (theList must be initialized correctly before calling this method). If thePeriod != 0.0 then at least one boundary of new ranges (if <*this> intersects theVal+k*thePeriod) will be equal to theVal+thePeriod*k, where k is an integer number (k = 0, +/-1, +/-2, ...). (let thePeriod in above example be 4 ==> we will obtain four ranges: [3, 5], [5, 9], [9, 13] and [13, 15].
        	:param theVal:
        	:type theVal: float
        	:param theList:
        	:type theList: NCollection_List<Bnd_Range>
        	:param thePeriod: default value is 0.0
        	:type thePeriod: float
        	:rtype: None
        """
        return _Bnd.Bnd_Range_Split(self, *args)


    def TrimFrom(self, *args) -> "void":
        """
        * Trims the First value in range by the given lower limit. Marks range as Void if the given Lower value is greater than range Max.
        	:param theValLower:
        	:type theValLower: float
        	:rtype: None
        """
        return _Bnd.Bnd_Range_TrimFrom(self, *args)


    def TrimTo(self, *args) -> "void":
        """
        * Trim the Last value in range by the given Upper limit. Marks range as Void if the given Upper value is smaller than range Max.
        	:param theValUpper:
        	:type theValUpper: float
        	:rtype: None
        """
        return _Bnd.Bnd_Range_TrimTo(self, *args)


    def Union(self, *args) -> "Standard_Boolean":
        """
        * Joins *this and theOther to one interval. Replaces *this to the result. Returns false if the operation cannot be done (e.g. input arguments are empty or separated). @sa use method ::Add() to merge two ranges unconditionally
        	:param theOther:
        	:type theOther: Bnd_Range
        	:rtype: bool
        """
        return _Bnd.Bnd_Range_Union(self, *args)


    def __eq_wrapper__(self, other: 'Bnd_Range') -> "bool":
        """__eq_wrapper__(Bnd_Range self, Bnd_Range other) -> bool"""
        return _Bnd.Bnd_Range___eq_wrapper__(self, other)


    def __eq__(self, right):
        try:
            return self.__eq_wrapper__(right)
        except:
            return False


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_Range
Bnd_Range.Add = new_instancemethod(_Bnd.Bnd_Range_Add, None, Bnd_Range)
Bnd_Range.Common = new_instancemethod(_Bnd.Bnd_Range_Common, None, Bnd_Range)
Bnd_Range.Delta = new_instancemethod(_Bnd.Bnd_Range_Delta, None, Bnd_Range)
Bnd_Range.DumpJsonToString = new_instancemethod(_Bnd.Bnd_Range_DumpJsonToString, None, Bnd_Range)
Bnd_Range.Enlarge = new_instancemethod(_Bnd.Bnd_Range_Enlarge, None, Bnd_Range)
Bnd_Range.GetBounds = new_instancemethod(_Bnd.Bnd_Range_GetBounds, None, Bnd_Range)
Bnd_Range.GetIntermediatePoint = new_instancemethod(_Bnd.Bnd_Range_GetIntermediatePoint, None, Bnd_Range)
Bnd_Range.GetMax = new_instancemethod(_Bnd.Bnd_Range_GetMax, None, Bnd_Range)
Bnd_Range.GetMin = new_instancemethod(_Bnd.Bnd_Range_GetMin, None, Bnd_Range)
Bnd_Range.IsIntersected = new_instancemethod(_Bnd.Bnd_Range_IsIntersected, None, Bnd_Range)
Bnd_Range.IsOut = new_instancemethod(_Bnd.Bnd_Range_IsOut, None, Bnd_Range)
Bnd_Range.IsVoid = new_instancemethod(_Bnd.Bnd_Range_IsVoid, None, Bnd_Range)
Bnd_Range.SetVoid = new_instancemethod(_Bnd.Bnd_Range_SetVoid, None, Bnd_Range)
Bnd_Range.Shift = new_instancemethod(_Bnd.Bnd_Range_Shift, None, Bnd_Range)
Bnd_Range.Shifted = new_instancemethod(_Bnd.Bnd_Range_Shifted, None, Bnd_Range)
Bnd_Range.Split = new_instancemethod(_Bnd.Bnd_Range_Split, None, Bnd_Range)
Bnd_Range.TrimFrom = new_instancemethod(_Bnd.Bnd_Range_TrimFrom, None, Bnd_Range)
Bnd_Range.TrimTo = new_instancemethod(_Bnd.Bnd_Range_TrimTo, None, Bnd_Range)
Bnd_Range.Union = new_instancemethod(_Bnd.Bnd_Range_Union, None, Bnd_Range)
Bnd_Range.__eq_wrapper__ = new_instancemethod(_Bnd.Bnd_Range___eq_wrapper__, None, Bnd_Range)
Bnd_Range_swigregister = _Bnd.Bnd_Range_swigregister
Bnd_Range_swigregister(Bnd_Range)

class Bnd_Sphere(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        :param theOther:
        	:type theOther: Bnd_Sphere
        	:rtype: None
        """
        return _Bnd.Bnd_Sphere_Add(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        * Constructor of a definite sphere
        	:param theCntr:
        	:type theCntr: gp_XYZ
        	:param theRad:
        	:type theRad: float
        	:param theU:
        	:type theU: int
        	:param theV:
        	:type theV: int
        	:rtype: None
        """
        _Bnd.Bnd_Sphere_swiginit(self, _Bnd.new_Bnd_Sphere(*args))

    def Center(self, *args) -> "gp_XYZ const":
        """
        * Returns center of sphere object
        	:rtype: gp_XYZ
        """
        return _Bnd.Bnd_Sphere_Center(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        :param theNode:
        	:type theNode: gp_XYZ
        	:rtype: float
        """
        return _Bnd.Bnd_Sphere_Distance(self, *args)


    def Distances(self, *args) -> "void":
        """
        * Calculate and return minimal and maximal distance to sphere. NOTE: This function is tightly optimized; any modifications may affect performance!
        	:param theXYZ:
        	:type theXYZ: gp_XYZ
        	:param theMin:
        	:type theMin: float
        	:param theMax:
        	:type theMax: float
        	:rtype: None
        """
        return _Bnd.Bnd_Sphere_Distances(self, *args)


    def IsOut(self, *args) -> "Standard_Boolean":
        """
        :param theOther:
        	:type theOther: Bnd_Sphere
        	:rtype: bool
        :param thePnt:
        	:type thePnt: gp_XYZ
        	:param theMaxDist:
        	:type theMaxDist: float
        	:rtype: bool
        """
        return _Bnd.Bnd_Sphere_IsOut(self, *args)


    def IsValid(self, *args) -> "Standard_Boolean":
        """
        * Returns validity status, indicating that this sphere corresponds to a real entity
        	:rtype: bool
        """
        return _Bnd.Bnd_Sphere_IsValid(self, *args)


    def Project(self, *args) -> "Standard_Boolean":
        """
        * Projects a point on entity. Returns true if success
        	:param theNode:
        	:type theNode: gp_XYZ
        	:param theProjNode:
        	:type theProjNode: gp_XYZ
        	:param theDist:
        	:type theDist: float
        	:param theInside:
        	:type theInside: bool
        	:rtype: bool
        """
        return _Bnd.Bnd_Sphere_Project(self, *args)


    def Radius(self, *args) -> "Standard_Real":
        """
        * Returns the radius value
        	:rtype: float
        """
        return _Bnd.Bnd_Sphere_Radius(self, *args)


    def SetValid(self, *args) -> "void":
        """
        :param isValid:
        	:type isValid: bool
        	:rtype: None
        """
        return _Bnd.Bnd_Sphere_SetValid(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        :param theNode:
        	:type theNode: gp_XYZ
        	:rtype: float
        """
        return _Bnd.Bnd_Sphere_SquareDistance(self, *args)


    def SquareDistances(self, *args) -> "void":
        """
        * Calculate and return minimal and maximal distance to sphere. NOTE: This function is tightly optimized; any modifications may affect performance!
        	:param theXYZ:
        	:type theXYZ: gp_XYZ
        	:param theMin:
        	:type theMin: float
        	:param theMax:
        	:type theMax: float
        	:rtype: None
        """
        return _Bnd.Bnd_Sphere_SquareDistances(self, *args)


    def SquareExtent(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Bnd.Bnd_Sphere_SquareExtent(self, *args)


    def U(self, *args) -> "Standard_Integer":
        """
        * Returns the U parameter on shape
        	:rtype: int
        """
        return _Bnd.Bnd_Sphere_U(self, *args)


    def V(self, *args) -> "Standard_Integer":
        """
        * Returns the V parameter on shape
        	:rtype: int
        """
        return _Bnd.Bnd_Sphere_V(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Bnd.delete_Bnd_Sphere
Bnd_Sphere.Add = new_instancemethod(_Bnd.Bnd_Sphere_Add, None, Bnd_Sphere)
Bnd_Sphere.Center = new_instancemethod(_Bnd.Bnd_Sphere_Center, None, Bnd_Sphere)
Bnd_Sphere.Distance = new_instancemethod(_Bnd.Bnd_Sphere_Distance, None, Bnd_Sphere)
Bnd_Sphere.Distances = new_instancemethod(_Bnd.Bnd_Sphere_Distances, None, Bnd_Sphere)
Bnd_Sphere.IsOut = new_instancemethod(_Bnd.Bnd_Sphere_IsOut, None, Bnd_Sphere)
Bnd_Sphere.IsValid = new_instancemethod(_Bnd.Bnd_Sphere_IsValid, None, Bnd_Sphere)
Bnd_Sphere.Project = new_instancemethod(_Bnd.Bnd_Sphere_Project, None, Bnd_Sphere)
Bnd_Sphere.Radius = new_instancemethod(_Bnd.Bnd_Sphere_Radius, None, Bnd_Sphere)
Bnd_Sphere.SetValid = new_instancemethod(_Bnd.Bnd_Sphere_SetValid, None, Bnd_Sphere)
Bnd_Sphere.SquareDistance = new_instancemethod(_Bnd.Bnd_Sphere_SquareDistance, None, Bnd_Sphere)
Bnd_Sphere.SquareDistances = new_instancemethod(_Bnd.Bnd_Sphere_SquareDistances, None, Bnd_Sphere)
Bnd_Sphere.SquareExtent = new_instancemethod(_Bnd.Bnd_Sphere_SquareExtent, None, Bnd_Sphere)
Bnd_Sphere.U = new_instancemethod(_Bnd.Bnd_Sphere_U, None, Bnd_Sphere)
Bnd_Sphere.V = new_instancemethod(_Bnd.Bnd_Sphere_V, None, Bnd_Sphere)
Bnd_Sphere_swigregister = _Bnd.Bnd_Sphere_swigregister
Bnd_Sphere_swigregister(Bnd_Sphere)

class Bnd_Tools(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bnd2BVH(*args) -> "BVH_Box< Standard_Real,3 >":
        """
        * @name Bnd_Box to BVH_Box conversion Converts the given Bnd_Box2d to BVH_Box
        	:param theBox:
        	:type theBox: Bnd_Box2d
        	:rtype: BVH_Box<float, 2>
        * Converts the given Bnd_Box to BVH_Box
        	:param theBox:
        	:type theBox: Bnd_Box
        	:rtype: BVH_Box<float, 3>
        """
        return _Bnd.Bnd_Tools_Bnd2BVH(*args)

    Bnd2BVH = staticmethod(Bnd2BVH)

    __repr__ = _dumps_object


    def __init__(self):
        _Bnd.Bnd_Tools_swiginit(self, _Bnd.new_Bnd_Tools())
    __swig_destroy__ = _Bnd.delete_Bnd_Tools
Bnd_Tools_swigregister = _Bnd.Bnd_Tools_swigregister
Bnd_Tools_swigregister(Bnd_Tools)

def Bnd_Tools_Bnd2BVH(*args) -> "BVH_Box< Standard_Real,3 >":
    """
    * @name Bnd_Box to BVH_Box conversion Converts the given Bnd_Box2d to BVH_Box
    	:param theBox:
    	:type theBox: Bnd_Box2d
    	:rtype: BVH_Box<float, 2>
    * Converts the given Bnd_Box to BVH_Box
    	:param theBox:
    	:type theBox: Bnd_Box
    	:rtype: BVH_Box<float, 3>
    """
    return _Bnd.Bnd_Tools_Bnd2BVH(*args)

class Bnd_HArray1OfBox(Bnd_Array1OfBox, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Bnd.Bnd_HArray1OfBox_swiginit(self, _Bnd.new_Bnd_HArray1OfBox(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Bnd_HArray1OfBox_DownCast(t)

    __swig_destroy__ = _Bnd.delete_Bnd_HArray1OfBox
Bnd_HArray1OfBox.Array1 = new_instancemethod(_Bnd.Bnd_HArray1OfBox_Array1, None, Bnd_HArray1OfBox)
Bnd_HArray1OfBox.ChangeArray1 = new_instancemethod(_Bnd.Bnd_HArray1OfBox_ChangeArray1, None, Bnd_HArray1OfBox)
Bnd_HArray1OfBox_swigregister = _Bnd.Bnd_HArray1OfBox_swigregister
Bnd_HArray1OfBox_swigregister(Bnd_HArray1OfBox)

class Bnd_HArray1OfSphere(Bnd_Array1OfSphere, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Bnd.Bnd_HArray1OfSphere_swiginit(self, _Bnd.new_Bnd_HArray1OfSphere(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Bnd_HArray1OfSphere_DownCast(t)

    __swig_destroy__ = _Bnd.delete_Bnd_HArray1OfSphere
Bnd_HArray1OfSphere.Array1 = new_instancemethod(_Bnd.Bnd_HArray1OfSphere_Array1, None, Bnd_HArray1OfSphere)
Bnd_HArray1OfSphere.ChangeArray1 = new_instancemethod(_Bnd.Bnd_HArray1OfSphere_ChangeArray1, None, Bnd_HArray1OfSphere)
Bnd_HArray1OfSphere_swigregister = _Bnd.Bnd_HArray1OfSphere_swigregister
Bnd_HArray1OfSphere_swigregister(Bnd_HArray1OfSphere)

class Bnd_HArray1OfBox2d(Bnd_Array1OfBox2d, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Bnd.Bnd_HArray1OfBox2d_swiginit(self, _Bnd.new_Bnd_HArray1OfBox2d(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Bnd_HArray1OfBox2d_DownCast(t)

    __swig_destroy__ = _Bnd.delete_Bnd_HArray1OfBox2d
Bnd_HArray1OfBox2d.Array1 = new_instancemethod(_Bnd.Bnd_HArray1OfBox2d_Array1, None, Bnd_HArray1OfBox2d)
Bnd_HArray1OfBox2d.ChangeArray1 = new_instancemethod(_Bnd.Bnd_HArray1OfBox2d_ChangeArray1, None, Bnd_HArray1OfBox2d)
Bnd_HArray1OfBox2d_swigregister = _Bnd.Bnd_HArray1OfBox2d_swigregister
Bnd_HArray1OfBox2d_swigregister(Bnd_HArray1OfBox2d)



