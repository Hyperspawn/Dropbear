# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
CDF module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_cdf.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _CDF.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_CDF')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_CDF')
    _CDF = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_CDF', [dirname(__file__)])
        except ImportError:
            import _CDF
            return _CDF
        try:
            _mod = imp.load_module('_CDF', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _CDF = swig_import_helper()
    del swig_import_helper
else:
    import _CDF
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CDF.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_CDF.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_CDF.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_CDF.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_CDF.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_CDF.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_CDF.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_CDF.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_CDF.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_CDF.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_CDF.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_CDF.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_CDF.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_CDF.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_CDF.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_CDF.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_CDF.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _CDF.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _CDF.process_exception(error, method_name, class_name)
process_exception = _CDF.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.CDM
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.Resource
import OCC.Core.PCDM
import OCC.Core.Storage
CDF_TOA_New = _CDF.CDF_TOA_New
CDF_TOA_Modified = _CDF.CDF_TOA_Modified
CDF_TOA_Unchanged = _CDF.CDF_TOA_Unchanged
CDF_TS_OK = _CDF.CDF_TS_OK
CDF_TS_NoCurrentDocument = _CDF.CDF_TS_NoCurrentDocument
CDF_TS_NoDriver = _CDF.CDF_TS_NoDriver
CDF_TS_NoSubComponentDriver = _CDF.CDF_TS_NoSubComponentDriver
CDF_SCS_Consistent = _CDF.CDF_SCS_Consistent
CDF_SCS_Unconsistent = _CDF.CDF_SCS_Unconsistent
CDF_SCS_Stored = _CDF.CDF_SCS_Stored
CDF_SCS_Modified = _CDF.CDF_SCS_Modified
CDF_SSNS_OK = _CDF.CDF_SSNS_OK
CDF_SSNS_ReplacingAnExistentDocument = _CDF.CDF_SSNS_ReplacingAnExistentDocument
CDF_SSNS_OpenDocument = _CDF.CDF_SSNS_OpenDocument

def Handle_CDF_Application_Create() -> "opencascade::handle< CDF_Application >":
    return _CDF.Handle_CDF_Application_Create()
Handle_CDF_Application_Create = _CDF.Handle_CDF_Application_Create

def Handle_CDF_Application_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_Application >":
    return _CDF.Handle_CDF_Application_DownCast(t)
Handle_CDF_Application_DownCast = _CDF.Handle_CDF_Application_DownCast

def Handle_CDF_Application_IsNull(t: 'opencascade::handle< CDF_Application > const &') -> "bool":
    return _CDF.Handle_CDF_Application_IsNull(t)
Handle_CDF_Application_IsNull = _CDF.Handle_CDF_Application_IsNull

def Handle_CDF_Directory_Create() -> "opencascade::handle< CDF_Directory >":
    return _CDF.Handle_CDF_Directory_Create()
Handle_CDF_Directory_Create = _CDF.Handle_CDF_Directory_Create

def Handle_CDF_Directory_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_Directory >":
    return _CDF.Handle_CDF_Directory_DownCast(t)
Handle_CDF_Directory_DownCast = _CDF.Handle_CDF_Directory_DownCast

def Handle_CDF_Directory_IsNull(t: 'opencascade::handle< CDF_Directory > const &') -> "bool":
    return _CDF.Handle_CDF_Directory_IsNull(t)
Handle_CDF_Directory_IsNull = _CDF.Handle_CDF_Directory_IsNull

def Handle_CDF_MetaDataDriver_Create() -> "opencascade::handle< CDF_MetaDataDriver >":
    return _CDF.Handle_CDF_MetaDataDriver_Create()
Handle_CDF_MetaDataDriver_Create = _CDF.Handle_CDF_MetaDataDriver_Create

def Handle_CDF_MetaDataDriver_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_MetaDataDriver >":
    return _CDF.Handle_CDF_MetaDataDriver_DownCast(t)
Handle_CDF_MetaDataDriver_DownCast = _CDF.Handle_CDF_MetaDataDriver_DownCast

def Handle_CDF_MetaDataDriver_IsNull(t: 'opencascade::handle< CDF_MetaDataDriver > const &') -> "bool":
    return _CDF.Handle_CDF_MetaDataDriver_IsNull(t)
Handle_CDF_MetaDataDriver_IsNull = _CDF.Handle_CDF_MetaDataDriver_IsNull

def Handle_CDF_MetaDataDriverFactory_Create() -> "opencascade::handle< CDF_MetaDataDriverFactory >":
    return _CDF.Handle_CDF_MetaDataDriverFactory_Create()
Handle_CDF_MetaDataDriverFactory_Create = _CDF.Handle_CDF_MetaDataDriverFactory_Create

def Handle_CDF_MetaDataDriverFactory_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_MetaDataDriverFactory >":
    return _CDF.Handle_CDF_MetaDataDriverFactory_DownCast(t)
Handle_CDF_MetaDataDriverFactory_DownCast = _CDF.Handle_CDF_MetaDataDriverFactory_DownCast

def Handle_CDF_MetaDataDriverFactory_IsNull(t: 'opencascade::handle< CDF_MetaDataDriverFactory > const &') -> "bool":
    return _CDF.Handle_CDF_MetaDataDriverFactory_IsNull(t)
Handle_CDF_MetaDataDriverFactory_IsNull = _CDF.Handle_CDF_MetaDataDriverFactory_IsNull

def Handle_CDF_Session_Create() -> "opencascade::handle< CDF_Session >":
    return _CDF.Handle_CDF_Session_Create()
Handle_CDF_Session_Create = _CDF.Handle_CDF_Session_Create

def Handle_CDF_Session_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_Session >":
    return _CDF.Handle_CDF_Session_DownCast(t)
Handle_CDF_Session_DownCast = _CDF.Handle_CDF_Session_DownCast

def Handle_CDF_Session_IsNull(t: 'opencascade::handle< CDF_Session > const &') -> "bool":
    return _CDF.Handle_CDF_Session_IsNull(t)
Handle_CDF_Session_IsNull = _CDF.Handle_CDF_Session_IsNull

def Handle_CDF_StoreList_Create() -> "opencascade::handle< CDF_StoreList >":
    return _CDF.Handle_CDF_StoreList_Create()
Handle_CDF_StoreList_Create = _CDF.Handle_CDF_StoreList_Create

def Handle_CDF_StoreList_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_StoreList >":
    return _CDF.Handle_CDF_StoreList_DownCast(t)
Handle_CDF_StoreList_DownCast = _CDF.Handle_CDF_StoreList_DownCast

def Handle_CDF_StoreList_IsNull(t: 'opencascade::handle< CDF_StoreList > const &') -> "bool":
    return _CDF.Handle_CDF_StoreList_IsNull(t)
Handle_CDF_StoreList_IsNull = _CDF.Handle_CDF_StoreList_IsNull

def Handle_CDF_FWOSDriver_Create() -> "opencascade::handle< CDF_FWOSDriver >":
    return _CDF.Handle_CDF_FWOSDriver_Create()
Handle_CDF_FWOSDriver_Create = _CDF.Handle_CDF_FWOSDriver_Create

def Handle_CDF_FWOSDriver_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_FWOSDriver >":
    return _CDF.Handle_CDF_FWOSDriver_DownCast(t)
Handle_CDF_FWOSDriver_DownCast = _CDF.Handle_CDF_FWOSDriver_DownCast

def Handle_CDF_FWOSDriver_IsNull(t: 'opencascade::handle< CDF_FWOSDriver > const &') -> "bool":
    return _CDF.Handle_CDF_FWOSDriver_IsNull(t)
Handle_CDF_FWOSDriver_IsNull = _CDF.Handle_CDF_FWOSDriver_IsNull
class cdf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetLicense(*args) -> "void":
        """
        :param anApplicationIdentifier:
        	:type anApplicationIdentifier: int
        	:rtype: void
        """
        return _CDF.cdf_GetLicense(*args)

    GetLicense = staticmethod(GetLicense)

    def IsAvailable(*args) -> "Standard_Boolean":
        """
        :param anApplicationIdentifier:
        	:type anApplicationIdentifier: int
        	:rtype: bool
        """
        return _CDF.cdf_IsAvailable(*args)

    IsAvailable = staticmethod(IsAvailable)

    __repr__ = _dumps_object


    def __init__(self):
        _CDF.cdf_swiginit(self, _CDF.new_cdf())
    __swig_destroy__ = _CDF.delete_cdf
cdf_swigregister = _CDF.cdf_swigregister
cdf_swigregister(cdf)

def cdf_GetLicense(*args) -> "void":
    """
    :param anApplicationIdentifier:
    	:type anApplicationIdentifier: int
    	:rtype: void
    """
    return _CDF.cdf_GetLicense(*args)

def cdf_IsAvailable(*args) -> "Standard_Boolean":
    """
    :param anApplicationIdentifier:
    	:type anApplicationIdentifier: int
    	:rtype: bool
    """
    return _CDF.cdf_IsAvailable(*args)

class CDF_Application(OCC.Core.CDM.CDM_Application):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CanClose(self, *args) -> "CDM_CanCloseStatus":
        """
        :param aDocument:
        	:type aDocument: CDM_Document
        	:rtype: CDM_CanCloseStatus
        """
        return _CDF.CDF_Application_CanClose(self, *args)


    def CanRetrieve(self, *args) -> "PCDM_ReaderStatus":
        """
        :param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:rtype: PCDM_ReaderStatus
        :param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:param aVersion:
        	:type aVersion: TCollection_ExtendedString
        	:rtype: PCDM_ReaderStatus
        """
        return _CDF.CDF_Application_CanRetrieve(self, *args)


    def Close(self, *args) -> "void":
        """
        * removes the document of the current session directory and closes the document;
        	:param aDocument:
        	:type aDocument: CDM_Document
        	:rtype: None
        """
        return _CDF.CDF_Application_Close(self, *args)


    def DefaultFolder(self, *args) -> "Standard_ExtString":
        """:rtype: Standard_ExtString"""
        return _CDF.CDF_Application_DefaultFolder(self, *args)


    def Format(self, *args) -> "Standard_Boolean":
        """
        * try to retrieve a Format directly in the file or in application resource by using extension. returns True if found;
        	:param aFileName:
        	:type aFileName: TCollection_ExtendedString
        	:param theFormat:
        	:type theFormat: TCollection_ExtendedString
        	:rtype: bool
        """
        return _CDF.CDF_Application_Format(self, *args)


    def GetRetrieveStatus(self, *args) -> "PCDM_ReaderStatus":
        """
        * Checks status after Retrieve
        	:rtype: PCDM_ReaderStatus
        """
        return _CDF.CDF_Application_GetRetrieveStatus(self, *args)


    def Load(*args) -> "opencascade::handle< CDF_Application >":
        """
        * plugs an application. //! Open is used - for opening a Document that has been created in an application - for opening a Document from the database - for opening a Document from a file. The Open methods always add the document in the session directory and calls the virtual Activate method. The document is considered to be opened until Close is used. To be storable, a document must be opened by an application since the application resources are needed to store it.
        	:param aGUID:
        	:type aGUID: Standard_GUID
        	:rtype: opencascade::handle<CDF_Application>
        """
        return _CDF.CDF_Application_Load(*args)

    Load = staticmethod(Load)

    def Open(self, *args) -> "void":
        """
        * puts the document in the current session directory and calls the virtual method Activate on it.
        	:param aDocument:
        	:type aDocument: CDM_Document
        	:rtype: None
        """
        return _CDF.CDF_Application_Open(self, *args)


    def ReadFromString(self, src: 'std::string') -> "void":
        """ReadFromString(CDF_Application self, std::string src)"""
        return _CDF.CDF_Application_ReadFromString(self, src)


    def ReaderFromFormat(self, *args) -> "opencascade::handle< PCDM_Reader >":
        """
        * Returns instance of read driver for specified format. //! Default implementation uses plugin mechanism to load reader dynamically. For this to work, application resources should define GUID of the plugin as value of [Format].RetrievalPlugin, and 'Plugin' resource should define name of plugin library to be loaded as value of [GUID].Location. Plugin library should provide method PLUGINFACTORY returning instance of the reader for the same GUID (see Plugin_Macro.hxx). //! In case if reader is not available, will raise Standard_NoSuchObject or other exception if raised by plugin loader.
        	:param aFormat:
        	:type aFormat: TCollection_ExtendedString
        	:rtype: opencascade::handle<PCDM_Reader>
        """
        return _CDF.CDF_Application_ReaderFromFormat(self, *args)


    def Retrieve(self, *args) -> "opencascade::handle< CDM_Document >":
        """
        * This method retrieves a document from the database. If the Document references other documents which have been updated, the latest version of these documents will be used if {UseStorageConfiguration} is Standard_True. The content of {aFolder}, {aName} and {aVersion} depends on the Database Manager system. If the DBMS is only based on the OS, {aFolder} is a directory and {aName} is the name of a file. In this case the use of the syntax with {aVersion} has no sense. For example: //! opencascade::handle<CDM_Document> theDocument=myApplication->Retrieve('/home/cascade','box.dsg'); If the DBMS is EUCLID/Design Manager, {aFolder}, {aName} have the form they have in EUCLID/Design Manager. For example: //! opencascade::handle<CDM_Document> theDocument=myApplication->Retrieve('|user|cascade','box'); //! Since the version is not specified in this syntax, the latest wil be used. A link is kept with the database through an instance of CDM_MetaData
        	:param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:param UseStorageConfiguration: default value is Standard_True
        	:type UseStorageConfiguration: bool
        	:rtype: opencascade::handle<CDM_Document>
        * This method retrieves a document from the database. If the Document references other documents which have been updated, the latest version of these documents will be used if {UseStorageConfiguration} is Standard_True. -- If the DBMS is only based on the OS, this syntax should not be used. //! If the DBMS is EUCLID/Design Manager, {aFolder}, {aName} and {aVersion} have the form they have in EUCLID/Design Manager. For example: //! opencascade::handle<CDM_Document> theDocument=myApplication->Retrieve('|user|cascade','box','2'); A link is kept with the database through an instance of CDM_MetaData
        	:param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:param aVersion:
        	:type aVersion: TCollection_ExtendedString
        	:param UseStorageConfiguration: default value is Standard_True
        	:type UseStorageConfiguration: bool
        	:rtype: opencascade::handle<CDM_Document>
        """
        return _CDF.CDF_Application_Retrieve(self, *args)


    def SetDefaultFolder(self, *args) -> "Standard_Boolean":
        """
        :param aFolder:
        	:type aFolder: Standard_ExtString
        	:rtype: bool
        """
        return _CDF.CDF_Application_SetDefaultFolder(self, *args)


    def WriterFromFormat(self, *args) -> "opencascade::handle< PCDM_StorageDriver >":
        """
        * Returns instance of storage driver for specified format. //! Default implementation uses plugin mechanism to load driver dynamically. For this to work, application resources should define GUID of the plugin as value of [Format].StoragePlugin, and 'Plugin' resource should define name of plugin library to be loaded as value of [GUID].Location. Plugin library should provide method PLUGINFACTORY returning instance of the reader for the same GUID (see Plugin_Macro.hxx). //! In case if driver is not available, will raise Standard_NoSuchObject or other exception if raised by plugin loader.
        	:param aFormat:
        	:type aFormat: TCollection_ExtendedString
        	:rtype: opencascade::handle<PCDM_StorageDriver>
        """
        return _CDF.CDF_Application_WriterFromFormat(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_Application_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_Application
CDF_Application.CanClose = new_instancemethod(_CDF.CDF_Application_CanClose, None, CDF_Application)
CDF_Application.CanRetrieve = new_instancemethod(_CDF.CDF_Application_CanRetrieve, None, CDF_Application)
CDF_Application.Close = new_instancemethod(_CDF.CDF_Application_Close, None, CDF_Application)
CDF_Application.DefaultFolder = new_instancemethod(_CDF.CDF_Application_DefaultFolder, None, CDF_Application)
CDF_Application.Format = new_instancemethod(_CDF.CDF_Application_Format, None, CDF_Application)
CDF_Application.GetRetrieveStatus = new_instancemethod(_CDF.CDF_Application_GetRetrieveStatus, None, CDF_Application)
CDF_Application.Open = new_instancemethod(_CDF.CDF_Application_Open, None, CDF_Application)
CDF_Application.ReadFromString = new_instancemethod(_CDF.CDF_Application_ReadFromString, None, CDF_Application)
CDF_Application.ReaderFromFormat = new_instancemethod(_CDF.CDF_Application_ReaderFromFormat, None, CDF_Application)
CDF_Application.Retrieve = new_instancemethod(_CDF.CDF_Application_Retrieve, None, CDF_Application)
CDF_Application.SetDefaultFolder = new_instancemethod(_CDF.CDF_Application_SetDefaultFolder, None, CDF_Application)
CDF_Application.WriterFromFormat = new_instancemethod(_CDF.CDF_Application_WriterFromFormat, None, CDF_Application)
CDF_Application_swigregister = _CDF.CDF_Application_swigregister
CDF_Application_swigregister(CDF_Application)

def CDF_Application_Load(*args) -> "opencascade::handle< CDF_Application >":
    """
    * plugs an application. //! Open is used - for opening a Document that has been created in an application - for opening a Document from the database - for opening a Document from a file. The Open methods always add the document in the session directory and calls the virtual Activate method. The document is considered to be opened until Close is used. To be storable, a document must be opened by an application since the application resources are needed to store it.
    	:param aGUID:
    	:type aGUID: Standard_GUID
    	:rtype: opencascade::handle<CDF_Application>
    """
    return _CDF.CDF_Application_Load(*args)

class CDF_Directory(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * adds a document into the directory.
        	:param aDocument:
        	:type aDocument: CDM_Document
        	:rtype: None
        """
        return _CDF.CDF_Directory_Add(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty directory.
        	:rtype: None
        """
        _CDF.CDF_Directory_swiginit(self, _CDF.new_CDF_Directory(*args))

    def Contains(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the document aDocument is in the directory
        	:param aDocument:
        	:type aDocument: CDM_Document
        	:rtype: bool
        """
        return _CDF.CDF_Directory_Contains(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * returns true if the directory is empty.
        	:rtype: bool
        """
        return _CDF.CDF_Directory_IsEmpty(self, *args)


    def Last(self, *args) -> "opencascade::handle< CDM_Document >":
        """
        * returns the last document (if any) which has been added in the directory.
        	:rtype: opencascade::handle<CDM_Document>
        """
        return _CDF.CDF_Directory_Last(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        * returns the number of documents of the directory.
        	:rtype: int
        """
        return _CDF.CDF_Directory_Length(self, *args)


    def Remove(self, *args) -> "void":
        """
        * removes the document.
        	:param aDocument:
        	:type aDocument: CDM_Document
        	:rtype: None
        """
        return _CDF.CDF_Directory_Remove(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_Directory_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_Directory
CDF_Directory.Add = new_instancemethod(_CDF.CDF_Directory_Add, None, CDF_Directory)
CDF_Directory.Contains = new_instancemethod(_CDF.CDF_Directory_Contains, None, CDF_Directory)
CDF_Directory.IsEmpty = new_instancemethod(_CDF.CDF_Directory_IsEmpty, None, CDF_Directory)
CDF_Directory.Last = new_instancemethod(_CDF.CDF_Directory_Last, None, CDF_Directory)
CDF_Directory.Length = new_instancemethod(_CDF.CDF_Directory_Length, None, CDF_Directory)
CDF_Directory.Remove = new_instancemethod(_CDF.CDF_Directory_Remove, None, CDF_Directory)
CDF_Directory_swigregister = _CDF.CDF_Directory_swigregister
CDF_Directory_swigregister(CDF_Directory)

class CDF_DirectoryIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * creates an Iterator with the directory of the current CDF.
        	:rtype: None
        :param aDirectory:
        	:type aDirectory: CDF_Directory
        	:rtype: None
        """
        _CDF.CDF_DirectoryIterator_swiginit(self, _CDF.new_CDF_DirectoryIterator(*args))

    def Document(self, *args) -> "opencascade::handle< CDM_Document >":
        """
        * Returns item value of current entry
        	:rtype: opencascade::handle<CDM_Document>
        """
        return _CDF.CDF_DirectoryIterator_Document(self, *args)


    def MoreDocument(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there are more entries to return
        	:rtype: bool
        """
        return _CDF.CDF_DirectoryIterator_MoreDocument(self, *args)


    def NextDocument(self, *args) -> "void":
        """
        * Go to the next entry (if there is not, Value will raise an exception)
        	:rtype: None
        """
        return _CDF.CDF_DirectoryIterator_NextDocument(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_DirectoryIterator
CDF_DirectoryIterator.Document = new_instancemethod(_CDF.CDF_DirectoryIterator_Document, None, CDF_DirectoryIterator)
CDF_DirectoryIterator.MoreDocument = new_instancemethod(_CDF.CDF_DirectoryIterator_MoreDocument, None, CDF_DirectoryIterator)
CDF_DirectoryIterator.NextDocument = new_instancemethod(_CDF.CDF_DirectoryIterator_NextDocument, None, CDF_DirectoryIterator)
CDF_DirectoryIterator_swigregister = _CDF.CDF_DirectoryIterator_swigregister
CDF_DirectoryIterator_swigregister(CDF_DirectoryIterator)

class CDF_MetaDataDriver(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BuildFileName(self, *args) -> "TCollection_ExtendedString":
        """
        :param aDocument:
        	:type aDocument: CDM_Document
        	:rtype: TCollection_ExtendedString
        """
        return _CDF.CDF_MetaDataDriver_BuildFileName(self, *args)


    def CreateDependsOn(self, *args) -> "void":
        """
        * Creates a 'Depends On' relation between two Datas. By default does nothing
        	:param aFirstData:
        	:type aFirstData: CDM_MetaData
        	:param aSecondData:
        	:type aSecondData: CDM_MetaData
        	:rtype: void
        """
        return _CDF.CDF_MetaDataDriver_CreateDependsOn(self, *args)


    def CreateMetaData(self, *args) -> "opencascade::handle< CDM_MetaData >":
        """
        * should create meta-data corresponding to aData and maintaining a meta-link between these meta-data and aFileName CreateMetaData is called by CreateData If the metadata-driver has version capabilities, version must be set in the returned Data.
        	:param aDocument:
        	:type aDocument: CDM_Document
        	:param aFileName:
        	:type aFileName: TCollection_ExtendedString
        	:rtype: opencascade::handle<CDM_MetaData>
        """
        return _CDF.CDF_MetaDataDriver_CreateMetaData(self, *args)


    def CreateReference(self, *args) -> "void":
        """
        :param aFrom:
        	:type aFrom: CDM_MetaData
        	:param aTo:
        	:type aTo: CDM_MetaData
        	:param aReferenceIdentifier:
        	:type aReferenceIdentifier: int
        	:param aToDocumentVersion:
        	:type aToDocumentVersion: int
        	:rtype: void
        """
        return _CDF.CDF_MetaDataDriver_CreateReference(self, *args)


    def DefaultFolder(self, *args) -> "TCollection_ExtendedString":
        """:rtype: TCollection_ExtendedString"""
        return _CDF.CDF_MetaDataDriver_DefaultFolder(self, *args)


    def Find(self, *args) -> "Standard_Boolean":
        """
        * should indicate whether meta-data exist in the DBMS corresponding to the Data. aVersion may be NULL;
        	:param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:param aVersion:
        	:type aVersion: TCollection_ExtendedString
        	:rtype: bool
        * calls Find with an empty version
        	:param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:rtype: bool
        """
        return _CDF.CDF_MetaDataDriver_Find(self, *args)


    def FindFolder(self, *args) -> "Standard_Boolean":
        """
        :param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:rtype: bool
        """
        return _CDF.CDF_MetaDataDriver_FindFolder(self, *args)


    def HasReadPermission(self, *args) -> "Standard_Boolean":
        """
        :param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:param aVersion:
        	:type aVersion: TCollection_ExtendedString
        	:rtype: bool
        """
        return _CDF.CDF_MetaDataDriver_HasReadPermission(self, *args)


    def HasVersion(self, *args) -> "Standard_Boolean":
        """
        * by default return Standard_True.
        	:param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:rtype: bool
        """
        return _CDF.CDF_MetaDataDriver_HasVersion(self, *args)


    def HasVersionCapability(self, *args) -> "Standard_Boolean":
        """
        * returns true if the MetaDataDriver can manage different versions of a Data. By default, returns Standard_False.
        	:rtype: bool
        """
        return _CDF.CDF_MetaDataDriver_HasVersionCapability(self, *args)


    def LastVersion(self, *args) -> "opencascade::handle< CDM_MetaData >":
        """
        * by default returns aMetaDATA should return the MetaData stored in the DBMS with the meta-data corresponding to the path. If the MetaDataDriver has version management capabilities the version has to be set in the returned MetaData. MetaData is called by GetMetaData If the version is not included in the path , MetaData should return the last version of the metadata is deferred;
        	:param aMetaData:
        	:type aMetaData: CDM_MetaData
        	:rtype: opencascade::handle<CDM_MetaData>
        """
        return _CDF.CDF_MetaDataDriver_LastVersion(self, *args)


    def MetaData(self, *args) -> "opencascade::handle< CDM_MetaData >":
        """
        * should return the MetaData stored in the DBMS with the meta-data corresponding to the Data. If the MetaDataDriver has version management capabilities the version has to be set in the returned MetaData. aVersion may be NULL MetaData is called by GetMetaData If the version is set to NULL, MetaData should return the last version of the metadata
        	:param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:param aVersion:
        	:type aVersion: TCollection_ExtendedString
        	:rtype: opencascade::handle<CDM_MetaData>
        * calls MetaData with an empty version
        	:param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:rtype: opencascade::handle<CDM_MetaData>
        """
        return _CDF.CDF_MetaDataDriver_MetaData(self, *args)


    def ReferenceIterator(self, *args) -> "opencascade::handle< PCDM_ReferenceIterator >":
        """:rtype: opencascade::handle<PCDM_ReferenceIterator>"""
        return _CDF.CDF_MetaDataDriver_ReferenceIterator(self, *args)


    def SetName(self, *args) -> "TCollection_ExtendedString":
        """
        * this methods is usefull if the name of an object -- depends on the metadatadriver. For example a Driver -- based on the operating system can choose to add the extension of file to create to the object.
        	:param aDocument:
        	:type aDocument: CDM_Document
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:rtype: TCollection_ExtendedString
        """
        return _CDF.CDF_MetaDataDriver_SetName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_MetaDataDriver_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_MetaDataDriver
CDF_MetaDataDriver.BuildFileName = new_instancemethod(_CDF.CDF_MetaDataDriver_BuildFileName, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.CreateDependsOn = new_instancemethod(_CDF.CDF_MetaDataDriver_CreateDependsOn, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.CreateMetaData = new_instancemethod(_CDF.CDF_MetaDataDriver_CreateMetaData, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.CreateReference = new_instancemethod(_CDF.CDF_MetaDataDriver_CreateReference, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.DefaultFolder = new_instancemethod(_CDF.CDF_MetaDataDriver_DefaultFolder, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.Find = new_instancemethod(_CDF.CDF_MetaDataDriver_Find, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.FindFolder = new_instancemethod(_CDF.CDF_MetaDataDriver_FindFolder, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.HasReadPermission = new_instancemethod(_CDF.CDF_MetaDataDriver_HasReadPermission, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.HasVersion = new_instancemethod(_CDF.CDF_MetaDataDriver_HasVersion, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.HasVersionCapability = new_instancemethod(_CDF.CDF_MetaDataDriver_HasVersionCapability, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.LastVersion = new_instancemethod(_CDF.CDF_MetaDataDriver_LastVersion, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.MetaData = new_instancemethod(_CDF.CDF_MetaDataDriver_MetaData, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.ReferenceIterator = new_instancemethod(_CDF.CDF_MetaDataDriver_ReferenceIterator, None, CDF_MetaDataDriver)
CDF_MetaDataDriver.SetName = new_instancemethod(_CDF.CDF_MetaDataDriver_SetName, None, CDF_MetaDataDriver)
CDF_MetaDataDriver_swigregister = _CDF.CDF_MetaDataDriver_swigregister
CDF_MetaDataDriver_swigregister(CDF_MetaDataDriver)

class CDF_MetaDataDriverFactory(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Build(self, *args) -> "opencascade::handle< CDF_MetaDataDriver >":
        """:rtype: opencascade::handle<CDF_MetaDataDriver>"""
        return _CDF.CDF_MetaDataDriverFactory_Build(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_MetaDataDriverFactory_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_MetaDataDriverFactory
CDF_MetaDataDriverFactory.Build = new_instancemethod(_CDF.CDF_MetaDataDriverFactory_Build, None, CDF_MetaDataDriverFactory)
CDF_MetaDataDriverFactory_swigregister = _CDF.CDF_MetaDataDriverFactory_swigregister
CDF_MetaDataDriverFactory_swigregister(CDF_MetaDataDriverFactory)

class CDF_Session(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _CDF.CDF_Session_swiginit(self, _CDF.new_CDF_Session(*args))

    def CurrentApplication(self, *args) -> "opencascade::handle< CDF_Application >":
        """:rtype: opencascade::handle<CDF_Application>"""
        return _CDF.CDF_Session_CurrentApplication(self, *args)


    def CurrentSession(*args) -> "opencascade::handle< CDF_Session >":
        """
        * returns the only one instance of Session that has been created.
        	:rtype: opencascade::handle<CDF_Session>
        """
        return _CDF.CDF_Session_CurrentSession(*args)

    CurrentSession = staticmethod(CurrentSession)

    def Directory(self, *args) -> "opencascade::handle< CDF_Directory >":
        """
        * returns the directory of the session;
        	:rtype: opencascade::handle<CDF_Directory>
        """
        return _CDF.CDF_Session_Directory(self, *args)


    def Exists(*args) -> "Standard_Boolean":
        """
        * returns true if a session has been created.
        	:rtype: bool
        """
        return _CDF.CDF_Session_Exists(*args)

    Exists = staticmethod(Exists)

    def HasCurrentApplication(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _CDF.CDF_Session_HasCurrentApplication(self, *args)


    def LoadDriver(self, *args) -> "void":
        """:rtype: None"""
        return _CDF.CDF_Session_LoadDriver(self, *args)


    def MetaDataDriver(self, *args) -> "opencascade::handle< CDF_MetaDataDriver >":
        """:rtype: opencascade::handle<CDF_MetaDataDriver>"""
        return _CDF.CDF_Session_MetaDataDriver(self, *args)


    def SetCurrentApplication(self, *args) -> "void":
        """
        :param anApplication:
        	:type anApplication: CDF_Application
        	:rtype: None
        """
        return _CDF.CDF_Session_SetCurrentApplication(self, *args)


    def UnsetCurrentApplication(self, *args) -> "void":
        """:rtype: None"""
        return _CDF.CDF_Session_UnsetCurrentApplication(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_Session_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_Session
CDF_Session.CurrentApplication = new_instancemethod(_CDF.CDF_Session_CurrentApplication, None, CDF_Session)
CDF_Session.Directory = new_instancemethod(_CDF.CDF_Session_Directory, None, CDF_Session)
CDF_Session.HasCurrentApplication = new_instancemethod(_CDF.CDF_Session_HasCurrentApplication, None, CDF_Session)
CDF_Session.LoadDriver = new_instancemethod(_CDF.CDF_Session_LoadDriver, None, CDF_Session)
CDF_Session.MetaDataDriver = new_instancemethod(_CDF.CDF_Session_MetaDataDriver, None, CDF_Session)
CDF_Session.SetCurrentApplication = new_instancemethod(_CDF.CDF_Session_SetCurrentApplication, None, CDF_Session)
CDF_Session.UnsetCurrentApplication = new_instancemethod(_CDF.CDF_Session_UnsetCurrentApplication, None, CDF_Session)
CDF_Session_swigregister = _CDF.CDF_Session_swigregister
CDF_Session_swigregister(CDF_Session)

def CDF_Session_CurrentSession(*args) -> "opencascade::handle< CDF_Session >":
    """
    * returns the only one instance of Session that has been created.
    	:rtype: opencascade::handle<CDF_Session>
    """
    return _CDF.CDF_Session_CurrentSession(*args)

def CDF_Session_Exists(*args) -> "Standard_Boolean":
    """
    * returns true if a session has been created.
    	:rtype: bool
    """
    return _CDF.CDF_Session_Exists(*args)

class CDF_Store(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AssociatedStatusText(self, *args) -> "Standard_ExtString":
        """:rtype: Standard_ExtString"""
        return _CDF.CDF_Store_AssociatedStatusText(self, *args)


    def __init__(self, *args):
        """
        * creates a store list from the document of the current selection.
        	:param aDocument:
        	:type aDocument: CDM_Document
        	:rtype: None
        """
        _CDF.CDF_Store_swiginit(self, _CDF.new_CDF_Store(*args))

    def Comment(self, *args) -> "Standard_ExtString":
        """:rtype: Standard_ExtString"""
        return _CDF.CDF_Store_Comment(self, *args)


    def Component(self, *args) -> "Standard_ExtString":
        """
        * Returns item value of current entry
        	:rtype: Standard_ExtString
        """
        return _CDF.CDF_Store_Component(self, *args)


    def CurrentIsConsistent(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _CDF.CDF_Store_CurrentIsConsistent(self, *args)


    def Description(self, *args) -> "Standard_ExtString":
        """
        * returns the description of the format of the main object.
        	:rtype: Standard_ExtString
        """
        return _CDF.CDF_Store_Description(self, *args)


    def Folder(self, *args) -> "Standard_ExtString":
        """
        * returns the folder in which the current document will be stored.
        	:rtype: Standard_ExtString
        """
        return _CDF.CDF_Store_Folder(self, *args)


    def HasAPreviousVersion(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _CDF.CDF_Store_HasAPreviousVersion(self, *args)


    def HasSubComponents(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _CDF.CDF_Store_HasSubComponents(self, *args)


    def InitComponent(self, *args) -> "void":
        """
        * Allows to Start a new Iteration from beginning
        	:rtype: None
        """
        return _CDF.CDF_Store_InitComponent(self, *args)


    def IsConsistent(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _CDF.CDF_Store_IsConsistent(self, *args)


    def IsMainDocument(self, *args) -> "Standard_Boolean":
        """
        * returns true if the currentdocument is the main one, ie the document of the current selection.
        	:rtype: bool
        """
        return _CDF.CDF_Store_IsMainDocument(self, *args)


    def IsModified(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _CDF.CDF_Store_IsModified(self, *args)


    def IsStored(self, *args) -> "Standard_Boolean":
        """
        * returns true if the current document is already stored
        	:rtype: bool
        """
        return _CDF.CDF_Store_IsStored(self, *args)


    def MetaDataPath(self, *args) -> "Standard_ExtString":
        """
        * returns the path of the previous store is the object is already stored, otherwise an empty string;
        	:rtype: Standard_ExtString
        """
        return _CDF.CDF_Store_MetaDataPath(self, *args)


    def MoreComponent(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there are more entries to return
        	:rtype: bool
        """
        return _CDF.CDF_Store_MoreComponent(self, *args)


    def Name(self, *args) -> "Standard_ExtString":
        """
        * returns the name under which the current document will be stored
        	:rtype: Standard_ExtString
        """
        return _CDF.CDF_Store_Name(self, *args)


    def NextComponent(self, *args) -> "void":
        """
        * Go to the next entry (if there is not, Value will raise an exception)
        	:rtype: None
        """
        return _CDF.CDF_Store_NextComponent(self, *args)


    def Path(self, *args) -> "Standard_ExtString":
        """
        * returns the complete path of the created meta-data.
        	:rtype: Standard_ExtString
        """
        return _CDF.CDF_Store_Path(self, *args)


    def PreviousVersion(self, *args) -> "Standard_ExtString":
        """:rtype: Standard_ExtString"""
        return _CDF.CDF_Store_PreviousVersion(self, *args)


    def Realize(self, *args) -> "void":
        """:rtype: None"""
        return _CDF.CDF_Store_Realize(self, *args)


    def RecheckName(self, *args) -> "CDF_StoreSetNameStatus":
        """
        * defines the name under which the document should be stored. uses for example after modification of the folder.
        	:rtype: CDF_StoreSetNameStatus
        """
        return _CDF.CDF_Store_RecheckName(self, *args)


    def SetComment(self, *args) -> "void":
        """
        :param aComment:
        	:type aComment: Standard_ExtString
        	:rtype: None
        """
        return _CDF.CDF_Store_SetComment(self, *args)


    def SetCurrent(self, *args) -> "void":
        """
        :rtype: None
        :param aPresentation:
        	:type aPresentation: Standard_ExtString
        	:rtype: None
        """
        return _CDF.CDF_Store_SetCurrent(self, *args)


    def SetFolder(self, *args) -> "Standard_Boolean":
        """
        * defines the folder in which the document should be stored. returns Standard_True if the Folder exists, Standard_False otherwise.
        	:param aFolder:
        	:type aFolder: TCollection_ExtendedString
        	:rtype: bool
        * defines the folder in which the document should be stored. returns Standard_True if the Folder exists, Standard_False otherwise.
        	:param aFolder:
        	:type aFolder: Standard_ExtString
        	:rtype: bool
        """
        return _CDF.CDF_Store_SetFolder(self, *args)


    def SetMain(self, *args) -> "void":
        """
        * the two following methods can be used just after Realize or Import -- method to know if thes methods worked correctly, and if not why.
        	:rtype: None
        """
        return _CDF.CDF_Store_SetMain(self, *args)


    def SetName(self, *args) -> "CDF_StoreSetNameStatus":
        """
        * defines the name under which the document should be stored.
        	:param aName:
        	:type aName: Standard_ExtString
        	:rtype: CDF_StoreSetNameStatus
        * defines the name under which the document should be stored.
        	:param aName:
        	:type aName: TCollection_ExtendedString
        	:rtype: CDF_StoreSetNameStatus
        """
        return _CDF.CDF_Store_SetName(self, *args)


    def SetPreviousVersion(self, *args) -> "Standard_Boolean":
        """
        :param aPreviousVersion:
        	:type aPreviousVersion: Standard_ExtString
        	:rtype: bool
        """
        return _CDF.CDF_Store_SetPreviousVersion(self, *args)


    def StoreStatus(self, *args) -> "PCDM_StoreStatus":
        """:rtype: PCDM_StoreStatus"""
        return _CDF.CDF_Store_StoreStatus(self, *args)


    def SubComponentStatus(self, *args) -> "CDF_SubComponentStatus":
        """
        :param aPresentation:
        	:type aPresentation: Standard_ExtString
        	:rtype: CDF_SubComponentStatus
        """
        return _CDF.CDF_Store_SubComponentStatus(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_Store
CDF_Store.AssociatedStatusText = new_instancemethod(_CDF.CDF_Store_AssociatedStatusText, None, CDF_Store)
CDF_Store.Comment = new_instancemethod(_CDF.CDF_Store_Comment, None, CDF_Store)
CDF_Store.Component = new_instancemethod(_CDF.CDF_Store_Component, None, CDF_Store)
CDF_Store.CurrentIsConsistent = new_instancemethod(_CDF.CDF_Store_CurrentIsConsistent, None, CDF_Store)
CDF_Store.Description = new_instancemethod(_CDF.CDF_Store_Description, None, CDF_Store)
CDF_Store.Folder = new_instancemethod(_CDF.CDF_Store_Folder, None, CDF_Store)
CDF_Store.HasAPreviousVersion = new_instancemethod(_CDF.CDF_Store_HasAPreviousVersion, None, CDF_Store)
CDF_Store.HasSubComponents = new_instancemethod(_CDF.CDF_Store_HasSubComponents, None, CDF_Store)
CDF_Store.InitComponent = new_instancemethod(_CDF.CDF_Store_InitComponent, None, CDF_Store)
CDF_Store.IsConsistent = new_instancemethod(_CDF.CDF_Store_IsConsistent, None, CDF_Store)
CDF_Store.IsMainDocument = new_instancemethod(_CDF.CDF_Store_IsMainDocument, None, CDF_Store)
CDF_Store.IsModified = new_instancemethod(_CDF.CDF_Store_IsModified, None, CDF_Store)
CDF_Store.IsStored = new_instancemethod(_CDF.CDF_Store_IsStored, None, CDF_Store)
CDF_Store.MetaDataPath = new_instancemethod(_CDF.CDF_Store_MetaDataPath, None, CDF_Store)
CDF_Store.MoreComponent = new_instancemethod(_CDF.CDF_Store_MoreComponent, None, CDF_Store)
CDF_Store.Name = new_instancemethod(_CDF.CDF_Store_Name, None, CDF_Store)
CDF_Store.NextComponent = new_instancemethod(_CDF.CDF_Store_NextComponent, None, CDF_Store)
CDF_Store.Path = new_instancemethod(_CDF.CDF_Store_Path, None, CDF_Store)
CDF_Store.PreviousVersion = new_instancemethod(_CDF.CDF_Store_PreviousVersion, None, CDF_Store)
CDF_Store.Realize = new_instancemethod(_CDF.CDF_Store_Realize, None, CDF_Store)
CDF_Store.RecheckName = new_instancemethod(_CDF.CDF_Store_RecheckName, None, CDF_Store)
CDF_Store.SetComment = new_instancemethod(_CDF.CDF_Store_SetComment, None, CDF_Store)
CDF_Store.SetCurrent = new_instancemethod(_CDF.CDF_Store_SetCurrent, None, CDF_Store)
CDF_Store.SetFolder = new_instancemethod(_CDF.CDF_Store_SetFolder, None, CDF_Store)
CDF_Store.SetMain = new_instancemethod(_CDF.CDF_Store_SetMain, None, CDF_Store)
CDF_Store.SetName = new_instancemethod(_CDF.CDF_Store_SetName, None, CDF_Store)
CDF_Store.SetPreviousVersion = new_instancemethod(_CDF.CDF_Store_SetPreviousVersion, None, CDF_Store)
CDF_Store.StoreStatus = new_instancemethod(_CDF.CDF_Store_StoreStatus, None, CDF_Store)
CDF_Store.SubComponentStatus = new_instancemethod(_CDF.CDF_Store_SubComponentStatus, None, CDF_Store)
CDF_Store_swigregister = _CDF.CDF_Store_swigregister
CDF_Store_swigregister(CDF_Store)

class CDF_StoreList(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param aDocument:
        	:type aDocument: CDM_Document
        	:rtype: None
        """
        _CDF.CDF_StoreList_swiginit(self, _CDF.new_CDF_StoreList(*args))

    def Init(self, *args) -> "void":
        """:rtype: None"""
        return _CDF.CDF_StoreList_Init(self, *args)


    def IsConsistent(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _CDF.CDF_StoreList_IsConsistent(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _CDF.CDF_StoreList_More(self, *args)


    def Next(self, *args) -> "void":
        """:rtype: None"""
        return _CDF.CDF_StoreList_Next(self, *args)


    def Store(self, *args) -> "PCDM_StoreStatus":
        """
        * stores each object of the storelist in the reverse order of which they had been added.
        	:param aMetaData:
        	:type aMetaData: CDM_MetaData
        	:param aStatusAssociatedText:
        	:type aStatusAssociatedText: TCollection_ExtendedString
        	:rtype: PCDM_StoreStatus
        """
        return _CDF.CDF_StoreList_Store(self, *args)


    def Value(self, *args) -> "opencascade::handle< CDM_Document >":
        """:rtype: opencascade::handle<CDM_Document>"""
        return _CDF.CDF_StoreList_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_StoreList_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_StoreList
CDF_StoreList.Init = new_instancemethod(_CDF.CDF_StoreList_Init, None, CDF_StoreList)
CDF_StoreList.IsConsistent = new_instancemethod(_CDF.CDF_StoreList_IsConsistent, None, CDF_StoreList)
CDF_StoreList.More = new_instancemethod(_CDF.CDF_StoreList_More, None, CDF_StoreList)
CDF_StoreList.Next = new_instancemethod(_CDF.CDF_StoreList_Next, None, CDF_StoreList)
CDF_StoreList.Store = new_instancemethod(_CDF.CDF_StoreList_Store, None, CDF_StoreList)
CDF_StoreList.Value = new_instancemethod(_CDF.CDF_StoreList_Value, None, CDF_StoreList)
CDF_StoreList_swigregister = _CDF.CDF_StoreList_swigregister
CDF_StoreList_swigregister(CDF_StoreList)

class CDF_FWOSDriver(CDF_MetaDataDriver):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * initializes the MetaDatadriver with its specific name.
        	:rtype: None
        """
        _CDF.CDF_FWOSDriver_swiginit(self, _CDF.new_CDF_FWOSDriver(*args))


    @staticmethod
    def DownCast(t):
      return Handle_CDF_FWOSDriver_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_FWOSDriver
CDF_FWOSDriver_swigregister = _CDF.CDF_FWOSDriver_swigregister
CDF_FWOSDriver_swigregister(CDF_FWOSDriver)



