# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Convert module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_convert.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Convert.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Convert')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Convert')
    _Convert = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Convert', [dirname(__file__)])
        except ImportError:
            import _Convert
            return _Convert
        try:
            _mod = imp.load_module('_Convert', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Convert = swig_import_helper()
    del swig_import_helper
else:
    import _Convert
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Convert.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Convert.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Convert.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Convert.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Convert.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Convert.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Convert.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Convert.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Convert.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Convert.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Convert.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Convert.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Convert.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Convert.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Convert.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Convert.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Convert.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Convert.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _Convert.process_exception(error, method_name, class_name)
process_exception = _Convert.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.gp
Convert_TgtThetaOver2 = _Convert.Convert_TgtThetaOver2
Convert_TgtThetaOver2_1 = _Convert.Convert_TgtThetaOver2_1
Convert_TgtThetaOver2_2 = _Convert.Convert_TgtThetaOver2_2
Convert_TgtThetaOver2_3 = _Convert.Convert_TgtThetaOver2_3
Convert_TgtThetaOver2_4 = _Convert.Convert_TgtThetaOver2_4
Convert_QuasiAngular = _Convert.Convert_QuasiAngular
Convert_RationalC1 = _Convert.Convert_RationalC1
Convert_Polynomial = _Convert.Convert_Polynomial
class Convert_SequenceOfArray1OfPoles(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Convert.Convert_SequenceOfArray1OfPoles_swiginit(self, _Convert.new_Convert_SequenceOfArray1OfPoles(*args))
    delNode = staticmethod(_Convert.Convert_SequenceOfArray1OfPoles_delNode)
    __swig_destroy__ = _Convert.delete_Convert_SequenceOfArray1OfPoles
Convert_SequenceOfArray1OfPoles.begin = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_begin, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.end = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_end, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.cbegin = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_cbegin, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.cend = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_cend, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Size = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Size, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Length = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Length, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Lower = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Lower, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Upper = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Upper, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.IsEmpty = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_IsEmpty, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Reverse = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Reverse, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Exchange = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Exchange, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Clear = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Clear, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Assign = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Assign, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Set = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Set, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Remove = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Remove, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Append = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Append, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Prepend = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Prepend, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.InsertBefore = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_InsertBefore, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.InsertAfter = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_InsertAfter, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Split = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Split, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.First = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_First, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.ChangeFirst = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_ChangeFirst, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Last = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Last, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.ChangeLast = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_ChangeLast, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.Value = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_Value, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.ChangeValue = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_ChangeValue, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.__call__ = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles___call__, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles.SetValue = new_instancemethod(_Convert.Convert_SequenceOfArray1OfPoles_SetValue, None, Convert_SequenceOfArray1OfPoles)
Convert_SequenceOfArray1OfPoles_swigregister = _Convert.Convert_SequenceOfArray1OfPoles_swigregister
Convert_SequenceOfArray1OfPoles_swigregister(Convert_SequenceOfArray1OfPoles)

def Convert_SequenceOfArray1OfPoles_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _Convert.Convert_SequenceOfArray1OfPoles_delNode(theNode, theAl)
Convert_SequenceOfArray1OfPoles_delNode = _Convert.Convert_SequenceOfArray1OfPoles_delNode

class Convert_CompBezierCurves2dToBSplineCurve2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddCurve(self, *args) -> "void":
        """
        * Adds the Bezier curve defined by the table of poles Poles, to the sequence (still contained in this framework) of adjacent Bezier curves to be converted into a BSpline curve. Only polynomial (i.e. non-rational) Bezier curves are converted using this framework. If this is not the first call to the function (i.e. if this framework still contains data in its sequence of Bezier curves), the degree of continuity of the BSpline curve will be increased at the time of computation at the first point of the added Bezier curve (i.e. the first point of the Poles table). This will be the case if the tangent vector of the curve at this point is parallel to the tangent vector at the end point of the preceding Bezier curve in the sequence of Bezier curves still contained in this framework. An angular tolerance given at the time of construction of this framework, will be used to check the parallelism of the two tangent vectors. This checking procedure, and all the relative computations will be performed by the function Perform. When the sequence of adjacent Bezier curves is complete, use the following functions: - Perform to compute the data needed to build the BSpline curve, - and the available consultation functions to access the computed data. This data may be used to construct the BSpline curve. Warning The sequence of Bezier curves treated by this framework is automatically initialized with the first Bezier curve when the function is first called. During subsequent use of this function, ensure that the first point of the added Bezier curve (i.e. the first point of the Poles table) is coincident with the last point of the sequence (i.e. the last point of the preceding Bezier curve in the sequence) of Bezier curves still contained in this framework. An error may occur at the time of computation if this condition is not satisfied. Particular care must be taken with respect to the above, as this condition is not checked either when defining the sequence of Bezier curves or at the time of computation.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:rtype: None
        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_AddCurve(self, *args)


    def __init__(self, *args):
        """
        * Constructs a framework for converting a sequence of adjacent non-rational Bezier curves into a BSpline curve. Knots will be created on the computed BSpline curve at each junction point of two consecutive Bezier curves. The degree of continuity of the BSpline curve will be increased at the junction point of two consecutive Bezier curves if their tangent vectors at this point are parallel. AngularTolerance (given in radians, and defaulted to 1.0 e-4) will be used to check the parallelism of the two tangent vectors. Use the following functions: - AddCurve to define in sequence the adjacent Bezier curves to be converted, - Perform to compute the data needed to build the BSpline curve, - and the available consultation functions to access the computed data. This data may be used to construct the BSpline curve.
        	:param AngularTolerance: default value is 1.0e-4
        	:type AngularTolerance: float
        	:rtype: None
        """
        _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_swiginit(self, _Convert.new_Convert_CompBezierCurves2dToBSplineCurve2d(*args))

    def Degree(self, *args) -> "Standard_Integer":
        """
        * Returns the degree of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.
        	:rtype: int
        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Degree(self, *args)


    def KnotsAndMults(self, *args) -> "void":
        """
        * Loads the Knots table with the knots and the Mults table with the corresponding multiplicities of the BSpline curve whose data is computed in this framework. Warning - Do not use this function before the computation is performed (Perform function). - The length of the Knots and Mults arrays must be equal to the number of knots in the BSpline curve whose data is computed in this framework. Particular care must be taken with respect to the above as these conditions are not checked, and an error may occur.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_KnotsAndMults(self, *args)


    def NbKnots(self, *args) -> "Standard_Integer":
        """
        * Returns the number of knots of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.
        	:rtype: int
        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_NbKnots(self, *args)


    def NbPoles(self, *args) -> "Standard_Integer":
        """
        * Returns the number of poles of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.
        	:rtype: int
        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_NbPoles(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Computes all the data needed to build a BSpline curve equivalent to the sequence of adjacent Bezier curves still contained in this framework. A knot is inserted on the computed BSpline curve at the junction point of two consecutive Bezier curves. The degree of continuity of the BSpline curve will be increased at the junction point of two consecutive Bezier curves if their tangent vectors at this point are parallel. An angular tolerance given at the time of construction of this framework is used to check the parallelism of the two tangent vectors. Use the available consultation functions to access the computed data. This data may then be used to construct the BSpline curve. Warning Ensure that the curves in the sequence of Bezier curves contained in this framework are adjacent. An error may occur at the time of computation if this condition is not satisfied. Particular care must be taken with respect to the above as this condition is not checked, either when defining the Bezier curve sequence or at the time of computation.
        	:rtype: None
        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Perform(self, *args)


    def Poles(self, *args) -> "void":
        """
        * Loads the Poles table with the poles of the BSpline curve whose data is computed in this framework. Warning - Do not use this function before the computation is performed (Perform function). - The length of the Poles array must be equal to the number of poles of the BSpline curve whose data is computed in this framework. Particular care must be taken with respect to the above, as these conditions are not checked, and an error may occur.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:rtype: None
        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CompBezierCurves2dToBSplineCurve2d
Convert_CompBezierCurves2dToBSplineCurve2d.AddCurve = new_instancemethod(_Convert.Convert_CompBezierCurves2dToBSplineCurve2d_AddCurve, None, Convert_CompBezierCurves2dToBSplineCurve2d)
Convert_CompBezierCurves2dToBSplineCurve2d.Degree = new_instancemethod(_Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Degree, None, Convert_CompBezierCurves2dToBSplineCurve2d)
Convert_CompBezierCurves2dToBSplineCurve2d.KnotsAndMults = new_instancemethod(_Convert.Convert_CompBezierCurves2dToBSplineCurve2d_KnotsAndMults, None, Convert_CompBezierCurves2dToBSplineCurve2d)
Convert_CompBezierCurves2dToBSplineCurve2d.NbKnots = new_instancemethod(_Convert.Convert_CompBezierCurves2dToBSplineCurve2d_NbKnots, None, Convert_CompBezierCurves2dToBSplineCurve2d)
Convert_CompBezierCurves2dToBSplineCurve2d.NbPoles = new_instancemethod(_Convert.Convert_CompBezierCurves2dToBSplineCurve2d_NbPoles, None, Convert_CompBezierCurves2dToBSplineCurve2d)
Convert_CompBezierCurves2dToBSplineCurve2d.Perform = new_instancemethod(_Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Perform, None, Convert_CompBezierCurves2dToBSplineCurve2d)
Convert_CompBezierCurves2dToBSplineCurve2d.Poles = new_instancemethod(_Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Poles, None, Convert_CompBezierCurves2dToBSplineCurve2d)
Convert_CompBezierCurves2dToBSplineCurve2d_swigregister = _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_swigregister
Convert_CompBezierCurves2dToBSplineCurve2d_swigregister(Convert_CompBezierCurves2dToBSplineCurve2d)

class Convert_CompBezierCurvesToBSplineCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddCurve(self, *args) -> "void":
        """
        * Adds the Bezier curve defined by the table of poles Poles, to the sequence (still contained in this framework) of adjacent Bezier curves to be converted into a BSpline curve. Only polynomial (i.e. non-rational) Bezier curves are converted using this framework. If this is not the first call to the function (i.e. if this framework still contains data in its Bezier curve sequence), the degree of continuity of the BSpline curve will be increased at the time of computation at the first point of the added Bezier curve (i.e. the first point of the Poles table). This will be the case if the tangent vector of the curve at this point is parallel to the tangent vector at the end point of the preceding Bezier curve in the Bezier curve sequence still contained in this framework. An angular tolerance given at the time of construction of this framework will be used to check the parallelism of the two tangent vectors. This checking procedure and all related computations will be performed by the Perform function. When the adjacent Bezier curve sequence is complete, use the following functions: - Perform to compute the data needed to build the BSpline curve, - and the available consultation functions to access the computed data. This data may be used to construct the BSpline curve. Warning The Bezier curve sequence treated by this framework is automatically initialized with the first Bezier curve when the function is first called. During subsequent use of this function, ensure that the first point of the added Bezier curve (i.e. the first point of the Poles table) is coincident with the last point of the Bezier curve sequence (i.e. the last point of the preceding Bezier curve in the sequence) still contained in this framework. An error may occur at the time of computation if this condition is not satisfied. Particular care must be taken with respect to the above, as this condition is not checked either when defining the Bezier curve sequence or at the time of computation.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:rtype: None
        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_AddCurve(self, *args)


    def __init__(self, *args):
        """
        * Constructs a framework for converting a sequence of adjacent non-rational Bezier curves into a BSpline curve. Knots will be created on the computed BSpline curve at each junction point of two consecutive Bezier curves. The degree of continuity of the BSpline curve will be increased at the junction point of two consecutive Bezier curves if their tangent vectors at this point are parallel. AngularTolerance (given in radians, and defaulted to 1.0 e-4) will be used to check the parallelism of the two tangent vectors. Use the following functions: - AddCurve to define in sequence the adjacent Bezier curves to be converted, - Perform to compute the data needed to build the BSpline curve, - and the available consultation functions to access the computed data. This data may be used to construct the BSpline curve.
        	:param AngularTolerance: default value is 1.0e-4
        	:type AngularTolerance: float
        	:rtype: None
        """
        _Convert.Convert_CompBezierCurvesToBSplineCurve_swiginit(self, _Convert.new_Convert_CompBezierCurvesToBSplineCurve(*args))

    def Degree(self, *args) -> "Standard_Integer":
        """
        * Returns the degree of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.
        	:rtype: int
        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_Degree(self, *args)


    def KnotsAndMults(self, *args) -> "void":
        """
        * - loads the Knots table with the knots, - and loads the Mults table with the corresponding multiplicities of the BSpline curve whose data is computed in this framework. Warning - Do not use this function before the computation is performed (Perform function). - The length of the Knots and Mults arrays must be equal to the number of knots in the BSpline curve whose data is computed in this framework. Particular care must be taken with respect to the above as these conditions are not checked, and an error may occur.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_KnotsAndMults(self, *args)


    def NbKnots(self, *args) -> "Standard_Integer":
        """
        * Returns the number of knots of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.
        	:rtype: int
        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_NbKnots(self, *args)


    def NbPoles(self, *args) -> "Standard_Integer":
        """
        * Returns the number of poles of the BSpline curve whose data is computed in this framework. Warning Take particular care not to use this function before the computation is performed (Perform function), as this condition is not checked and an error may therefore occur.
        	:rtype: int
        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_NbPoles(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Computes all the data needed to build a BSpline curve equivalent to the adjacent Bezier curve sequence still contained in this framework. A knot is inserted on the computed BSpline curve at the junction point of two consecutive Bezier curves. The degree of continuity of the BSpline curve will be increased at the junction point of two consecutive Bezier curves if their tangent vectors at this point are parallel. An angular tolerance given at the time of construction of this framework is used to check the parallelism of the two tangent vectors. Use the available consultation functions to access the computed data. This data may then be used to construct the BSpline curve. Warning Make sure that the curves in the Bezier curve sequence contained in this framework are adjacent. An error may occur at the time of computation if this condition is not satisfied. Particular care must be taken with respect to the above as this condition is not checked, either when defining the Bezier curve sequence or at the time of computation.
        	:rtype: None
        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_Perform(self, *args)


    def Poles(self, *args) -> "void":
        """
        * Loads the Poles table with the poles of the BSpline curve whose data is computed in this framework. Warning - Do not use this function before the computation is performed (Perform function). - The length of the Poles array must be equal to the number of poles of the BSpline curve whose data is computed in this framework. Particular care must be taken with respect to the above, as these conditions are not checked, and an error may occur.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:rtype: None
        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CompBezierCurvesToBSplineCurve
Convert_CompBezierCurvesToBSplineCurve.AddCurve = new_instancemethod(_Convert.Convert_CompBezierCurvesToBSplineCurve_AddCurve, None, Convert_CompBezierCurvesToBSplineCurve)
Convert_CompBezierCurvesToBSplineCurve.Degree = new_instancemethod(_Convert.Convert_CompBezierCurvesToBSplineCurve_Degree, None, Convert_CompBezierCurvesToBSplineCurve)
Convert_CompBezierCurvesToBSplineCurve.KnotsAndMults = new_instancemethod(_Convert.Convert_CompBezierCurvesToBSplineCurve_KnotsAndMults, None, Convert_CompBezierCurvesToBSplineCurve)
Convert_CompBezierCurvesToBSplineCurve.NbKnots = new_instancemethod(_Convert.Convert_CompBezierCurvesToBSplineCurve_NbKnots, None, Convert_CompBezierCurvesToBSplineCurve)
Convert_CompBezierCurvesToBSplineCurve.NbPoles = new_instancemethod(_Convert.Convert_CompBezierCurvesToBSplineCurve_NbPoles, None, Convert_CompBezierCurvesToBSplineCurve)
Convert_CompBezierCurvesToBSplineCurve.Perform = new_instancemethod(_Convert.Convert_CompBezierCurvesToBSplineCurve_Perform, None, Convert_CompBezierCurvesToBSplineCurve)
Convert_CompBezierCurvesToBSplineCurve.Poles = new_instancemethod(_Convert.Convert_CompBezierCurvesToBSplineCurve_Poles, None, Convert_CompBezierCurvesToBSplineCurve)
Convert_CompBezierCurvesToBSplineCurve_swigregister = _Convert.Convert_CompBezierCurvesToBSplineCurve_swigregister
Convert_CompBezierCurvesToBSplineCurve_swigregister(Convert_CompBezierCurvesToBSplineCurve)

class Convert_CompPolynomialToPoles(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Warning! Continuity can be at MOST the maximum degree of the polynomial functions TrueIntervals : this is the true parameterisation for the composite curve that is : the curve has myContinuity if the nth curve is parameterized between myTrueIntervals(n) and myTrueIntervals(n+1) //! Coefficients have to be the implicit 'c form': Coefficients[Numcurves][MaxDegree+1][Dimension] //! Warning! The NumberOfCoefficient of an polynome is his degree + 1 Example: To convert the linear function f(x) = 2*x + 1 on the domaine [2,5] to BSpline with the bound [-1,1]. Arguments are : NumCurves = 1; Continuity = 1; Dimension = 1; MaxDegree = 1; NumCoeffPerCurve [1] = {2}; Coefficients[2] = {1, 2}; PolynomialIntervals[1,2] = {{2,5}} TrueIntervals[2] = {-1, 1}
        	:param NumCurves:
        	:type NumCurves: int
        	:param Continuity:
        	:type Continuity: int
        	:param Dimension:
        	:type Dimension: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param NumCoeffPerCurve:
        	:type NumCoeffPerCurve: TColStd_HArray1OfInteger
        	:param Coefficients:
        	:type Coefficients: TColStd_HArray1OfReal
        	:param PolynomialIntervals:
        	:type PolynomialIntervals: TColStd_HArray2OfReal
        	:param TrueIntervals:
        	:type TrueIntervals: TColStd_HArray1OfReal
        	:rtype: None
        * To Convert sevral span with different order of Continuity. Warning: The Length of Continuity have to be NumCurves-1
        	:param NumCurves:
        	:type NumCurves: int
        	:param Dimension:
        	:type Dimension: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param Continuity:
        	:type Continuity: TColStd_Array1OfInteger
        	:param NumCoeffPerCurve:
        	:type NumCoeffPerCurve: TColStd_Array1OfInteger
        	:param Coefficients:
        	:type Coefficients: TColStd_Array1OfReal
        	:param PolynomialIntervals:
        	:type PolynomialIntervals: TColStd_Array2OfReal
        	:param TrueIntervals:
        	:type TrueIntervals: TColStd_Array1OfReal
        	:rtype: None
        * To Convert only one span.
        	:param Dimension:
        	:type Dimension: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param Degree:
        	:type Degree: int
        	:param Coefficients:
        	:type Coefficients: TColStd_Array1OfReal
        	:param PolynomialIntervals:
        	:type PolynomialIntervals: TColStd_Array1OfReal
        	:param TrueIntervals:
        	:type TrueIntervals: TColStd_Array1OfReal
        	:rtype: None
        """
        _Convert.Convert_CompPolynomialToPoles_swiginit(self, _Convert.new_Convert_CompPolynomialToPoles(*args))

    def Degree(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_CompPolynomialToPoles_Degree(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Convert.Convert_CompPolynomialToPoles_IsDone(self, *args)


    def Knots(self, *args) -> "void":
        """
        * Knots of the n-dimensional Bspline
        	:param K:
        	:type K: TColStd_HArray1OfReal
        	:rtype: None
        """
        return _Convert.Convert_CompPolynomialToPoles_Knots(self, *args)


    def Multiplicities(self, *args) -> "void":
        """
        * Multiplicities of the knots in the BSpline
        	:param M:
        	:type M: TColStd_HArray1OfInteger
        	:rtype: None
        """
        return _Convert.Convert_CompPolynomialToPoles_Multiplicities(self, *args)


    def NbKnots(self, *args) -> "Standard_Integer":
        """
        * Degree of the n-dimensional Bspline
        	:rtype: int
        """
        return _Convert.Convert_CompPolynomialToPoles_NbKnots(self, *args)


    def NbPoles(self, *args) -> "Standard_Integer":
        """
        * number of poles of the n-dimensional BSpline
        	:rtype: int
        """
        return _Convert.Convert_CompPolynomialToPoles_NbPoles(self, *args)


    def Poles(self, *args) -> "void":
        """
        * returns the poles of the n-dimensional BSpline in the following format : [1..NumPoles][1..Dimension]
        	:param Poles:
        	:type Poles: TColStd_HArray2OfReal
        	:rtype: None
        """
        return _Convert.Convert_CompPolynomialToPoles_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CompPolynomialToPoles
Convert_CompPolynomialToPoles.Degree = new_instancemethod(_Convert.Convert_CompPolynomialToPoles_Degree, None, Convert_CompPolynomialToPoles)
Convert_CompPolynomialToPoles.IsDone = new_instancemethod(_Convert.Convert_CompPolynomialToPoles_IsDone, None, Convert_CompPolynomialToPoles)
Convert_CompPolynomialToPoles.Knots = new_instancemethod(_Convert.Convert_CompPolynomialToPoles_Knots, None, Convert_CompPolynomialToPoles)
Convert_CompPolynomialToPoles.Multiplicities = new_instancemethod(_Convert.Convert_CompPolynomialToPoles_Multiplicities, None, Convert_CompPolynomialToPoles)
Convert_CompPolynomialToPoles.NbKnots = new_instancemethod(_Convert.Convert_CompPolynomialToPoles_NbKnots, None, Convert_CompPolynomialToPoles)
Convert_CompPolynomialToPoles.NbPoles = new_instancemethod(_Convert.Convert_CompPolynomialToPoles_NbPoles, None, Convert_CompPolynomialToPoles)
Convert_CompPolynomialToPoles.Poles = new_instancemethod(_Convert.Convert_CompPolynomialToPoles_Poles, None, Convert_CompPolynomialToPoles)
Convert_CompPolynomialToPoles_swigregister = _Convert.Convert_CompPolynomialToPoles_swigregister
Convert_CompPolynomialToPoles_swigregister(Convert_CompPolynomialToPoles)

class Convert_ConicToBSplineCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BuildCosAndSin(self, *args) -> "void":
        """
        :param Parametrisation:
        	:type Parametrisation: Convert_ParameterisationType
        	:param CosNumerator:
        	:type CosNumerator: TColStd_HArray1OfReal
        	:param SinNumerator:
        	:type SinNumerator: TColStd_HArray1OfReal
        	:param Denominator:
        	:type Denominator: TColStd_HArray1OfReal
        	:param Degree:
        	:type Degree: int
        	:param Knots:
        	:type Knots: TColStd_HArray1OfReal
        	:param Mults:
        	:type Mults: TColStd_HArray1OfInteger
        	:rtype: None
        :param Parametrisation:
        	:type Parametrisation: Convert_ParameterisationType
        	:param UFirst:
        	:type UFirst: float
        	:param ULast:
        	:type ULast: float
        	:param CosNumerator:
        	:type CosNumerator: TColStd_HArray1OfReal
        	:param SinNumerator:
        	:type SinNumerator: TColStd_HArray1OfReal
        	:param Denominator:
        	:type Denominator: TColStd_HArray1OfReal
        	:param Degree:
        	:type Degree: int
        	:param Knots:
        	:type Knots: TColStd_HArray1OfReal
        	:param Mults:
        	:type Mults: TColStd_HArray1OfInteger
        	:rtype: None
        """
        return _Convert.Convert_ConicToBSplineCurve_BuildCosAndSin(self, *args)


    def Degree(self, *args) -> "Standard_Integer":
        """
        * Returns the degree of the BSpline curve whose data is computed in this framework.
        	:rtype: int
        """
        return _Convert.Convert_ConicToBSplineCurve_Degree(self, *args)


    def IsPeriodic(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the BSpline curve whose data is computed in this framework is periodic.
        	:rtype: bool
        """
        return _Convert.Convert_ConicToBSplineCurve_IsPeriodic(self, *args)


    def Knot(self, *args) -> "Standard_Real":
        """
        * Returns the knot of index Index to the knots table of the BSpline curve whose data is computed in this framework. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of the BSpline curve whose data is computed in this framework.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _Convert.Convert_ConicToBSplineCurve_Knot(self, *args)


    def Multiplicity(self, *args) -> "Standard_Integer":
        """
        * Returns the multiplicity of the knot of index Index to the knots table of the BSpline curve whose data is computed in this framework. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of the BSpline curve whose data is computed in this framework.
        	:param Index:
        	:type Index: int
        	:rtype: int
        """
        return _Convert.Convert_ConicToBSplineCurve_Multiplicity(self, *args)


    def NbKnots(self, *args) -> "Standard_Integer":
        """
        * Returns the number of knots of the BSpline curve whose data is computed in this framework.
        	:rtype: int
        """
        return _Convert.Convert_ConicToBSplineCurve_NbKnots(self, *args)


    def NbPoles(self, *args) -> "Standard_Integer":
        """
        * Returns the number of poles of the BSpline curve whose data is computed in this framework.
        	:rtype: int
        """
        return _Convert.Convert_ConicToBSplineCurve_NbPoles(self, *args)


    def Pole(self, *args) -> "gp_Pnt2d":
        """
        * Returns the pole of index Index to the poles table of the BSpline curve whose data is computed in this framework. Exceptions Standard_OutOfRange if Index is outside the bounds of the poles table of the BSpline curve whose data is computed in this framework.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt2d
        """
        return _Convert.Convert_ConicToBSplineCurve_Pole(self, *args)


    def Weight(self, *args) -> "Standard_Real":
        """
        * Returns the weight of the pole of index Index to the poles table of the BSpline curve whose data is computed in this framework. Exceptions Standard_OutOfRange if Index is outside the bounds of the poles table of the BSpline curve whose data is computed in this framework.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _Convert.Convert_ConicToBSplineCurve_Weight(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_ConicToBSplineCurve
Convert_ConicToBSplineCurve.BuildCosAndSin = new_instancemethod(_Convert.Convert_ConicToBSplineCurve_BuildCosAndSin, None, Convert_ConicToBSplineCurve)
Convert_ConicToBSplineCurve.Degree = new_instancemethod(_Convert.Convert_ConicToBSplineCurve_Degree, None, Convert_ConicToBSplineCurve)
Convert_ConicToBSplineCurve.IsPeriodic = new_instancemethod(_Convert.Convert_ConicToBSplineCurve_IsPeriodic, None, Convert_ConicToBSplineCurve)
Convert_ConicToBSplineCurve.Knot = new_instancemethod(_Convert.Convert_ConicToBSplineCurve_Knot, None, Convert_ConicToBSplineCurve)
Convert_ConicToBSplineCurve.Multiplicity = new_instancemethod(_Convert.Convert_ConicToBSplineCurve_Multiplicity, None, Convert_ConicToBSplineCurve)
Convert_ConicToBSplineCurve.NbKnots = new_instancemethod(_Convert.Convert_ConicToBSplineCurve_NbKnots, None, Convert_ConicToBSplineCurve)
Convert_ConicToBSplineCurve.NbPoles = new_instancemethod(_Convert.Convert_ConicToBSplineCurve_NbPoles, None, Convert_ConicToBSplineCurve)
Convert_ConicToBSplineCurve.Pole = new_instancemethod(_Convert.Convert_ConicToBSplineCurve_Pole, None, Convert_ConicToBSplineCurve)
Convert_ConicToBSplineCurve.Weight = new_instancemethod(_Convert.Convert_ConicToBSplineCurve_Weight, None, Convert_ConicToBSplineCurve)
Convert_ConicToBSplineCurve_swigregister = _Convert.Convert_ConicToBSplineCurve_swigregister
Convert_ConicToBSplineCurve_swigregister(Convert_ConicToBSplineCurve)

class Convert_ElementarySurfaceToBSplineSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsUPeriodic(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the BSpline surface whose data is computed in this framework is periodic in the u or v parametric direction.
        	:rtype: bool
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_IsVPeriodic(self, *args)


    def NbUKnots(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbUKnots(self, *args)


    def NbUPoles(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbUPoles(self, *args)


    def NbVKnots(self, *args) -> "Standard_Integer":
        """
        * Returns the number of knots for the u or v parametric direction of the BSpline surface whose data is computed in this framework .
        	:rtype: int
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbVKnots(self, *args)


    def NbVPoles(self, *args) -> "Standard_Integer":
        """
        * Returns the number of poles for the u or v parametric direction of the BSpline surface whose data is computed in this framework.
        	:rtype: int
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbVPoles(self, *args)


    def Pole(self, *args) -> "gp_Pnt":
        """
        * Returns the pole of index (UIndex,VIndex) to the poles table of the BSpline surface whose data is computed in this framework. Exceptions Standard_OutOfRange if, for the BSpline surface whose data is computed in this framework: - UIndex is outside the bounds of the poles table in the u parametric direction, or - VIndex is outside the bounds of the poles table in the v parametric direction.
        	:param UIndex:
        	:type UIndex: int
        	:param VIndex:
        	:type VIndex: int
        	:rtype: gp_Pnt
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_Pole(self, *args)


    def UDegree(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_UDegree(self, *args)


    def UKnot(self, *args) -> "Standard_Real":
        """
        * Returns the U-knot of range UIndex. Raised if UIndex < 1 or UIndex > NbUKnots.
        	:param UIndex:
        	:type UIndex: int
        	:rtype: float
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_UKnot(self, *args)


    def UMultiplicity(self, *args) -> "Standard_Integer":
        """
        * Returns the multiplicity of the U-knot of range UIndex. Raised if UIndex < 1 or UIndex > NbUKnots.
        	:param UIndex:
        	:type UIndex: int
        	:rtype: int
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_UMultiplicity(self, *args)


    def VDegree(self, *args) -> "Standard_Integer":
        """
        * Returns the degree for the u or v parametric direction of the BSpline surface whose data is computed in this framework.
        	:rtype: int
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_VDegree(self, *args)


    def VKnot(self, *args) -> "Standard_Real":
        """
        * Returns the V-knot of range VIndex. Raised if VIndex < 1 or VIndex > NbVKnots.
        	:param UIndex:
        	:type UIndex: int
        	:rtype: float
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_VKnot(self, *args)


    def VMultiplicity(self, *args) -> "Standard_Integer":
        """
        * Returns the multiplicity of the V-knot of range VIndex. Raised if VIndex < 1 or VIndex > NbVKnots.
        	:param VIndex:
        	:type VIndex: int
        	:rtype: int
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_VMultiplicity(self, *args)


    def Weight(self, *args) -> "Standard_Real":
        """
        * Returns the weight of the pole of index (UIndex,VIndex) to the poles table of the BSpline surface whose data is computed in this framework. Exceptions Standard_OutOfRange if, for the BSpline surface whose data is computed in this framework: - UIndex is outside the bounds of the poles table in the u parametric direction, or - VIndex is outside the bounds of the poles table in the v parametric direction.
        	:param UIndex:
        	:type UIndex: int
        	:param VIndex:
        	:type VIndex: int
        	:rtype: float
        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_Weight(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_ElementarySurfaceToBSplineSurface
Convert_ElementarySurfaceToBSplineSurface.IsUPeriodic = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_IsUPeriodic, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.IsVPeriodic = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_IsVPeriodic, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.NbUKnots = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_NbUKnots, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.NbUPoles = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_NbUPoles, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.NbVKnots = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_NbVKnots, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.NbVPoles = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_NbVPoles, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.Pole = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_Pole, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.UDegree = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_UDegree, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.UKnot = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_UKnot, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.UMultiplicity = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_UMultiplicity, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.VDegree = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_VDegree, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.VKnot = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_VKnot, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.VMultiplicity = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_VMultiplicity, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface.Weight = new_instancemethod(_Convert.Convert_ElementarySurfaceToBSplineSurface_Weight, None, Convert_ElementarySurfaceToBSplineSurface)
Convert_ElementarySurfaceToBSplineSurface_swigregister = _Convert.Convert_ElementarySurfaceToBSplineSurface_swigregister
Convert_ElementarySurfaceToBSplineSurface_swigregister(Convert_ElementarySurfaceToBSplineSurface)

class Convert_GridPolynomialToPoles(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * To only one polynomial Surface. The Length of <PolynomialUIntervals> and <PolynomialVIntervals> have to be 2. This values defined the parametric domain of the Polynomial Equation. //! Coefficients : The <Coefficients> have to be formated than an 'C array' [MaxUDegree+1] [MaxVDegree+1] [3]
        	:param MaxUDegree:
        	:type MaxUDegree: int
        	:param MaxVDegree:
        	:type MaxVDegree: int
        	:param NumCoeff:
        	:type NumCoeff: TColStd_HArray1OfInteger
        	:param Coefficients:
        	:type Coefficients: TColStd_HArray1OfReal
        	:param PolynomialUIntervals:
        	:type PolynomialUIntervals: TColStd_HArray1OfReal
        	:param PolynomialVIntervals:
        	:type PolynomialVIntervals: TColStd_HArray1OfReal
        	:rtype: None
        * To one grid of polynomial Surface. Warning! Continuity in each parametric direction can be at MOST the maximum degree of the polynomial functions. //! <TrueUIntervals>, <TrueVIntervals> : this is the true parameterisation for the composite surface //! Coefficients : The Coefficients have to be formated than an 'C array' [NbVSurfaces] [NBUSurfaces] [MaxUDegree+1] [MaxVDegree+1] [3] raises DomainError if <NumCoeffPerSurface> is not a [1, NbVSurfaces*NbUSurfaces, 1,2] array. if <Coefficients> is not a
        	:param NbUSurfaces:
        	:type NbUSurfaces: int
        	:param NBVSurfaces:
        	:type NBVSurfaces: int
        	:param UContinuity:
        	:type UContinuity: int
        	:param VContinuity:
        	:type VContinuity: int
        	:param MaxUDegree:
        	:type MaxUDegree: int
        	:param MaxVDegree:
        	:type MaxVDegree: int
        	:param NumCoeffPerSurface:
        	:type NumCoeffPerSurface: TColStd_HArray2OfInteger
        	:param Coefficients:
        	:type Coefficients: TColStd_HArray1OfReal
        	:param PolynomialUIntervals:
        	:type PolynomialUIntervals: TColStd_HArray1OfReal
        	:param PolynomialVIntervals:
        	:type PolynomialVIntervals: TColStd_HArray1OfReal
        	:param TrueUIntervals:
        	:type TrueUIntervals: TColStd_HArray1OfReal
        	:param TrueVIntervals:
        	:type TrueVIntervals: TColStd_HArray1OfReal
        	:rtype: None
        """
        _Convert.Convert_GridPolynomialToPoles_swiginit(self, _Convert.new_Convert_GridPolynomialToPoles(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Convert.Convert_GridPolynomialToPoles_IsDone(self, *args)


    def NbUKnots(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_GridPolynomialToPoles_NbUKnots(self, *args)


    def NbUPoles(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_GridPolynomialToPoles_NbUPoles(self, *args)


    def NbVKnots(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_GridPolynomialToPoles_NbVKnots(self, *args)


    def NbVPoles(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_GridPolynomialToPoles_NbVPoles(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param UContinuity:
        	:type UContinuity: int
        	:param VContinuity:
        	:type VContinuity: int
        	:param MaxUDegree:
        	:type MaxUDegree: int
        	:param MaxVDegree:
        	:type MaxVDegree: int
        	:param NumCoeffPerSurface:
        	:type NumCoeffPerSurface: TColStd_HArray2OfInteger
        	:param Coefficients:
        	:type Coefficients: TColStd_HArray1OfReal
        	:param PolynomialUIntervals:
        	:type PolynomialUIntervals: TColStd_HArray1OfReal
        	:param PolynomialVIntervals:
        	:type PolynomialVIntervals: TColStd_HArray1OfReal
        	:param TrueUIntervals:
        	:type TrueUIntervals: TColStd_HArray1OfReal
        	:param TrueVIntervals:
        	:type TrueVIntervals: TColStd_HArray1OfReal
        	:rtype: None
        """
        return _Convert.Convert_GridPolynomialToPoles_Perform(self, *args)


    def Poles(self, *args) -> "opencascade::handle< TColgp_HArray2OfPnt > const &":
        """
        * returns the poles of the BSpline Surface
        	:rtype: opencascade::handle<TColgp_HArray2OfPnt>
        """
        return _Convert.Convert_GridPolynomialToPoles_Poles(self, *args)


    def UDegree(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_GridPolynomialToPoles_UDegree(self, *args)


    def UKnots(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal > const &":
        """
        * Knots in the U direction
        	:rtype: opencascade::handle<TColStd_HArray1OfReal>
        """
        return _Convert.Convert_GridPolynomialToPoles_UKnots(self, *args)


    def UMultiplicities(self, *args) -> "opencascade::handle< TColStd_HArray1OfInteger > const &":
        """
        * Multiplicities of the knots in the U direction
        	:rtype: opencascade::handle<TColStd_HArray1OfInteger>
        """
        return _Convert.Convert_GridPolynomialToPoles_UMultiplicities(self, *args)


    def VDegree(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Convert.Convert_GridPolynomialToPoles_VDegree(self, *args)


    def VKnots(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal > const &":
        """
        * Knots in the V direction
        	:rtype: opencascade::handle<TColStd_HArray1OfReal>
        """
        return _Convert.Convert_GridPolynomialToPoles_VKnots(self, *args)


    def VMultiplicities(self, *args) -> "opencascade::handle< TColStd_HArray1OfInteger > const &":
        """
        * Multiplicities of the knots in the V direction
        	:rtype: opencascade::handle<TColStd_HArray1OfInteger>
        """
        return _Convert.Convert_GridPolynomialToPoles_VMultiplicities(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_GridPolynomialToPoles
Convert_GridPolynomialToPoles.IsDone = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_IsDone, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.NbUKnots = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_NbUKnots, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.NbUPoles = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_NbUPoles, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.NbVKnots = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_NbVKnots, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.NbVPoles = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_NbVPoles, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.Perform = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_Perform, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.Poles = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_Poles, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.UDegree = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_UDegree, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.UKnots = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_UKnots, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.UMultiplicities = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_UMultiplicities, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.VDegree = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_VDegree, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.VKnots = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_VKnots, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles.VMultiplicities = new_instancemethod(_Convert.Convert_GridPolynomialToPoles_VMultiplicities, None, Convert_GridPolynomialToPoles)
Convert_GridPolynomialToPoles_swigregister = _Convert.Convert_GridPolynomialToPoles_swigregister
Convert_GridPolynomialToPoles_swigregister(Convert_GridPolynomialToPoles)

class Convert_CircleToBSplineCurve(Convert_ConicToBSplineCurve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The equivalent B-spline curve has the same orientation as the circle C.
        	:param C:
        	:type C: gp_Circ2d
        	:param Parameterisation: default value is Convert_TgtThetaOver2
        	:type Parameterisation: Convert_ParameterisationType
        	:rtype: None
        * The circle C is limited between the parametric values U1, U2 in radians. U1 and U2 [0.0, 2*Pi] . The equivalent B-spline curve is oriented from U1 to U2 and has the same orientation as the circle C. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi
        	:param C:
        	:type C: gp_Circ2d
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Parameterisation: default value is Convert_TgtThetaOver2
        	:type Parameterisation: Convert_ParameterisationType
        	:rtype: None
        """
        _Convert.Convert_CircleToBSplineCurve_swiginit(self, _Convert.new_Convert_CircleToBSplineCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CircleToBSplineCurve
Convert_CircleToBSplineCurve_swigregister = _Convert.Convert_CircleToBSplineCurve_swigregister
Convert_CircleToBSplineCurve_swigregister(Convert_CircleToBSplineCurve)

class Convert_ConeToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The equivalent B-spline surface as the same orientation as the Cone in the U and V parametric directions. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi Raised if V1 = V2.
        	:param C:
        	:type C: gp_Cone
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        * The equivalent B-spline surface as the same orientation as the Cone in the U and V parametric directions. //! Raised if V1 = V2.
        	:param C:
        	:type C: gp_Cone
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        """
        _Convert.Convert_ConeToBSplineSurface_swiginit(self, _Convert.new_Convert_ConeToBSplineSurface(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_ConeToBSplineSurface
Convert_ConeToBSplineSurface_swigregister = _Convert.Convert_ConeToBSplineSurface_swigregister
Convert_ConeToBSplineSurface_swigregister(Convert_ConeToBSplineSurface)

class Convert_CylinderToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The equivalent B-splineSurface as the same orientation as the cylinder in the U and V parametric directions. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi Raised if V1 = V2.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        * The equivalent B-splineSurface as the same orientation as the cylinder in the U and V parametric directions. //! Raised if V1 = V2.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        """
        _Convert.Convert_CylinderToBSplineSurface_swiginit(self, _Convert.new_Convert_CylinderToBSplineSurface(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_CylinderToBSplineSurface
Convert_CylinderToBSplineSurface_swigregister = _Convert.Convert_CylinderToBSplineSurface_swigregister
Convert_CylinderToBSplineSurface_swigregister(Convert_CylinderToBSplineSurface)

class Convert_EllipseToBSplineCurve(Convert_ConicToBSplineCurve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The equivalent B-spline curve has the same orientation as the ellipse E.
        	:param E:
        	:type E: gp_Elips2d
        	:param Parameterisation: default value is Convert_TgtThetaOver2
        	:type Parameterisation: Convert_ParameterisationType
        	:rtype: None
        * The ellipse E is limited between the parametric values U1, U2. The equivalent B-spline curve is oriented from U1 to U2 and has the same orientation as E. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi
        	:param E:
        	:type E: gp_Elips2d
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Parameterisation: default value is Convert_TgtThetaOver2
        	:type Parameterisation: Convert_ParameterisationType
        	:rtype: None
        """
        _Convert.Convert_EllipseToBSplineCurve_swiginit(self, _Convert.new_Convert_EllipseToBSplineCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_EllipseToBSplineCurve
Convert_EllipseToBSplineCurve_swigregister = _Convert.Convert_EllipseToBSplineCurve_swigregister
Convert_EllipseToBSplineCurve_swigregister(Convert_EllipseToBSplineCurve)

class Convert_HyperbolaToBSplineCurve(Convert_ConicToBSplineCurve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The hyperbola H is limited between the parametric values U1, U2 and the equivalent B-spline curve has the same orientation as the hyperbola.
        	:param H:
        	:type H: gp_Hypr2d
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:rtype: None
        """
        _Convert.Convert_HyperbolaToBSplineCurve_swiginit(self, _Convert.new_Convert_HyperbolaToBSplineCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_HyperbolaToBSplineCurve
Convert_HyperbolaToBSplineCurve_swigregister = _Convert.Convert_HyperbolaToBSplineCurve_swigregister
Convert_HyperbolaToBSplineCurve_swigregister(Convert_HyperbolaToBSplineCurve)

class Convert_ParabolaToBSplineCurve(Convert_ConicToBSplineCurve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The parabola Prb is limited between the parametric values U1, U2 and the equivalent B-spline curve as the same orientation as the parabola Prb.
        	:param Prb:
        	:type Prb: gp_Parab2d
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:rtype: None
        """
        _Convert.Convert_ParabolaToBSplineCurve_swiginit(self, _Convert.new_Convert_ParabolaToBSplineCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_ParabolaToBSplineCurve
Convert_ParabolaToBSplineCurve_swigregister = _Convert.Convert_ParabolaToBSplineCurve_swigregister
Convert_ParabolaToBSplineCurve_swigregister(Convert_ParabolaToBSplineCurve)

class Convert_SphereToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The equivalent B-spline surface as the same orientation as the sphere in the U and V parametric directions. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi Raised if V1 = V2.
        	:param Sph:
        	:type Sph: gp_Sphere
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        * The equivalent B-spline surface as the same orientation as the sphere in the U and V parametric directions. //! Raised if UTrim = True and Param1 = Param2 or Param1 = Param2 + 2.0 * Pi Raised if UTrim = False and Param1 = Param2
        	:param Sph:
        	:type Sph: gp_Sphere
        	:param Param1:
        	:type Param1: float
        	:param Param2:
        	:type Param2: float
        	:param UTrim: default value is Standard_True
        	:type UTrim: bool
        	:rtype: None
        * The equivalent B-spline surface as the same orientation as the sphere in the U and V parametric directions.
        	:param Sph:
        	:type Sph: gp_Sphere
        	:rtype: None
        """
        _Convert.Convert_SphereToBSplineSurface_swiginit(self, _Convert.new_Convert_SphereToBSplineSurface(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_SphereToBSplineSurface
Convert_SphereToBSplineSurface_swigregister = _Convert.Convert_SphereToBSplineSurface_swigregister
Convert_SphereToBSplineSurface_swigregister(Convert_SphereToBSplineSurface)

class Convert_TorusToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The equivalent B-spline surface as the same orientation as the torus in the U and V parametric directions. //! Raised if U1 = U2 or U1 = U2 + 2.0 * Pi Raised if V1 = V2 or V1 = V2 + 2.0 * Pi
        	:param T:
        	:type T: gp_Torus
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        * The equivalent B-spline surface as the same orientation as the torus in the U and V parametric directions. //! Raised if Param1 = Param2 or Param1 = Param2 + 2.0 * Pi
        	:param T:
        	:type T: gp_Torus
        	:param Param1:
        	:type Param1: float
        	:param Param2:
        	:type Param2: float
        	:param UTrim: default value is Standard_True
        	:type UTrim: bool
        	:rtype: None
        * The equivalent B-spline surface as the same orientation as the torus in the U and V parametric directions.
        	:param T:
        	:type T: gp_Torus
        	:rtype: None
        """
        _Convert.Convert_TorusToBSplineSurface_swiginit(self, _Convert.new_Convert_TorusToBSplineSurface(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Convert.delete_Convert_TorusToBSplineSurface
Convert_TorusToBSplineSurface_swigregister = _Convert.Convert_TorusToBSplineSurface_swigregister
Convert_TorusToBSplineSurface_swigregister(Convert_TorusToBSplineSurface)



