# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
FairCurve module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_faircurve.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _FairCurve.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_FairCurve')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_FairCurve')
    _FairCurve = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_FairCurve', [dirname(__file__)])
        except ImportError:
            import _FairCurve
            return _FairCurve
        try:
            _mod = imp.load_module('_FairCurve', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _FairCurve = swig_import_helper()
    del swig_import_helper
else:
    import _FairCurve
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _FairCurve.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_FairCurve.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_FairCurve.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_FairCurve.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_FairCurve.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_FairCurve.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_FairCurve.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_FairCurve.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_FairCurve.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_FairCurve.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_FairCurve.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_FairCurve.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_FairCurve.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_FairCurve.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_FairCurve.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_FairCurve.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_FairCurve.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _FairCurve.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _FairCurve.process_exception(error, method_name, class_name)
process_exception = _FairCurve.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Geom2d
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.math
import OCC.Core.Message
FairCurve_OK = _FairCurve.FairCurve_OK
FairCurve_NotConverged = _FairCurve.FairCurve_NotConverged
FairCurve_InfiniteSliding = _FairCurve.FairCurve_InfiniteSliding
FairCurve_NullHeight = _FairCurve.FairCurve_NullHeight
class FairCurve_Batten(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Compute(self, *args) -> "Standard_Boolean":
        """
        * Performs the algorithm, using the arguments Code, NbIterations and Tolerance and computes the curve with respect to the constraints. Code will have one of the following values: - OK - NotConverged - InfiniteSliding - NullHeight The parameters Tolerance and NbIterations control how precise the computation is, and how long it will take.
        	:param Code:
        	:type Code: FairCurve_AnalysisCode
        	:param NbIterations: default value is 50
        	:type NbIterations: int
        	:param Tolerance: default value is 1.0e-3
        	:type Tolerance: float
        	:rtype: bool
        """
        return _FairCurve.FairCurve_Batten_Compute(self, *args)


    def Curve(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        * Returns the computed curve a 2d BSpline.
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _FairCurve.FairCurve_Batten_Curve(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(FairCurve_Batten self) -> std::string"""
        return _FairCurve.FairCurve_Batten_DumpToString(self)


    def __init__(self, *args):
        """
        * Constructor with the two points and the geometrical characteristics of the batten (elastic beam) Height is the height of the deformation, and Slope is the slope value, initialized at 0. The user can then supply the desired slope value by the method, SetSlope. Other parameters are initialized as follow : - FreeSliding = False - ConstraintOrder1 = 1 - ConstraintOrder2 = 1 - Angle1 = 0 - Angle2 = 0 - SlidingFactor = 1 Exceptions NegativeValue if Height is less than or equal to 0. NullValue if the distance between P1 and P2 is less than or equal to the tolerance value for distance in Precision::Confusion: P1.IsEqual(P2, Precision::Confusion()). The function gp_Pnt2d::IsEqual tests to see if this is the case.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:param Height:
        	:type Height: float
        	:param Slope: default value is 0
        	:type Slope: float
        	:rtype: None
        """
        _FairCurve.FairCurve_Batten_swiginit(self, _FairCurve.new_FairCurve_Batten(*args))

    def GetAngle1(self, *args) -> "Standard_Real":
        """
        * Returns the established first angle.
        	:rtype: float
        """
        return _FairCurve.FairCurve_Batten_GetAngle1(self, *args)


    def GetAngle2(self, *args) -> "Standard_Real":
        """
        * Returns the established second angle.
        	:rtype: float
        """
        return _FairCurve.FairCurve_Batten_GetAngle2(self, *args)


    def GetConstraintOrder1(self, *args) -> "Standard_Integer":
        """
        * Returns the established first constraint order.
        	:rtype: int
        """
        return _FairCurve.FairCurve_Batten_GetConstraintOrder1(self, *args)


    def GetConstraintOrder2(self, *args) -> "Standard_Integer":
        """
        * Returns the established second constraint order.
        	:rtype: int
        """
        return _FairCurve.FairCurve_Batten_GetConstraintOrder2(self, *args)


    def GetFreeSliding(self, *args) -> "Standard_Boolean":
        """
        * Returns the initial free sliding value, false by default. Free sliding is generally more aesthetically pleasing than constrained sliding. However, the computation can fail with values such as angles greater than PI/2. This is because the resulting batten length is theoretically infinite.
        	:rtype: bool
        """
        return _FairCurve.FairCurve_Batten_GetFreeSliding(self, *args)


    def GetHeight(self, *args) -> "Standard_Real":
        """
        * Returns the thickness of the lathe.
        	:rtype: float
        """
        return _FairCurve.FairCurve_Batten_GetHeight(self, *args)


    def GetP1(self, *args) -> "gp_Pnt2d const":
        """
        * Returns the established location of the point P1.
        	:rtype: gp_Pnt2d
        """
        return _FairCurve.FairCurve_Batten_GetP1(self, *args)


    def GetP2(self, *args) -> "gp_Pnt2d const":
        """
        * Returns the established location of the point P2.
        	:rtype: gp_Pnt2d
        """
        return _FairCurve.FairCurve_Batten_GetP2(self, *args)


    def GetSlidingFactor(self, *args) -> "Standard_Real":
        """
        * Returns the initial sliding factor.
        	:rtype: float
        """
        return _FairCurve.FairCurve_Batten_GetSlidingFactor(self, *args)


    def GetSlope(self, *args) -> "Standard_Real":
        """
        * Returns the established slope value.
        	:rtype: float
        """
        return _FairCurve.FairCurve_Batten_GetSlope(self, *args)


    def SetAngle1(self, *args) -> "void":
        """
        * Allows you to change the angle Angle1 at the first point, P1. The default setting is 0.
        	:param Angle1:
        	:type Angle1: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetAngle1(self, *args)


    def SetAngle2(self, *args) -> "void":
        """
        * Allows you to change the angle Angle2 at the second point, P2. The default setting is 0.
        	:param Angle2:
        	:type Angle2: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetAngle2(self, *args)


    def SetConstraintOrder1(self, *args) -> "void":
        """
        * Allows you to change the order of the constraint on the first point. ConstraintOrder has the default setting of 1. The following settings are available: - 0-the curve must pass through a point - 1-the curve must pass through a point and have a given tangent - 2-the curve must pass through a point, have a given tangent and a given curvature. The third setting is only valid for FairCurve_MinimalVariation curves. These constraints, though geometric, represent the mechanical constraints due, for example, to the resistance of the material the actual physical batten is made of.
        	:param ConstraintOrder:
        	:type ConstraintOrder: int
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetConstraintOrder1(self, *args)


    def SetConstraintOrder2(self, *args) -> "void":
        """
        * Allows you to change the order of the constraint on the second point. ConstraintOrder is initialized with the default setting of 1. The following settings are available: - 0-the curve must pass through a point - 1-the curve must pass through a point and have a given tangent - 2-the curve must pass through a point, have a given tangent and a given curvature. The third setting is only valid for FairCurve_MinimalVariation curves. These constraints, though geometric, represent the mechanical constraints due, for example, to the resistance of the material the actual physical batten is made of.
        	:param ConstraintOrder:
        	:type ConstraintOrder: int
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetConstraintOrder2(self, *args)


    def SetFreeSliding(self, *args) -> "void":
        """
        * Freesliding is initialized with the default setting false. When Freesliding is set to true and, as a result, sliding is free, the sliding factor is automatically computed to satisfy the equilibrium of the batten.
        	:param FreeSliding:
        	:type FreeSliding: bool
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetFreeSliding(self, *args)


    def SetHeight(self, *args) -> "void":
        """
        * Allows you to change the height of the deformation. Raises NegativeValue; -- if Height <= 0 if Height <= 0
        	:param Height:
        	:type Height: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetHeight(self, *args)


    def SetP1(self, *args) -> "void":
        """
        * Allows you to change the location of the point, P1, and in doing so, modify the curve. Warning This method changes the angle as well as the point. Exceptions NullValue if the distance between P1 and P2 is less than or equal to the tolerance value for distance in Precision::Confusion: P1.IsEqual(P2, Precision::Confusion()). The function gp_Pnt2d::IsEqual tests to see if this is the case.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetP1(self, *args)


    def SetP2(self, *args) -> "void":
        """
        * Allows you to change the location of the point, P1, and in doing so, modify the curve. Warning This method changes the angle as well as the point. Exceptions NullValue if the distance between P1 and P2 is less than or equal to the tolerance value for distance in Precision::Confusion: P1.IsEqual(P2, Precision::Confusion()). The function gp_Pnt2d::IsEqual tests to see if this is the case.
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetP2(self, *args)


    def SetSlidingFactor(self, *args) -> "void":
        """
        * Allows you to change the ratio SlidingFactor. This compares the length of the batten and the reference length, which is, in turn, a function of the constraints. This modification has one of the following two effects: - if you increase the value, it inflates the batten - if you decrease the value, it flattens the batten. When sliding is free, the sliding factor is automatically computed to satisfy the equilibrium of the batten. When sliding is imposed, a value is required for the sliding factor. SlidingFactor is initialized with the default setting of 1.
        	:param SlidingFactor:
        	:type SlidingFactor: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetSlidingFactor(self, *args)


    def SetSlope(self, *args) -> "void":
        """
        * Allows you to set the slope value, Slope.
        	:param Slope:
        	:type Slope: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_Batten_SetSlope(self, *args)


    def SlidingOfReference(self, *args) -> "Standard_Real":
        """
        * Computes the real number value for length Sliding of Reference for new constraints. If you want to give a specific length to a batten curve, use the following syntax: b.SetSlidingFactor(L / b.SlidingOfReference()) where b is the name of the batten curve object.
        	:rtype: float
        """
        return _FairCurve.FairCurve_Batten_SlidingOfReference(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_Batten
FairCurve_Batten.Compute = new_instancemethod(_FairCurve.FairCurve_Batten_Compute, None, FairCurve_Batten)
FairCurve_Batten.Curve = new_instancemethod(_FairCurve.FairCurve_Batten_Curve, None, FairCurve_Batten)
FairCurve_Batten.DumpToString = new_instancemethod(_FairCurve.FairCurve_Batten_DumpToString, None, FairCurve_Batten)
FairCurve_Batten.GetAngle1 = new_instancemethod(_FairCurve.FairCurve_Batten_GetAngle1, None, FairCurve_Batten)
FairCurve_Batten.GetAngle2 = new_instancemethod(_FairCurve.FairCurve_Batten_GetAngle2, None, FairCurve_Batten)
FairCurve_Batten.GetConstraintOrder1 = new_instancemethod(_FairCurve.FairCurve_Batten_GetConstraintOrder1, None, FairCurve_Batten)
FairCurve_Batten.GetConstraintOrder2 = new_instancemethod(_FairCurve.FairCurve_Batten_GetConstraintOrder2, None, FairCurve_Batten)
FairCurve_Batten.GetFreeSliding = new_instancemethod(_FairCurve.FairCurve_Batten_GetFreeSliding, None, FairCurve_Batten)
FairCurve_Batten.GetHeight = new_instancemethod(_FairCurve.FairCurve_Batten_GetHeight, None, FairCurve_Batten)
FairCurve_Batten.GetP1 = new_instancemethod(_FairCurve.FairCurve_Batten_GetP1, None, FairCurve_Batten)
FairCurve_Batten.GetP2 = new_instancemethod(_FairCurve.FairCurve_Batten_GetP2, None, FairCurve_Batten)
FairCurve_Batten.GetSlidingFactor = new_instancemethod(_FairCurve.FairCurve_Batten_GetSlidingFactor, None, FairCurve_Batten)
FairCurve_Batten.GetSlope = new_instancemethod(_FairCurve.FairCurve_Batten_GetSlope, None, FairCurve_Batten)
FairCurve_Batten.SetAngle1 = new_instancemethod(_FairCurve.FairCurve_Batten_SetAngle1, None, FairCurve_Batten)
FairCurve_Batten.SetAngle2 = new_instancemethod(_FairCurve.FairCurve_Batten_SetAngle2, None, FairCurve_Batten)
FairCurve_Batten.SetConstraintOrder1 = new_instancemethod(_FairCurve.FairCurve_Batten_SetConstraintOrder1, None, FairCurve_Batten)
FairCurve_Batten.SetConstraintOrder2 = new_instancemethod(_FairCurve.FairCurve_Batten_SetConstraintOrder2, None, FairCurve_Batten)
FairCurve_Batten.SetFreeSliding = new_instancemethod(_FairCurve.FairCurve_Batten_SetFreeSliding, None, FairCurve_Batten)
FairCurve_Batten.SetHeight = new_instancemethod(_FairCurve.FairCurve_Batten_SetHeight, None, FairCurve_Batten)
FairCurve_Batten.SetP1 = new_instancemethod(_FairCurve.FairCurve_Batten_SetP1, None, FairCurve_Batten)
FairCurve_Batten.SetP2 = new_instancemethod(_FairCurve.FairCurve_Batten_SetP2, None, FairCurve_Batten)
FairCurve_Batten.SetSlidingFactor = new_instancemethod(_FairCurve.FairCurve_Batten_SetSlidingFactor, None, FairCurve_Batten)
FairCurve_Batten.SetSlope = new_instancemethod(_FairCurve.FairCurve_Batten_SetSlope, None, FairCurve_Batten)
FairCurve_Batten.SlidingOfReference = new_instancemethod(_FairCurve.FairCurve_Batten_SlidingOfReference, None, FairCurve_Batten)
FairCurve_Batten_swigregister = _FairCurve.FairCurve_Batten_swigregister
FairCurve_Batten_swigregister(FairCurve_Batten)

class FairCurve_BattenLaw(OCC.Core.math.math_Function):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor of linear batten with Heigth : the Heigth at the middle point Slope : the geometric slope of the batten Sliding : Active Length of the batten without extension
        	:param Heigth:
        	:type Heigth: float
        	:param Slope:
        	:type Slope: float
        	:param Sliding:
        	:type Sliding: float
        	:rtype: None
        """
        _FairCurve.FairCurve_BattenLaw_swiginit(self, _FairCurve.new_FairCurve_BattenLaw(*args))

    def SetHeigth(self, *args) -> "void":
        """
        * Change the value of Heigth at the middle point.
        	:param Heigth:
        	:type Heigth: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_BattenLaw_SetHeigth(self, *args)


    def SetSliding(self, *args) -> "void":
        """
        * Change the value of sliding
        	:param Sliding:
        	:type Sliding: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_BattenLaw_SetSliding(self, *args)


    def SetSlope(self, *args) -> "void":
        """
        * Change the value of the geometric slope.
        	:param Slope:
        	:type Slope: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_BattenLaw_SetSlope(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_BattenLaw
FairCurve_BattenLaw.SetHeigth = new_instancemethod(_FairCurve.FairCurve_BattenLaw_SetHeigth, None, FairCurve_BattenLaw)
FairCurve_BattenLaw.SetSliding = new_instancemethod(_FairCurve.FairCurve_BattenLaw_SetSliding, None, FairCurve_BattenLaw)
FairCurve_BattenLaw.SetSlope = new_instancemethod(_FairCurve.FairCurve_BattenLaw_SetSlope, None, FairCurve_BattenLaw)
FairCurve_BattenLaw_swigregister = _FairCurve.FairCurve_BattenLaw_swigregister
FairCurve_BattenLaw_swigregister(FairCurve_BattenLaw)

class FairCurve_DistributionOfEnergy(OCC.Core.math.math_FunctionSet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetDerivativeOrder(self, *args) -> "void":
        """
        :param DerivativeOrder:
        	:type DerivativeOrder: int
        	:rtype: None
        """
        return _FairCurve.FairCurve_DistributionOfEnergy_SetDerivativeOrder(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_DistributionOfEnergy
FairCurve_DistributionOfEnergy.SetDerivativeOrder = new_instancemethod(_FairCurve.FairCurve_DistributionOfEnergy_SetDerivativeOrder, None, FairCurve_DistributionOfEnergy)
FairCurve_DistributionOfEnergy_swigregister = _FairCurve.FairCurve_DistributionOfEnergy_swigregister
FairCurve_DistributionOfEnergy_swigregister(FairCurve_DistributionOfEnergy)

class FairCurve_Energy(OCC.Core.math.math_MultipleVarFunctionWithHessian):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Poles(self, *args) -> "opencascade::handle< TColgp_HArray1OfPnt2d > const &":
        """
        * return the poles
        	:rtype: opencascade::handle<TColgp_HArray1OfPnt2d>
        """
        return _FairCurve.FairCurve_Energy_Poles(self, *args)


    def Values(self, *args) -> "Standard_Boolean":
        """
        * computes the Energy <E> and the gradient <G> of the energy for the variable <X>. Returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: math_Vector
        	:param E:
        	:type E: float
        	:param G:
        	:type G: math_Vector
        	:rtype: bool
        * computes the Energy <E>, the gradient <G> and the Hessian <H> of the energy for the variable <X>. Returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: math_Vector
        	:param E:
        	:type E: float
        	:param G:
        	:type G: math_Vector
        	:param H:
        	:type H: math_Matrix
        	:rtype: bool
        """
        return _FairCurve.FairCurve_Energy_Values(self, *args)


    def Variable(self, *args) -> "Standard_Boolean":
        """
        * compute the variables <X> wich correspond with the field <MyPoles>
        	:param X:
        	:type X: math_Vector
        	:rtype: bool
        """
        return _FairCurve.FairCurve_Energy_Variable(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_Energy
FairCurve_Energy.Poles = new_instancemethod(_FairCurve.FairCurve_Energy_Poles, None, FairCurve_Energy)
FairCurve_Energy.Values = new_instancemethod(_FairCurve.FairCurve_Energy_Values, None, FairCurve_Energy)
FairCurve_Energy.Variable = new_instancemethod(_FairCurve.FairCurve_Energy_Variable, None, FairCurve_Energy)
FairCurve_Energy_swigregister = _FairCurve.FairCurve_Energy_swigregister
FairCurve_Energy_swigregister(FairCurve_Energy)

class FairCurve_Newton(OCC.Core.math.math_NewtonMinimum):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * The tolerance required on the solution is given by Tolerance. Iteration are stopped if (!WithSingularity) and H(F(Xi)) is not definite positive (if the smaller eigenvalue of H < Convexity) or IsConverged() returns True for 2 successives Iterations. Warning: This constructor do not computation
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunctionWithHessian
        	:param theSpatialTolerance: default value is 1.0e-7
        	:type theSpatialTolerance: float
        	:param theCriteriumTolerance: default value is 1.0e-7
        	:type theCriteriumTolerance: float
        	:param theNbIterations: default value is 40
        	:type theNbIterations: int
        	:param theConvexity: default value is 1.0e-6
        	:type theConvexity: float
        	:param theWithSingularity: default value is Standard_True
        	:type theWithSingularity: bool
        	:rtype: None
        """
        _FairCurve.FairCurve_Newton_swiginit(self, _FairCurve.new_FairCurve_Newton(*args))

    def IsConverged(self, *args) -> "Standard_Boolean":
        """
        * This method is called at the end of each iteration to check the convergence : || Xi+1 - Xi || < SpatialTolerance/100 Or || Xi+1 - Xi || < SpatialTolerance and |F(Xi+1) - F(Xi)| < CriteriumTolerance * |F(xi)| It can be redefined in a sub-class to implement a specific test.
        	:rtype: bool
        """
        return _FairCurve.FairCurve_Newton_IsConverged(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_Newton
FairCurve_Newton.IsConverged = new_instancemethod(_FairCurve.FairCurve_Newton_IsConverged, None, FairCurve_Newton)
FairCurve_Newton_swigregister = _FairCurve.FairCurve_Newton_swigregister
FairCurve_Newton_swigregister(FairCurve_Newton)

class FairCurve_DistributionOfJerk(FairCurve_DistributionOfEnergy):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param BSplOrder:
        	:type BSplOrder: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_HArray1OfReal
        	:param Poles:
        	:type Poles: TColgp_HArray1OfPnt2d
        	:param DerivativeOrder:
        	:type DerivativeOrder: int
        	:param Law:
        	:type Law: FairCurve_BattenLaw
        	:param NbValAux: default value is 0
        	:type NbValAux: int
        	:rtype: None
        """
        _FairCurve.FairCurve_DistributionOfJerk_swiginit(self, _FairCurve.new_FairCurve_DistributionOfJerk(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_DistributionOfJerk
FairCurve_DistributionOfJerk_swigregister = _FairCurve.FairCurve_DistributionOfJerk_swigregister
FairCurve_DistributionOfJerk_swigregister(FairCurve_DistributionOfJerk)

class FairCurve_DistributionOfSagging(FairCurve_DistributionOfEnergy):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param BSplOrder:
        	:type BSplOrder: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_HArray1OfReal
        	:param Poles:
        	:type Poles: TColgp_HArray1OfPnt2d
        	:param DerivativeOrder:
        	:type DerivativeOrder: int
        	:param Law:
        	:type Law: FairCurve_BattenLaw
        	:param NbValAux: default value is 0
        	:type NbValAux: int
        	:rtype: None
        """
        _FairCurve.FairCurve_DistributionOfSagging_swiginit(self, _FairCurve.new_FairCurve_DistributionOfSagging(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_DistributionOfSagging
FairCurve_DistributionOfSagging_swigregister = _FairCurve.FairCurve_DistributionOfSagging_swigregister
FairCurve_DistributionOfSagging_swigregister(FairCurve_DistributionOfSagging)

class FairCurve_DistributionOfTension(FairCurve_DistributionOfEnergy):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param BSplOrder:
        	:type BSplOrder: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_HArray1OfReal
        	:param Poles:
        	:type Poles: TColgp_HArray1OfPnt2d
        	:param DerivativeOrder:
        	:type DerivativeOrder: int
        	:param LengthSliding:
        	:type LengthSliding: float
        	:param Law:
        	:type Law: FairCurve_BattenLaw
        	:param NbValAux: default value is 0
        	:type NbValAux: int
        	:param Uniform: default value is Standard_False
        	:type Uniform: bool
        	:rtype: None
        """
        _FairCurve.FairCurve_DistributionOfTension_swiginit(self, _FairCurve.new_FairCurve_DistributionOfTension(*args))

    def SetLengthSliding(self, *args) -> "void":
        """
        * change the length sliding
        	:param LengthSliding:
        	:type LengthSliding: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_DistributionOfTension_SetLengthSliding(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_DistributionOfTension
FairCurve_DistributionOfTension.SetLengthSliding = new_instancemethod(_FairCurve.FairCurve_DistributionOfTension_SetLengthSliding, None, FairCurve_DistributionOfTension)
FairCurve_DistributionOfTension_swigregister = _FairCurve.FairCurve_DistributionOfTension_swigregister
FairCurve_DistributionOfTension_swigregister(FairCurve_DistributionOfTension)

class FairCurve_EnergyOfBatten(FairCurve_Energy):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Angles corresspond to the Ox axis
        	:param BSplOrder:
        	:type BSplOrder: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_HArray1OfReal
        	:param Poles:
        	:type Poles: TColgp_HArray1OfPnt2d
        	:param ContrOrder1:
        	:type ContrOrder1: int
        	:param ContrOrder2:
        	:type ContrOrder2: int
        	:param Law:
        	:type Law: FairCurve_BattenLaw
        	:param LengthSliding:
        	:type LengthSliding: float
        	:param FreeSliding: default value is Standard_True
        	:type FreeSliding: bool
        	:param Angle1: default value is 0
        	:type Angle1: float
        	:param Angle2: default value is 0
        	:type Angle2: float
        	:rtype: None
        """
        _FairCurve.FairCurve_EnergyOfBatten_swiginit(self, _FairCurve.new_FairCurve_EnergyOfBatten(*args))

    def LengthSliding(self, *args) -> "Standard_Real":
        """
        * return the lengthSliding = P1P2 + Sliding
        	:rtype: float
        """
        return _FairCurve.FairCurve_EnergyOfBatten_LengthSliding(self, *args)


    def Status(self, *args) -> "FairCurve_AnalysisCode":
        """
        * return the status
        	:rtype: FairCurve_AnalysisCode
        """
        return _FairCurve.FairCurve_EnergyOfBatten_Status(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_EnergyOfBatten
FairCurve_EnergyOfBatten.LengthSliding = new_instancemethod(_FairCurve.FairCurve_EnergyOfBatten_LengthSliding, None, FairCurve_EnergyOfBatten)
FairCurve_EnergyOfBatten.Status = new_instancemethod(_FairCurve.FairCurve_EnergyOfBatten_Status, None, FairCurve_EnergyOfBatten)
FairCurve_EnergyOfBatten_swigregister = _FairCurve.FairCurve_EnergyOfBatten_swigregister
FairCurve_EnergyOfBatten_swigregister(FairCurve_EnergyOfBatten)

class FairCurve_EnergyOfMVC(FairCurve_Energy):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Angles corresspond to the Ox axis
        	:param BSplOrder:
        	:type BSplOrder: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_HArray1OfReal
        	:param Poles:
        	:type Poles: TColgp_HArray1OfPnt2d
        	:param ContrOrder1:
        	:type ContrOrder1: int
        	:param ContrOrder2:
        	:type ContrOrder2: int
        	:param Law:
        	:type Law: FairCurve_BattenLaw
        	:param PhysicalRatio:
        	:type PhysicalRatio: float
        	:param LengthSliding:
        	:type LengthSliding: float
        	:param FreeSliding: default value is Standard_True
        	:type FreeSliding: bool
        	:param Angle1: default value is 0
        	:type Angle1: float
        	:param Angle2: default value is 0
        	:type Angle2: float
        	:param Curvature1: default value is 0
        	:type Curvature1: float
        	:param Curvature2: default value is 0
        	:type Curvature2: float
        	:rtype: None
        """
        _FairCurve.FairCurve_EnergyOfMVC_swiginit(self, _FairCurve.new_FairCurve_EnergyOfMVC(*args))

    def LengthSliding(self, *args) -> "Standard_Real":
        """
        * return the lengthSliding = P1P2 + Sliding
        	:rtype: float
        """
        return _FairCurve.FairCurve_EnergyOfMVC_LengthSliding(self, *args)


    def Status(self, *args) -> "FairCurve_AnalysisCode":
        """
        * return the status
        	:rtype: FairCurve_AnalysisCode
        """
        return _FairCurve.FairCurve_EnergyOfMVC_Status(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_EnergyOfMVC
FairCurve_EnergyOfMVC.LengthSliding = new_instancemethod(_FairCurve.FairCurve_EnergyOfMVC_LengthSliding, None, FairCurve_EnergyOfMVC)
FairCurve_EnergyOfMVC.Status = new_instancemethod(_FairCurve.FairCurve_EnergyOfMVC_Status, None, FairCurve_EnergyOfMVC)
FairCurve_EnergyOfMVC_swigregister = _FairCurve.FairCurve_EnergyOfMVC_swigregister
FairCurve_EnergyOfMVC_swigregister(FairCurve_EnergyOfMVC)

class FairCurve_MinimalVariation(FairCurve_Batten):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(FairCurve_MinimalVariation self) -> std::string"""
        return _FairCurve.FairCurve_MinimalVariation_DumpToString(self)


    def __init__(self, *args):
        """
        * Constructs the two contact points P1 and P2 and the geometrical characteristics of the batten (elastic beam) These include the real number values for height of deformation Height, slope value Slope, and kind of energy PhysicalRatio. The kinds of energy include: - Jerk (0) - Sagging (1). Note that the default setting for Physical Ration is in FairCurve_Batten Other parameters are initialized as follow : - FreeSliding = False - ConstraintOrder1 = 1 - ConstraintOrder2 = 1 - Angle1 = 0 - Angle2 = 0 - Curvature1 = 0 - Curvature2 = 0 - SlidingFactor = 1 Warning If PhysicalRatio equals 1, you cannot impose constraints on curvature. Exceptions NegativeValue if Height is less than or equal to 0. NullValue if the distance between P1 and P2 is less than or equal to the tolerance value for distance in Precision::Confusion: P1.IsEqual(P2, Precision::Confusion()). The function gp_Pnt2d::IsEqual tests to see if this is the case. Definition of the geometricals constraints
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:param Heigth:
        	:type Heigth: float
        	:param Slope: default value is 0
        	:type Slope: float
        	:param PhysicalRatio: default value is 0
        	:type PhysicalRatio: float
        	:rtype: None
        """
        _FairCurve.FairCurve_MinimalVariation_swiginit(self, _FairCurve.new_FairCurve_MinimalVariation(*args))

    def GetCurvature1(self, *args) -> "Standard_Real":
        """
        * Returns the first established curvature.
        	:rtype: float
        """
        return _FairCurve.FairCurve_MinimalVariation_GetCurvature1(self, *args)


    def GetCurvature2(self, *args) -> "Standard_Real":
        """
        * Returns the second established curvature.
        	:rtype: float
        """
        return _FairCurve.FairCurve_MinimalVariation_GetCurvature2(self, *args)


    def GetPhysicalRatio(self, *args) -> "Standard_Real":
        """
        * Returns the physical ratio, or kind of energy.
        	:rtype: float
        """
        return _FairCurve.FairCurve_MinimalVariation_GetPhysicalRatio(self, *args)


    def SetCurvature1(self, *args) -> "void":
        """
        * Allows you to set a new constraint on curvature at the first point.
        	:param Curvature:
        	:type Curvature: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_MinimalVariation_SetCurvature1(self, *args)


    def SetCurvature2(self, *args) -> "void":
        """
        * Allows you to set a new constraint on curvature at the second point.
        	:param Curvature:
        	:type Curvature: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_MinimalVariation_SetCurvature2(self, *args)


    def SetPhysicalRatio(self, *args) -> "void":
        """
        * Allows you to set the physical ratio Ratio. The kinds of energy which you can specify include: 0 is only 'Jerk' Energy 1 is only 'Sagging' Energy like batten Warning: if Ratio is 1 it is impossible to impose curvature constraints. Raises DomainError if Ratio < 0 or Ratio > 1
        	:param Ratio:
        	:type Ratio: float
        	:rtype: None
        """
        return _FairCurve.FairCurve_MinimalVariation_SetPhysicalRatio(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FairCurve.delete_FairCurve_MinimalVariation
FairCurve_MinimalVariation.DumpToString = new_instancemethod(_FairCurve.FairCurve_MinimalVariation_DumpToString, None, FairCurve_MinimalVariation)
FairCurve_MinimalVariation.GetCurvature1 = new_instancemethod(_FairCurve.FairCurve_MinimalVariation_GetCurvature1, None, FairCurve_MinimalVariation)
FairCurve_MinimalVariation.GetCurvature2 = new_instancemethod(_FairCurve.FairCurve_MinimalVariation_GetCurvature2, None, FairCurve_MinimalVariation)
FairCurve_MinimalVariation.GetPhysicalRatio = new_instancemethod(_FairCurve.FairCurve_MinimalVariation_GetPhysicalRatio, None, FairCurve_MinimalVariation)
FairCurve_MinimalVariation.SetCurvature1 = new_instancemethod(_FairCurve.FairCurve_MinimalVariation_SetCurvature1, None, FairCurve_MinimalVariation)
FairCurve_MinimalVariation.SetCurvature2 = new_instancemethod(_FairCurve.FairCurve_MinimalVariation_SetCurvature2, None, FairCurve_MinimalVariation)
FairCurve_MinimalVariation.SetPhysicalRatio = new_instancemethod(_FairCurve.FairCurve_MinimalVariation_SetPhysicalRatio, None, FairCurve_MinimalVariation)
FairCurve_MinimalVariation_swigregister = _FairCurve.FairCurve_MinimalVariation_swigregister
FairCurve_MinimalVariation_swigregister(FairCurve_MinimalVariation)



