# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
GeomFill module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_geomfill.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _GeomFill.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GeomFill')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GeomFill')
    _GeomFill = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GeomFill', [dirname(__file__)])
        except ImportError:
            import _GeomFill
            return _GeomFill
        try:
            _mod = imp.load_module('_GeomFill', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GeomFill = swig_import_helper()
    del swig_import_helper
else:
    import _GeomFill
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomFill.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_GeomFill.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_GeomFill.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_GeomFill.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_GeomFill.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_GeomFill.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_GeomFill.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_GeomFill.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_GeomFill.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_GeomFill.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_GeomFill.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_GeomFill.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_GeomFill.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_GeomFill.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_GeomFill.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_GeomFill.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_GeomFill.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _GeomFill.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _GeomFill.process_exception(error, method_name, class_name)
process_exception = _GeomFill.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Convert
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.gp
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.AppBlend
import OCC.Core.Approx
import OCC.Core.Adaptor3d
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.AppCont
import OCC.Core.AppParCurves
import OCC.Core.Law
import OCC.Core.TColGeom
GeomFill_Section = _GeomFill.GeomFill_Section
GeomFill_Location = _GeomFill.GeomFill_Location
GeomFill_IsCorrectedFrenet = _GeomFill.GeomFill_IsCorrectedFrenet
GeomFill_IsFixed = _GeomFill.GeomFill_IsFixed
GeomFill_IsFrenet = _GeomFill.GeomFill_IsFrenet
GeomFill_IsConstantNormal = _GeomFill.GeomFill_IsConstantNormal
GeomFill_IsDarboux = _GeomFill.GeomFill_IsDarboux
GeomFill_IsGuideAC = _GeomFill.GeomFill_IsGuideAC
GeomFill_IsGuidePlan = _GeomFill.GeomFill_IsGuidePlan
GeomFill_IsGuideACWithContact = _GeomFill.GeomFill_IsGuideACWithContact
GeomFill_IsGuidePlanWithContact = _GeomFill.GeomFill_IsGuidePlanWithContact
GeomFill_IsDiscreteTrihedron = _GeomFill.GeomFill_IsDiscreteTrihedron
GeomFill_StretchStyle = _GeomFill.GeomFill_StretchStyle
GeomFill_CoonsStyle = _GeomFill.GeomFill_CoonsStyle
GeomFill_CurvedStyle = _GeomFill.GeomFill_CurvedStyle
GeomFill_PipeOk = _GeomFill.GeomFill_PipeOk
GeomFill_PipeNotOk = _GeomFill.GeomFill_PipeNotOk
GeomFill_PlaneNotIntersectGuide = _GeomFill.GeomFill_PlaneNotIntersectGuide
GeomFill_ImpossibleContact = _GeomFill.GeomFill_ImpossibleContact

def Handle_GeomFill_Boundary_Create() -> "opencascade::handle< GeomFill_Boundary >":
    return _GeomFill.Handle_GeomFill_Boundary_Create()
Handle_GeomFill_Boundary_Create = _GeomFill.Handle_GeomFill_Boundary_Create

def Handle_GeomFill_Boundary_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_Boundary >":
    return _GeomFill.Handle_GeomFill_Boundary_DownCast(t)
Handle_GeomFill_Boundary_DownCast = _GeomFill.Handle_GeomFill_Boundary_DownCast

def Handle_GeomFill_Boundary_IsNull(t: 'opencascade::handle< GeomFill_Boundary > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_Boundary_IsNull(t)
Handle_GeomFill_Boundary_IsNull = _GeomFill.Handle_GeomFill_Boundary_IsNull

def Handle_GeomFill_CircularBlendFunc_Create() -> "opencascade::handle< GeomFill_CircularBlendFunc >":
    return _GeomFill.Handle_GeomFill_CircularBlendFunc_Create()
Handle_GeomFill_CircularBlendFunc_Create = _GeomFill.Handle_GeomFill_CircularBlendFunc_Create

def Handle_GeomFill_CircularBlendFunc_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_CircularBlendFunc >":
    return _GeomFill.Handle_GeomFill_CircularBlendFunc_DownCast(t)
Handle_GeomFill_CircularBlendFunc_DownCast = _GeomFill.Handle_GeomFill_CircularBlendFunc_DownCast

def Handle_GeomFill_CircularBlendFunc_IsNull(t: 'opencascade::handle< GeomFill_CircularBlendFunc > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_CircularBlendFunc_IsNull(t)
Handle_GeomFill_CircularBlendFunc_IsNull = _GeomFill.Handle_GeomFill_CircularBlendFunc_IsNull

def Handle_GeomFill_CoonsAlgPatch_Create() -> "opencascade::handle< GeomFill_CoonsAlgPatch >":
    return _GeomFill.Handle_GeomFill_CoonsAlgPatch_Create()
Handle_GeomFill_CoonsAlgPatch_Create = _GeomFill.Handle_GeomFill_CoonsAlgPatch_Create

def Handle_GeomFill_CoonsAlgPatch_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_CoonsAlgPatch >":
    return _GeomFill.Handle_GeomFill_CoonsAlgPatch_DownCast(t)
Handle_GeomFill_CoonsAlgPatch_DownCast = _GeomFill.Handle_GeomFill_CoonsAlgPatch_DownCast

def Handle_GeomFill_CoonsAlgPatch_IsNull(t: 'opencascade::handle< GeomFill_CoonsAlgPatch > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_CoonsAlgPatch_IsNull(t)
Handle_GeomFill_CoonsAlgPatch_IsNull = _GeomFill.Handle_GeomFill_CoonsAlgPatch_IsNull

def Handle_GeomFill_Line_Create() -> "opencascade::handle< GeomFill_Line >":
    return _GeomFill.Handle_GeomFill_Line_Create()
Handle_GeomFill_Line_Create = _GeomFill.Handle_GeomFill_Line_Create

def Handle_GeomFill_Line_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_Line >":
    return _GeomFill.Handle_GeomFill_Line_DownCast(t)
Handle_GeomFill_Line_DownCast = _GeomFill.Handle_GeomFill_Line_DownCast

def Handle_GeomFill_Line_IsNull(t: 'opencascade::handle< GeomFill_Line > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_Line_IsNull(t)
Handle_GeomFill_Line_IsNull = _GeomFill.Handle_GeomFill_Line_IsNull

def Handle_GeomFill_LocationLaw_Create() -> "opencascade::handle< GeomFill_LocationLaw >":
    return _GeomFill.Handle_GeomFill_LocationLaw_Create()
Handle_GeomFill_LocationLaw_Create = _GeomFill.Handle_GeomFill_LocationLaw_Create

def Handle_GeomFill_LocationLaw_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_LocationLaw >":
    return _GeomFill.Handle_GeomFill_LocationLaw_DownCast(t)
Handle_GeomFill_LocationLaw_DownCast = _GeomFill.Handle_GeomFill_LocationLaw_DownCast

def Handle_GeomFill_LocationLaw_IsNull(t: 'opencascade::handle< GeomFill_LocationLaw > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_LocationLaw_IsNull(t)
Handle_GeomFill_LocationLaw_IsNull = _GeomFill.Handle_GeomFill_LocationLaw_IsNull

def Handle_GeomFill_SectionLaw_Create() -> "opencascade::handle< GeomFill_SectionLaw >":
    return _GeomFill.Handle_GeomFill_SectionLaw_Create()
Handle_GeomFill_SectionLaw_Create = _GeomFill.Handle_GeomFill_SectionLaw_Create

def Handle_GeomFill_SectionLaw_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_SectionLaw >":
    return _GeomFill.Handle_GeomFill_SectionLaw_DownCast(t)
Handle_GeomFill_SectionLaw_DownCast = _GeomFill.Handle_GeomFill_SectionLaw_DownCast

def Handle_GeomFill_SectionLaw_IsNull(t: 'opencascade::handle< GeomFill_SectionLaw > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_SectionLaw_IsNull(t)
Handle_GeomFill_SectionLaw_IsNull = _GeomFill.Handle_GeomFill_SectionLaw_IsNull

def Handle_GeomFill_SweepFunction_Create() -> "opencascade::handle< GeomFill_SweepFunction >":
    return _GeomFill.Handle_GeomFill_SweepFunction_Create()
Handle_GeomFill_SweepFunction_Create = _GeomFill.Handle_GeomFill_SweepFunction_Create

def Handle_GeomFill_SweepFunction_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_SweepFunction >":
    return _GeomFill.Handle_GeomFill_SweepFunction_DownCast(t)
Handle_GeomFill_SweepFunction_DownCast = _GeomFill.Handle_GeomFill_SweepFunction_DownCast

def Handle_GeomFill_SweepFunction_IsNull(t: 'opencascade::handle< GeomFill_SweepFunction > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_SweepFunction_IsNull(t)
Handle_GeomFill_SweepFunction_IsNull = _GeomFill.Handle_GeomFill_SweepFunction_IsNull

def Handle_GeomFill_TgtField_Create() -> "opencascade::handle< GeomFill_TgtField >":
    return _GeomFill.Handle_GeomFill_TgtField_Create()
Handle_GeomFill_TgtField_Create = _GeomFill.Handle_GeomFill_TgtField_Create

def Handle_GeomFill_TgtField_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_TgtField >":
    return _GeomFill.Handle_GeomFill_TgtField_DownCast(t)
Handle_GeomFill_TgtField_DownCast = _GeomFill.Handle_GeomFill_TgtField_DownCast

def Handle_GeomFill_TgtField_IsNull(t: 'opencascade::handle< GeomFill_TgtField > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_TgtField_IsNull(t)
Handle_GeomFill_TgtField_IsNull = _GeomFill.Handle_GeomFill_TgtField_IsNull

def Handle_GeomFill_TrihedronLaw_Create() -> "opencascade::handle< GeomFill_TrihedronLaw >":
    return _GeomFill.Handle_GeomFill_TrihedronLaw_Create()
Handle_GeomFill_TrihedronLaw_Create = _GeomFill.Handle_GeomFill_TrihedronLaw_Create

def Handle_GeomFill_TrihedronLaw_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_TrihedronLaw >":
    return _GeomFill.Handle_GeomFill_TrihedronLaw_DownCast(t)
Handle_GeomFill_TrihedronLaw_DownCast = _GeomFill.Handle_GeomFill_TrihedronLaw_DownCast

def Handle_GeomFill_TrihedronLaw_IsNull(t: 'opencascade::handle< GeomFill_TrihedronLaw > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_TrihedronLaw_IsNull(t)
Handle_GeomFill_TrihedronLaw_IsNull = _GeomFill.Handle_GeomFill_TrihedronLaw_IsNull

def Handle_GeomFill_BoundWithSurf_Create() -> "opencascade::handle< GeomFill_BoundWithSurf >":
    return _GeomFill.Handle_GeomFill_BoundWithSurf_Create()
Handle_GeomFill_BoundWithSurf_Create = _GeomFill.Handle_GeomFill_BoundWithSurf_Create

def Handle_GeomFill_BoundWithSurf_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_BoundWithSurf >":
    return _GeomFill.Handle_GeomFill_BoundWithSurf_DownCast(t)
Handle_GeomFill_BoundWithSurf_DownCast = _GeomFill.Handle_GeomFill_BoundWithSurf_DownCast

def Handle_GeomFill_BoundWithSurf_IsNull(t: 'opencascade::handle< GeomFill_BoundWithSurf > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_BoundWithSurf_IsNull(t)
Handle_GeomFill_BoundWithSurf_IsNull = _GeomFill.Handle_GeomFill_BoundWithSurf_IsNull

def Handle_GeomFill_ConstantBiNormal_Create() -> "opencascade::handle< GeomFill_ConstantBiNormal >":
    return _GeomFill.Handle_GeomFill_ConstantBiNormal_Create()
Handle_GeomFill_ConstantBiNormal_Create = _GeomFill.Handle_GeomFill_ConstantBiNormal_Create

def Handle_GeomFill_ConstantBiNormal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_ConstantBiNormal >":
    return _GeomFill.Handle_GeomFill_ConstantBiNormal_DownCast(t)
Handle_GeomFill_ConstantBiNormal_DownCast = _GeomFill.Handle_GeomFill_ConstantBiNormal_DownCast

def Handle_GeomFill_ConstantBiNormal_IsNull(t: 'opencascade::handle< GeomFill_ConstantBiNormal > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_ConstantBiNormal_IsNull(t)
Handle_GeomFill_ConstantBiNormal_IsNull = _GeomFill.Handle_GeomFill_ConstantBiNormal_IsNull

def Handle_GeomFill_CorrectedFrenet_Create() -> "opencascade::handle< GeomFill_CorrectedFrenet >":
    return _GeomFill.Handle_GeomFill_CorrectedFrenet_Create()
Handle_GeomFill_CorrectedFrenet_Create = _GeomFill.Handle_GeomFill_CorrectedFrenet_Create

def Handle_GeomFill_CorrectedFrenet_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_CorrectedFrenet >":
    return _GeomFill.Handle_GeomFill_CorrectedFrenet_DownCast(t)
Handle_GeomFill_CorrectedFrenet_DownCast = _GeomFill.Handle_GeomFill_CorrectedFrenet_DownCast

def Handle_GeomFill_CorrectedFrenet_IsNull(t: 'opencascade::handle< GeomFill_CorrectedFrenet > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_CorrectedFrenet_IsNull(t)
Handle_GeomFill_CorrectedFrenet_IsNull = _GeomFill.Handle_GeomFill_CorrectedFrenet_IsNull

def Handle_GeomFill_CurveAndTrihedron_Create() -> "opencascade::handle< GeomFill_CurveAndTrihedron >":
    return _GeomFill.Handle_GeomFill_CurveAndTrihedron_Create()
Handle_GeomFill_CurveAndTrihedron_Create = _GeomFill.Handle_GeomFill_CurveAndTrihedron_Create

def Handle_GeomFill_CurveAndTrihedron_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_CurveAndTrihedron >":
    return _GeomFill.Handle_GeomFill_CurveAndTrihedron_DownCast(t)
Handle_GeomFill_CurveAndTrihedron_DownCast = _GeomFill.Handle_GeomFill_CurveAndTrihedron_DownCast

def Handle_GeomFill_CurveAndTrihedron_IsNull(t: 'opencascade::handle< GeomFill_CurveAndTrihedron > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_CurveAndTrihedron_IsNull(t)
Handle_GeomFill_CurveAndTrihedron_IsNull = _GeomFill.Handle_GeomFill_CurveAndTrihedron_IsNull

def Handle_GeomFill_Darboux_Create() -> "opencascade::handle< GeomFill_Darboux >":
    return _GeomFill.Handle_GeomFill_Darboux_Create()
Handle_GeomFill_Darboux_Create = _GeomFill.Handle_GeomFill_Darboux_Create

def Handle_GeomFill_Darboux_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_Darboux >":
    return _GeomFill.Handle_GeomFill_Darboux_DownCast(t)
Handle_GeomFill_Darboux_DownCast = _GeomFill.Handle_GeomFill_Darboux_DownCast

def Handle_GeomFill_Darboux_IsNull(t: 'opencascade::handle< GeomFill_Darboux > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_Darboux_IsNull(t)
Handle_GeomFill_Darboux_IsNull = _GeomFill.Handle_GeomFill_Darboux_IsNull

def Handle_GeomFill_DegeneratedBound_Create() -> "opencascade::handle< GeomFill_DegeneratedBound >":
    return _GeomFill.Handle_GeomFill_DegeneratedBound_Create()
Handle_GeomFill_DegeneratedBound_Create = _GeomFill.Handle_GeomFill_DegeneratedBound_Create

def Handle_GeomFill_DegeneratedBound_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_DegeneratedBound >":
    return _GeomFill.Handle_GeomFill_DegeneratedBound_DownCast(t)
Handle_GeomFill_DegeneratedBound_DownCast = _GeomFill.Handle_GeomFill_DegeneratedBound_DownCast

def Handle_GeomFill_DegeneratedBound_IsNull(t: 'opencascade::handle< GeomFill_DegeneratedBound > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_DegeneratedBound_IsNull(t)
Handle_GeomFill_DegeneratedBound_IsNull = _GeomFill.Handle_GeomFill_DegeneratedBound_IsNull

def Handle_GeomFill_DiscreteTrihedron_Create() -> "opencascade::handle< GeomFill_DiscreteTrihedron >":
    return _GeomFill.Handle_GeomFill_DiscreteTrihedron_Create()
Handle_GeomFill_DiscreteTrihedron_Create = _GeomFill.Handle_GeomFill_DiscreteTrihedron_Create

def Handle_GeomFill_DiscreteTrihedron_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_DiscreteTrihedron >":
    return _GeomFill.Handle_GeomFill_DiscreteTrihedron_DownCast(t)
Handle_GeomFill_DiscreteTrihedron_DownCast = _GeomFill.Handle_GeomFill_DiscreteTrihedron_DownCast

def Handle_GeomFill_DiscreteTrihedron_IsNull(t: 'opencascade::handle< GeomFill_DiscreteTrihedron > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_DiscreteTrihedron_IsNull(t)
Handle_GeomFill_DiscreteTrihedron_IsNull = _GeomFill.Handle_GeomFill_DiscreteTrihedron_IsNull

def Handle_GeomFill_DraftTrihedron_Create() -> "opencascade::handle< GeomFill_DraftTrihedron >":
    return _GeomFill.Handle_GeomFill_DraftTrihedron_Create()
Handle_GeomFill_DraftTrihedron_Create = _GeomFill.Handle_GeomFill_DraftTrihedron_Create

def Handle_GeomFill_DraftTrihedron_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_DraftTrihedron >":
    return _GeomFill.Handle_GeomFill_DraftTrihedron_DownCast(t)
Handle_GeomFill_DraftTrihedron_DownCast = _GeomFill.Handle_GeomFill_DraftTrihedron_DownCast

def Handle_GeomFill_DraftTrihedron_IsNull(t: 'opencascade::handle< GeomFill_DraftTrihedron > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_DraftTrihedron_IsNull(t)
Handle_GeomFill_DraftTrihedron_IsNull = _GeomFill.Handle_GeomFill_DraftTrihedron_IsNull

def Handle_GeomFill_EvolvedSection_Create() -> "opencascade::handle< GeomFill_EvolvedSection >":
    return _GeomFill.Handle_GeomFill_EvolvedSection_Create()
Handle_GeomFill_EvolvedSection_Create = _GeomFill.Handle_GeomFill_EvolvedSection_Create

def Handle_GeomFill_EvolvedSection_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_EvolvedSection >":
    return _GeomFill.Handle_GeomFill_EvolvedSection_DownCast(t)
Handle_GeomFill_EvolvedSection_DownCast = _GeomFill.Handle_GeomFill_EvolvedSection_DownCast

def Handle_GeomFill_EvolvedSection_IsNull(t: 'opencascade::handle< GeomFill_EvolvedSection > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_EvolvedSection_IsNull(t)
Handle_GeomFill_EvolvedSection_IsNull = _GeomFill.Handle_GeomFill_EvolvedSection_IsNull

def Handle_GeomFill_Fixed_Create() -> "opencascade::handle< GeomFill_Fixed >":
    return _GeomFill.Handle_GeomFill_Fixed_Create()
Handle_GeomFill_Fixed_Create = _GeomFill.Handle_GeomFill_Fixed_Create

def Handle_GeomFill_Fixed_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_Fixed >":
    return _GeomFill.Handle_GeomFill_Fixed_DownCast(t)
Handle_GeomFill_Fixed_DownCast = _GeomFill.Handle_GeomFill_Fixed_DownCast

def Handle_GeomFill_Fixed_IsNull(t: 'opencascade::handle< GeomFill_Fixed > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_Fixed_IsNull(t)
Handle_GeomFill_Fixed_IsNull = _GeomFill.Handle_GeomFill_Fixed_IsNull

def Handle_GeomFill_Frenet_Create() -> "opencascade::handle< GeomFill_Frenet >":
    return _GeomFill.Handle_GeomFill_Frenet_Create()
Handle_GeomFill_Frenet_Create = _GeomFill.Handle_GeomFill_Frenet_Create

def Handle_GeomFill_Frenet_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_Frenet >":
    return _GeomFill.Handle_GeomFill_Frenet_DownCast(t)
Handle_GeomFill_Frenet_DownCast = _GeomFill.Handle_GeomFill_Frenet_DownCast

def Handle_GeomFill_Frenet_IsNull(t: 'opencascade::handle< GeomFill_Frenet > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_Frenet_IsNull(t)
Handle_GeomFill_Frenet_IsNull = _GeomFill.Handle_GeomFill_Frenet_IsNull

def Handle_GeomFill_LocationDraft_Create() -> "opencascade::handle< GeomFill_LocationDraft >":
    return _GeomFill.Handle_GeomFill_LocationDraft_Create()
Handle_GeomFill_LocationDraft_Create = _GeomFill.Handle_GeomFill_LocationDraft_Create

def Handle_GeomFill_LocationDraft_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_LocationDraft >":
    return _GeomFill.Handle_GeomFill_LocationDraft_DownCast(t)
Handle_GeomFill_LocationDraft_DownCast = _GeomFill.Handle_GeomFill_LocationDraft_DownCast

def Handle_GeomFill_LocationDraft_IsNull(t: 'opencascade::handle< GeomFill_LocationDraft > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_LocationDraft_IsNull(t)
Handle_GeomFill_LocationDraft_IsNull = _GeomFill.Handle_GeomFill_LocationDraft_IsNull

def Handle_GeomFill_LocationGuide_Create() -> "opencascade::handle< GeomFill_LocationGuide >":
    return _GeomFill.Handle_GeomFill_LocationGuide_Create()
Handle_GeomFill_LocationGuide_Create = _GeomFill.Handle_GeomFill_LocationGuide_Create

def Handle_GeomFill_LocationGuide_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_LocationGuide >":
    return _GeomFill.Handle_GeomFill_LocationGuide_DownCast(t)
Handle_GeomFill_LocationGuide_DownCast = _GeomFill.Handle_GeomFill_LocationGuide_DownCast

def Handle_GeomFill_LocationGuide_IsNull(t: 'opencascade::handle< GeomFill_LocationGuide > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_LocationGuide_IsNull(t)
Handle_GeomFill_LocationGuide_IsNull = _GeomFill.Handle_GeomFill_LocationGuide_IsNull

def Handle_GeomFill_SimpleBound_Create() -> "opencascade::handle< GeomFill_SimpleBound >":
    return _GeomFill.Handle_GeomFill_SimpleBound_Create()
Handle_GeomFill_SimpleBound_Create = _GeomFill.Handle_GeomFill_SimpleBound_Create

def Handle_GeomFill_SimpleBound_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_SimpleBound >":
    return _GeomFill.Handle_GeomFill_SimpleBound_DownCast(t)
Handle_GeomFill_SimpleBound_DownCast = _GeomFill.Handle_GeomFill_SimpleBound_DownCast

def Handle_GeomFill_SimpleBound_IsNull(t: 'opencascade::handle< GeomFill_SimpleBound > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_SimpleBound_IsNull(t)
Handle_GeomFill_SimpleBound_IsNull = _GeomFill.Handle_GeomFill_SimpleBound_IsNull

def Handle_GeomFill_TgtOnCoons_Create() -> "opencascade::handle< GeomFill_TgtOnCoons >":
    return _GeomFill.Handle_GeomFill_TgtOnCoons_Create()
Handle_GeomFill_TgtOnCoons_Create = _GeomFill.Handle_GeomFill_TgtOnCoons_Create

def Handle_GeomFill_TgtOnCoons_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_TgtOnCoons >":
    return _GeomFill.Handle_GeomFill_TgtOnCoons_DownCast(t)
Handle_GeomFill_TgtOnCoons_DownCast = _GeomFill.Handle_GeomFill_TgtOnCoons_DownCast

def Handle_GeomFill_TgtOnCoons_IsNull(t: 'opencascade::handle< GeomFill_TgtOnCoons > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_TgtOnCoons_IsNull(t)
Handle_GeomFill_TgtOnCoons_IsNull = _GeomFill.Handle_GeomFill_TgtOnCoons_IsNull

def Handle_GeomFill_TrihedronWithGuide_Create() -> "opencascade::handle< GeomFill_TrihedronWithGuide >":
    return _GeomFill.Handle_GeomFill_TrihedronWithGuide_Create()
Handle_GeomFill_TrihedronWithGuide_Create = _GeomFill.Handle_GeomFill_TrihedronWithGuide_Create

def Handle_GeomFill_TrihedronWithGuide_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_TrihedronWithGuide >":
    return _GeomFill.Handle_GeomFill_TrihedronWithGuide_DownCast(t)
Handle_GeomFill_TrihedronWithGuide_DownCast = _GeomFill.Handle_GeomFill_TrihedronWithGuide_DownCast

def Handle_GeomFill_TrihedronWithGuide_IsNull(t: 'opencascade::handle< GeomFill_TrihedronWithGuide > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_TrihedronWithGuide_IsNull(t)
Handle_GeomFill_TrihedronWithGuide_IsNull = _GeomFill.Handle_GeomFill_TrihedronWithGuide_IsNull

def Handle_GeomFill_UniformSection_Create() -> "opencascade::handle< GeomFill_UniformSection >":
    return _GeomFill.Handle_GeomFill_UniformSection_Create()
Handle_GeomFill_UniformSection_Create = _GeomFill.Handle_GeomFill_UniformSection_Create

def Handle_GeomFill_UniformSection_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_UniformSection >":
    return _GeomFill.Handle_GeomFill_UniformSection_DownCast(t)
Handle_GeomFill_UniformSection_DownCast = _GeomFill.Handle_GeomFill_UniformSection_DownCast

def Handle_GeomFill_UniformSection_IsNull(t: 'opencascade::handle< GeomFill_UniformSection > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_UniformSection_IsNull(t)
Handle_GeomFill_UniformSection_IsNull = _GeomFill.Handle_GeomFill_UniformSection_IsNull

def Handle_GeomFill_GuideTrihedronAC_Create() -> "opencascade::handle< GeomFill_GuideTrihedronAC >":
    return _GeomFill.Handle_GeomFill_GuideTrihedronAC_Create()
Handle_GeomFill_GuideTrihedronAC_Create = _GeomFill.Handle_GeomFill_GuideTrihedronAC_Create

def Handle_GeomFill_GuideTrihedronAC_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_GuideTrihedronAC >":
    return _GeomFill.Handle_GeomFill_GuideTrihedronAC_DownCast(t)
Handle_GeomFill_GuideTrihedronAC_DownCast = _GeomFill.Handle_GeomFill_GuideTrihedronAC_DownCast

def Handle_GeomFill_GuideTrihedronAC_IsNull(t: 'opencascade::handle< GeomFill_GuideTrihedronAC > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_GuideTrihedronAC_IsNull(t)
Handle_GeomFill_GuideTrihedronAC_IsNull = _GeomFill.Handle_GeomFill_GuideTrihedronAC_IsNull

def Handle_GeomFill_GuideTrihedronPlan_Create() -> "opencascade::handle< GeomFill_GuideTrihedronPlan >":
    return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_Create()
Handle_GeomFill_GuideTrihedronPlan_Create = _GeomFill.Handle_GeomFill_GuideTrihedronPlan_Create

def Handle_GeomFill_GuideTrihedronPlan_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_GuideTrihedronPlan >":
    return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_DownCast(t)
Handle_GeomFill_GuideTrihedronPlan_DownCast = _GeomFill.Handle_GeomFill_GuideTrihedronPlan_DownCast

def Handle_GeomFill_GuideTrihedronPlan_IsNull(t: 'opencascade::handle< GeomFill_GuideTrihedronPlan > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_IsNull(t)
Handle_GeomFill_GuideTrihedronPlan_IsNull = _GeomFill.Handle_GeomFill_GuideTrihedronPlan_IsNull

def Handle_GeomFill_HArray1OfLocationLaw_Create() -> "opencascade::handle< GeomFill_HArray1OfLocationLaw >":
    return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_Create()
Handle_GeomFill_HArray1OfLocationLaw_Create = _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_Create

def Handle_GeomFill_HArray1OfLocationLaw_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_HArray1OfLocationLaw >":
    return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_DownCast(t)
Handle_GeomFill_HArray1OfLocationLaw_DownCast = _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_DownCast

def Handle_GeomFill_HArray1OfLocationLaw_IsNull(t: 'opencascade::handle< GeomFill_HArray1OfLocationLaw > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_IsNull(t)
Handle_GeomFill_HArray1OfLocationLaw_IsNull = _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_IsNull

def Handle_GeomFill_HArray1OfSectionLaw_Create() -> "opencascade::handle< GeomFill_HArray1OfSectionLaw >":
    return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_Create()
Handle_GeomFill_HArray1OfSectionLaw_Create = _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_Create

def Handle_GeomFill_HArray1OfSectionLaw_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_HArray1OfSectionLaw >":
    return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_DownCast(t)
Handle_GeomFill_HArray1OfSectionLaw_DownCast = _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_DownCast

def Handle_GeomFill_HArray1OfSectionLaw_IsNull(t: 'opencascade::handle< GeomFill_HArray1OfSectionLaw > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_IsNull(t)
Handle_GeomFill_HArray1OfSectionLaw_IsNull = _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_IsNull

def Handle_GeomFill_HSequenceOfAx2_Create() -> "opencascade::handle< GeomFill_HSequenceOfAx2 >":
    return _GeomFill.Handle_GeomFill_HSequenceOfAx2_Create()
Handle_GeomFill_HSequenceOfAx2_Create = _GeomFill.Handle_GeomFill_HSequenceOfAx2_Create

def Handle_GeomFill_HSequenceOfAx2_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< GeomFill_HSequenceOfAx2 >":
    return _GeomFill.Handle_GeomFill_HSequenceOfAx2_DownCast(t)
Handle_GeomFill_HSequenceOfAx2_DownCast = _GeomFill.Handle_GeomFill_HSequenceOfAx2_DownCast

def Handle_GeomFill_HSequenceOfAx2_IsNull(t: 'opencascade::handle< GeomFill_HSequenceOfAx2 > const &') -> "bool":
    return _GeomFill.Handle_GeomFill_HSequenceOfAx2_IsNull(t)
Handle_GeomFill_HSequenceOfAx2_IsNull = _GeomFill.Handle_GeomFill_HSequenceOfAx2_IsNull
class GeomFill_SequenceOfTrsf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _GeomFill.GeomFill_SequenceOfTrsf_swiginit(self, _GeomFill.new_GeomFill_SequenceOfTrsf(*args))
    delNode = staticmethod(_GeomFill.GeomFill_SequenceOfTrsf_delNode)
    __swig_destroy__ = _GeomFill.delete_GeomFill_SequenceOfTrsf
GeomFill_SequenceOfTrsf.begin = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_begin, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.end = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_end, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.cbegin = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_cbegin, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.cend = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_cend, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Size = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Size, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Length = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Length, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Lower = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Lower, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Upper = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Upper, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.IsEmpty = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_IsEmpty, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Reverse = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Reverse, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Exchange = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Exchange, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Clear = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Clear, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Assign = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Assign, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Set = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Set, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Remove = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Remove, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Append = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Append, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Prepend = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Prepend, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.InsertBefore = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_InsertBefore, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.InsertAfter = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_InsertAfter, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Split = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Split, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.First = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_First, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.ChangeFirst = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_ChangeFirst, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Last = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Last, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.ChangeLast = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_ChangeLast, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.Value = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_Value, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.ChangeValue = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_ChangeValue, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.__call__ = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf___call__, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf.SetValue = new_instancemethod(_GeomFill.GeomFill_SequenceOfTrsf_SetValue, None, GeomFill_SequenceOfTrsf)
GeomFill_SequenceOfTrsf_swigregister = _GeomFill.GeomFill_SequenceOfTrsf_swigregister
GeomFill_SequenceOfTrsf_swigregister(GeomFill_SequenceOfTrsf)

def GeomFill_SequenceOfTrsf_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _GeomFill.GeomFill_SequenceOfTrsf_delNode(theNode, theAl)
GeomFill_SequenceOfTrsf_delNode = _GeomFill.GeomFill_SequenceOfTrsf_delNode

class GeomFill_Array1OfLocationLaw(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _GeomFill.GeomFill_Array1OfLocationLaw_swiginit(self, _GeomFill.new_GeomFill_Array1OfLocationLaw(*args))
    __swig_destroy__ = _GeomFill.delete_GeomFill_Array1OfLocationLaw

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

GeomFill_Array1OfLocationLaw.begin = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_begin, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.end = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_end, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.cbegin = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_cbegin, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.cend = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_cend, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Init = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Init, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Size = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Size, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Length = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Length, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.IsEmpty = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_IsEmpty, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Lower = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Lower, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Upper = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Upper, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.IsDeletable = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_IsDeletable, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.IsAllocated = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_IsAllocated, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Assign = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Assign, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Move = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Move, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Set = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Set, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.First = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_First, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.ChangeFirst = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_ChangeFirst, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Last = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Last, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.ChangeLast = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_ChangeLast, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Value = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Value, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.ChangeValue = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_ChangeValue, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.__call__ = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw___call__, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.SetValue = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_SetValue, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw.Resize = new_instancemethod(_GeomFill.GeomFill_Array1OfLocationLaw_Resize, None, GeomFill_Array1OfLocationLaw)
GeomFill_Array1OfLocationLaw_swigregister = _GeomFill.GeomFill_Array1OfLocationLaw_swigregister
GeomFill_Array1OfLocationLaw_swigregister(GeomFill_Array1OfLocationLaw)

class GeomFill_Array1OfSectionLaw(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _GeomFill.GeomFill_Array1OfSectionLaw_swiginit(self, _GeomFill.new_GeomFill_Array1OfSectionLaw(*args))
    __swig_destroy__ = _GeomFill.delete_GeomFill_Array1OfSectionLaw

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

GeomFill_Array1OfSectionLaw.begin = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_begin, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.end = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_end, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.cbegin = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_cbegin, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.cend = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_cend, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Init = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Init, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Size = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Size, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Length = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Length, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.IsEmpty = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_IsEmpty, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Lower = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Lower, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Upper = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Upper, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.IsDeletable = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_IsDeletable, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.IsAllocated = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_IsAllocated, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Assign = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Assign, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Move = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Move, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Set = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Set, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.First = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_First, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.ChangeFirst = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_ChangeFirst, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Last = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Last, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.ChangeLast = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_ChangeLast, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Value = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Value, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.ChangeValue = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_ChangeValue, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.__call__ = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw___call__, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.SetValue = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_SetValue, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw.Resize = new_instancemethod(_GeomFill.GeomFill_Array1OfSectionLaw_Resize, None, GeomFill_Array1OfSectionLaw)
GeomFill_Array1OfSectionLaw_swigregister = _GeomFill.GeomFill_Array1OfSectionLaw_swigregister
GeomFill_Array1OfSectionLaw_swigregister(GeomFill_Array1OfSectionLaw)

class GeomFill_SequenceOfAx2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _GeomFill.GeomFill_SequenceOfAx2_swiginit(self, _GeomFill.new_GeomFill_SequenceOfAx2(*args))
    delNode = staticmethod(_GeomFill.GeomFill_SequenceOfAx2_delNode)
    __swig_destroy__ = _GeomFill.delete_GeomFill_SequenceOfAx2
GeomFill_SequenceOfAx2.begin = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_begin, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.end = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_end, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.cbegin = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_cbegin, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.cend = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_cend, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Size = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Size, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Length = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Length, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Lower = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Lower, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Upper = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Upper, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.IsEmpty = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_IsEmpty, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Reverse = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Reverse, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Exchange = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Exchange, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Clear = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Clear, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Assign = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Assign, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Set = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Set, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Remove = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Remove, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Append = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Append, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Prepend = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Prepend, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.InsertBefore = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_InsertBefore, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.InsertAfter = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_InsertAfter, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Split = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Split, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.First = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_First, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.ChangeFirst = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_ChangeFirst, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Last = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Last, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.ChangeLast = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_ChangeLast, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.Value = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_Value, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.ChangeValue = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_ChangeValue, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.__call__ = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2___call__, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2.SetValue = new_instancemethod(_GeomFill.GeomFill_SequenceOfAx2_SetValue, None, GeomFill_SequenceOfAx2)
GeomFill_SequenceOfAx2_swigregister = _GeomFill.GeomFill_SequenceOfAx2_swigregister
GeomFill_SequenceOfAx2_swigregister(GeomFill_SequenceOfAx2)

def GeomFill_SequenceOfAx2_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _GeomFill.GeomFill_SequenceOfAx2_delNode(theNode, theAl)
GeomFill_SequenceOfAx2_delNode = _GeomFill.GeomFill_SequenceOfAx2_delNode

class geomfill(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetCircle(*args) -> "Standard_Boolean":
        """
        :param TConv:
        	:type TConv: Convert_ParameterisationType
        	:param ns1:
        	:type ns1: gp_Vec
        	:param ns2:
        	:type ns2: gp_Vec
        	:param nplan:
        	:type nplan: gp_Vec
        	:param pt1:
        	:type pt1: gp_Pnt
        	:param pt2:
        	:type pt2: gp_Pnt
        	:param Rayon:
        	:type Rayon: float
        	:param Center:
        	:type Center: gp_Pnt
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        :param TConv:
        	:type TConv: Convert_ParameterisationType
        	:param ns1:
        	:type ns1: gp_Vec
        	:param ns2:
        	:type ns2: gp_Vec
        	:param dn1w:
        	:type dn1w: gp_Vec
        	:param dn2w:
        	:type dn2w: gp_Vec
        	:param nplan:
        	:type nplan: gp_Vec
        	:param dnplan:
        	:type dnplan: gp_Vec
        	:param pts1:
        	:type pts1: gp_Pnt
        	:param pts2:
        	:type pts2: gp_Pnt
        	:param tang1:
        	:type tang1: gp_Vec
        	:param tang2:
        	:type tang2: gp_Vec
        	:param Rayon:
        	:type Rayon: float
        	:param DRayon:
        	:type DRayon: float
        	:param Center:
        	:type Center: gp_Pnt
        	:param DCenter:
        	:type DCenter: gp_Vec
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:rtype: bool
        :param TConv:
        	:type TConv: Convert_ParameterisationType
        	:param ns1:
        	:type ns1: gp_Vec
        	:param ns2:
        	:type ns2: gp_Vec
        	:param dn1w:
        	:type dn1w: gp_Vec
        	:param dn2w:
        	:type dn2w: gp_Vec
        	:param d2n1w:
        	:type d2n1w: gp_Vec
        	:param d2n2w:
        	:type d2n2w: gp_Vec
        	:param nplan:
        	:type nplan: gp_Vec
        	:param dnplan:
        	:type dnplan: gp_Vec
        	:param d2nplan:
        	:type d2nplan: gp_Vec
        	:param pts1:
        	:type pts1: gp_Pnt
        	:param pts2:
        	:type pts2: gp_Pnt
        	:param tang1:
        	:type tang1: gp_Vec
        	:param tang2:
        	:type tang2: gp_Vec
        	:param Dtang1:
        	:type Dtang1: gp_Vec
        	:param Dtang2:
        	:type Dtang2: gp_Vec
        	:param Rayon:
        	:type Rayon: float
        	:param DRayon:
        	:type DRayon: float
        	:param D2Rayon:
        	:type D2Rayon: float
        	:param Center:
        	:type Center: gp_Pnt
        	:param DCenter:
        	:type DCenter: gp_Vec
        	:param D2Center:
        	:type D2Center: gp_Vec
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:param D2Weigths:
        	:type D2Weigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _GeomFill.geomfill_GetCircle(*args)

    GetCircle = staticmethod(GetCircle)

    def GetMinimalWeights(*args) -> "void":
        """
        :param TConv:
        	:type TConv: Convert_ParameterisationType
        	:param AngleMin:
        	:type AngleMin: float
        	:param AngleMax:
        	:type AngleMax: float
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        """
        return _GeomFill.geomfill_GetMinimalWeights(*args)

    GetMinimalWeights = staticmethod(GetMinimalWeights)

    def GetShape(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
        """
        :param MaxAng:
        	:type MaxAng: float
        	:param NbPoles:
        	:type NbPoles: int
        	:param NbKnots:
        	:type NbKnots: int
        	:param Degree:
        	:type Degree: int
        	:param TypeConv:
        	:type TypeConv: Convert_ParameterisationType
        	:rtype: void
        """
        return _GeomFill.geomfill_GetShape(*args)

    GetShape = staticmethod(GetShape)

    def GetTolerance(*args) -> "Standard_Real":
        """
        * Used by the generical classes to determine Tolerance for approximation
        	:param TConv:
        	:type TConv: Convert_ParameterisationType
        	:param AngleMin:
        	:type AngleMin: float
        	:param Radius:
        	:type Radius: float
        	:param AngularTol:
        	:type AngularTol: float
        	:param SpatialTol:
        	:type SpatialTol: float
        	:rtype: float
        """
        return _GeomFill.geomfill_GetTolerance(*args)

    GetTolerance = staticmethod(GetTolerance)

    def Knots(*args) -> "void":
        """
        :param TypeConv:
        	:type TypeConv: Convert_ParameterisationType
        	:param TKnots:
        	:type TKnots: TColStd_Array1OfReal
        	:rtype: void
        """
        return _GeomFill.geomfill_Knots(*args)

    Knots = staticmethod(Knots)

    def Mults(*args) -> "void":
        """
        :param TypeConv:
        	:type TypeConv: Convert_ParameterisationType
        	:param TMults:
        	:type TMults: TColStd_Array1OfInteger
        	:rtype: void
        """
        return _GeomFill.geomfill_Mults(*args)

    Mults = staticmethod(Mults)

    def Surface(*args) -> "opencascade::handle< Geom_Surface >":
        """
        * Builds a ruled surface between the two curves, Curve1 and Curve2.
        	:param Curve1:
        	:type Curve1: Geom_Curve
        	:param Curve2:
        	:type Curve2: Geom_Curve
        	:rtype: opencascade::handle<Geom_Surface>
        """
        return _GeomFill.geomfill_Surface(*args)

    Surface = staticmethod(Surface)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomFill.geomfill_swiginit(self, _GeomFill.new_geomfill())
    __swig_destroy__ = _GeomFill.delete_geomfill
geomfill_swigregister = _GeomFill.geomfill_swigregister
geomfill_swigregister(geomfill)

def geomfill_GetCircle(*args) -> "Standard_Boolean":
    """
    :param TConv:
    	:type TConv: Convert_ParameterisationType
    	:param ns1:
    	:type ns1: gp_Vec
    	:param ns2:
    	:type ns2: gp_Vec
    	:param nplan:
    	:type nplan: gp_Vec
    	:param pt1:
    	:type pt1: gp_Pnt
    	:param pt2:
    	:type pt2: gp_Pnt
    	:param Rayon:
    	:type Rayon: float
    	:param Center:
    	:type Center: gp_Pnt
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weigths:
    	:type Weigths: TColStd_Array1OfReal
    	:rtype: void
    :param TConv:
    	:type TConv: Convert_ParameterisationType
    	:param ns1:
    	:type ns1: gp_Vec
    	:param ns2:
    	:type ns2: gp_Vec
    	:param dn1w:
    	:type dn1w: gp_Vec
    	:param dn2w:
    	:type dn2w: gp_Vec
    	:param nplan:
    	:type nplan: gp_Vec
    	:param dnplan:
    	:type dnplan: gp_Vec
    	:param pts1:
    	:type pts1: gp_Pnt
    	:param pts2:
    	:type pts2: gp_Pnt
    	:param tang1:
    	:type tang1: gp_Vec
    	:param tang2:
    	:type tang2: gp_Vec
    	:param Rayon:
    	:type Rayon: float
    	:param DRayon:
    	:type DRayon: float
    	:param Center:
    	:type Center: gp_Pnt
    	:param DCenter:
    	:type DCenter: gp_Vec
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param DPoles:
    	:type DPoles: TColgp_Array1OfVec
    	:param Weigths:
    	:type Weigths: TColStd_Array1OfReal
    	:param DWeigths:
    	:type DWeigths: TColStd_Array1OfReal
    	:rtype: bool
    :param TConv:
    	:type TConv: Convert_ParameterisationType
    	:param ns1:
    	:type ns1: gp_Vec
    	:param ns2:
    	:type ns2: gp_Vec
    	:param dn1w:
    	:type dn1w: gp_Vec
    	:param dn2w:
    	:type dn2w: gp_Vec
    	:param d2n1w:
    	:type d2n1w: gp_Vec
    	:param d2n2w:
    	:type d2n2w: gp_Vec
    	:param nplan:
    	:type nplan: gp_Vec
    	:param dnplan:
    	:type dnplan: gp_Vec
    	:param d2nplan:
    	:type d2nplan: gp_Vec
    	:param pts1:
    	:type pts1: gp_Pnt
    	:param pts2:
    	:type pts2: gp_Pnt
    	:param tang1:
    	:type tang1: gp_Vec
    	:param tang2:
    	:type tang2: gp_Vec
    	:param Dtang1:
    	:type Dtang1: gp_Vec
    	:param Dtang2:
    	:type Dtang2: gp_Vec
    	:param Rayon:
    	:type Rayon: float
    	:param DRayon:
    	:type DRayon: float
    	:param D2Rayon:
    	:type D2Rayon: float
    	:param Center:
    	:type Center: gp_Pnt
    	:param DCenter:
    	:type DCenter: gp_Vec
    	:param D2Center:
    	:type D2Center: gp_Vec
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param DPoles:
    	:type DPoles: TColgp_Array1OfVec
    	:param D2Poles:
    	:type D2Poles: TColgp_Array1OfVec
    	:param Weigths:
    	:type Weigths: TColStd_Array1OfReal
    	:param DWeigths:
    	:type DWeigths: TColStd_Array1OfReal
    	:param D2Weigths:
    	:type D2Weigths: TColStd_Array1OfReal
    	:rtype: bool
    """
    return _GeomFill.geomfill_GetCircle(*args)

def geomfill_GetMinimalWeights(*args) -> "void":
    """
    :param TConv:
    	:type TConv: Convert_ParameterisationType
    	:param AngleMin:
    	:type AngleMin: float
    	:param AngleMax:
    	:type AngleMax: float
    	:param Weigths:
    	:type Weigths: TColStd_Array1OfReal
    	:rtype: void
    """
    return _GeomFill.geomfill_GetMinimalWeights(*args)

def geomfill_GetShape(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
    """
    :param MaxAng:
    	:type MaxAng: float
    	:param NbPoles:
    	:type NbPoles: int
    	:param NbKnots:
    	:type NbKnots: int
    	:param Degree:
    	:type Degree: int
    	:param TypeConv:
    	:type TypeConv: Convert_ParameterisationType
    	:rtype: void
    """
    return _GeomFill.geomfill_GetShape(*args)

def geomfill_GetTolerance(*args) -> "Standard_Real":
    """
    * Used by the generical classes to determine Tolerance for approximation
    	:param TConv:
    	:type TConv: Convert_ParameterisationType
    	:param AngleMin:
    	:type AngleMin: float
    	:param Radius:
    	:type Radius: float
    	:param AngularTol:
    	:type AngularTol: float
    	:param SpatialTol:
    	:type SpatialTol: float
    	:rtype: float
    """
    return _GeomFill.geomfill_GetTolerance(*args)

def geomfill_Knots(*args) -> "void":
    """
    :param TypeConv:
    	:type TypeConv: Convert_ParameterisationType
    	:param TKnots:
    	:type TKnots: TColStd_Array1OfReal
    	:rtype: void
    """
    return _GeomFill.geomfill_Knots(*args)

def geomfill_Mults(*args) -> "void":
    """
    :param TypeConv:
    	:type TypeConv: Convert_ParameterisationType
    	:param TMults:
    	:type TMults: TColStd_Array1OfInteger
    	:rtype: void
    """
    return _GeomFill.geomfill_Mults(*args)

def geomfill_Surface(*args) -> "opencascade::handle< Geom_Surface >":
    """
    * Builds a ruled surface between the two curves, Curve1 and Curve2.
    	:param Curve1:
    	:type Curve1: Geom_Curve
    	:param Curve2:
    	:type Curve2: Geom_Curve
    	:rtype: opencascade::handle<Geom_Surface>
    """
    return _GeomFill.geomfill_Surface(*args)

class GeomFill_AppSurf(OCC.Core.AppBlend.AppBlend_Approx):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Continuity(self, *args) -> "GeomAbs_Shape":
        """
        * returns the Continuity used in the approximation
        	:rtype: GeomAbs_Shape
        """
        return _GeomFill.GeomFill_AppSurf_Continuity(self, *args)


    def CriteriumWeight(self, *args) -> "void":
        """
        * returns the Weights (as percent) associed to the criterium used in the optimization.
        	:param W1:
        	:type W1: float
        	:param W2:
        	:type W2: float
        	:param W3:
        	:type W3: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSurf_CriteriumWeight(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param Degmin:
        	:type Degmin: int
        	:param Degmax:
        	:type Degmax: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIt:
        	:type NbIt: int
        	:param KnownParameters: default value is Standard_False
        	:type KnownParameters: bool
        	:rtype: None
        """
        _GeomFill.GeomFill_AppSurf_swiginit(self, _GeomFill.new_GeomFill_AppSurf(*args))

    def Init(self, *args) -> "void":
        """
        :param Degmin:
        	:type Degmin: int
        	:param Degmax:
        	:type Degmax: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIt:
        	:type NbIt: int
        	:param KnownParameters: default value is Standard_False
        	:type KnownParameters: bool
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSurf_Init(self, *args)


    def ParType(self, *args) -> "Approx_ParametrizationType":
        """
        * returns the type of parametrization used in the approximation
        	:rtype: Approx_ParametrizationType
        """
        return _GeomFill.GeomFill_AppSurf_ParType(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param Lin:
        	:type Lin: GeomFill_Line
        	:param SecGen:
        	:type SecGen: GeomFill_SectionGenerator
        	:param SpApprox: default value is Standard_False
        	:type SpApprox: bool
        	:rtype: None
        :param Lin:
        	:type Lin: GeomFill_Line
        	:param SecGen:
        	:type SecGen: GeomFill_SectionGenerator
        	:param NbMaxP:
        	:type NbMaxP: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSurf_Perform(self, *args)


    def PerformSmoothing(self, *args) -> "void":
        """
        :param Lin:
        	:type Lin: GeomFill_Line
        	:param SecGen:
        	:type SecGen: GeomFill_SectionGenerator
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSurf_PerformSmoothing(self, *args)


    def SetContinuity(self, *args) -> "void":
        """
        * Define the Continuity used in the approximation
        	:param C:
        	:type C: GeomAbs_Shape
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSurf_SetContinuity(self, *args)


    def SetCriteriumWeight(self, *args) -> "void":
        """
        * define the Weights associed to the criterium used in the optimization. //! if Wi <= 0
        	:param W1:
        	:type W1: float
        	:param W2:
        	:type W2: float
        	:param W3:
        	:type W3: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSurf_SetCriteriumWeight(self, *args)


    def SetParType(self, *args) -> "void":
        """
        * Define the type of parametrization used in the approximation
        	:param ParType:
        	:type ParType: Approx_ParametrizationType
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSurf_SetParType(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_AppSurf
GeomFill_AppSurf.Continuity = new_instancemethod(_GeomFill.GeomFill_AppSurf_Continuity, None, GeomFill_AppSurf)
GeomFill_AppSurf.CriteriumWeight = new_instancemethod(_GeomFill.GeomFill_AppSurf_CriteriumWeight, None, GeomFill_AppSurf)
GeomFill_AppSurf.Init = new_instancemethod(_GeomFill.GeomFill_AppSurf_Init, None, GeomFill_AppSurf)
GeomFill_AppSurf.ParType = new_instancemethod(_GeomFill.GeomFill_AppSurf_ParType, None, GeomFill_AppSurf)
GeomFill_AppSurf.Perform = new_instancemethod(_GeomFill.GeomFill_AppSurf_Perform, None, GeomFill_AppSurf)
GeomFill_AppSurf.PerformSmoothing = new_instancemethod(_GeomFill.GeomFill_AppSurf_PerformSmoothing, None, GeomFill_AppSurf)
GeomFill_AppSurf.SetContinuity = new_instancemethod(_GeomFill.GeomFill_AppSurf_SetContinuity, None, GeomFill_AppSurf)
GeomFill_AppSurf.SetCriteriumWeight = new_instancemethod(_GeomFill.GeomFill_AppSurf_SetCriteriumWeight, None, GeomFill_AppSurf)
GeomFill_AppSurf.SetParType = new_instancemethod(_GeomFill.GeomFill_AppSurf_SetParType, None, GeomFill_AppSurf)
GeomFill_AppSurf_swigregister = _GeomFill.GeomFill_AppSurf_swigregister
GeomFill_AppSurf_swigregister(GeomFill_AppSurf)

class GeomFill_AppSweep(OCC.Core.AppBlend.AppBlend_Approx):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Continuity(self, *args) -> "GeomAbs_Shape":
        """
        * returns the Continuity used in the approximation
        	:rtype: GeomAbs_Shape
        """
        return _GeomFill.GeomFill_AppSweep_Continuity(self, *args)


    def CriteriumWeight(self, *args) -> "void":
        """
        * returns the Weights (as percent) associed to the criterium used in the optimization.
        	:param W1:
        	:type W1: float
        	:param W2:
        	:type W2: float
        	:param W3:
        	:type W3: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSweep_CriteriumWeight(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param Degmin:
        	:type Degmin: int
        	:param Degmax:
        	:type Degmax: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIt:
        	:type NbIt: int
        	:param KnownParameters: default value is Standard_False
        	:type KnownParameters: bool
        	:rtype: None
        """
        _GeomFill.GeomFill_AppSweep_swiginit(self, _GeomFill.new_GeomFill_AppSweep(*args))

    def Init(self, *args) -> "void":
        """
        :param Degmin:
        	:type Degmin: int
        	:param Degmax:
        	:type Degmax: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIt:
        	:type NbIt: int
        	:param KnownParameters: default value is Standard_False
        	:type KnownParameters: bool
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSweep_Init(self, *args)


    def ParType(self, *args) -> "Approx_ParametrizationType":
        """
        * returns the type of parametrization used in the approximation
        	:rtype: Approx_ParametrizationType
        """
        return _GeomFill.GeomFill_AppSweep_ParType(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param Lin:
        	:type Lin: GeomFill_Line
        	:param SecGen:
        	:type SecGen: GeomFill_SweepSectionGenerator
        	:param SpApprox: default value is Standard_False
        	:type SpApprox: bool
        	:rtype: None
        :param Lin:
        	:type Lin: GeomFill_Line
        	:param SecGen:
        	:type SecGen: GeomFill_SweepSectionGenerator
        	:param NbMaxP:
        	:type NbMaxP: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSweep_Perform(self, *args)


    def PerformSmoothing(self, *args) -> "void":
        """
        :param Lin:
        	:type Lin: GeomFill_Line
        	:param SecGen:
        	:type SecGen: GeomFill_SweepSectionGenerator
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSweep_PerformSmoothing(self, *args)


    def SetContinuity(self, *args) -> "void":
        """
        * Define the Continuity used in the approximation
        	:param C:
        	:type C: GeomAbs_Shape
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSweep_SetContinuity(self, *args)


    def SetCriteriumWeight(self, *args) -> "void":
        """
        * define the Weights associed to the criterium used in the optimization. //! if Wi <= 0
        	:param W1:
        	:type W1: float
        	:param W2:
        	:type W2: float
        	:param W3:
        	:type W3: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSweep_SetCriteriumWeight(self, *args)


    def SetParType(self, *args) -> "void":
        """
        * Define the type of parametrization used in the approximation
        	:param ParType:
        	:type ParType: Approx_ParametrizationType
        	:rtype: None
        """
        return _GeomFill.GeomFill_AppSweep_SetParType(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_AppSweep
GeomFill_AppSweep.Continuity = new_instancemethod(_GeomFill.GeomFill_AppSweep_Continuity, None, GeomFill_AppSweep)
GeomFill_AppSweep.CriteriumWeight = new_instancemethod(_GeomFill.GeomFill_AppSweep_CriteriumWeight, None, GeomFill_AppSweep)
GeomFill_AppSweep.Init = new_instancemethod(_GeomFill.GeomFill_AppSweep_Init, None, GeomFill_AppSweep)
GeomFill_AppSweep.ParType = new_instancemethod(_GeomFill.GeomFill_AppSweep_ParType, None, GeomFill_AppSweep)
GeomFill_AppSweep.Perform = new_instancemethod(_GeomFill.GeomFill_AppSweep_Perform, None, GeomFill_AppSweep)
GeomFill_AppSweep.PerformSmoothing = new_instancemethod(_GeomFill.GeomFill_AppSweep_PerformSmoothing, None, GeomFill_AppSweep)
GeomFill_AppSweep.SetContinuity = new_instancemethod(_GeomFill.GeomFill_AppSweep_SetContinuity, None, GeomFill_AppSweep)
GeomFill_AppSweep.SetCriteriumWeight = new_instancemethod(_GeomFill.GeomFill_AppSweep_SetCriteriumWeight, None, GeomFill_AppSweep)
GeomFill_AppSweep.SetParType = new_instancemethod(_GeomFill.GeomFill_AppSweep_SetParType, None, GeomFill_AppSweep)
GeomFill_AppSweep_swigregister = _GeomFill.GeomFill_AppSweep_swigregister
GeomFill_AppSweep_swigregister(GeomFill_AppSweep)

class GeomFill_BSplineCurves(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs a default BSpline surface framework.
        	:rtype: None
        :param C1:
        	:type C1: Geom_BSplineCurve
        	:param C2:
        	:type C2: Geom_BSplineCurve
        	:param C3:
        	:type C3: Geom_BSplineCurve
        	:param C4:
        	:type C4: Geom_BSplineCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        :param C1:
        	:type C1: Geom_BSplineCurve
        	:param C2:
        	:type C2: Geom_BSplineCurve
        	:param C3:
        	:type C3: Geom_BSplineCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        * Constructs a framework for building a BSpline surface from either - the four contiguous BSpline curves, C1, C2, C3 and C4, or - the three contiguous BSpline curves, C1, C2 and C3, or - the two contiguous BSpline curves, C1 and C2. The type of filling style Type to be used is one of: - GeomFill_Stretch - the style with the flattest patch - GeomFill_Coons - a rounded style of patch with less depth than that of Curved - GeomFill_Curved - the style with the most rounded patch.Constructs a framework for building a BSpline surface common to the two BSpline curves, C1 and C2. Exceptions Standard_ConstructionError if the curves are not contiguous.
        	:param C1:
        	:type C1: Geom_BSplineCurve
        	:param C2:
        	:type C2: Geom_BSplineCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        """
        _GeomFill.GeomFill_BSplineCurves_swiginit(self, _GeomFill.new_GeomFill_BSplineCurves(*args))

    def Init(self, *args) -> "void":
        """
        * if the curves cannot be joined
        	:param C1:
        	:type C1: Geom_BSplineCurve
        	:param C2:
        	:type C2: Geom_BSplineCurve
        	:param C3:
        	:type C3: Geom_BSplineCurve
        	:param C4:
        	:type C4: Geom_BSplineCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        * if the curves cannot be joined
        	:param C1:
        	:type C1: Geom_BSplineCurve
        	:param C2:
        	:type C2: Geom_BSplineCurve
        	:param C3:
        	:type C3: Geom_BSplineCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        * Initializes or reinitializes this algorithm with two, three, or four curves - C1, C2, C3, and C4 - and Type, one of the following filling styles: - GeomFill_Stretch - the style with the flattest patch - GeomFill_Coons - a rounded style of patch with less depth than that of Curved - GeomFill_Curved - the style with the most rounded patch. Exceptions Standard_ConstructionError if the curves are not contiguous.
        	:param C1:
        	:type C1: Geom_BSplineCurve
        	:param C2:
        	:type C2: Geom_BSplineCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        """
        return _GeomFill.GeomFill_BSplineCurves_Init(self, *args)


    def Surface(self, *args) -> "opencascade::handle< Geom_BSplineSurface > const &":
        """
        * Returns the BSpline surface Surface resulting from the computation performed by this algorithm.
        	:rtype: opencascade::handle<Geom_BSplineSurface>
        """
        return _GeomFill.GeomFill_BSplineCurves_Surface(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_BSplineCurves
GeomFill_BSplineCurves.Init = new_instancemethod(_GeomFill.GeomFill_BSplineCurves_Init, None, GeomFill_BSplineCurves)
GeomFill_BSplineCurves.Surface = new_instancemethod(_GeomFill.GeomFill_BSplineCurves_Surface, None, GeomFill_BSplineCurves)
GeomFill_BSplineCurves_swigregister = _GeomFill.GeomFill_BSplineCurves_swigregister
GeomFill_BSplineCurves_swigregister(GeomFill_BSplineCurves)

class GeomFill_BezierCurves(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an empty framework for building a Bezier surface from contiguous Bezier curves. You use the Init function to define the boundaries of the surface.
        	:rtype: None
        * Constructs a framework for building a Bezier surface from the four contiguous Bezier curves, C1, C2, C3 and C4 Raises Standard_ConstructionError if the curves are not contiguous.
        	:param C1:
        	:type C1: Geom_BezierCurve
        	:param C2:
        	:type C2: Geom_BezierCurve
        	:param C3:
        	:type C3: Geom_BezierCurve
        	:param C4:
        	:type C4: Geom_BezierCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        * Constructs a framework for building a Bezier surface from the three contiguous Bezier curves, C1, C2 and C3 Raises Standard_ConstructionError if the curves are not contiguous.
        	:param C1:
        	:type C1: Geom_BezierCurve
        	:param C2:
        	:type C2: Geom_BezierCurve
        	:param C3:
        	:type C3: Geom_BezierCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        * Constructs a framework for building a Bezier surface from the two contiguous Bezier curves, C1 and C2 Raises Standard_ConstructionError if the curves are not contiguous.
        	:param C1:
        	:type C1: Geom_BezierCurve
        	:param C2:
        	:type C2: Geom_BezierCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        """
        _GeomFill.GeomFill_BezierCurves_swiginit(self, _GeomFill.new_GeomFill_BezierCurves(*args))

    def Init(self, *args) -> "void":
        """
        * if the curves cannot be joined
        	:param C1:
        	:type C1: Geom_BezierCurve
        	:param C2:
        	:type C2: Geom_BezierCurve
        	:param C3:
        	:type C3: Geom_BezierCurve
        	:param C4:
        	:type C4: Geom_BezierCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        * if the curves cannot be joined
        	:param C1:
        	:type C1: Geom_BezierCurve
        	:param C2:
        	:type C2: Geom_BezierCurve
        	:param C3:
        	:type C3: Geom_BezierCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        * Initializes or reinitializes this algorithm with two, three, or four curves - C1, C2, C3, and C4 - and Type, one of the following filling styles: - GeomFill_Stretch - the style with the flattest patch - GeomFill_Coons - a rounded style of patch with less depth than that of Curved - GeomFill_Curved - the style with the most rounded patch. Exceptions Standard_ConstructionError if the curves are not contiguous.
        	:param C1:
        	:type C1: Geom_BezierCurve
        	:param C2:
        	:type C2: Geom_BezierCurve
        	:param Type:
        	:type Type: GeomFill_FillingStyle
        	:rtype: None
        """
        return _GeomFill.GeomFill_BezierCurves_Init(self, *args)


    def Surface(self, *args) -> "opencascade::handle< Geom_BezierSurface > const &":
        """
        * Returns the Bezier surface resulting from the computation performed by this algorithm.
        	:rtype: opencascade::handle<Geom_BezierSurface>
        """
        return _GeomFill.GeomFill_BezierCurves_Surface(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_BezierCurves
GeomFill_BezierCurves.Init = new_instancemethod(_GeomFill.GeomFill_BezierCurves_Init, None, GeomFill_BezierCurves)
GeomFill_BezierCurves.Surface = new_instancemethod(_GeomFill.GeomFill_BezierCurves_Surface, None, GeomFill_BezierCurves)
GeomFill_BezierCurves_swigregister = _GeomFill.GeomFill_BezierCurves_swigregister
GeomFill_BezierCurves_swigregister(GeomFill_BezierCurves)

class GeomFill_Boundary(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Bounds(self, *args) -> "void":
        """
        :param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_Boundary_Bounds(self, *args)


    def D1(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Vec
        	:rtype: void
        """
        return _GeomFill.GeomFill_Boundary_D1(self, *args)


    def D1Norm(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param N:
        	:type N: gp_Vec
        	:param DN:
        	:type DN: gp_Vec
        	:rtype: void
        """
        return _GeomFill.GeomFill_Boundary_D1Norm(self, *args)


    def HasNormals(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _GeomFill.GeomFill_Boundary_HasNormals(self, *args)


    def IsDegenerated(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _GeomFill.GeomFill_Boundary_IsDegenerated(self, *args)


    def Norm(self, *args) -> "gp_Vec":
        """
        :param U:
        	:type U: float
        	:rtype: gp_Vec
        """
        return _GeomFill.GeomFill_Boundary_Norm(self, *args)


    def Points(self, *args) -> "void":
        """
        :param PFirst:
        	:type PFirst: gp_Pnt
        	:param PLast:
        	:type PLast: gp_Pnt
        	:rtype: None
        """
        return _GeomFill.GeomFill_Boundary_Points(self, *args)


    def Reparametrize(self, *args) -> "void":
        """
        :param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param HasDF:
        	:type HasDF: bool
        	:param HasDL:
        	:type HasDL: bool
        	:param DF:
        	:type DF: float
        	:param DL:
        	:type DL: float
        	:param Rev:
        	:type Rev: bool
        	:rtype: void
        """
        return _GeomFill.GeomFill_Boundary_Reparametrize(self, *args)


    def Tol3d(self, *args) -> "void":
        """
        :rtype: float
        :param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_Boundary_Tol3d(self, *args)


    def Tolang(self, *args) -> "void":
        """
        :rtype: float
        :param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_Boundary_Tolang(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        :param U:
        	:type U: float
        	:rtype: gp_Pnt
        """
        return _GeomFill.GeomFill_Boundary_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_Boundary_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Boundary
GeomFill_Boundary.Bounds = new_instancemethod(_GeomFill.GeomFill_Boundary_Bounds, None, GeomFill_Boundary)
GeomFill_Boundary.D1 = new_instancemethod(_GeomFill.GeomFill_Boundary_D1, None, GeomFill_Boundary)
GeomFill_Boundary.D1Norm = new_instancemethod(_GeomFill.GeomFill_Boundary_D1Norm, None, GeomFill_Boundary)
GeomFill_Boundary.HasNormals = new_instancemethod(_GeomFill.GeomFill_Boundary_HasNormals, None, GeomFill_Boundary)
GeomFill_Boundary.IsDegenerated = new_instancemethod(_GeomFill.GeomFill_Boundary_IsDegenerated, None, GeomFill_Boundary)
GeomFill_Boundary.Norm = new_instancemethod(_GeomFill.GeomFill_Boundary_Norm, None, GeomFill_Boundary)
GeomFill_Boundary.Points = new_instancemethod(_GeomFill.GeomFill_Boundary_Points, None, GeomFill_Boundary)
GeomFill_Boundary.Reparametrize = new_instancemethod(_GeomFill.GeomFill_Boundary_Reparametrize, None, GeomFill_Boundary)
GeomFill_Boundary.Tol3d = new_instancemethod(_GeomFill.GeomFill_Boundary_Tol3d, None, GeomFill_Boundary)
GeomFill_Boundary.Tolang = new_instancemethod(_GeomFill.GeomFill_Boundary_Tolang, None, GeomFill_Boundary)
GeomFill_Boundary.Value = new_instancemethod(_GeomFill.GeomFill_Boundary_Value, None, GeomFill_Boundary)
GeomFill_Boundary_swigregister = _GeomFill.GeomFill_Boundary_swigregister
GeomFill_Boundary_swigregister(GeomFill_Boundary)

class GeomFill_CircularBlendFunc(OCC.Core.Approx.Approx_SweepFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Create a Blend with a constant radius with 2 guide-line. <FShape> sets the type of fillet surface. The -- default value is Convert_TgtThetaOver2 (classical -- nurbs -- representation of circles). ChFi3d_QuasiAngular -- corresponds to a nurbs representation of circles -- which parameterisation matches the circle one. -- ChFi3d_Polynomial corresponds to a polynomial -- representation of circles.
        	:param Path:
        	:type Path: Adaptor3d_HCurve
        	:param Curve1:
        	:type Curve1: Adaptor3d_HCurve
        	:param Curve2:
        	:type Curve2: Adaptor3d_HCurve
        	:param Radius:
        	:type Radius: float
        	:param Polynomial: default value is Standard_False
        	:type Polynomial: bool
        	:rtype: None
        """
        _GeomFill.GeomFill_CircularBlendFunc_swiginit(self, _GeomFill.new_GeomFill_CircularBlendFunc(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_CircularBlendFunc_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_CircularBlendFunc
GeomFill_CircularBlendFunc_swigregister = _GeomFill.GeomFill_CircularBlendFunc_swigregister
GeomFill_CircularBlendFunc_swigregister(GeomFill_CircularBlendFunc)

class GeomFill_ConstrainedFilling(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Boundary(self, *args) -> "opencascade::handle< GeomFill_Boundary >":
        """
        * Returns the bound of index i after sort.
        	:param I:
        	:type I: int
        	:rtype: opencascade::handle<GeomFill_Boundary>
        """
        return _GeomFill.GeomFill_ConstrainedFilling_Boundary(self, *args)


    def CheckApprox(self, *args) -> "void":
        """
        * Computes values and normals along the bound I and compare them to the approx result curves (bound and tgte field) , draw the normals and tangents.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_ConstrainedFilling_CheckApprox(self, *args)


    def CheckCoonsAlgPatch(self, *args) -> "void":
        """
        * Computes the fields of tangents on 30 points along the bound I, these are not the constraint tangents but gives an idea of the coonsAlgPatch regularity.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_ConstrainedFilling_CheckCoonsAlgPatch(self, *args)


    def CheckResult(self, *args) -> "void":
        """
        * Computes values and normals along the bound I on both constraint surface and result surface, draw the normals, and computes the max distance between values and the max angle between normals.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_ConstrainedFilling_CheckResult(self, *args)


    def CheckTgteField(self, *args) -> "void":
        """
        * Computes the fields of tangents and normals on 30 points along the bound I, draw them, and computes the max dot product that must be near than 0.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_ConstrainedFilling_CheckTgteField(self, *args)


    def Eval(self, *args) -> "Standard_Integer":
        """
        * Internal use for Advmath approximation call.
        	:param W:
        	:type W: float
        	:param Ord:
        	:type Ord: int
        	:param Result:
        	:type Result: float
        	:rtype: int
        """
        return _GeomFill.GeomFill_ConstrainedFilling_Eval(self, *args)


    def __init__(self, *args):
        """
        * Constructs an empty framework for filling a surface from boundaries. The boundaries of the surface will be defined, and the surface will be built by using the function Init. The surface will respect the following constraints: - its degree will not be greater than MaxDeg - the maximum number of segments MaxSeg which BSpline surfaces can have.
        	:param MaxDeg:
        	:type MaxDeg: int
        	:param MaxSeg:
        	:type MaxSeg: int
        	:rtype: None
        """
        _GeomFill.GeomFill_ConstrainedFilling_swiginit(self, _GeomFill.new_GeomFill_ConstrainedFilling(*args))

    def Init(self, *args) -> "void":
        """
        :param B1:
        	:type B1: GeomFill_Boundary
        	:param B2:
        	:type B2: GeomFill_Boundary
        	:param B3:
        	:type B3: GeomFill_Boundary
        	:param NoCheck: default value is Standard_False
        	:type NoCheck: bool
        	:rtype: None
        * Constructs a BSpline surface filled from the series of boundaries B1, B2, B3 and, if need be, B4, which serve: - as path constraints - and optionally, as tangency constraints if they are GeomFill_BoundWithSurf curves. The boundaries may be given in any order: they are classified and if necessary, reversed and reparameterized. The surface will also respect the following constraints: - its degree will not be greater than the maximum degree defined at the time of construction of this framework, and - the maximum number of segments MaxSeg which BSpline surfaces can have
        	:param B1:
        	:type B1: GeomFill_Boundary
        	:param B2:
        	:type B2: GeomFill_Boundary
        	:param B3:
        	:type B3: GeomFill_Boundary
        	:param B4:
        	:type B4: GeomFill_Boundary
        	:param NoCheck: default value is Standard_False
        	:type NoCheck: bool
        	:rtype: None
        """
        return _GeomFill.GeomFill_ConstrainedFilling_Init(self, *args)


    def ReBuild(self, *args) -> "void":
        """
        * Computes the new poles of the surface using the new blending functions set by several calls to SetDomain.
        	:rtype: None
        """
        return _GeomFill.GeomFill_ConstrainedFilling_ReBuild(self, *args)


    def SetDomain(self, *args) -> "void":
        """
        * Allows to modify domain on witch the blending function associated to the constrained boundary B will propag the influence of the field of tangency. Can be usefull to reduce influence of boundaries on whitch the Coons compatibility conditions are not respected. l is a relative value of the parametric range of B. Default value for l is 1 (used in Init). Warning: Must be called after Init with a constrained boundary used in the call to Init.
        	:param l:
        	:type l: float
        	:param B:
        	:type B: GeomFill_BoundWithSurf
        	:rtype: None
        """
        return _GeomFill.GeomFill_ConstrainedFilling_SetDomain(self, *args)


    def Surface(self, *args) -> "opencascade::handle< Geom_BSplineSurface >":
        """
        * Returns the BSpline surface after computation of the fill by this framework.
        	:rtype: opencascade::handle<Geom_BSplineSurface>
        """
        return _GeomFill.GeomFill_ConstrainedFilling_Surface(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_ConstrainedFilling
GeomFill_ConstrainedFilling.Boundary = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_Boundary, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling.CheckApprox = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_CheckApprox, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling.CheckCoonsAlgPatch = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_CheckCoonsAlgPatch, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling.CheckResult = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_CheckResult, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling.CheckTgteField = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_CheckTgteField, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling.Eval = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_Eval, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling.Init = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_Init, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling.ReBuild = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_ReBuild, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling.SetDomain = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_SetDomain, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling.Surface = new_instancemethod(_GeomFill.GeomFill_ConstrainedFilling_Surface, None, GeomFill_ConstrainedFilling)
GeomFill_ConstrainedFilling_swigregister = _GeomFill.GeomFill_ConstrainedFilling_swigregister
GeomFill_ConstrainedFilling_swigregister(GeomFill_ConstrainedFilling)

class GeomFill_CoonsAlgPatch(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bound(self, *args) -> "opencascade::handle< GeomFill_Boundary > const &":
        """
        :param I:
        	:type I: int
        	:rtype: opencascade::handle<GeomFill_Boundary>
        """
        return _GeomFill.GeomFill_CoonsAlgPatch_Bound(self, *args)


    def Corner(self, *args) -> "gp_Pnt const":
        """
        :param I:
        	:type I: int
        	:rtype: gp_Pnt
        """
        return _GeomFill.GeomFill_CoonsAlgPatch_Corner(self, *args)


    def D1U(self, *args) -> "gp_Vec":
        """
        * Computes the d/dU partial derivative on the algorithmic patch at parameters U and V.
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: gp_Vec
        """
        return _GeomFill.GeomFill_CoonsAlgPatch_D1U(self, *args)


    def D1V(self, *args) -> "gp_Vec":
        """
        * Computes the d/dV partial derivative on the algorithmic patch at parameters U and V.
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: gp_Vec
        """
        return _GeomFill.GeomFill_CoonsAlgPatch_D1V(self, *args)


    def DUV(self, *args) -> "gp_Vec":
        """
        * Computes the d2/dUdV partial derivative on the algorithmic patch made with linear blending functions at parameter U and V.
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: gp_Vec
        """
        return _GeomFill.GeomFill_CoonsAlgPatch_DUV(self, *args)


    def Func(self, *args) -> "opencascade::handle< Law_Function > const &":
        """
        * Give the blending functions.
        	:param f1:
        	:type f1: Law_Function
        	:param f2:
        	:type f2: Law_Function
        	:rtype: None
        :param I:
        	:type I: int
        	:rtype: opencascade::handle<Law_Function>
        """
        return _GeomFill.GeomFill_CoonsAlgPatch_Func(self, *args)


    def __init__(self, *args):
        """
        * Constructs the algorithmic patch. By Default the constructed blending functions are linear. Warning: No control is done on the bounds. B1/B3 and B2/B4 must be same range and well oriented.
        	:param B1:
        	:type B1: GeomFill_Boundary
        	:param B2:
        	:type B2: GeomFill_Boundary
        	:param B3:
        	:type B3: GeomFill_Boundary
        	:param B4:
        	:type B4: GeomFill_Boundary
        	:rtype: None
        """
        _GeomFill.GeomFill_CoonsAlgPatch_swiginit(self, _GeomFill.new_GeomFill_CoonsAlgPatch(*args))

    def SetFunc(self, *args) -> "void":
        """
        * Set the blending functions.
        	:param f1:
        	:type f1: Law_Function
        	:param f2:
        	:type f2: Law_Function
        	:rtype: None
        """
        return _GeomFill.GeomFill_CoonsAlgPatch_SetFunc(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        * Computes the value on the algorithmic patch at parameters U and V.
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: gp_Pnt
        """
        return _GeomFill.GeomFill_CoonsAlgPatch_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_CoonsAlgPatch_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_CoonsAlgPatch
GeomFill_CoonsAlgPatch.Bound = new_instancemethod(_GeomFill.GeomFill_CoonsAlgPatch_Bound, None, GeomFill_CoonsAlgPatch)
GeomFill_CoonsAlgPatch.Corner = new_instancemethod(_GeomFill.GeomFill_CoonsAlgPatch_Corner, None, GeomFill_CoonsAlgPatch)
GeomFill_CoonsAlgPatch.D1U = new_instancemethod(_GeomFill.GeomFill_CoonsAlgPatch_D1U, None, GeomFill_CoonsAlgPatch)
GeomFill_CoonsAlgPatch.D1V = new_instancemethod(_GeomFill.GeomFill_CoonsAlgPatch_D1V, None, GeomFill_CoonsAlgPatch)
GeomFill_CoonsAlgPatch.DUV = new_instancemethod(_GeomFill.GeomFill_CoonsAlgPatch_DUV, None, GeomFill_CoonsAlgPatch)
GeomFill_CoonsAlgPatch.Func = new_instancemethod(_GeomFill.GeomFill_CoonsAlgPatch_Func, None, GeomFill_CoonsAlgPatch)
GeomFill_CoonsAlgPatch.SetFunc = new_instancemethod(_GeomFill.GeomFill_CoonsAlgPatch_SetFunc, None, GeomFill_CoonsAlgPatch)
GeomFill_CoonsAlgPatch.Value = new_instancemethod(_GeomFill.GeomFill_CoonsAlgPatch_Value, None, GeomFill_CoonsAlgPatch)
GeomFill_CoonsAlgPatch_swigregister = _GeomFill.GeomFill_CoonsAlgPatch_swigregister
GeomFill_CoonsAlgPatch_swigregister(GeomFill_CoonsAlgPatch)

class GeomFill_CornerState(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Constraint(self, *args) -> "void":
        """:rtype: None"""
        return _GeomFill.GeomFill_CornerState_Constraint(self, *args)


    def DoKill(self, *args) -> "void":
        """
        :param Scal:
        	:type Scal: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_CornerState_DoKill(self, *args)


    def Gap(self, *args) -> "void":
        """
        :rtype: float
        :param G:
        	:type G: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_CornerState_Gap(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_CornerState_swiginit(self, _GeomFill.new_GeomFill_CornerState(*args))

    def HasConstraint(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _GeomFill.GeomFill_CornerState_HasConstraint(self, *args)


    def IsToKill(self, *args) -> "Standard_Boolean":
        """
        :param Scal:
        	:type Scal: float
        	:rtype: bool
        """
        return _GeomFill.GeomFill_CornerState_IsToKill(self, *args)


    def NorAng(self, *args) -> "void":
        """
        :rtype: float
        :param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_CornerState_NorAng(self, *args)


    def TgtAng(self, *args) -> "void":
        """
        :rtype: float
        :param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_CornerState_TgtAng(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_CornerState
GeomFill_CornerState.Constraint = new_instancemethod(_GeomFill.GeomFill_CornerState_Constraint, None, GeomFill_CornerState)
GeomFill_CornerState.DoKill = new_instancemethod(_GeomFill.GeomFill_CornerState_DoKill, None, GeomFill_CornerState)
GeomFill_CornerState.Gap = new_instancemethod(_GeomFill.GeomFill_CornerState_Gap, None, GeomFill_CornerState)
GeomFill_CornerState.HasConstraint = new_instancemethod(_GeomFill.GeomFill_CornerState_HasConstraint, None, GeomFill_CornerState)
GeomFill_CornerState.IsToKill = new_instancemethod(_GeomFill.GeomFill_CornerState_IsToKill, None, GeomFill_CornerState)
GeomFill_CornerState.NorAng = new_instancemethod(_GeomFill.GeomFill_CornerState_NorAng, None, GeomFill_CornerState)
GeomFill_CornerState.TgtAng = new_instancemethod(_GeomFill.GeomFill_CornerState_TgtAng, None, GeomFill_CornerState)
GeomFill_CornerState_swigregister = _GeomFill.GeomFill_CornerState_swigregister
GeomFill_CornerState_swigregister(GeomFill_CornerState)

class GeomFill_Filling(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_Filling_swiginit(self, _GeomFill.new_GeomFill_Filling(*args))

    def NbUPoles(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _GeomFill.GeomFill_Filling_NbUPoles(self, *args)


    def NbVPoles(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _GeomFill.GeomFill_Filling_NbVPoles(self, *args)


    def Poles(self, *args) -> "void":
        """
        :param Poles:
        	:type Poles: TColgp_Array2OfPnt
        	:rtype: None
        """
        return _GeomFill.GeomFill_Filling_Poles(self, *args)


    def Weights(self, *args) -> "void":
        """
        :param Weights:
        	:type Weights: TColStd_Array2OfReal
        	:rtype: None
        """
        return _GeomFill.GeomFill_Filling_Weights(self, *args)


    def isRational(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _GeomFill.GeomFill_Filling_isRational(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Filling
GeomFill_Filling.NbUPoles = new_instancemethod(_GeomFill.GeomFill_Filling_NbUPoles, None, GeomFill_Filling)
GeomFill_Filling.NbVPoles = new_instancemethod(_GeomFill.GeomFill_Filling_NbVPoles, None, GeomFill_Filling)
GeomFill_Filling.Poles = new_instancemethod(_GeomFill.GeomFill_Filling_Poles, None, GeomFill_Filling)
GeomFill_Filling.Weights = new_instancemethod(_GeomFill.GeomFill_Filling_Weights, None, GeomFill_Filling)
GeomFill_Filling.isRational = new_instancemethod(_GeomFill.GeomFill_Filling_isRational, None, GeomFill_Filling)
GeomFill_Filling_swigregister = _GeomFill.GeomFill_Filling_swigregister
GeomFill_Filling_swigregister(GeomFill_Filling)

class GeomFill_FunctionDraft(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Deriv2T(self, *args) -> "Standard_Boolean":
        """
        * returns the values <F> of the T2 derivatives for the parameter Param .
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param Param:
        	:type Param: float
        	:param W:
        	:type W: float
        	:param d2N:
        	:type d2N: gp_Vec
        	:param teta:
        	:type teta: float
        	:param F:
        	:type F: math_Vector
        	:rtype: bool
        """
        return _GeomFill.GeomFill_FunctionDraft_Deriv2T(self, *args)


    def Deriv2X(self, *args) -> "Standard_Boolean":
        """
        * returns the values <T> of the X2 derivatives for the parameter Param .
        	:param X:
        	:type X: math_Vector
        	:param T:
        	:type T: GeomFill_Tensor
        	:rtype: bool
        """
        return _GeomFill.GeomFill_FunctionDraft_Deriv2X(self, *args)


    def DerivT(self, *args) -> "Standard_Boolean":
        """
        * returns the values <F> of the T derivatives for the parameter Param .
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param Param:
        	:type Param: float
        	:param W:
        	:type W: float
        	:param dN:
        	:type dN: gp_Vec
        	:param teta:
        	:type teta: float
        	:param F:
        	:type F: math_Vector
        	:rtype: bool
        """
        return _GeomFill.GeomFill_FunctionDraft_DerivT(self, *args)


    def DerivTX(self, *args) -> "Standard_Boolean":
        """
        * returns the values <D> of the TX derivatives for the parameter Param .
        	:param dN:
        	:type dN: gp_Vec
        	:param teta:
        	:type teta: float
        	:param D:
        	:type D: math_Matrix
        	:rtype: bool
        """
        return _GeomFill.GeomFill_FunctionDraft_DerivTX(self, *args)


    def __init__(self, *args):
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: None
        """
        _GeomFill.GeomFill_FunctionDraft_swiginit(self, _GeomFill.new_GeomFill_FunctionDraft(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_FunctionDraft
GeomFill_FunctionDraft.Deriv2T = new_instancemethod(_GeomFill.GeomFill_FunctionDraft_Deriv2T, None, GeomFill_FunctionDraft)
GeomFill_FunctionDraft.Deriv2X = new_instancemethod(_GeomFill.GeomFill_FunctionDraft_Deriv2X, None, GeomFill_FunctionDraft)
GeomFill_FunctionDraft.DerivT = new_instancemethod(_GeomFill.GeomFill_FunctionDraft_DerivT, None, GeomFill_FunctionDraft)
GeomFill_FunctionDraft.DerivTX = new_instancemethod(_GeomFill.GeomFill_FunctionDraft_DerivTX, None, GeomFill_FunctionDraft)
GeomFill_FunctionDraft_swigregister = _GeomFill.GeomFill_FunctionDraft_swigregister
GeomFill_FunctionDraft_swigregister(GeomFill_FunctionDraft)

class GeomFill_FunctionGuide(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DerivT(self, *args) -> "Standard_Boolean":
        """
        * returns the values <F> of the T derivatives for the parameter Param .
        	:param X:
        	:type X: math_Vector
        	:param DCentre:
        	:type DCentre: gp_XYZ
        	:param DDir:
        	:type DDir: gp_XYZ
        	:param DFDT:
        	:type DFDT: math_Vector
        	:rtype: bool
        """
        return _GeomFill.GeomFill_FunctionGuide_DerivT(self, *args)


    def __init__(self, *args):
        """
        :param S:
        	:type S: GeomFill_SectionLaw
        	:param Guide:
        	:type Guide: Adaptor3d_HCurve
        	:param ParamOnLaw: default value is 0.0
        	:type ParamOnLaw: float
        	:rtype: None
        """
        _GeomFill.GeomFill_FunctionGuide_swiginit(self, _GeomFill.new_GeomFill_FunctionGuide(*args))

    def SetParam(self, *args) -> "void":
        """
        :param Param:
        	:type Param: float
        	:param Centre:
        	:type Centre: gp_Pnt
        	:param Dir:
        	:type Dir: gp_XYZ
        	:param XDir:
        	:type XDir: gp_XYZ
        	:rtype: None
        """
        return _GeomFill.GeomFill_FunctionGuide_SetParam(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_FunctionGuide
GeomFill_FunctionGuide.DerivT = new_instancemethod(_GeomFill.GeomFill_FunctionGuide_DerivT, None, GeomFill_FunctionGuide)
GeomFill_FunctionGuide.SetParam = new_instancemethod(_GeomFill.GeomFill_FunctionGuide_SetParam, None, GeomFill_FunctionGuide)
GeomFill_FunctionGuide_swigregister = _GeomFill.GeomFill_FunctionGuide_swigregister
GeomFill_FunctionGuide_swigregister(GeomFill_FunctionGuide)

class GeomFill_Line(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param NbPoints:
        	:type NbPoints: int
        	:rtype: None
        """
        _GeomFill.GeomFill_Line_swiginit(self, _GeomFill.new_GeomFill_Line(*args))

    def NbPoints(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _GeomFill.GeomFill_Line_NbPoints(self, *args)


    def Point(self, *args) -> "Standard_Integer":
        """
        :param Index:
        	:type Index: int
        	:rtype: int
        """
        return _GeomFill.GeomFill_Line_Point(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_Line_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Line
GeomFill_Line.NbPoints = new_instancemethod(_GeomFill.GeomFill_Line_NbPoints, None, GeomFill_Line)
GeomFill_Line.Point = new_instancemethod(_GeomFill.GeomFill_Line_Point, None, GeomFill_Line)
GeomFill_Line_swigregister = _GeomFill.GeomFill_Line_swigregister
GeomFill_Line_swigregister(GeomFill_Line)

class GeomFill_LocFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def D0(self, *args) -> "Standard_Boolean":
        """
        * compute the section for v = param
        	:param Param:
        	:type Param: float
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocFunction_D0(self, *args)


    def D1(self, *args) -> "Standard_Boolean":
        """
        * compute the first derivative in v direction of the section for v = param
        	:param Param:
        	:type Param: float
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocFunction_D1(self, *args)


    def D2(self, *args) -> "Standard_Boolean":
        """
        * compute the second derivative in v direction of the section for v = param
        	:param Param:
        	:type Param: float
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocFunction_D2(self, *args)


    def DN(self, *args) -> "void":
        """
        :param Param:
        	:type Param: float
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Order:
        	:type Order: int
        	:param Result:
        	:type Result: float
        	:param Ier:
        	:type Ier: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_LocFunction_DN(self, *args)


    def __init__(self, *args):
        """
        :param Law:
        	:type Law: GeomFill_LocationLaw
        	:rtype: None
        """
        _GeomFill.GeomFill_LocFunction_swiginit(self, _GeomFill.new_GeomFill_LocFunction(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_LocFunction
GeomFill_LocFunction.D0 = new_instancemethod(_GeomFill.GeomFill_LocFunction_D0, None, GeomFill_LocFunction)
GeomFill_LocFunction.D1 = new_instancemethod(_GeomFill.GeomFill_LocFunction_D1, None, GeomFill_LocFunction)
GeomFill_LocFunction.D2 = new_instancemethod(_GeomFill.GeomFill_LocFunction_D2, None, GeomFill_LocFunction)
GeomFill_LocFunction.DN = new_instancemethod(_GeomFill.GeomFill_LocFunction_DN, None, GeomFill_LocFunction)
GeomFill_LocFunction_swigregister = _GeomFill.GeomFill_LocFunction_swigregister
GeomFill_LocFunction_swigregister(GeomFill_LocFunction)

class GeomFill_LocationLaw(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Copy(self, *args) -> "opencascade::handle< GeomFill_LocationLaw >":
        """:rtype: opencascade::handle<GeomFill_LocationLaw>"""
        return _GeomFill.GeomFill_LocationLaw_Copy(self, *args)


    def D0(self, *args) -> "Standard_Boolean":
        """
        * compute Location
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:rtype: bool
        * compute Location and 2d points
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationLaw_D0(self, *args)


    def D1(self, *args) -> "Standard_Boolean":
        """
        * compute location 2d points and associated first derivatives. Warning : It used only for C1 or C2 aproximation
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:param DM:
        	:type DM: gp_Mat
        	:param DV:
        	:type DV: gp_Vec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationLaw_D1(self, *args)


    def D2(self, *args) -> "Standard_Boolean":
        """
        * compute location 2d points and associated first and seconde derivatives. Warning : It used only for C2 aproximation
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:param DM:
        	:type DM: gp_Mat
        	:param DV:
        	:type DV: gp_Vec
        	:param D2M:
        	:type D2M: gp_Mat
        	:param D2V:
        	:type D2V: gp_Vec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param D2Poles2d:
        	:type D2Poles2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationLaw_D2(self, *args)


    def ErrorStatus(self, *args) -> "GeomFill_PipeError":
        """
        * Give a status to the Law Returns PipeOk (default implementation)
        	:rtype: GeomFill_PipeError
        """
        return _GeomFill.GeomFill_LocationLaw_ErrorStatus(self, *args)


    def GetAverageLaw(self, *args) -> "void":
        """
        * Get average value of M(t) and V(t) it is usfull to make fast approximation of rational surfaces.
        	:param AM:
        	:type AM: gp_Mat
        	:param AV:
        	:type AV: gp_Vec
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_GetAverageLaw(self, *args)


    def GetCurve(self, *args) -> "opencascade::handle< Adaptor3d_HCurve > const &":
        """:rtype: opencascade::handle<Adaptor3d_HCurve>"""
        return _GeomFill.GeomFill_LocationLaw_GetCurve(self, *args)


    def GetDomain(self, *args) -> "void":
        """
        * Gets the bounds of the function parametric domain. Warning: This domain it is not modified by the SetValue method
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_GetDomain(self, *args)


    def GetInterval(self, *args) -> "void":
        """
        * Gets the bounds of the parametric interval on the function
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_GetInterval(self, *args)


    def GetMaximalNorm(self, *args) -> "Standard_Real":
        """
        * Get the maximum Norm of the matrix-location part. It is usful to find an good Tolerance to approx M(t).
        	:rtype: float
        """
        return _GeomFill.GeomFill_LocationLaw_GetMaximalNorm(self, *args)


    def HasFirstRestriction(self, *args) -> "Standard_Boolean":
        """
        * Say if the first restriction is defined in this class. If it is true the first element of poles array in D0,D1,D2... Correspond to this restriction. Returns Standard_False (default implementation)
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationLaw_HasFirstRestriction(self, *args)


    def HasLastRestriction(self, *args) -> "Standard_Boolean":
        """
        * Say if the last restriction is defined in this class. If it is true the last element of poles array in D0,D1,D2... Correspond to this restriction. Returns Standard_False (default implementation)
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationLaw_HasLastRestriction(self, *args)


    def Intervals(self, *args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_Intervals(self, *args)


    def IsRotation(self, *args) -> "Standard_Boolean":
        """
        * Say if the Location Law, is a rotation of Location The default implementation is ' returns False '.
        	:param Error:
        	:type Error: float
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationLaw_IsRotation(self, *args)


    def IsTranslation(self, *args) -> "Standard_Boolean":
        """
        * Say if the Location Law, is an translation of Location The default implementation is ' returns False '.
        	:param Error:
        	:type Error: float
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationLaw_IsTranslation(self, *args)


    def Nb2dCurves(self, *args) -> "Standard_Integer":
        """
        * get the number of 2d curves (Restrictions + Traces) to approximate.
        	:rtype: int
        """
        return _GeomFill.GeomFill_LocationLaw_Nb2dCurves(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _GeomFill.GeomFill_LocationLaw_NbIntervals(self, *args)


    def Resolution(self, *args) -> "void":
        """
        * Returns the resolutions in the sub-space 2d <Index> This information is usfull to find an good tolerance in 2d approximation.
        	:param Index:
        	:type Index: int
        	:param Tol:
        	:type Tol: float
        	:param TolU:
        	:type TolU: float
        	:param TolV:
        	:type TolV: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_Resolution(self, *args)


    def Rotation(self, *args) -> "void":
        """
        :param Center:
        	:type Center: gp_Pnt
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_Rotation(self, *args)


    def SetCurve(self, *args) -> "void":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_SetCurve(self, *args)


    def SetInterval(self, *args) -> "void":
        """
        * Sets the bounds of the parametric interval on the function This determines the derivatives in these values if the function is not Cn.
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_SetInterval(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Is usefull, if (me) have to run numerical algorithm to perform D0, D1 or D2 The default implementation make nothing.
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_SetTolerance(self, *args)


    def SetTrsf(self, *args) -> "void":
        """
        * Set a transformation Matrix like the law M(t) become Mat * M(t)
        	:param Transfo:
        	:type Transfo: gp_Mat
        	:rtype: void
        """
        return _GeomFill.GeomFill_LocationLaw_SetTrsf(self, *args)


    def TraceNumber(self, *args) -> "Standard_Integer":
        """
        * Give the number of trace (Curves 2d wich are not restriction) Returns 0 (default implementation)
        	:rtype: int
        """
        return _GeomFill.GeomFill_LocationLaw_TraceNumber(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_LocationLaw_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_LocationLaw
GeomFill_LocationLaw.Copy = new_instancemethod(_GeomFill.GeomFill_LocationLaw_Copy, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.D0 = new_instancemethod(_GeomFill.GeomFill_LocationLaw_D0, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.D1 = new_instancemethod(_GeomFill.GeomFill_LocationLaw_D1, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.D2 = new_instancemethod(_GeomFill.GeomFill_LocationLaw_D2, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.ErrorStatus = new_instancemethod(_GeomFill.GeomFill_LocationLaw_ErrorStatus, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.GetAverageLaw = new_instancemethod(_GeomFill.GeomFill_LocationLaw_GetAverageLaw, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.GetCurve = new_instancemethod(_GeomFill.GeomFill_LocationLaw_GetCurve, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.GetDomain = new_instancemethod(_GeomFill.GeomFill_LocationLaw_GetDomain, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.GetInterval = new_instancemethod(_GeomFill.GeomFill_LocationLaw_GetInterval, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.GetMaximalNorm = new_instancemethod(_GeomFill.GeomFill_LocationLaw_GetMaximalNorm, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.HasFirstRestriction = new_instancemethod(_GeomFill.GeomFill_LocationLaw_HasFirstRestriction, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.HasLastRestriction = new_instancemethod(_GeomFill.GeomFill_LocationLaw_HasLastRestriction, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.Intervals = new_instancemethod(_GeomFill.GeomFill_LocationLaw_Intervals, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.IsRotation = new_instancemethod(_GeomFill.GeomFill_LocationLaw_IsRotation, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.IsTranslation = new_instancemethod(_GeomFill.GeomFill_LocationLaw_IsTranslation, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.Nb2dCurves = new_instancemethod(_GeomFill.GeomFill_LocationLaw_Nb2dCurves, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.NbIntervals = new_instancemethod(_GeomFill.GeomFill_LocationLaw_NbIntervals, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.Resolution = new_instancemethod(_GeomFill.GeomFill_LocationLaw_Resolution, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.Rotation = new_instancemethod(_GeomFill.GeomFill_LocationLaw_Rotation, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.SetCurve = new_instancemethod(_GeomFill.GeomFill_LocationLaw_SetCurve, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.SetInterval = new_instancemethod(_GeomFill.GeomFill_LocationLaw_SetInterval, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.SetTolerance = new_instancemethod(_GeomFill.GeomFill_LocationLaw_SetTolerance, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.SetTrsf = new_instancemethod(_GeomFill.GeomFill_LocationLaw_SetTrsf, None, GeomFill_LocationLaw)
GeomFill_LocationLaw.TraceNumber = new_instancemethod(_GeomFill.GeomFill_LocationLaw_TraceNumber, None, GeomFill_LocationLaw)
GeomFill_LocationLaw_swigregister = _GeomFill.GeomFill_LocationLaw_swigregister
GeomFill_LocationLaw_swigregister(GeomFill_LocationLaw)

class GeomFill_Pipe(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ErrorOnSurf(self, *args) -> "Standard_Real":
        """
        * Returns the approximation's error. if the Surface is plane, cylinder ... this error can be 0.
        	:rtype: float
        """
        return _GeomFill.GeomFill_Pipe_ErrorOnSurf(self, *args)


    def ExchangeUV(self, *args) -> "Standard_Boolean":
        """
        * The u parametric direction of the surface constructed by this algorithm usually corresponds to the evolution along the path and the v parametric direction corresponds to the evolution along the section(s). However, this rule is not respected when constructing certain specific Geom surfaces (typically cylindrical surfaces, surfaces of revolution, etc.) for which the parameterization is inversed. The ExchangeUV function checks for this, and returns true in all these specific cases. Warning Do not use this function before the surface is built.
        	:rtype: bool
        """
        return _GeomFill.GeomFill_Pipe_ExchangeUV(self, *args)


    def GenerateParticularCase(self, *args) -> "Standard_Boolean":
        """
        * Sets a flag to try to create as many planes, cylinder,... as possible. Default value is <Standard_False>.
        	:param B:
        	:type B: bool
        	:rtype: None
        * Returns the flag.
        	:rtype: bool
        """
        return _GeomFill.GeomFill_Pipe_GenerateParticularCase(self, *args)


    def __init__(self, *args):
        """
        * Constructs an empty algorithm for building pipes. Use the function Init to initialize it.
        	:rtype: None
        :param Path:
        	:type Path: Geom_Curve
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Create a pipe with a constant section (<FirstSection>) and a path (<Path>) Option can be - GeomFill_IsCorrectedFrenet - GeomFill_IsFrenet - GeomFill_IsConstant
        	:param Path:
        	:type Path: Geom_Curve
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:param Option: default value is GeomFill_IsCorrectedFrenet
        	:type Option: GeomFill_Trihedron
        	:rtype: None
        * Create a pipe with a constant section (<FirstSection>) and a path defined by <Path> and <Support>
        	:param Path:
        	:type Path: Geom2d_Curve
        	:param Support:
        	:type Support: Geom_Surface
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:rtype: None
        * Create a pipe with a constant section (<FirstSection>) and a path <Path> and a fixed binormal direction <Dir>
        	:param Path:
        	:type Path: Geom_Curve
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:param Dir:
        	:type Dir: gp_Dir
        	:rtype: None
        * Create a pipe with an evolving section The section evoluate from First to Last Section
        	:param Path:
        	:type Path: Geom_Curve
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:param LastSect:
        	:type LastSect: Geom_Curve
        	:rtype: None
        * Create a pipe with N sections The section evoluate from First to Last Section
        	:param Path:
        	:type Path: Geom_Curve
        	:param NSections:
        	:type NSections: TColGeom_SequenceOfCurve
        	:rtype: None
        * Create a pipe with a constant radius with 2 guide-line.
        	:param Path:
        	:type Path: Geom_Curve
        	:param Curve1:
        	:type Curve1: Geom_Curve
        	:param Curve2:
        	:type Curve2: Geom_Curve
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Create a pipe with a constant radius with 2 guide-line.
        	:param Path:
        	:type Path: Adaptor3d_HCurve
        	:param Curve1:
        	:type Curve1: Adaptor3d_HCurve
        	:param Curve2:
        	:type Curve2: Adaptor3d_HCurve
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Create a pipe with a constant section and with 1 guide-line. Use the function Perform to build the surface. All standard specific cases are detected in order to construct, according to the respective geometric nature of Path and the sections, a planar, cylindrical, conical, spherical or toroidal surface, a surface of linear extrusion or a surface of revolution. In the general case, the result is a BSpline surface (NURBS) built by approximation of a series of sections where: - the number of sections N is chosen automatically by the algorithm according to the respective geometries of Path and the sections. N is greater than or equal to 2; - N points Pi (with i in the range [ 1,N ]) are defined at regular intervals along the curve Path from its first point to its end point. At each point Pi, a coordinate system Ti is computed with Pi as origin, and with the tangential and normal vectors to Path defining two of its coordinate axes. In the case of a pipe with a constant circular section, the first section is a circle of radius Radius centered on the origin of Path and whose 'Z Axis' is aligned along the vector tangential to the origin of Path. In the case of a pipe with a constant section, the first section is the curve FirstSect. In these two cases, the ith section (for values of i greater than 1) is obtained by applying to a copy of this first section the geometric transformation which transforms coordinate system T1 into coordinate system Ti. In the case of an evolving section, N-2 intermediate curves Si are first computed (if N is greater than 2, and with i in the range [ 2,N-1 ]) whose geometry evolves regularly from the curve S1=FirstSect to the curve SN=LastSect. The first section is FirstSect, and the ith section (for values of i greater than 1) is obtained by applying to the curve Si the geometric transformation which transforms coordinate system T1 into coordinate system Ti.
        	:param Path:
        	:type Path: Geom_Curve
        	:param Guide:
        	:type Guide: Adaptor3d_HCurve
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:param ByACR:
        	:type ByACR: bool
        	:param rotat:
        	:type rotat: bool
        	:rtype: None
        """
        _GeomFill.GeomFill_Pipe_swiginit(self, _GeomFill.new_GeomFill_Pipe(*args))

    def Init(self, *args) -> "void":
        """
        :param Path:
        	:type Path: Geom_Curve
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        :param Path:
        	:type Path: Geom_Curve
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:param Option: default value is GeomFill_IsCorrectedFrenet
        	:type Option: GeomFill_Trihedron
        	:rtype: None
        :param Path:
        	:type Path: Geom2d_Curve
        	:param Support:
        	:type Support: Geom_Surface
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:rtype: None
        :param Path:
        	:type Path: Geom_Curve
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:param Dir:
        	:type Dir: gp_Dir
        	:rtype: None
        :param Path:
        	:type Path: Geom_Curve
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:param LastSect:
        	:type LastSect: Geom_Curve
        	:rtype: None
        :param Path:
        	:type Path: Geom_Curve
        	:param NSections:
        	:type NSections: TColGeom_SequenceOfCurve
        	:rtype: None
        * Create a pipe with a constant radius with 2 guide-line.
        	:param Path:
        	:type Path: Adaptor3d_HCurve
        	:param Curve1:
        	:type Curve1: Adaptor3d_HCurve
        	:param Curve2:
        	:type Curve2: Adaptor3d_HCurve
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Initializes this pipe algorithm to build the following surface: - a pipe with a constant circular section of radius Radius along the path Path, or - a pipe with constant section FirstSect along the path Path, or - a pipe where the section evolves from FirstSect to LastSect along the path Path. Use the function Perform to build the surface. Note: a description of the resulting surface is given under Constructors.
        	:param Path:
        	:type Path: Geom_Curve
        	:param Guide:
        	:type Guide: Adaptor3d_HCurve
        	:param FirstSect:
        	:type FirstSect: Geom_Curve
        	:param ByACR:
        	:type ByACR: bool
        	:param rotat:
        	:type rotat: bool
        	:rtype: None
        """
        return _GeomFill.GeomFill_Pipe_Init(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns whether approximation was done.
        	:rtype: bool
        """
        return _GeomFill.GeomFill_Pipe_IsDone(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Builds the pipe defined at the time of initialization of this algorithm. A description of the resulting surface is given under Constructors. If WithParameters (defaulted to false) is set to true, the approximation algorithm (used only in the general case of construction of a BSpline surface) builds the surface with a u parameter corresponding to the one of the path. Exceptions Standard_ConstructionError if a surface cannot be constructed from the data. Warning: It is the old Perform method, the next methode is recommended.
        	:param WithParameters: default value is Standard_False
        	:type WithParameters: bool
        	:param myPolynomial: default value is Standard_False
        	:type myPolynomial: bool
        	:rtype: None
        * detects the particular cases. And compute the surface. if none particular case is detected we make an approximation with respect of the Tolerance <Tol>, the continuty <Conti>, the maximum degree <MaxDegree>, the maximum number of span <NbMaxSegment> and the spine parametrization. If we can't create a surface with the data
        	:param Tol:
        	:type Tol: float
        	:param Polynomial:
        	:type Polynomial: bool
        	:param Conti: default value is GeomAbs_C1
        	:type Conti: GeomAbs_Shape
        	:param MaxDegree: default value is 11
        	:type MaxDegree: int
        	:param NbMaxSegment: default value is 30
        	:type NbMaxSegment: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_Pipe_Perform(self, *args)


    def Surface(self, *args) -> "opencascade::handle< Geom_Surface > const &":
        """
        * Returns the surface built by this algorithm. Warning Do not use this function before the surface is built (in this case the function will return a null handle).
        	:rtype: opencascade::handle<Geom_Surface>
        """
        return _GeomFill.GeomFill_Pipe_Surface(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Pipe
GeomFill_Pipe.ErrorOnSurf = new_instancemethod(_GeomFill.GeomFill_Pipe_ErrorOnSurf, None, GeomFill_Pipe)
GeomFill_Pipe.ExchangeUV = new_instancemethod(_GeomFill.GeomFill_Pipe_ExchangeUV, None, GeomFill_Pipe)
GeomFill_Pipe.GenerateParticularCase = new_instancemethod(_GeomFill.GeomFill_Pipe_GenerateParticularCase, None, GeomFill_Pipe)
GeomFill_Pipe.Init = new_instancemethod(_GeomFill.GeomFill_Pipe_Init, None, GeomFill_Pipe)
GeomFill_Pipe.IsDone = new_instancemethod(_GeomFill.GeomFill_Pipe_IsDone, None, GeomFill_Pipe)
GeomFill_Pipe.Perform = new_instancemethod(_GeomFill.GeomFill_Pipe_Perform, None, GeomFill_Pipe)
GeomFill_Pipe.Surface = new_instancemethod(_GeomFill.GeomFill_Pipe_Surface, None, GeomFill_Pipe)
GeomFill_Pipe_swigregister = _GeomFill.GeomFill_Pipe_swigregister
GeomFill_Pipe_swigregister(GeomFill_Pipe)

class GeomFill_PlanFunc(OCC.Core.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def D2(self, *args) -> "void":
        """
        :param X:
        	:type X: float
        	:param F:
        	:type F: float
        	:param D1:
        	:type D1: float
        	:param D2:
        	:type D2: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_PlanFunc_D2(self, *args)


    def D2E(self, *args) -> "void":
        """
        :param X:
        	:type X: float
        	:param DP:
        	:type DP: gp_Vec
        	:param D2P:
        	:type D2P: gp_Vec
        	:param DV:
        	:type DV: gp_Vec
        	:param D2V:
        	:type D2V: gp_Vec
        	:param DFDT:
        	:type DFDT: float
        	:param D2FDT2:
        	:type D2FDT2: float
        	:param D2FDTDX:
        	:type D2FDTDX: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_PlanFunc_D2E(self, *args)


    def DEDT(self, *args) -> "void":
        """
        :param X:
        	:type X: float
        	:param DP:
        	:type DP: gp_Vec
        	:param DV:
        	:type DV: gp_Vec
        	:param DF:
        	:type DF: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_PlanFunc_DEDT(self, *args)


    def __init__(self, *args):
        """
        :param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Vec
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: None
        """
        _GeomFill.GeomFill_PlanFunc_swiginit(self, _GeomFill.new_GeomFill_PlanFunc(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_PlanFunc
GeomFill_PlanFunc.D2 = new_instancemethod(_GeomFill.GeomFill_PlanFunc_D2, None, GeomFill_PlanFunc)
GeomFill_PlanFunc.D2E = new_instancemethod(_GeomFill.GeomFill_PlanFunc_D2E, None, GeomFill_PlanFunc)
GeomFill_PlanFunc.DEDT = new_instancemethod(_GeomFill.GeomFill_PlanFunc_DEDT, None, GeomFill_PlanFunc)
GeomFill_PlanFunc_swigregister = _GeomFill.GeomFill_PlanFunc_swigregister
GeomFill_PlanFunc_swigregister(GeomFill_PlanFunc)

class GeomFill_PolynomialConvertor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_PolynomialConvertor_swiginit(self, _GeomFill.new_GeomFill_PolynomialConvertor(*args))

    def Init(self, *args) -> "void":
        """:rtype: None"""
        return _GeomFill.GeomFill_PolynomialConvertor_Init(self, *args)


    def Initialized(self, *args) -> "Standard_Boolean":
        """
        * say if <self> is Initialized
        	:rtype: bool
        """
        return _GeomFill.GeomFill_PolynomialConvertor_Initialized(self, *args)


    def Section(self, *args) -> "void":
        """
        :param FirstPnt:
        	:type FirstPnt: gp_Pnt
        	:param Center:
        	:type Center: gp_Pnt
        	:param Dir:
        	:type Dir: gp_Vec
        	:param Angle:
        	:type Angle: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:rtype: None
        :param FirstPnt:
        	:type FirstPnt: gp_Pnt
        	:param DFirstPnt:
        	:type DFirstPnt: gp_Vec
        	:param Center:
        	:type Center: gp_Pnt
        	:param DCenter:
        	:type DCenter: gp_Vec
        	:param Dir:
        	:type Dir: gp_Vec
        	:param DDir:
        	:type DDir: gp_Vec
        	:param Angle:
        	:type Angle: float
        	:param DAngle:
        	:type DAngle: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:rtype: None
        :param FirstPnt:
        	:type FirstPnt: gp_Pnt
        	:param DFirstPnt:
        	:type DFirstPnt: gp_Vec
        	:param D2FirstPnt:
        	:type D2FirstPnt: gp_Vec
        	:param Center:
        	:type Center: gp_Pnt
        	:param DCenter:
        	:type DCenter: gp_Vec
        	:param D2Center:
        	:type D2Center: gp_Vec
        	:param Dir:
        	:type Dir: gp_Vec
        	:param DDir:
        	:type DDir: gp_Vec
        	:param D2Dir:
        	:type D2Dir: gp_Vec
        	:param Angle:
        	:type Angle: float
        	:param DAngle:
        	:type DAngle: float
        	:param D2Angle:
        	:type D2Angle: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:rtype: None
        """
        return _GeomFill.GeomFill_PolynomialConvertor_Section(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_PolynomialConvertor
GeomFill_PolynomialConvertor.Init = new_instancemethod(_GeomFill.GeomFill_PolynomialConvertor_Init, None, GeomFill_PolynomialConvertor)
GeomFill_PolynomialConvertor.Initialized = new_instancemethod(_GeomFill.GeomFill_PolynomialConvertor_Initialized, None, GeomFill_PolynomialConvertor)
GeomFill_PolynomialConvertor.Section = new_instancemethod(_GeomFill.GeomFill_PolynomialConvertor_Section, None, GeomFill_PolynomialConvertor)
GeomFill_PolynomialConvertor_swigregister = _GeomFill.GeomFill_PolynomialConvertor_swigregister
GeomFill_PolynomialConvertor_swigregister(GeomFill_PolynomialConvertor)

class GeomFill_Profiler(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddCurve(self, *args) -> "void":
        """
        :param Curve:
        	:type Curve: Geom_Curve
        	:rtype: None
        """
        return _GeomFill.GeomFill_Profiler_AddCurve(self, *args)


    def Curve(self, *args) -> "opencascade::handle< Geom_Curve > const &":
        """
        :param Index:
        	:type Index: int
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _GeomFill.GeomFill_Profiler_Curve(self, *args)


    def Degree(self, *args) -> "Standard_Integer":
        """
        * Raises if not yet perform
        	:rtype: int
        """
        return _GeomFill.GeomFill_Profiler_Degree(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_Profiler_swiginit(self, _GeomFill.new_GeomFill_Profiler(*args))

    def IsPeriodic(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _GeomFill.GeomFill_Profiler_IsPeriodic(self, *args)


    def KnotsAndMults(self, *args) -> "void":
        """
        * Raises if not yet perform Raises if the lengthes of <Knots> and <Mults> are not equal to NbKnots().
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _GeomFill.GeomFill_Profiler_KnotsAndMults(self, *args)


    def NbKnots(self, *args) -> "Standard_Integer":
        """
        * Raises if not yet perform
        	:rtype: int
        """
        return _GeomFill.GeomFill_Profiler_NbKnots(self, *args)


    def NbPoles(self, *args) -> "Standard_Integer":
        """
        * Raises if not yet perform
        	:rtype: int
        """
        return _GeomFill.GeomFill_Profiler_NbPoles(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Converts all curves to BSplineCurves. Set them to the common profile. <PTol> is used to compare 2 knots.
        	:param PTol:
        	:type PTol: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_Profiler_Perform(self, *args)


    def Poles(self, *args) -> "void":
        """
        * returns in <Poles> the poles of the BSplineCurve from index <Index> adjusting to the current profile. Raises if not yet perform Raises if <Index> not in the range [1,NbCurves] if the length of <Poles> is not equal to NbPoles().
        	:param Index:
        	:type Index: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:rtype: None
        """
        return _GeomFill.GeomFill_Profiler_Poles(self, *args)


    def Weights(self, *args) -> "void":
        """
        * returns in <Weights> the weights of the BSplineCurve from index <Index> adjusting to the current profile. Raises if not yet perform Raises if <Index> not in the range [1,NbCurves] or if the length of <Weights> is not equal to NbPoles().
        	:param Index:
        	:type Index: int
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:rtype: None
        """
        return _GeomFill.GeomFill_Profiler_Weights(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Profiler
GeomFill_Profiler.AddCurve = new_instancemethod(_GeomFill.GeomFill_Profiler_AddCurve, None, GeomFill_Profiler)
GeomFill_Profiler.Curve = new_instancemethod(_GeomFill.GeomFill_Profiler_Curve, None, GeomFill_Profiler)
GeomFill_Profiler.Degree = new_instancemethod(_GeomFill.GeomFill_Profiler_Degree, None, GeomFill_Profiler)
GeomFill_Profiler.IsPeriodic = new_instancemethod(_GeomFill.GeomFill_Profiler_IsPeriodic, None, GeomFill_Profiler)
GeomFill_Profiler.KnotsAndMults = new_instancemethod(_GeomFill.GeomFill_Profiler_KnotsAndMults, None, GeomFill_Profiler)
GeomFill_Profiler.NbKnots = new_instancemethod(_GeomFill.GeomFill_Profiler_NbKnots, None, GeomFill_Profiler)
GeomFill_Profiler.NbPoles = new_instancemethod(_GeomFill.GeomFill_Profiler_NbPoles, None, GeomFill_Profiler)
GeomFill_Profiler.Perform = new_instancemethod(_GeomFill.GeomFill_Profiler_Perform, None, GeomFill_Profiler)
GeomFill_Profiler.Poles = new_instancemethod(_GeomFill.GeomFill_Profiler_Poles, None, GeomFill_Profiler)
GeomFill_Profiler.Weights = new_instancemethod(_GeomFill.GeomFill_Profiler_Weights, None, GeomFill_Profiler)
GeomFill_Profiler_swigregister = _GeomFill.GeomFill_Profiler_swigregister
GeomFill_Profiler_swigregister(GeomFill_Profiler)

class GeomFill_QuasiAngularConvertor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_QuasiAngularConvertor_swiginit(self, _GeomFill.new_GeomFill_QuasiAngularConvertor(*args))

    def Init(self, *args) -> "void":
        """:rtype: None"""
        return _GeomFill.GeomFill_QuasiAngularConvertor_Init(self, *args)


    def Initialized(self, *args) -> "Standard_Boolean":
        """
        * say if <self> is Initialized
        	:rtype: bool
        """
        return _GeomFill.GeomFill_QuasiAngularConvertor_Initialized(self, *args)


    def Section(self, *args) -> "void":
        """
        :param FirstPnt:
        	:type FirstPnt: gp_Pnt
        	:param Center:
        	:type Center: gp_Pnt
        	:param Dir:
        	:type Dir: gp_Vec
        	:param Angle:
        	:type Angle: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:rtype: None
        :param FirstPnt:
        	:type FirstPnt: gp_Pnt
        	:param DFirstPnt:
        	:type DFirstPnt: gp_Vec
        	:param Center:
        	:type Center: gp_Pnt
        	:param DCenter:
        	:type DCenter: gp_Vec
        	:param Dir:
        	:type Dir: gp_Vec
        	:param DDir:
        	:type DDir: gp_Vec
        	:param Angle:
        	:type Angle: float
        	:param DAngle:
        	:type DAngle: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param DWeights:
        	:type DWeights: TColStd_Array1OfReal
        	:rtype: None
        :param FirstPnt:
        	:type FirstPnt: gp_Pnt
        	:param DFirstPnt:
        	:type DFirstPnt: gp_Vec
        	:param D2FirstPnt:
        	:type D2FirstPnt: gp_Vec
        	:param Center:
        	:type Center: gp_Pnt
        	:param DCenter:
        	:type DCenter: gp_Vec
        	:param D2Center:
        	:type D2Center: gp_Vec
        	:param Dir:
        	:type Dir: gp_Vec
        	:param DDir:
        	:type DDir: gp_Vec
        	:param D2Dir:
        	:type D2Dir: gp_Vec
        	:param Angle:
        	:type Angle: float
        	:param DAngle:
        	:type DAngle: float
        	:param D2Angle:
        	:type D2Angle: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param DWeights:
        	:type DWeights: TColStd_Array1OfReal
        	:param D2Weights:
        	:type D2Weights: TColStd_Array1OfReal
        	:rtype: None
        """
        return _GeomFill.GeomFill_QuasiAngularConvertor_Section(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_QuasiAngularConvertor
GeomFill_QuasiAngularConvertor.Init = new_instancemethod(_GeomFill.GeomFill_QuasiAngularConvertor_Init, None, GeomFill_QuasiAngularConvertor)
GeomFill_QuasiAngularConvertor.Initialized = new_instancemethod(_GeomFill.GeomFill_QuasiAngularConvertor_Initialized, None, GeomFill_QuasiAngularConvertor)
GeomFill_QuasiAngularConvertor.Section = new_instancemethod(_GeomFill.GeomFill_QuasiAngularConvertor_Section, None, GeomFill_QuasiAngularConvertor)
GeomFill_QuasiAngularConvertor_swigregister = _GeomFill.GeomFill_QuasiAngularConvertor_swigregister
GeomFill_QuasiAngularConvertor_swigregister(GeomFill_QuasiAngularConvertor)

class GeomFill_SectionLaw(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BSplineSurface(self, *args) -> "opencascade::handle< Geom_BSplineSurface >":
        """
        * give if possible an bspline Surface, like iso-v are the section. If it is not possible this methode have to get an Null Surface. It is the default implementation.
        	:rtype: opencascade::handle<Geom_BSplineSurface>
        """
        return _GeomFill.GeomFill_SectionLaw_BSplineSurface(self, *args)


    def BarycentreOfSurf(self, *args) -> "gp_Pnt":
        """
        * Get the barycentre of Surface. An very poor estimation is sufficent. This information is usefull to perform well conditioned rational approximation. Warning: Used only if <self> IsRational
        	:rtype: gp_Pnt
        """
        return _GeomFill.GeomFill_SectionLaw_BarycentreOfSurf(self, *args)


    def CirclSection(self, *args) -> "opencascade::handle< Geom_Curve >":
        """
        * Return the circle section at parameter <Param>, if <self> a IsConicalLaw
        	:param Param:
        	:type Param: float
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _GeomFill.GeomFill_SectionLaw_CirclSection(self, *args)


    def ConstantSection(self, *args) -> "opencascade::handle< Geom_Curve >":
        """
        * Return a copy of the constant Section, if me IsConstant
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _GeomFill.GeomFill_SectionLaw_ConstantSection(self, *args)


    def D0(self, *args) -> "Standard_Boolean":
        """
        * compute the section for v = param
        	:param Param:
        	:type Param: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _GeomFill.GeomFill_SectionLaw_D0(self, *args)


    def D1(self, *args) -> "Standard_Boolean":
        """
        * compute the first derivative in v direction of the section for v = param Warning : It used only for C1 or C2 aproximation
        	:param Param:
        	:type Param: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _GeomFill.GeomFill_SectionLaw_D1(self, *args)


    def D2(self, *args) -> "Standard_Boolean":
        """
        * compute the second derivative in v direction of the section for v = param Warning : It used only for C2 aproximation
        	:param Param:
        	:type Param: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:param D2Weigths:
        	:type D2Weigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _GeomFill.GeomFill_SectionLaw_D2(self, *args)


    def GetDomain(self, *args) -> "void":
        """
        * Gets the bounds of the function parametric domain. Warning: This domain it is not modified by the SetValue method
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_GetDomain(self, *args)


    def GetInterval(self, *args) -> "void":
        """
        * Gets the bounds of the parametric interval on the function
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_GetInterval(self, *args)


    def GetMinimalWeight(self, *args) -> "void":
        """
        * Compute the minimal value of weight for each poles in all sections. This information is usefull to control error in rational approximation. Warning: Used only if <self> IsRational
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_GetMinimalWeight(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        * Returns the tolerances associated at each poles to reach in approximation, to satisfy: BoundTol error at the Boundary AngleTol tangent error at the Boundary (in radian) SurfTol error inside the surface.
        	:param BoundTol:
        	:type BoundTol: float
        	:param SurfTol:
        	:type SurfTol: float
        	:param AngleTol:
        	:type AngleTol: float
        	:param Tol3d:
        	:type Tol3d: TColStd_Array1OfReal
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_GetTolerance(self, *args)


    def Intervals(self, *args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_Intervals(self, *args)


    def IsConicalLaw(self, *args) -> "Standard_Boolean":
        """
        * Returns True if all section are circle, with same plane,same center and linear radius evolution Return False by Default.
        	:param Error:
        	:type Error: float
        	:rtype: bool
        """
        return _GeomFill.GeomFill_SectionLaw_IsConicalLaw(self, *args)


    def IsConstant(self, *args) -> "Standard_Boolean":
        """
        * Say if all sections are equals
        	:param Error:
        	:type Error: float
        	:rtype: bool
        """
        return _GeomFill.GeomFill_SectionLaw_IsConstant(self, *args)


    def IsRational(self, *args) -> "Standard_Boolean":
        """
        * Returns if the sections are rationnal or not
        	:rtype: bool
        """
        return _GeomFill.GeomFill_SectionLaw_IsRational(self, *args)


    def IsUPeriodic(self, *args) -> "Standard_Boolean":
        """
        * Returns if the sections are periodic or not
        	:rtype: bool
        """
        return _GeomFill.GeomFill_SectionLaw_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args) -> "Standard_Boolean":
        """
        * Returns if law is periodic or not
        	:rtype: bool
        """
        return _GeomFill.GeomFill_SectionLaw_IsVPeriodic(self, *args)


    def Knots(self, *args) -> "void":
        """
        * get the Knots of the section
        	:param TKnots:
        	:type TKnots: TColStd_Array1OfReal
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_Knots(self, *args)


    def MaximalSection(self, *args) -> "Standard_Real":
        """
        * Returns the length of the greater section. This information is usefull to G1's control. Warning: With an little value, approximation can be slower.
        	:rtype: float
        """
        return _GeomFill.GeomFill_SectionLaw_MaximalSection(self, *args)


    def Mults(self, *args) -> "void":
        """
        * get the Multplicities of the section
        	:param TMults:
        	:type TMults: TColStd_Array1OfInteger
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_Mults(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _GeomFill.GeomFill_SectionLaw_NbIntervals(self, *args)


    def SectionShape(self, *args) -> "void":
        """
        * get the format of an section
        	:param NbPoles:
        	:type NbPoles: int
        	:param NbKnots:
        	:type NbKnots: int
        	:param Degree:
        	:type Degree: int
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_SectionShape(self, *args)


    def SetInterval(self, *args) -> "void":
        """
        * Sets the bounds of the parametric interval on the function This determines the derivatives in these values if the function is not Cn.
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_SetInterval(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Is usefull, if (me) have to run numerical algorithm to perform D0, D1 or D2 The default implementation make nothing.
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_SectionLaw_SetTolerance(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_SectionLaw_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_SectionLaw
GeomFill_SectionLaw.BSplineSurface = new_instancemethod(_GeomFill.GeomFill_SectionLaw_BSplineSurface, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.BarycentreOfSurf = new_instancemethod(_GeomFill.GeomFill_SectionLaw_BarycentreOfSurf, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.CirclSection = new_instancemethod(_GeomFill.GeomFill_SectionLaw_CirclSection, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.ConstantSection = new_instancemethod(_GeomFill.GeomFill_SectionLaw_ConstantSection, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.D0 = new_instancemethod(_GeomFill.GeomFill_SectionLaw_D0, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.D1 = new_instancemethod(_GeomFill.GeomFill_SectionLaw_D1, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.D2 = new_instancemethod(_GeomFill.GeomFill_SectionLaw_D2, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.GetDomain = new_instancemethod(_GeomFill.GeomFill_SectionLaw_GetDomain, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.GetInterval = new_instancemethod(_GeomFill.GeomFill_SectionLaw_GetInterval, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.GetMinimalWeight = new_instancemethod(_GeomFill.GeomFill_SectionLaw_GetMinimalWeight, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.GetTolerance = new_instancemethod(_GeomFill.GeomFill_SectionLaw_GetTolerance, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.Intervals = new_instancemethod(_GeomFill.GeomFill_SectionLaw_Intervals, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.IsConicalLaw = new_instancemethod(_GeomFill.GeomFill_SectionLaw_IsConicalLaw, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.IsConstant = new_instancemethod(_GeomFill.GeomFill_SectionLaw_IsConstant, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.IsRational = new_instancemethod(_GeomFill.GeomFill_SectionLaw_IsRational, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.IsUPeriodic = new_instancemethod(_GeomFill.GeomFill_SectionLaw_IsUPeriodic, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.IsVPeriodic = new_instancemethod(_GeomFill.GeomFill_SectionLaw_IsVPeriodic, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.Knots = new_instancemethod(_GeomFill.GeomFill_SectionLaw_Knots, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.MaximalSection = new_instancemethod(_GeomFill.GeomFill_SectionLaw_MaximalSection, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.Mults = new_instancemethod(_GeomFill.GeomFill_SectionLaw_Mults, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.NbIntervals = new_instancemethod(_GeomFill.GeomFill_SectionLaw_NbIntervals, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.SectionShape = new_instancemethod(_GeomFill.GeomFill_SectionLaw_SectionShape, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.SetInterval = new_instancemethod(_GeomFill.GeomFill_SectionLaw_SetInterval, None, GeomFill_SectionLaw)
GeomFill_SectionLaw.SetTolerance = new_instancemethod(_GeomFill.GeomFill_SectionLaw_SetTolerance, None, GeomFill_SectionLaw)
GeomFill_SectionLaw_swigregister = _GeomFill.GeomFill_SectionLaw_swigregister
GeomFill_SectionLaw_swigregister(GeomFill_SectionLaw)

class GeomFill_SectionPlacement(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _GeomFill.GeomFill_SectionPlacement_Angle(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _GeomFill.GeomFill_SectionPlacement_Distance(self, *args)


    def __init__(self, *args):
        """
        :param L:
        	:type L: GeomFill_LocationLaw
        	:param Section:
        	:type Section: Geom_Geometry
        	:rtype: None
        """
        _GeomFill.GeomFill_SectionPlacement_swiginit(self, _GeomFill.new_GeomFill_SectionPlacement(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _GeomFill.GeomFill_SectionPlacement_IsDone(self, *args)


    def ModifiedSection(self, *args) -> "opencascade::handle< Geom_Curve >":
        """
        * Compute the Section, in the coordinate syteme given by the Location Law. To have the Normal to section equal to the Location Law Normal. If <WithTranslation> contact beetween <Section> and <Path> is forced.
        	:param WithTranslation:
        	:type WithTranslation: bool
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _GeomFill.GeomFill_SectionPlacement_ModifiedSection(self, *args)


    def ParameterOnPath(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _GeomFill.GeomFill_SectionPlacement_ParameterOnPath(self, *args)


    def ParameterOnSection(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _GeomFill.GeomFill_SectionPlacement_ParameterOnSection(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param Tol:
        	:type Tol: float
        	:rtype: None
        :param Path:
        	:type Path: Adaptor3d_HCurve
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        :param ParamOnPath:
        	:type ParamOnPath: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_SectionPlacement_Perform(self, *args)


    def Section(self, *args) -> "opencascade::handle< Geom_Curve >":
        """
        * Compute the Section, in the coordinate syteme given by the Location Law. If <WithTranslation> contact beetween <Section> and <Path> is forced.
        	:param WithTranslation:
        	:type WithTranslation: bool
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _GeomFill.GeomFill_SectionPlacement_Section(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * To change the section Law
        	:param L:
        	:type L: GeomFill_LocationLaw
        	:rtype: None
        """
        return _GeomFill.GeomFill_SectionPlacement_SetLocation(self, *args)


    def Transformation(self, *args) -> "gp_Trsf":
        """
        :param WithTranslation:
        	:type WithTranslation: bool
        	:param WithCorrection: default value is Standard_False
        	:type WithCorrection: bool
        	:rtype: gp_Trsf
        """
        return _GeomFill.GeomFill_SectionPlacement_Transformation(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_SectionPlacement
GeomFill_SectionPlacement.Angle = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_Angle, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement.Distance = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_Distance, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement.IsDone = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_IsDone, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement.ModifiedSection = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_ModifiedSection, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement.ParameterOnPath = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_ParameterOnPath, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement.ParameterOnSection = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_ParameterOnSection, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement.Perform = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_Perform, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement.Section = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_Section, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement.SetLocation = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_SetLocation, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement.Transformation = new_instancemethod(_GeomFill.GeomFill_SectionPlacement_Transformation, None, GeomFill_SectionPlacement)
GeomFill_SectionPlacement_swigregister = _GeomFill.GeomFill_SectionPlacement_swigregister
GeomFill_SectionPlacement_swigregister(GeomFill_SectionPlacement)

class GeomFill_SnglrFunc(OCC.Core.Adaptor3d.Adaptor3d_Curve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param HC:
        	:type HC: Adaptor3d_HCurve
        	:rtype: None
        """
        _GeomFill.GeomFill_SnglrFunc_swiginit(self, _GeomFill.new_GeomFill_SnglrFunc(*args))

    def SetRatio(self, *args) -> "void":
        """
        :param Ratio:
        	:type Ratio: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_SnglrFunc_SetRatio(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_SnglrFunc
GeomFill_SnglrFunc.SetRatio = new_instancemethod(_GeomFill.GeomFill_SnglrFunc_SetRatio, None, GeomFill_SnglrFunc)
GeomFill_SnglrFunc_swigregister = _GeomFill.GeomFill_SnglrFunc_swigregister
GeomFill_SnglrFunc_swigregister(GeomFill_SnglrFunc)

class GeomFill_Sweep(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Build(self, *args) -> "void":
        """
        * Build the Sweeep Surface ApproxStyle defines Approximation Strategy - GeomFill_Section : The composed Function : Location X Section is directly approximed. - GeomFill_Location : The location law is approximed, and the SweepSurface is build algebric composition of approximed location law and section law This option is Ok, if Section.Surface() methode is effective. Continuity : The continuity in v waiting on the surface Degmax : The maximum degree in v requiered on the surface Segmax : The maximum number of span in v requiered on the surface //! raise If Domain are infinite or Profile not Setted.
        	:param Section:
        	:type Section: GeomFill_SectionLaw
        	:param Methode: default value is GeomFill_Location
        	:type Methode: GeomFill_ApproxStyle
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param Degmax: default value is 10
        	:type Degmax: int
        	:param Segmax: default value is 30
        	:type Segmax: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_Sweep_Build(self, *args)


    def ErrorOnRestriction(self, *args) -> "void":
        """
        * Gets the Approximation error.
        	:param IsFirst:
        	:type IsFirst: bool
        	:param UError:
        	:type UError: float
        	:param VError:
        	:type VError: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_Sweep_ErrorOnRestriction(self, *args)


    def ErrorOnSurface(self, *args) -> "Standard_Real":
        """
        * Gets the Approximation error.
        	:rtype: float
        """
        return _GeomFill.GeomFill_Sweep_ErrorOnSurface(self, *args)


    def ErrorOnTrace(self, *args) -> "void":
        """
        * Gets the Approximation error.
        	:param IndexOfTrace:
        	:type IndexOfTrace: int
        	:param UError:
        	:type UError: float
        	:param VError:
        	:type VError: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_Sweep_ErrorOnTrace(self, *args)


    def ExchangeUV(self, *args) -> "Standard_Boolean":
        """
        * returns true if sections are U-Iso This can be produce in some cases when <WithKpart> is True.
        	:rtype: bool
        """
        return _GeomFill.GeomFill_Sweep_ExchangeUV(self, *args)


    def __init__(self, *args):
        """
        :param Location:
        	:type Location: GeomFill_LocationLaw
        	:param WithKpart: default value is Standard_True
        	:type WithKpart: bool
        	:rtype: None
        """
        _GeomFill.GeomFill_Sweep_swiginit(self, _GeomFill.new_GeomFill_Sweep(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Tells if the Surface is Buildt.
        	:rtype: bool
        """
        return _GeomFill.GeomFill_Sweep_IsDone(self, *args)


    def NumberOfTrace(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _GeomFill.GeomFill_Sweep_NumberOfTrace(self, *args)


    def Restriction(self, *args) -> "opencascade::handle< Geom2d_Curve >":
        """
        :param IsFirst:
        	:type IsFirst: bool
        	:rtype: opencascade::handle<Geom2d_Curve>
        """
        return _GeomFill.GeomFill_Sweep_Restriction(self, *args)


    def SetDomain(self, *args) -> "void":
        """
        * Set parametric information [<First>, <Last>] Sets the parametric bound of the sweeping surface to build. <SectionFirst>, <SectionLast> gives coresponding bounds parameter on the section law of <First> and <Last> //! V-Iso on Sweeping Surface S(u,v) is defined by Location(v) and Section(w) where w = SectionFirst + (v - First) / (Last-First) * (SectionLast - SectionFirst) //! By default w = v, and First and Last are given by First and Last parameter stored in LocationLaw.
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param SectionFirst:
        	:type SectionFirst: float
        	:param SectionLast:
        	:type SectionLast: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_Sweep_SetDomain(self, *args)


    def SetForceApproxC1(self, *args) -> "void":
        """
        * Set the flag that indicates attempt to approximate a C1-continuous surface if a swept surface proved to be C0.
        	:param ForceApproxC1:
        	:type ForceApproxC1: bool
        	:rtype: None
        """
        return _GeomFill.GeomFill_Sweep_SetForceApproxC1(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Set Approximation Tolerance Tol3d : Tolerance to surface approximation Tol2d : Tolerance used to perform curve approximation Normaly the 2d curve are approximated with a tolerance given by the resolution method define in <LocationLaw> but if this tolerance is too large Tol2d is used. TolAngular : Tolerance (in radian) to control the angle beetween tangents on the section law and tangent of iso-v on approximed surface
        	:param Tol3d:
        	:type Tol3d: float
        	:param BoundTol: default value is 1.0
        	:type BoundTol: float
        	:param Tol2d: default value is 1.0e-5
        	:type Tol2d: float
        	:param TolAngular: default value is 1.0
        	:type TolAngular: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_Sweep_SetTolerance(self, *args)


    def Surface(self, *args) -> "opencascade::handle< Geom_Surface >":
        """:rtype: opencascade::handle<Geom_Surface>"""
        return _GeomFill.GeomFill_Sweep_Surface(self, *args)


    def Trace(self, *args) -> "opencascade::handle< Geom2d_Curve >":
        """
        :param IndexOfTrace:
        	:type IndexOfTrace: int
        	:rtype: opencascade::handle<Geom2d_Curve>
        """
        return _GeomFill.GeomFill_Sweep_Trace(self, *args)


    def UReversed(self, *args) -> "Standard_Boolean":
        """
        * returns true if Parametrisation sens in U is inverse of parametrisation sens of section (or of path if ExchangeUV)
        	:rtype: bool
        """
        return _GeomFill.GeomFill_Sweep_UReversed(self, *args)


    def VReversed(self, *args) -> "Standard_Boolean":
        """
        * returns true if Parametrisation sens in V is inverse of parametrisation sens of path (or of section if ExchangeUV)
        	:rtype: bool
        """
        return _GeomFill.GeomFill_Sweep_VReversed(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Sweep
GeomFill_Sweep.Build = new_instancemethod(_GeomFill.GeomFill_Sweep_Build, None, GeomFill_Sweep)
GeomFill_Sweep.ErrorOnRestriction = new_instancemethod(_GeomFill.GeomFill_Sweep_ErrorOnRestriction, None, GeomFill_Sweep)
GeomFill_Sweep.ErrorOnSurface = new_instancemethod(_GeomFill.GeomFill_Sweep_ErrorOnSurface, None, GeomFill_Sweep)
GeomFill_Sweep.ErrorOnTrace = new_instancemethod(_GeomFill.GeomFill_Sweep_ErrorOnTrace, None, GeomFill_Sweep)
GeomFill_Sweep.ExchangeUV = new_instancemethod(_GeomFill.GeomFill_Sweep_ExchangeUV, None, GeomFill_Sweep)
GeomFill_Sweep.IsDone = new_instancemethod(_GeomFill.GeomFill_Sweep_IsDone, None, GeomFill_Sweep)
GeomFill_Sweep.NumberOfTrace = new_instancemethod(_GeomFill.GeomFill_Sweep_NumberOfTrace, None, GeomFill_Sweep)
GeomFill_Sweep.Restriction = new_instancemethod(_GeomFill.GeomFill_Sweep_Restriction, None, GeomFill_Sweep)
GeomFill_Sweep.SetDomain = new_instancemethod(_GeomFill.GeomFill_Sweep_SetDomain, None, GeomFill_Sweep)
GeomFill_Sweep.SetForceApproxC1 = new_instancemethod(_GeomFill.GeomFill_Sweep_SetForceApproxC1, None, GeomFill_Sweep)
GeomFill_Sweep.SetTolerance = new_instancemethod(_GeomFill.GeomFill_Sweep_SetTolerance, None, GeomFill_Sweep)
GeomFill_Sweep.Surface = new_instancemethod(_GeomFill.GeomFill_Sweep_Surface, None, GeomFill_Sweep)
GeomFill_Sweep.Trace = new_instancemethod(_GeomFill.GeomFill_Sweep_Trace, None, GeomFill_Sweep)
GeomFill_Sweep.UReversed = new_instancemethod(_GeomFill.GeomFill_Sweep_UReversed, None, GeomFill_Sweep)
GeomFill_Sweep.VReversed = new_instancemethod(_GeomFill.GeomFill_Sweep_VReversed, None, GeomFill_Sweep)
GeomFill_Sweep_swigregister = _GeomFill.GeomFill_Sweep_swigregister
GeomFill_Sweep_swigregister(GeomFill_Sweep)

class GeomFill_SweepFunction(OCC.Core.Approx.Approx_SweepFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Section:
        	:type Section: GeomFill_SectionLaw
        	:param Location:
        	:type Location: GeomFill_LocationLaw
        	:param FirstParameter:
        	:type FirstParameter: float
        	:param FirstParameterOnS:
        	:type FirstParameterOnS: float
        	:param RatioParameterOnS:
        	:type RatioParameterOnS: float
        	:rtype: None
        """
        _GeomFill.GeomFill_SweepFunction_swiginit(self, _GeomFill.new_GeomFill_SweepFunction(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_SweepFunction_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_SweepFunction
GeomFill_SweepFunction_swigregister = _GeomFill.GeomFill_SweepFunction_swigregister
GeomFill_SweepFunction_swigregister(GeomFill_SweepFunction)

class GeomFill_Tensor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetChangeValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const', Mat: 'Standard_Integer const') -> "Standard_Real":
        """GetChangeValue(GeomFill_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat) -> Standard_Real"""
        return _GeomFill.GeomFill_Tensor_GetChangeValue(self, Row, Col, Mat)


    def SetChangeValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const', Mat: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetChangeValue(GeomFill_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat, Standard_Real value)"""
        return _GeomFill.GeomFill_Tensor_SetChangeValue(self, Row, Col, Mat, value)


    def __init__(self, *args):
        """
        :param NbRow:
        	:type NbRow: int
        	:param NbCol:
        	:type NbCol: int
        	:param NbMat:
        	:type NbMat: int
        	:rtype: None
        """
        _GeomFill.GeomFill_Tensor_swiginit(self, _GeomFill.new_GeomFill_Tensor(*args))

    def Init(self, *args) -> "void":
        """
        * Initialize all the elements of a Tensor to InitialValue.
        	:param InitialValue:
        	:type InitialValue: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_Tensor_Init(self, *args)


    def Multiply(self, *args) -> "void":
        """
        :param Right:
        	:type Right: math_Vector
        	:param Product:
        	:type Product: math_Matrix
        	:rtype: None
        """
        return _GeomFill.GeomFill_Tensor_Multiply(self, *args)


    def Value(self, *args) -> "Standard_Real const &":
        """
        * accesses (in read or write mode) the value of index <Row>, <Col> and <Mat> of a Tensor. An exception is raised if <Row>, <Col> or <Mat> are not in the correct range.
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:param Mat:
        	:type Mat: int
        	:rtype: float
        """
        return _GeomFill.GeomFill_Tensor_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Tensor
GeomFill_Tensor.GetChangeValue = new_instancemethod(_GeomFill.GeomFill_Tensor_GetChangeValue, None, GeomFill_Tensor)
GeomFill_Tensor.SetChangeValue = new_instancemethod(_GeomFill.GeomFill_Tensor_SetChangeValue, None, GeomFill_Tensor)
GeomFill_Tensor.Init = new_instancemethod(_GeomFill.GeomFill_Tensor_Init, None, GeomFill_Tensor)
GeomFill_Tensor.Multiply = new_instancemethod(_GeomFill.GeomFill_Tensor_Multiply, None, GeomFill_Tensor)
GeomFill_Tensor.Value = new_instancemethod(_GeomFill.GeomFill_Tensor_Value, None, GeomFill_Tensor)
GeomFill_Tensor_swigregister = _GeomFill.GeomFill_Tensor_swigregister
GeomFill_Tensor_swigregister(GeomFill_Tensor)

class GeomFill_TgtField(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def D1(self, *args) -> "void":
        """
        * Computes the derivative of the field of tangency at parameter W.
        	:param W:
        	:type W: float
        	:rtype: gp_Vec
        * Computes the value and the derivative of the field of tangency at parameter W.
        	:param W:
        	:type W: float
        	:param V:
        	:type V: gp_Vec
        	:param DV:
        	:type DV: gp_Vec
        	:rtype: void
        """
        return _GeomFill.GeomFill_TgtField_D1(self, *args)


    def IsScalable(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _GeomFill.GeomFill_TgtField_IsScalable(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param Func:
        	:type Func: Law_BSpline
        	:rtype: void
        """
        return _GeomFill.GeomFill_TgtField_Scale(self, *args)


    def Value(self, *args) -> "gp_Vec":
        """
        * Computes the value of the field of tangency at parameter W.
        	:param W:
        	:type W: float
        	:rtype: gp_Vec
        """
        return _GeomFill.GeomFill_TgtField_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_TgtField_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_TgtField
GeomFill_TgtField.D1 = new_instancemethod(_GeomFill.GeomFill_TgtField_D1, None, GeomFill_TgtField)
GeomFill_TgtField.IsScalable = new_instancemethod(_GeomFill.GeomFill_TgtField_IsScalable, None, GeomFill_TgtField)
GeomFill_TgtField.Scale = new_instancemethod(_GeomFill.GeomFill_TgtField_Scale, None, GeomFill_TgtField)
GeomFill_TgtField.Value = new_instancemethod(_GeomFill.GeomFill_TgtField_Value, None, GeomFill_TgtField)
GeomFill_TgtField_swigregister = _GeomFill.GeomFill_TgtField_swigregister
GeomFill_TgtField_swigregister(GeomFill_TgtField)

class GeomFill_TrihedronLaw(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Copy(self, *args) -> "opencascade::handle< GeomFill_TrihedronLaw >":
        """:rtype: opencascade::handle<GeomFill_TrihedronLaw>"""
        return _GeomFill.GeomFill_TrihedronLaw_Copy(self, *args)


    def D0(self, *args) -> "Standard_Boolean":
        """
        * compute Triedrhon on curve at parameter <Param>
        	:param Param:
        	:type Param: float
        	:param Tangent:
        	:type Tangent: gp_Vec
        	:param Normal:
        	:type Normal: gp_Vec
        	:param BiNormal:
        	:type BiNormal: gp_Vec
        	:rtype: bool
        """
        return _GeomFill.GeomFill_TrihedronLaw_D0(self, *args)


    def D1(self, *args) -> "Standard_Boolean":
        """
        * compute Triedrhon and derivative Trihedron on curve at parameter <Param> Warning : It used only for C1 or C2 aproximation
        	:param Param:
        	:type Param: float
        	:param Tangent:
        	:type Tangent: gp_Vec
        	:param DTangent:
        	:type DTangent: gp_Vec
        	:param Normal:
        	:type Normal: gp_Vec
        	:param DNormal:
        	:type DNormal: gp_Vec
        	:param BiNormal:
        	:type BiNormal: gp_Vec
        	:param DBiNormal:
        	:type DBiNormal: gp_Vec
        	:rtype: bool
        """
        return _GeomFill.GeomFill_TrihedronLaw_D1(self, *args)


    def D2(self, *args) -> "Standard_Boolean":
        """
        * compute Trihedron on curve first and seconde derivatives. Warning : It used only for C2 aproximation
        	:param Param:
        	:type Param: float
        	:param Tangent:
        	:type Tangent: gp_Vec
        	:param DTangent:
        	:type DTangent: gp_Vec
        	:param D2Tangent:
        	:type D2Tangent: gp_Vec
        	:param Normal:
        	:type Normal: gp_Vec
        	:param DNormal:
        	:type DNormal: gp_Vec
        	:param D2Normal:
        	:type D2Normal: gp_Vec
        	:param BiNormal:
        	:type BiNormal: gp_Vec
        	:param DBiNormal:
        	:type DBiNormal: gp_Vec
        	:param D2BiNormal:
        	:type D2BiNormal: gp_Vec
        	:rtype: bool
        """
        return _GeomFill.GeomFill_TrihedronLaw_D2(self, *args)


    def ErrorStatus(self, *args) -> "GeomFill_PipeError":
        """
        * Give a status to the Law Returns PipeOk (default implementation)
        	:rtype: GeomFill_PipeError
        """
        return _GeomFill.GeomFill_TrihedronLaw_ErrorStatus(self, *args)


    def GetAverageLaw(self, *args) -> "void":
        """
        * Get average value of M(t) and V(t) it is usfull to make fast approximation of rational surfaces.
        	:param ATangent:
        	:type ATangent: gp_Vec
        	:param ANormal:
        	:type ANormal: gp_Vec
        	:param ABiNormal:
        	:type ABiNormal: gp_Vec
        	:rtype: void
        """
        return _GeomFill.GeomFill_TrihedronLaw_GetAverageLaw(self, *args)


    def GetInterval(self, *args) -> "void":
        """
        * Gets the bounds of the parametric interval on the function
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_TrihedronLaw_GetInterval(self, *args)


    def Intervals(self, *args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: void
        """
        return _GeomFill.GeomFill_TrihedronLaw_Intervals(self, *args)


    def IsConstant(self, *args) -> "Standard_Boolean":
        """
        * Say if the law is Constant
        	:rtype: bool
        """
        return _GeomFill.GeomFill_TrihedronLaw_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args) -> "Standard_Boolean":
        """
        * Say if the law is defined, only by the 3d Geometry of the setted Curve Return False by Default.
        	:rtype: bool
        """
        return _GeomFill.GeomFill_TrihedronLaw_IsOnlyBy3dCurve(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _GeomFill.GeomFill_TrihedronLaw_NbIntervals(self, *args)


    def SetCurve(self, *args) -> "void":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: void
        """
        return _GeomFill.GeomFill_TrihedronLaw_SetCurve(self, *args)


    def SetInterval(self, *args) -> "void":
        """
        * Sets the bounds of the parametric interval on the function This determines the derivatives in these values if the function is not Cn.
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_TrihedronLaw_SetInterval(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_TrihedronLaw_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_TrihedronLaw
GeomFill_TrihedronLaw.Copy = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_Copy, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.D0 = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_D0, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.D1 = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_D1, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.D2 = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_D2, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.ErrorStatus = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_ErrorStatus, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.GetAverageLaw = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_GetAverageLaw, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.GetInterval = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_GetInterval, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.Intervals = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_Intervals, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.IsConstant = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_IsConstant, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.IsOnlyBy3dCurve = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_IsOnlyBy3dCurve, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.NbIntervals = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_NbIntervals, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.SetCurve = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_SetCurve, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw.SetInterval = new_instancemethod(_GeomFill.GeomFill_TrihedronLaw_SetInterval, None, GeomFill_TrihedronLaw)
GeomFill_TrihedronLaw_swigregister = _GeomFill.GeomFill_TrihedronLaw_swigregister
GeomFill_TrihedronLaw_swigregister(GeomFill_TrihedronLaw)

class GeomFill_BoundWithSurf(GeomFill_Boundary):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs a boundary object defined by the 3d curve CurveOnSurf. The surface to be filled along this boundary will be in the tolerance range defined by Tol3d. What's more, at each point of CurveOnSurf, the angle between the normal to the surface to be filled along this boundary, and the normal to the surface on which CurveOnSurf lies, must not be greater than TolAng. This object is to be used as a boundary for a GeomFill_ConstrainedFilling framework. Warning CurveOnSurf is an adapted curve, that is, an object which is an interface between: - the services provided by a curve lying on a surface from the package Geom - and those required of the curve by the computation algorithm which uses it. The adapted curve is created in the following way: opencascade::handle<Geom_Surface> mySurface = ... ; opencascade::handle<Geom2d_Curve> myParamCurve = ... ; // where myParamCurve is a 2D curve in the parametric space of the surface mySurface opencascade::handle<GeomAdaptor_HSurface> Surface = new GeomAdaptor_HSurface(mySurface); opencascade::handle<Geom2dAdaptor_HCurve> ParamCurve = new Geom2dAdaptor_HCurve(myParamCurve); CurveOnSurf = Adaptor3d_CurveOnSurface(ParamCurve,Surface); The boundary is then constructed with the CurveOnSurf object: Standard_Real Tol = ... ; Standard_Real TolAng = ... ; myBoundary = GeomFill_BoundWithSurf ( CurveOnSurf, Tol, TolAng );
        	:param CurveOnSurf:
        	:type CurveOnSurf: Adaptor3d_CurveOnSurface
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tolang:
        	:type Tolang: float
        	:rtype: None
        """
        _GeomFill.GeomFill_BoundWithSurf_swiginit(self, _GeomFill.new_GeomFill_BoundWithSurf(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_BoundWithSurf_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_BoundWithSurf
GeomFill_BoundWithSurf_swigregister = _GeomFill.GeomFill_BoundWithSurf_swigregister
GeomFill_BoundWithSurf_swigregister(GeomFill_BoundWithSurf)

class GeomFill_ConstantBiNormal(GeomFill_TrihedronLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param BiNormal:
        	:type BiNormal: gp_Dir
        	:rtype: None
        """
        _GeomFill.GeomFill_ConstantBiNormal_swiginit(self, _GeomFill.new_GeomFill_ConstantBiNormal(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_ConstantBiNormal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_ConstantBiNormal
GeomFill_ConstantBiNormal_swigregister = _GeomFill.GeomFill_ConstantBiNormal_swigregister
GeomFill_ConstantBiNormal_swigregister(GeomFill_ConstantBiNormal)

class GeomFill_Coons(GeomFill_Filling):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:param W1:
        	:type W1: TColStd_Array1OfReal
        	:param W2:
        	:type W2: TColStd_Array1OfReal
        	:param W3:
        	:type W3: TColStd_Array1OfReal
        	:param W4:
        	:type W4: TColStd_Array1OfReal
        	:rtype: None
        """
        _GeomFill.GeomFill_Coons_swiginit(self, _GeomFill.new_GeomFill_Coons(*args))

    def Init(self, *args) -> "void":
        """
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:param W1:
        	:type W1: TColStd_Array1OfReal
        	:param W2:
        	:type W2: TColStd_Array1OfReal
        	:param W3:
        	:type W3: TColStd_Array1OfReal
        	:param W4:
        	:type W4: TColStd_Array1OfReal
        	:rtype: None
        """
        return _GeomFill.GeomFill_Coons_Init(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Coons
GeomFill_Coons.Init = new_instancemethod(_GeomFill.GeomFill_Coons_Init, None, GeomFill_Coons)
GeomFill_Coons_swigregister = _GeomFill.GeomFill_Coons_swigregister
GeomFill_Coons_swigregister(GeomFill_Coons)

class GeomFill_CorrectedFrenet(GeomFill_TrihedronLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def EvaluateBestMode(self, *args) -> "GeomFill_Trihedron":
        """
        * Tries to define the best trihedron mode for the curve. It can be: - Frenet - CorrectedFrenet - DiscreteTrihedron Warning: the CorrectedFrenet must be constructed with option ForEvaluation = True, the curve must be set by method SetCurve.
        	:rtype: GeomFill_Trihedron
        """
        return _GeomFill.GeomFill_CorrectedFrenet_EvaluateBestMode(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param ForEvaluation:
        	:type ForEvaluation: bool
        	:rtype: None
        """
        _GeomFill.GeomFill_CorrectedFrenet_swiginit(self, _GeomFill.new_GeomFill_CorrectedFrenet(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_CorrectedFrenet_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_CorrectedFrenet
GeomFill_CorrectedFrenet.EvaluateBestMode = new_instancemethod(_GeomFill.GeomFill_CorrectedFrenet_EvaluateBestMode, None, GeomFill_CorrectedFrenet)
GeomFill_CorrectedFrenet_swigregister = _GeomFill.GeomFill_CorrectedFrenet_swigregister
GeomFill_CorrectedFrenet_swigregister(GeomFill_CorrectedFrenet)

class GeomFill_CurveAndTrihedron(GeomFill_LocationLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def D0(self, *args) -> "Standard_Boolean":
        """
        * compute Location and 2d points
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:rtype: bool
        * compute Location and 2d points
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:rtype: bool
        """
        return _GeomFill.GeomFill_CurveAndTrihedron_D0(self, *args)


    def __init__(self, *args):
        """
        :param Trihedron:
        	:type Trihedron: GeomFill_TrihedronLaw
        	:rtype: None
        """
        _GeomFill.GeomFill_CurveAndTrihedron_swiginit(self, _GeomFill.new_GeomFill_CurveAndTrihedron(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_CurveAndTrihedron_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_CurveAndTrihedron
GeomFill_CurveAndTrihedron.D0 = new_instancemethod(_GeomFill.GeomFill_CurveAndTrihedron_D0, None, GeomFill_CurveAndTrihedron)
GeomFill_CurveAndTrihedron_swigregister = _GeomFill.GeomFill_CurveAndTrihedron_swigregister
GeomFill_CurveAndTrihedron_swigregister(GeomFill_CurveAndTrihedron)

class GeomFill_Curved(GeomFill_Filling):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:param W1:
        	:type W1: TColStd_Array1OfReal
        	:param W2:
        	:type W2: TColStd_Array1OfReal
        	:param W3:
        	:type W3: TColStd_Array1OfReal
        	:param W4:
        	:type W4: TColStd_Array1OfReal
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param W1:
        	:type W1: TColStd_Array1OfReal
        	:param W2:
        	:type W2: TColStd_Array1OfReal
        	:rtype: None
        """
        _GeomFill.GeomFill_Curved_swiginit(self, _GeomFill.new_GeomFill_Curved(*args))

    def Init(self, *args) -> "void":
        """
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:param W1:
        	:type W1: TColStd_Array1OfReal
        	:param W2:
        	:type W2: TColStd_Array1OfReal
        	:param W3:
        	:type W3: TColStd_Array1OfReal
        	:param W4:
        	:type W4: TColStd_Array1OfReal
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param W1:
        	:type W1: TColStd_Array1OfReal
        	:param W2:
        	:type W2: TColStd_Array1OfReal
        	:rtype: None
        """
        return _GeomFill.GeomFill_Curved_Init(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Curved
GeomFill_Curved.Init = new_instancemethod(_GeomFill.GeomFill_Curved_Init, None, GeomFill_Curved)
GeomFill_Curved_swigregister = _GeomFill.GeomFill_Curved_swigregister
GeomFill_Curved_swigregister(GeomFill_Curved)

class GeomFill_Darboux(GeomFill_TrihedronLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_Darboux_swiginit(self, _GeomFill.new_GeomFill_Darboux(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_Darboux_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Darboux
GeomFill_Darboux_swigregister = _GeomFill.GeomFill_Darboux_swigregister
GeomFill_Darboux_swigregister(GeomFill_Darboux)

class GeomFill_DegeneratedBound(GeomFill_Boundary):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Point:
        	:type Point: gp_Pnt
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tolang:
        	:type Tolang: float
        	:rtype: None
        """
        _GeomFill.GeomFill_DegeneratedBound_swiginit(self, _GeomFill.new_GeomFill_DegeneratedBound(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_DegeneratedBound_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_DegeneratedBound
GeomFill_DegeneratedBound_swigregister = _GeomFill.GeomFill_DegeneratedBound_swigregister
GeomFill_DegeneratedBound_swigregister(GeomFill_DegeneratedBound)

class GeomFill_DiscreteTrihedron(GeomFill_TrihedronLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_DiscreteTrihedron_swiginit(self, _GeomFill.new_GeomFill_DiscreteTrihedron(*args))

    def Init(self, *args) -> "void":
        """:rtype: None"""
        return _GeomFill.GeomFill_DiscreteTrihedron_Init(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_DiscreteTrihedron_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_DiscreteTrihedron
GeomFill_DiscreteTrihedron.Init = new_instancemethod(_GeomFill.GeomFill_DiscreteTrihedron_Init, None, GeomFill_DiscreteTrihedron)
GeomFill_DiscreteTrihedron_swigregister = _GeomFill.GeomFill_DiscreteTrihedron_swigregister
GeomFill_DiscreteTrihedron_swigregister(GeomFill_DiscreteTrihedron)

class GeomFill_DraftTrihedron(GeomFill_TrihedronLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param BiNormal:
        	:type BiNormal: gp_Vec
        	:param Angle:
        	:type Angle: float
        	:rtype: None
        """
        _GeomFill.GeomFill_DraftTrihedron_swiginit(self, _GeomFill.new_GeomFill_DraftTrihedron(*args))

    def SetAngle(self, *args) -> "void":
        """
        :param Angle:
        	:type Angle: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_DraftTrihedron_SetAngle(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_DraftTrihedron_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_DraftTrihedron
GeomFill_DraftTrihedron.SetAngle = new_instancemethod(_GeomFill.GeomFill_DraftTrihedron_SetAngle, None, GeomFill_DraftTrihedron)
GeomFill_DraftTrihedron_swigregister = _GeomFill.GeomFill_DraftTrihedron_swigregister
GeomFill_DraftTrihedron_swigregister(GeomFill_DraftTrihedron)

class GeomFill_EvolvedSection(GeomFill_SectionLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Make an SectionLaw with a Curve and a real Law.
        	:param C:
        	:type C: Geom_Curve
        	:param L:
        	:type L: Law_Function
        	:rtype: None
        """
        _GeomFill.GeomFill_EvolvedSection_swiginit(self, _GeomFill.new_GeomFill_EvolvedSection(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_EvolvedSection_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_EvolvedSection
GeomFill_EvolvedSection_swigregister = _GeomFill.GeomFill_EvolvedSection_swigregister
GeomFill_EvolvedSection_swigregister(GeomFill_EvolvedSection)

class GeomFill_Fixed(GeomFill_TrihedronLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Tangent:
        	:type Tangent: gp_Vec
        	:param Normal:
        	:type Normal: gp_Vec
        	:rtype: None
        """
        _GeomFill.GeomFill_Fixed_swiginit(self, _GeomFill.new_GeomFill_Fixed(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_Fixed_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Fixed
GeomFill_Fixed_swigregister = _GeomFill.GeomFill_Fixed_swigregister
GeomFill_Fixed_swigregister(GeomFill_Fixed)

class GeomFill_Frenet(GeomFill_TrihedronLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_Frenet_swiginit(self, _GeomFill.new_GeomFill_Frenet(*args))

    def Init(self, *args) -> "void":
        """:rtype: None"""
        return _GeomFill.GeomFill_Frenet_Init(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_Frenet_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Frenet
GeomFill_Frenet.Init = new_instancemethod(_GeomFill.GeomFill_Frenet_Init, None, GeomFill_Frenet)
GeomFill_Frenet_swigregister = _GeomFill.GeomFill_Frenet_swigregister
GeomFill_Frenet_swigregister(GeomFill_Frenet)

class GeomFill_Generator(GeomFill_Profiler):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_Generator_swiginit(self, _GeomFill.new_GeomFill_Generator(*args))

    def Surface(self, *args) -> "opencascade::handle< Geom_Surface > const &":
        """:rtype: opencascade::handle<Geom_Surface>"""
        return _GeomFill.GeomFill_Generator_Surface(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Generator
GeomFill_Generator.Surface = new_instancemethod(_GeomFill.GeomFill_Generator_Surface, None, GeomFill_Generator)
GeomFill_Generator_swigregister = _GeomFill.GeomFill_Generator_swigregister
GeomFill_Generator_swigregister(GeomFill_Generator)

class GeomFill_LocationDraft(GeomFill_LocationLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def D0(self, *args) -> "Standard_Boolean":
        """
        * compute Location
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:rtype: bool
        * compute Location and 2d points
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationDraft_D0(self, *args)


    def Direction(self, *args) -> "gp_Dir":
        """:rtype: gp_Dir"""
        return _GeomFill.GeomFill_LocationDraft_Direction(self, *args)


    def __init__(self, *args):
        """
        :param Direction:
        	:type Direction: gp_Dir
        	:param Angle:
        	:type Angle: float
        	:rtype: None
        """
        _GeomFill.GeomFill_LocationDraft_swiginit(self, _GeomFill.new_GeomFill_LocationDraft(*args))

    def IsIntersec(self, *args) -> "Standard_Boolean":
        """
        * Say if the generatrice interset the surface
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationDraft_IsIntersec(self, *args)


    def SetAngle(self, *args) -> "void":
        """
        :param Angle:
        	:type Angle: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_LocationDraft_SetAngle(self, *args)


    def SetStopSurf(self, *args) -> "void":
        """
        :param Surf:
        	:type Surf: Adaptor3d_HSurface
        	:rtype: None
        """
        return _GeomFill.GeomFill_LocationDraft_SetStopSurf(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_LocationDraft_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_LocationDraft
GeomFill_LocationDraft.D0 = new_instancemethod(_GeomFill.GeomFill_LocationDraft_D0, None, GeomFill_LocationDraft)
GeomFill_LocationDraft.Direction = new_instancemethod(_GeomFill.GeomFill_LocationDraft_Direction, None, GeomFill_LocationDraft)
GeomFill_LocationDraft.IsIntersec = new_instancemethod(_GeomFill.GeomFill_LocationDraft_IsIntersec, None, GeomFill_LocationDraft)
GeomFill_LocationDraft.SetAngle = new_instancemethod(_GeomFill.GeomFill_LocationDraft_SetAngle, None, GeomFill_LocationDraft)
GeomFill_LocationDraft.SetStopSurf = new_instancemethod(_GeomFill.GeomFill_LocationDraft_SetStopSurf, None, GeomFill_LocationDraft)
GeomFill_LocationDraft_swigregister = _GeomFill.GeomFill_LocationDraft_swigregister
GeomFill_LocationDraft_swigregister(GeomFill_LocationDraft)

class GeomFill_LocationGuide(GeomFill_LocationLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ComputeAutomaticLaw(self, *args) -> "GeomFill_PipeError":
        """
        :param ParAndRad:
        	:type ParAndRad: TColgp_HArray1OfPnt2d
        	:rtype: GeomFill_PipeError
        """
        return _GeomFill.GeomFill_LocationGuide_ComputeAutomaticLaw(self, *args)


    def D0(self, *args) -> "Standard_Boolean":
        """
        * compute Location
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:rtype: bool
        * compute Location and 2d points
        	:param Param:
        	:type Param: float
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_Vec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:rtype: bool
        """
        return _GeomFill.GeomFill_LocationGuide_D0(self, *args)


    def EraseRotation(self, *args) -> "void":
        """:rtype: None"""
        return _GeomFill.GeomFill_LocationGuide_EraseRotation(self, *args)


    def __init__(self, *args):
        """
        :param Triedre:
        	:type Triedre: GeomFill_TrihedronWithGuide
        	:rtype: None
        """
        _GeomFill.GeomFill_LocationGuide_swiginit(self, _GeomFill.new_GeomFill_LocationGuide(*args))

    def Guide(self, *args) -> "opencascade::handle< Adaptor3d_HCurve >":
        """:rtype: opencascade::handle<Adaptor3d_HCurve>"""
        return _GeomFill.GeomFill_LocationGuide_Guide(self, *args)


    def Section(self, *args) -> "opencascade::handle< Geom_Curve >":
        """:rtype: opencascade::handle<Geom_Curve>"""
        return _GeomFill.GeomFill_LocationGuide_Section(self, *args)


    def Set(self, *args) -> "void":
        """
        :param Section:
        	:type Section: GeomFill_SectionLaw
        	:param rotat:
        	:type rotat: bool
        	:param SFirst:
        	:type SFirst: float
        	:param SLast:
        	:type SLast: float
        	:param PrecAngle:
        	:type PrecAngle: float
        	:param LastAngle:
        	:type LastAngle: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_LocationGuide_Set(self, *args)


    def SetOrigine(self, *args) -> "void":
        """
        :param Param1:
        	:type Param1: float
        	:param Param2:
        	:type Param2: float
        	:rtype: None
        """
        return _GeomFill.GeomFill_LocationGuide_SetOrigine(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_LocationGuide_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_LocationGuide
GeomFill_LocationGuide.ComputeAutomaticLaw = new_instancemethod(_GeomFill.GeomFill_LocationGuide_ComputeAutomaticLaw, None, GeomFill_LocationGuide)
GeomFill_LocationGuide.D0 = new_instancemethod(_GeomFill.GeomFill_LocationGuide_D0, None, GeomFill_LocationGuide)
GeomFill_LocationGuide.EraseRotation = new_instancemethod(_GeomFill.GeomFill_LocationGuide_EraseRotation, None, GeomFill_LocationGuide)
GeomFill_LocationGuide.Guide = new_instancemethod(_GeomFill.GeomFill_LocationGuide_Guide, None, GeomFill_LocationGuide)
GeomFill_LocationGuide.Section = new_instancemethod(_GeomFill.GeomFill_LocationGuide_Section, None, GeomFill_LocationGuide)
GeomFill_LocationGuide.Set = new_instancemethod(_GeomFill.GeomFill_LocationGuide_Set, None, GeomFill_LocationGuide)
GeomFill_LocationGuide.SetOrigine = new_instancemethod(_GeomFill.GeomFill_LocationGuide_SetOrigine, None, GeomFill_LocationGuide)
GeomFill_LocationGuide_swigregister = _GeomFill.GeomFill_LocationGuide_swigregister
GeomFill_LocationGuide_swigregister(GeomFill_LocationGuide)

class GeomFill_SectionGenerator(GeomFill_Profiler):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _GeomFill.GeomFill_SectionGenerator_swiginit(self, _GeomFill.new_GeomFill_SectionGenerator(*args))

    def GetShape(self, *args) -> "void":
        """
        :param NbPoles:
        	:type NbPoles: int
        	:param NbKnots:
        	:type NbKnots: int
        	:param Degree:
        	:type Degree: int
        	:param NbPoles2d:
        	:type NbPoles2d: int
        	:rtype: None
        """
        return _GeomFill.GeomFill_SectionGenerator_GetShape(self, *args)


    def Knots(self, *args) -> "void":
        """
        :param TKnots:
        	:type TKnots: TColStd_Array1OfReal
        	:rtype: None
        """
        return _GeomFill.GeomFill_SectionGenerator_Knots(self, *args)


    def Mults(self, *args) -> "void":
        """
        :param TMults:
        	:type TMults: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _GeomFill.GeomFill_SectionGenerator_Mults(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        * Returns the parameter of Section<P>, to impose it for the approximation.
        	:param P:
        	:type P: int
        	:rtype: float
        """
        return _GeomFill.GeomFill_SectionGenerator_Parameter(self, *args)


    def Section(self, *args) -> "void":
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.
        	:param P:
        	:type P: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:rtype: bool
        :param P:
        	:type P: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: None
        """
        return _GeomFill.GeomFill_SectionGenerator_Section(self, *args)


    def SetParam(self, *args) -> "void":
        """
        :param Params:
        	:type Params: TColStd_HArray1OfReal
        	:rtype: None
        """
        return _GeomFill.GeomFill_SectionGenerator_SetParam(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_SectionGenerator
GeomFill_SectionGenerator.GetShape = new_instancemethod(_GeomFill.GeomFill_SectionGenerator_GetShape, None, GeomFill_SectionGenerator)
GeomFill_SectionGenerator.Knots = new_instancemethod(_GeomFill.GeomFill_SectionGenerator_Knots, None, GeomFill_SectionGenerator)
GeomFill_SectionGenerator.Mults = new_instancemethod(_GeomFill.GeomFill_SectionGenerator_Mults, None, GeomFill_SectionGenerator)
GeomFill_SectionGenerator.Parameter = new_instancemethod(_GeomFill.GeomFill_SectionGenerator_Parameter, None, GeomFill_SectionGenerator)
GeomFill_SectionGenerator.Section = new_instancemethod(_GeomFill.GeomFill_SectionGenerator_Section, None, GeomFill_SectionGenerator)
GeomFill_SectionGenerator.SetParam = new_instancemethod(_GeomFill.GeomFill_SectionGenerator_SetParam, None, GeomFill_SectionGenerator)
GeomFill_SectionGenerator_swigregister = _GeomFill.GeomFill_SectionGenerator_swigregister
GeomFill_SectionGenerator_swigregister(GeomFill_SectionGenerator)

class GeomFill_SimpleBound(GeomFill_Boundary):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs the boundary object defined by the 3d curve. The surface to be built along this boundary will be in the tolerance range defined by Tol3d. This object is to be used as a boundary for a GeomFill_ConstrainedFilling framework. Dummy is initialized but has no function in this class. Warning Curve is an adapted curve, that is, an object which is an interface between: - the services provided by a 3D curve from the package Geom - and those required of the curve by the computation algorithm which uses it. The adapted curve is created in one of the following ways: - First sequence: opencascade::handle<Geom_Curve> myCurve = ... ; opencascade::handle<GeomAdaptor_HCurve> Curve = new GeomAdaptor_HCurve(myCurve); - Second sequence: // Step 1 opencascade::handle<Geom_Curve> myCurve = ... ; GeomAdaptor_Curve Crv (myCurve); // Step 2 opencascade::handle<GeomAdaptor_HCurve> Curve = new GeomAdaptor_HCurve(Crv); You use the second part of this sequence if you already have the adapted curve Crv. The boundary is then constructed with the Curve object: Standard_Real Tol = ... ; Standard_Real dummy = 0. ; myBoundary = GeomFill_SimpleBound (Curve,Tol,dummy);
        	:param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tolang:
        	:type Tolang: float
        	:rtype: None
        """
        _GeomFill.GeomFill_SimpleBound_swiginit(self, _GeomFill.new_GeomFill_SimpleBound(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_SimpleBound_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_SimpleBound
GeomFill_SimpleBound_swigregister = _GeomFill.GeomFill_SimpleBound_swigregister
GeomFill_SimpleBound_swigregister(GeomFill_SimpleBound)

class GeomFill_Stretch(GeomFill_Filling):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:param W1:
        	:type W1: TColStd_Array1OfReal
        	:param W2:
        	:type W2: TColStd_Array1OfReal
        	:param W3:
        	:type W3: TColStd_Array1OfReal
        	:param W4:
        	:type W4: TColStd_Array1OfReal
        	:rtype: None
        """
        _GeomFill.GeomFill_Stretch_swiginit(self, _GeomFill.new_GeomFill_Stretch(*args))

    def Init(self, *args) -> "void":
        """
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:rtype: None
        :param P1:
        	:type P1: TColgp_Array1OfPnt
        	:param P2:
        	:type P2: TColgp_Array1OfPnt
        	:param P3:
        	:type P3: TColgp_Array1OfPnt
        	:param P4:
        	:type P4: TColgp_Array1OfPnt
        	:param W1:
        	:type W1: TColStd_Array1OfReal
        	:param W2:
        	:type W2: TColStd_Array1OfReal
        	:param W3:
        	:type W3: TColStd_Array1OfReal
        	:param W4:
        	:type W4: TColStd_Array1OfReal
        	:rtype: None
        """
        return _GeomFill.GeomFill_Stretch_Init(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_Stretch
GeomFill_Stretch.Init = new_instancemethod(_GeomFill.GeomFill_Stretch_Init, None, GeomFill_Stretch)
GeomFill_Stretch_swigregister = _GeomFill.GeomFill_Stretch_swigregister
GeomFill_Stretch_swigregister(GeomFill_Stretch)

class GeomFill_TgtOnCoons(GeomFill_TgtField):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def D1(self, *args) -> "void":
        """
        * Computes the derivative of the field of tangency at parameter W.
        	:param W:
        	:type W: float
        	:rtype: gp_Vec
        * Computes the value and the derivative of the field of tangency at parameter W.
        	:param W:
        	:type W: float
        	:param T:
        	:type T: gp_Vec
        	:param DT:
        	:type DT: gp_Vec
        	:rtype: None
        """
        return _GeomFill.GeomFill_TgtOnCoons_D1(self, *args)


    def __init__(self, *args):
        """
        :param K:
        	:type K: GeomFill_CoonsAlgPatch
        	:param I:
        	:type I: int
        	:rtype: None
        """
        _GeomFill.GeomFill_TgtOnCoons_swiginit(self, _GeomFill.new_GeomFill_TgtOnCoons(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_TgtOnCoons_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_TgtOnCoons
GeomFill_TgtOnCoons.D1 = new_instancemethod(_GeomFill.GeomFill_TgtOnCoons_D1, None, GeomFill_TgtOnCoons)
GeomFill_TgtOnCoons_swigregister = _GeomFill.GeomFill_TgtOnCoons_swigregister
GeomFill_TgtOnCoons_swigregister(GeomFill_TgtOnCoons)

class GeomFill_TrihedronWithGuide(GeomFill_TrihedronLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CurrentPointOnGuide(self, *args) -> "gp_Pnt":
        """
        * Returns the current point on guide found by D0, D1 or D2.
        	:rtype: gp_Pnt
        """
        return _GeomFill.GeomFill_TrihedronWithGuide_CurrentPointOnGuide(self, *args)


    def Guide(self, *args) -> "opencascade::handle< Adaptor3d_HCurve >":
        """:rtype: opencascade::handle<Adaptor3d_HCurve>"""
        return _GeomFill.GeomFill_TrihedronWithGuide_Guide(self, *args)


    def Origine(self, *args) -> "void":
        """
        :param Param1:
        	:type Param1: float
        	:param Param2:
        	:type Param2: float
        	:rtype: void
        """
        return _GeomFill.GeomFill_TrihedronWithGuide_Origine(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_TrihedronWithGuide_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_TrihedronWithGuide
GeomFill_TrihedronWithGuide.CurrentPointOnGuide = new_instancemethod(_GeomFill.GeomFill_TrihedronWithGuide_CurrentPointOnGuide, None, GeomFill_TrihedronWithGuide)
GeomFill_TrihedronWithGuide.Guide = new_instancemethod(_GeomFill.GeomFill_TrihedronWithGuide_Guide, None, GeomFill_TrihedronWithGuide)
GeomFill_TrihedronWithGuide.Origine = new_instancemethod(_GeomFill.GeomFill_TrihedronWithGuide_Origine, None, GeomFill_TrihedronWithGuide)
GeomFill_TrihedronWithGuide_swigregister = _GeomFill.GeomFill_TrihedronWithGuide_swigregister
GeomFill_TrihedronWithGuide_swigregister(GeomFill_TrihedronWithGuide)

class GeomFill_UniformSection(GeomFill_SectionLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Make an constant Law with C. [First, Last] define law definition domain
        	:param C:
        	:type C: Geom_Curve
        	:param FirstParameter: default value is 0.0
        	:type FirstParameter: float
        	:param LastParameter: default value is 1.0
        	:type LastParameter: float
        	:rtype: None
        """
        _GeomFill.GeomFill_UniformSection_swiginit(self, _GeomFill.new_GeomFill_UniformSection(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_UniformSection_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_UniformSection
GeomFill_UniformSection_swigregister = _GeomFill.GeomFill_UniformSection_swigregister
GeomFill_UniformSection_swigregister(GeomFill_UniformSection)

class GeomFill_GuideTrihedronAC(GeomFill_TrihedronWithGuide):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param guide:
        	:type guide: Adaptor3d_HCurve
        	:rtype: None
        """
        _GeomFill.GeomFill_GuideTrihedronAC_swiginit(self, _GeomFill.new_GeomFill_GuideTrihedronAC(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_GuideTrihedronAC_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_GuideTrihedronAC
GeomFill_GuideTrihedronAC_swigregister = _GeomFill.GeomFill_GuideTrihedronAC_swigregister
GeomFill_GuideTrihedronAC_swigregister(GeomFill_GuideTrihedronAC)

class GeomFill_GuideTrihedronPlan(GeomFill_TrihedronWithGuide):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param theGuide:
        	:type theGuide: Adaptor3d_HCurve
        	:rtype: None
        """
        _GeomFill.GeomFill_GuideTrihedronPlan_swiginit(self, _GeomFill.new_GeomFill_GuideTrihedronPlan(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_GuideTrihedronPlan_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomFill.delete_GeomFill_GuideTrihedronPlan
GeomFill_GuideTrihedronPlan_swigregister = _GeomFill.GeomFill_GuideTrihedronPlan_swigregister
GeomFill_GuideTrihedronPlan_swigregister(GeomFill_GuideTrihedronPlan)

class GeomFill_HArray1OfLocationLaw(GeomFill_Array1OfLocationLaw, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _GeomFill.GeomFill_HArray1OfLocationLaw_swiginit(self, _GeomFill.new_GeomFill_HArray1OfLocationLaw(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_HArray1OfLocationLaw_DownCast(t)

    __swig_destroy__ = _GeomFill.delete_GeomFill_HArray1OfLocationLaw
GeomFill_HArray1OfLocationLaw.Array1 = new_instancemethod(_GeomFill.GeomFill_HArray1OfLocationLaw_Array1, None, GeomFill_HArray1OfLocationLaw)
GeomFill_HArray1OfLocationLaw.ChangeArray1 = new_instancemethod(_GeomFill.GeomFill_HArray1OfLocationLaw_ChangeArray1, None, GeomFill_HArray1OfLocationLaw)
GeomFill_HArray1OfLocationLaw_swigregister = _GeomFill.GeomFill_HArray1OfLocationLaw_swigregister
GeomFill_HArray1OfLocationLaw_swigregister(GeomFill_HArray1OfLocationLaw)

class GeomFill_HArray1OfSectionLaw(GeomFill_Array1OfSectionLaw, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _GeomFill.GeomFill_HArray1OfSectionLaw_swiginit(self, _GeomFill.new_GeomFill_HArray1OfSectionLaw(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_HArray1OfSectionLaw_DownCast(t)

    __swig_destroy__ = _GeomFill.delete_GeomFill_HArray1OfSectionLaw
GeomFill_HArray1OfSectionLaw.Array1 = new_instancemethod(_GeomFill.GeomFill_HArray1OfSectionLaw_Array1, None, GeomFill_HArray1OfSectionLaw)
GeomFill_HArray1OfSectionLaw.ChangeArray1 = new_instancemethod(_GeomFill.GeomFill_HArray1OfSectionLaw_ChangeArray1, None, GeomFill_HArray1OfSectionLaw)
GeomFill_HArray1OfSectionLaw_swigregister = _GeomFill.GeomFill_HArray1OfSectionLaw_swigregister
GeomFill_HArray1OfSectionLaw_swigregister(GeomFill_HArray1OfSectionLaw)

class GeomFill_HSequenceOfAx2(GeomFill_SequenceOfAx2, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _GeomFill.GeomFill_HSequenceOfAx2_swiginit(self, _GeomFill.new_GeomFill_HSequenceOfAx2(*args))


    @staticmethod
    def DownCast(t):
      return Handle_GeomFill_HSequenceOfAx2_DownCast(t)

    __swig_destroy__ = _GeomFill.delete_GeomFill_HSequenceOfAx2
GeomFill_HSequenceOfAx2.Sequence = new_instancemethod(_GeomFill.GeomFill_HSequenceOfAx2_Sequence, None, GeomFill_HSequenceOfAx2)
GeomFill_HSequenceOfAx2.Append = new_instancemethod(_GeomFill.GeomFill_HSequenceOfAx2_Append, None, GeomFill_HSequenceOfAx2)
GeomFill_HSequenceOfAx2.ChangeSequence = new_instancemethod(_GeomFill.GeomFill_HSequenceOfAx2_ChangeSequence, None, GeomFill_HSequenceOfAx2)
GeomFill_HSequenceOfAx2_swigregister = _GeomFill.GeomFill_HSequenceOfAx2_swigregister
GeomFill_HSequenceOfAx2_swigregister(GeomFill_HSequenceOfAx2)



