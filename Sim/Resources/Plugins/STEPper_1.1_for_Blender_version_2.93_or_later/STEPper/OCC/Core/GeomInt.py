# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
GeomInt module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_geomint.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _GeomInt.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GeomInt')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GeomInt')
    _GeomInt = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GeomInt', [dirname(__file__)])
        except ImportError:
            import _GeomInt
            return _GeomInt
        try:
            _mod = imp.load_module('_GeomInt', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GeomInt = swig_import_helper()
    del swig_import_helper
else:
    import _GeomInt
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomInt.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_GeomInt.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_GeomInt.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_GeomInt.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_GeomInt.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_GeomInt.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_GeomInt.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_GeomInt.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_GeomInt.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_GeomInt.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_GeomInt.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_GeomInt.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_GeomInt.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_GeomInt.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_GeomInt.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_GeomInt.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_GeomInt.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _GeomInt.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _GeomInt.process_exception(error, method_name, class_name)
process_exception = _GeomInt.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.math
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.gp
import OCC.Core.AppParCurves
import OCC.Core.TColgp
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.Geom2d
import OCC.Core.IntPatch
import OCC.Core.Intf
import OCC.Core.Bnd
import OCC.Core.BVH
import OCC.Core.Adaptor3d
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.IntSurf
import OCC.Core.IntAna
import OCC.Core.GeomAdaptor
import OCC.Core.Approx
import OCC.Core.AppCont
import OCC.Core.IntImp
import OCC.Core.ApproxInt
class GeomInt_VectorOfReal(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _GeomInt.GeomInt_VectorOfReal_swiginit(self, _GeomInt.new_GeomInt_VectorOfReal(*args))
    __swig_destroy__ = _GeomInt.delete_GeomInt_VectorOfReal
GeomInt_VectorOfReal.begin = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_begin, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.end = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_end, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.cbegin = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_cbegin, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.cend = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_cend, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Length = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Length, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Size = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Size, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Lower = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Lower, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Upper = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Upper, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.IsEmpty = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_IsEmpty, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Assign = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Assign, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Set = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Set, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Append = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Append, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Appended = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Appended, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Value = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Value, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.First = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_First, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.ChangeFirst = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_ChangeFirst, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.Last = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_Last, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.ChangeLast = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_ChangeLast, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.__call__ = new_instancemethod(_GeomInt.GeomInt_VectorOfReal___call__, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.ChangeValue = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_ChangeValue, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal.SetValue = new_instancemethod(_GeomInt.GeomInt_VectorOfReal_SetValue, None, GeomInt_VectorOfReal)
GeomInt_VectorOfReal_swigregister = _GeomInt.GeomInt_VectorOfReal_swigregister
GeomInt_VectorOfReal_swigregister(GeomInt_VectorOfReal)

class GeomInt_SequenceOfParameterAndOrientation(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _GeomInt.GeomInt_SequenceOfParameterAndOrientation_swiginit(self, _GeomInt.new_GeomInt_SequenceOfParameterAndOrientation(*args))
    delNode = staticmethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_delNode)
    __swig_destroy__ = _GeomInt.delete_GeomInt_SequenceOfParameterAndOrientation
GeomInt_SequenceOfParameterAndOrientation.begin = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_begin, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.end = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_end, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.cbegin = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_cbegin, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.cend = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_cend, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Size = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Size, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Length = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Length, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Lower = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Lower, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Upper = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Upper, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.IsEmpty = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_IsEmpty, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Reverse = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Reverse, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Exchange = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Exchange, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Clear = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Clear, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Assign = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Assign, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Set = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Set, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Remove = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Remove, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Append = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Append, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Prepend = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Prepend, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.InsertBefore = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_InsertBefore, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.InsertAfter = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_InsertAfter, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Split = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Split, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.First = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_First, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.ChangeFirst = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_ChangeFirst, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Last = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Last, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.ChangeLast = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_ChangeLast, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.Value = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Value, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.ChangeValue = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_ChangeValue, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.__call__ = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation___call__, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation.SetValue = new_instancemethod(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_SetValue, None, GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation_swigregister = _GeomInt.GeomInt_SequenceOfParameterAndOrientation_swigregister
GeomInt_SequenceOfParameterAndOrientation_swigregister(GeomInt_SequenceOfParameterAndOrientation)

def GeomInt_SequenceOfParameterAndOrientation_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _GeomInt.GeomInt_SequenceOfParameterAndOrientation_delNode(theNode, theAl)
GeomInt_SequenceOfParameterAndOrientation_delNode = _GeomInt.GeomInt_SequenceOfParameterAndOrientation_delNode

class geomint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AdjustPeriodic(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Adjusts the parameter <thePar> to the range [theParMin, theParMax]
        	:param thePar:
        	:type thePar: float
        	:param theParMin:
        	:type theParMin: float
        	:param theParMax:
        	:type theParMax: float
        	:param thePeriod:
        	:type thePeriod: float
        	:param theNewPar:
        	:type theNewPar: float
        	:param theOffset:
        	:type theOffset: float
        	:param theEps: default value is 0.0
        	:type theEps: float
        	:rtype: bool
        """
        return _GeomInt.geomint_AdjustPeriodic(*args)

    AdjustPeriodic = staticmethod(AdjustPeriodic)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomInt.geomint_swiginit(self, _GeomInt.new_geomint())
    __swig_destroy__ = _GeomInt.delete_geomint
geomint_swigregister = _GeomInt.geomint_swigregister
geomint_swigregister(geomint)

def geomint_AdjustPeriodic(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Adjusts the parameter <thePar> to the range [theParMin, theParMax]
    	:param thePar:
    	:type thePar: float
    	:param theParMin:
    	:type theParMin: float
    	:param theParMax:
    	:type theParMax: float
    	:param thePeriod:
    	:type thePeriod: float
    	:param theNewPar:
    	:type theNewPar: float
    	:param theOffset:
    	:type theOffset: float
    	:param theEps: default value is 0.0
    	:type theEps: float
    	:rtype: bool
    """
    return _GeomInt.geomint_AdjustPeriodic(*args)

class GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox
GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister
GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CurveValue(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        * returns the MultiBSpCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_CurveValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the multiline.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_FirstConstraint(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the multiline.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_FunctionMatrix(self, *args)


    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has <NbPol> control points.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox(*args))

    def Index(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Index(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiBSpCurve.
        	:rtype: float
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiBSpCurve.
        	:rtype: float
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_NewParameters(self, *args)


    def SetFirstLambda(self, *args) -> "void":
        """
        :param l1:
        	:type l1: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_SetFirstLambda(self, *args)


    def SetLastLambda(self, *args) -> "void":
        """
        :param l2:
        	:type l2: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_SetLastLambda(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.CurveValue = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_CurveValue, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.DerivativeFunctionMatrix = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Error, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.FirstConstraint = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_FirstConstraint, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.FunctionMatrix = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_FunctionMatrix, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.Index = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Index, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.LastConstraint = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_LastConstraint, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.MaxError2d = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_MaxError2d, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.MaxError3d = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_MaxError3d, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.NewParameters = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_NewParameters, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.SetFirstLambda = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_SetFirstLambda, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.SetLastLambda = new_instancemethod(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_SetLastLambda, None, GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_FunctionMatrix(self, *args)


    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.BSplineValue = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_BSplineValue, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.BezierValue = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_BezierValue, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.DerivativeFunctionMatrix = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.Distance = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Distance, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Error, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.ErrorGradient = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_ErrorGradient, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.FirstLambda = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_FirstLambda, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.FunctionMatrix = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_FunctionMatrix, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.IsDone = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_IsDone, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.KIndex = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_KIndex, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.LastLambda = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_LastLambda, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.Perform = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Perform, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.Points = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Points, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.Poles = new_instancemethod(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Poles, None, GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox(OCC.Core.math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox
GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_IntSS(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Boundary(self, *args) -> "opencascade::handle< Geom_Curve > const &":
        """
        :param Index:
        	:type Index: int
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _GeomInt.GeomInt_IntSS_Boundary(self, *args)


    def BuildPCurves(*args) -> "Standard_Real &":
        """
        * creates 2D-curve on given surface from given 3D-curve
        	:param f:
        	:type f: float
        	:param l:
        	:type l: float
        	:param Tol:
        	:type Tol: float
        	:param S:
        	:type S: Geom_Surface
        	:param C:
        	:type C: Geom_Curve
        	:param C2d:
        	:type C2d: Geom2d_Curve
        	:rtype: void
        """
        return _GeomInt.GeomInt_IntSS_BuildPCurves(*args)

    BuildPCurves = staticmethod(BuildPCurves)

    def __init__(self, *args):
        """
        :rtype: None
        * performs general intersection of two surfaces just now
        	:param S1:
        	:type S1: Geom_Surface
        	:param S2:
        	:type S2: Geom_Surface
        	:param Tol:
        	:type Tol: float
        	:param Approx: default value is Standard_True
        	:type Approx: bool
        	:param ApproxS1: default value is Standard_False
        	:type ApproxS1: bool
        	:param ApproxS2: default value is Standard_False
        	:type ApproxS2: bool
        	:rtype: None
        """
        _GeomInt.GeomInt_IntSS_swiginit(self, _GeomInt.new_GeomInt_IntSS(*args))

    def HasLineOnS1(self, *args) -> "Standard_Boolean":
        """
        :param Index:
        	:type Index: int
        	:rtype: bool
        """
        return _GeomInt.GeomInt_IntSS_HasLineOnS1(self, *args)


    def HasLineOnS2(self, *args) -> "Standard_Boolean":
        """
        :param Index:
        	:type Index: int
        	:rtype: bool
        """
        return _GeomInt.GeomInt_IntSS_HasLineOnS2(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _GeomInt.GeomInt_IntSS_IsDone(self, *args)


    def Line(self, *args) -> "opencascade::handle< Geom_Curve > const &":
        """
        :param Index:
        	:type Index: int
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _GeomInt.GeomInt_IntSS_Line(self, *args)


    def LineOnS1(self, *args) -> "opencascade::handle< Geom2d_Curve > const &":
        """
        :param Index:
        	:type Index: int
        	:rtype: opencascade::handle<Geom2d_Curve>
        """
        return _GeomInt.GeomInt_IntSS_LineOnS1(self, *args)


    def LineOnS2(self, *args) -> "opencascade::handle< Geom2d_Curve > const &":
        """
        :param Index:
        	:type Index: int
        	:rtype: opencascade::handle<Geom2d_Curve>
        """
        return _GeomInt.GeomInt_IntSS_LineOnS2(self, *args)


    def MakeBSpline(*args) -> "opencascade::handle< Geom_Curve >":
        """
        :param WL:
        	:type WL: IntPatch_WLine
        	:param ideb:
        	:type ideb: int
        	:param ifin:
        	:type ifin: int
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _GeomInt.GeomInt_IntSS_MakeBSpline(*args)

    MakeBSpline = staticmethod(MakeBSpline)

    def MakeBSpline2d(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        :param theWLine:
        	:type theWLine: IntPatch_WLine
        	:param ideb:
        	:type ideb: int
        	:param ifin:
        	:type ifin: int
        	:param onFirst:
        	:type onFirst: bool
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _GeomInt.GeomInt_IntSS_MakeBSpline2d(*args)

    MakeBSpline2d = staticmethod(MakeBSpline2d)

    def NbBoundaries(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _GeomInt.GeomInt_IntSS_NbBoundaries(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _GeomInt.GeomInt_IntSS_NbLines(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _GeomInt.GeomInt_IntSS_NbPoints(self, *args)


    def Perform(self, *args) -> "void":
        """
        * general intersection of two surfaces
        	:param S1:
        	:type S1: Geom_Surface
        	:param S2:
        	:type S2: Geom_Surface
        	:param Tol:
        	:type Tol: float
        	:param Approx: default value is Standard_True
        	:type Approx: bool
        	:param ApproxS1: default value is Standard_False
        	:type ApproxS1: bool
        	:param ApproxS2: default value is Standard_False
        	:type ApproxS2: bool
        	:rtype: None
        * intersection of adapted surfaces
        	:param HS1:
        	:type HS1: GeomAdaptor_HSurface
        	:param HS2:
        	:type HS2: GeomAdaptor_HSurface
        	:param Tol:
        	:type Tol: float
        	:param Approx: default value is Standard_True
        	:type Approx: bool
        	:param ApproxS1: default value is Standard_False
        	:type ApproxS1: bool
        	:param ApproxS2: default value is Standard_False
        	:type ApproxS2: bool
        	:rtype: None
        * general intersection using a starting point
        	:param S1:
        	:type S1: Geom_Surface
        	:param S2:
        	:type S2: Geom_Surface
        	:param Tol:
        	:type Tol: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param Approx: default value is Standard_True
        	:type Approx: bool
        	:param ApproxS1: default value is Standard_False
        	:type ApproxS1: bool
        	:param ApproxS2: default value is Standard_False
        	:type ApproxS2: bool
        	:rtype: None
        * intersection of adapted surfaces using a starting point
        	:param HS1:
        	:type HS1: GeomAdaptor_HSurface
        	:param HS2:
        	:type HS2: GeomAdaptor_HSurface
        	:param Tol:
        	:type Tol: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param Approx: default value is Standard_True
        	:type Approx: bool
        	:param ApproxS1: default value is Standard_False
        	:type ApproxS1: bool
        	:param ApproxS2: default value is Standard_False
        	:type ApproxS2: bool
        	:rtype: None
        """
        return _GeomInt.GeomInt_IntSS_Perform(self, *args)


    def Pnt2d(self, *args) -> "gp_Pnt2d":
        """
        :param Index:
        	:type Index: int
        	:param OnFirst:
        	:type OnFirst: bool
        	:rtype: gp_Pnt2d
        """
        return _GeomInt.GeomInt_IntSS_Pnt2d(self, *args)


    def Point(self, *args) -> "gp_Pnt":
        """
        :param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _GeomInt.GeomInt_IntSS_Point(self, *args)


    def TolReached2d(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _GeomInt.GeomInt_IntSS_TolReached2d(self, *args)


    def TolReached3d(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _GeomInt.GeomInt_IntSS_TolReached3d(self, *args)


    def TreatRLine(*args) -> "Standard_Real &":
        """
        * converts RLine to Geom(2d)_Curve.
        	:param theRL:
        	:type theRL: IntPatch_RLine
        	:param theHS1:
        	:type theHS1: GeomAdaptor_HSurface
        	:param theHS2:
        	:type theHS2: GeomAdaptor_HSurface
        	:param theC3d:
        	:type theC3d: Geom_Curve
        	:param theC2d1:
        	:type theC2d1: Geom2d_Curve
        	:param theC2d2:
        	:type theC2d2: Geom2d_Curve
        	:param theTolReached:
        	:type theTolReached: float
        	:rtype: void
        """
        return _GeomInt.GeomInt_IntSS_TreatRLine(*args)

    TreatRLine = staticmethod(TreatRLine)

    def TrimILineOnSurfBoundaries(*args) -> "void":
        """
        * puts into theArrayOfParameters the parameters of intersection points of given theC2d1 and theC2d2 curves with the boundaries of the source surface.
        	:param theC2d1:
        	:type theC2d1: Geom2d_Curve
        	:param theC2d2:
        	:type theC2d2: Geom2d_Curve
        	:param theBound1:
        	:type theBound1: Bnd_Box2d
        	:param theBound2:
        	:type theBound2: Bnd_Box2d
        	:param theArrayOfParameters:
        	:type theArrayOfParameters: GeomInt_VectorOfReal
        	:rtype: void
        """
        return _GeomInt.GeomInt_IntSS_TrimILineOnSurfBoundaries(*args)

    TrimILineOnSurfBoundaries = staticmethod(TrimILineOnSurfBoundaries)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_IntSS
GeomInt_IntSS.Boundary = new_instancemethod(_GeomInt.GeomInt_IntSS_Boundary, None, GeomInt_IntSS)
GeomInt_IntSS.HasLineOnS1 = new_instancemethod(_GeomInt.GeomInt_IntSS_HasLineOnS1, None, GeomInt_IntSS)
GeomInt_IntSS.HasLineOnS2 = new_instancemethod(_GeomInt.GeomInt_IntSS_HasLineOnS2, None, GeomInt_IntSS)
GeomInt_IntSS.IsDone = new_instancemethod(_GeomInt.GeomInt_IntSS_IsDone, None, GeomInt_IntSS)
GeomInt_IntSS.Line = new_instancemethod(_GeomInt.GeomInt_IntSS_Line, None, GeomInt_IntSS)
GeomInt_IntSS.LineOnS1 = new_instancemethod(_GeomInt.GeomInt_IntSS_LineOnS1, None, GeomInt_IntSS)
GeomInt_IntSS.LineOnS2 = new_instancemethod(_GeomInt.GeomInt_IntSS_LineOnS2, None, GeomInt_IntSS)
GeomInt_IntSS.NbBoundaries = new_instancemethod(_GeomInt.GeomInt_IntSS_NbBoundaries, None, GeomInt_IntSS)
GeomInt_IntSS.NbLines = new_instancemethod(_GeomInt.GeomInt_IntSS_NbLines, None, GeomInt_IntSS)
GeomInt_IntSS.NbPoints = new_instancemethod(_GeomInt.GeomInt_IntSS_NbPoints, None, GeomInt_IntSS)
GeomInt_IntSS.Perform = new_instancemethod(_GeomInt.GeomInt_IntSS_Perform, None, GeomInt_IntSS)
GeomInt_IntSS.Pnt2d = new_instancemethod(_GeomInt.GeomInt_IntSS_Pnt2d, None, GeomInt_IntSS)
GeomInt_IntSS.Point = new_instancemethod(_GeomInt.GeomInt_IntSS_Point, None, GeomInt_IntSS)
GeomInt_IntSS.TolReached2d = new_instancemethod(_GeomInt.GeomInt_IntSS_TolReached2d, None, GeomInt_IntSS)
GeomInt_IntSS.TolReached3d = new_instancemethod(_GeomInt.GeomInt_IntSS_TolReached3d, None, GeomInt_IntSS)
GeomInt_IntSS_swigregister = _GeomInt.GeomInt_IntSS_swigregister
GeomInt_IntSS_swigregister(GeomInt_IntSS)

def GeomInt_IntSS_BuildPCurves(*args) -> "Standard_Real &":
    """
    * creates 2D-curve on given surface from given 3D-curve
    	:param f:
    	:type f: float
    	:param l:
    	:type l: float
    	:param Tol:
    	:type Tol: float
    	:param S:
    	:type S: Geom_Surface
    	:param C:
    	:type C: Geom_Curve
    	:param C2d:
    	:type C2d: Geom2d_Curve
    	:rtype: void
    """
    return _GeomInt.GeomInt_IntSS_BuildPCurves(*args)

def GeomInt_IntSS_MakeBSpline(*args) -> "opencascade::handle< Geom_Curve >":
    """
    :param WL:
    	:type WL: IntPatch_WLine
    	:param ideb:
    	:type ideb: int
    	:param ifin:
    	:type ifin: int
    	:rtype: opencascade::handle<Geom_Curve>
    """
    return _GeomInt.GeomInt_IntSS_MakeBSpline(*args)

def GeomInt_IntSS_MakeBSpline2d(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
    """
    :param theWLine:
    	:type theWLine: IntPatch_WLine
    	:param ideb:
    	:type ideb: int
    	:param ifin:
    	:type ifin: int
    	:param onFirst:
    	:type onFirst: bool
    	:rtype: opencascade::handle<Geom2d_BSplineCurve>
    """
    return _GeomInt.GeomInt_IntSS_MakeBSpline2d(*args)

def GeomInt_IntSS_TreatRLine(*args) -> "Standard_Real &":
    """
    * converts RLine to Geom(2d)_Curve.
    	:param theRL:
    	:type theRL: IntPatch_RLine
    	:param theHS1:
    	:type theHS1: GeomAdaptor_HSurface
    	:param theHS2:
    	:type theHS2: GeomAdaptor_HSurface
    	:param theC3d:
    	:type theC3d: Geom_Curve
    	:param theC2d1:
    	:type theC2d1: Geom2d_Curve
    	:param theC2d2:
    	:type theC2d2: Geom2d_Curve
    	:param theTolReached:
    	:type theTolReached: float
    	:rtype: void
    """
    return _GeomInt.GeomInt_IntSS_TreatRLine(*args)

def GeomInt_IntSS_TrimILineOnSurfBoundaries(*args) -> "void":
    """
    * puts into theArrayOfParameters the parameters of intersection points of given theC2d1 and theC2d2 curves with the boundaries of the source surface.
    	:param theC2d1:
    	:type theC2d1: Geom2d_Curve
    	:param theC2d2:
    	:type theC2d2: Geom2d_Curve
    	:param theBound1:
    	:type theBound1: Bnd_Box2d
    	:param theBound2:
    	:type theBound2: Bnd_Box2d
    	:param theArrayOfParameters:
    	:type theArrayOfParameters: GeomInt_VectorOfReal
    	:rtype: void
    """
    return _GeomInt.GeomInt_IntSS_TrimILineOnSurfBoundaries(*args)

class GeomInt_LineConstructor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        """
        _GeomInt.GeomInt_LineConstructor_swiginit(self, _GeomInt.new_GeomInt_LineConstructor(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if splitting was successful
        	:rtype: bool
        """
        return _GeomInt.GeomInt_LineConstructor_IsDone(self, *args)


    def Load(self, *args) -> "void":
        """
        * Initializes me by two surfaces and corresponding tools which represent boundaries of surfaces
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param S1:
        	:type S1: GeomAdaptor_HSurface
        	:param S2:
        	:type S2: GeomAdaptor_HSurface
        	:rtype: None
        """
        return _GeomInt.GeomInt_LineConstructor_Load(self, *args)


    def NbParts(self, *args) -> "Standard_Integer":
        """
        * Returns number of splits
        	:rtype: int
        """
        return _GeomInt.GeomInt_LineConstructor_NbParts(self, *args)


    def Part(self, *args) -> "void":
        """
        * Return first and last parameters for given index of split
        	:param I:
        	:type I: int
        	:param WFirst:
        	:type WFirst: float
        	:param WLast:
        	:type WLast: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_LineConstructor_Part(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Splits line
        	:param L:
        	:type L: IntPatch_Line
        	:rtype: None
        """
        return _GeomInt.GeomInt_LineConstructor_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_LineConstructor
GeomInt_LineConstructor.IsDone = new_instancemethod(_GeomInt.GeomInt_LineConstructor_IsDone, None, GeomInt_LineConstructor)
GeomInt_LineConstructor.Load = new_instancemethod(_GeomInt.GeomInt_LineConstructor_Load, None, GeomInt_LineConstructor)
GeomInt_LineConstructor.NbParts = new_instancemethod(_GeomInt.GeomInt_LineConstructor_NbParts, None, GeomInt_LineConstructor)
GeomInt_LineConstructor.Part = new_instancemethod(_GeomInt.GeomInt_LineConstructor_Part, None, GeomInt_LineConstructor)
GeomInt_LineConstructor.Perform = new_instancemethod(_GeomInt.GeomInt_LineConstructor_Perform, None, GeomInt_LineConstructor)
GeomInt_LineConstructor_swigregister = _GeomInt.GeomInt_LineConstructor_swigregister
GeomInt_LineConstructor_swigregister(GeomInt_LineConstructor)

class GeomInt_LineTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DecompositionOfWLine(*args) -> "Standard_Boolean":
        """
        :param theWLine:
        	:type theWLine: IntPatch_WLine
        	:param theSurface1:
        	:type theSurface1: GeomAdaptor_HSurface
        	:param theSurface2:
        	:type theSurface2: GeomAdaptor_HSurface
        	:param aTolSum:
        	:type aTolSum: float
        	:param theLConstructor:
        	:type theLConstructor: GeomInt_LineConstructor
        	:param theNewLines:
        	:type theNewLines: IntPatch_SequenceOfLine
        	:rtype: bool
        """
        return _GeomInt.GeomInt_LineTool_DecompositionOfWLine(*args)

    DecompositionOfWLine = staticmethod(DecompositionOfWLine)

    def FirstParameter(*args) -> "Standard_Real":
        """
        :param L:
        	:type L: IntPatch_Line
        	:rtype: float
        """
        return _GeomInt.GeomInt_LineTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args) -> "Standard_Real":
        """
        :param L:
        	:type L: IntPatch_Line
        	:rtype: float
        """
        return _GeomInt.GeomInt_LineTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def NbVertex(*args) -> "Standard_Integer":
        """
        :param L:
        	:type L: IntPatch_Line
        	:rtype: int
        """
        return _GeomInt.GeomInt_LineTool_NbVertex(*args)

    NbVertex = staticmethod(NbVertex)

    def Vertex(*args) -> "IntPatch_Point const &":
        """
        :param L:
        	:type L: IntPatch_Line
        	:param I:
        	:type I: int
        	:rtype: IntPatch_Point
        """
        return _GeomInt.GeomInt_LineTool_Vertex(*args)

    Vertex = staticmethod(Vertex)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomInt.GeomInt_LineTool_swiginit(self, _GeomInt.new_GeomInt_LineTool())
    __swig_destroy__ = _GeomInt.delete_GeomInt_LineTool
GeomInt_LineTool_swigregister = _GeomInt.GeomInt_LineTool_swigregister
GeomInt_LineTool_swigregister(GeomInt_LineTool)

def GeomInt_LineTool_DecompositionOfWLine(*args) -> "Standard_Boolean":
    """
    :param theWLine:
    	:type theWLine: IntPatch_WLine
    	:param theSurface1:
    	:type theSurface1: GeomAdaptor_HSurface
    	:param theSurface2:
    	:type theSurface2: GeomAdaptor_HSurface
    	:param aTolSum:
    	:type aTolSum: float
    	:param theLConstructor:
    	:type theLConstructor: GeomInt_LineConstructor
    	:param theNewLines:
    	:type theNewLines: IntPatch_SequenceOfLine
    	:rtype: bool
    """
    return _GeomInt.GeomInt_LineTool_DecompositionOfWLine(*args)

def GeomInt_LineTool_FirstParameter(*args) -> "Standard_Real":
    """
    :param L:
    	:type L: IntPatch_Line
    	:rtype: float
    """
    return _GeomInt.GeomInt_LineTool_FirstParameter(*args)

def GeomInt_LineTool_LastParameter(*args) -> "Standard_Real":
    """
    :param L:
    	:type L: IntPatch_Line
    	:rtype: float
    """
    return _GeomInt.GeomInt_LineTool_LastParameter(*args)

def GeomInt_LineTool_NbVertex(*args) -> "Standard_Integer":
    """
    :param L:
    	:type L: IntPatch_Line
    	:rtype: int
    """
    return _GeomInt.GeomInt_LineTool_NbVertex(*args)

def GeomInt_LineTool_Vertex(*args) -> "IntPatch_Point const &":
    """
    :param L:
    	:type L: IntPatch_Line
    	:param I:
    	:type I: int
    	:rtype: IntPatch_Point
    """
    return _GeomInt.GeomInt_LineTool_Vertex(*args)

class GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_Error(self, *args)


    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 1
        	:type NbIterations: int
        	:rtype: None
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations:
        	:type NbIterations: int
        	:param lambda1:
        	:type lambda1: float
        	:param lambda2:
        	:type lambda2: float
        	:rtype: None
        """
        _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        * returns all the BSpline curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.AverageError = new_instancemethod(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_AverageError, None, GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_Error, None, GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.IsDone = new_instancemethod(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_IsDone, None, GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.MaxError2d = new_instancemethod(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_MaxError2d, None, GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.MaxError3d = new_instancemethod(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_MaxError3d, None, GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.Value = new_instancemethod(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_Value, None, GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox)
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_swigregister
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_Error(self, *args)


    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiCurve
        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.AverageError = new_instancemethod(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_AverageError, None, GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_Error, None, GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.IsDone = new_instancemethod(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_IsDone, None, GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.MaxError2d = new_instancemethod(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_MaxError2d, None, GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.MaxError3d = new_instancemethod(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_MaxError3d, None, GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.Value = new_instancemethod(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_Value, None, GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_MyGradientbisOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AverageError(self, *args) -> "Standard_Real":
        """
        * returns the average error between the old and the new approximation.
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_Error(self, *args)


    def __init__(self, *args):
        """
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum difference between the old and the new approximation.
        	:rtype: float
        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.
        	:rtype: AppParCurves_MultiCurve
        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.AverageError = new_instancemethod(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_AverageError, None, GeomInt_MyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_Error, None, GeomInt_MyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.IsDone = new_instancemethod(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_IsDone, None, GeomInt_MyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.MaxError2d = new_instancemethod(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_MaxError2d, None, GeomInt_MyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.MaxError3d = new_instancemethod(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_MaxError3d, None, GeomInt_MyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.Value = new_instancemethod(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_Value, None, GeomInt_MyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the MultiCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiCurve
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_FirstConstraint(self, *args)


    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox(*args))

    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.CurveValue = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_CurveValue, None, GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_Error, None, GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.FirstConstraint = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_FirstConstraint, None, GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.LastConstraint = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_LastConstraint, None, GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.MaxError2d = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_MaxError2d, None, GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.MaxError3d = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_MaxError3d, None, GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.NewParameters = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_NewParameters, None, GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the MultiCurve approximating the set after computing the value F or Grad(F).
        	:rtype: AppParCurves_MultiCurve
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        * returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.
        	:param IPoint:
        	:type IPoint: int
        	:param CurveIndex:
        	:type CurveIndex: int
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param FirstPoint:
        	:type FirstPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_FirstConstraint(self, *args)


    def __init__(self, *args):
        """
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox(*args))

    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        :param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: AppParCurves_Constraint
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between the points and the MultiCurve.
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        * returns the new parameters of the MultiLine.
        	:rtype: math_Vector
        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.CurveValue = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_CurveValue, None, GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_Error, None, GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.FirstConstraint = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_FirstConstraint, None, GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.LastConstraint = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_LastConstraint, None, GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.MaxError2d = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_MaxError2d, None, GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.MaxError3d = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_MaxError3d, None, GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.NewParameters = new_instancemethod(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_NewParameters, None, GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_FunctionMatrix(self, *args)


    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.BSplineValue = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_BSplineValue, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.BezierValue = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_BezierValue, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.DerivativeFunctionMatrix = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_DerivativeFunctionMatrix, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.Distance = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Distance, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Error, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.ErrorGradient = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_ErrorGradient, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.FirstLambda = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_FirstLambda, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.FunctionMatrix = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_FunctionMatrix, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.IsDone = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_IsDone, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.KIndex = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_KIndex, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.LastLambda = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_LastLambda, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.Perform = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Perform, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.Points = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Points, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.Poles = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Poles, None, GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        * returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.
        	:rtype: AppParCurves_MultiCurve
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the derivative function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        * returns the distances between the points of the multiline and the approximation curves.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        * returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.
        	:param Grad:
        	:type Grad: math_Vector
        	:param F:
        	:type F: float
        	:param MaxE3d:
        	:type MaxE3d: float
        	:param MaxE2d:
        	:type MaxE2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (P2 - P1)/ V1 if the first point was a tangency point.
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the function matrix used to approximate the set.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_FunctionMatrix(self, *args)


    def __init__(self, *args):
        """
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        * Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        * Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.
        	:rtype: math_IntegerVector
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        * returns the value (PN - PN-1)/ VN if the last point was a tangency point.
        	:rtype: float
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:rtype: None
        * Is used after having initialized the fields.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        * Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param V1t:
        	:type V1t: math_Vector
        	:param V2t:
        	:type V2t: math_Vector
        	:param V1c:
        	:type V1c: math_Vector
        	:param V2c:
        	:type V2c: math_Vector
        	:param l1:
        	:type l1: float
        	:param l2:
        	:type l2: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of points value.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        * returns the matrix of resulting control points value.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.BSplineValue = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_BSplineValue, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.BezierValue = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_BezierValue, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.DerivativeFunctionMatrix = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.Distance = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Distance, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Error, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.ErrorGradient = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_ErrorGradient, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.FirstLambda = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_FirstLambda, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.FunctionMatrix = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_FunctionMatrix, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.IsDone = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_IsDone, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.KIndex = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_KIndex, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.LastLambda = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_LastLambda, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.Perform = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Perform, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.Points = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Points, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.Poles = new_instancemethod(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Poles, None, GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_ParameterAndOrientation(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param P:
        	:type P: float
        	:param Or1:
        	:type Or1: TopAbs_Orientation
        	:param Or2:
        	:type Or2: TopAbs_Orientation
        	:rtype: None
        """
        _GeomInt.GeomInt_ParameterAndOrientation_swiginit(self, _GeomInt.new_GeomInt_ParameterAndOrientation(*args))

    def Orientation1(self, *args) -> "TopAbs_Orientation":
        """:rtype: TopAbs_Orientation"""
        return _GeomInt.GeomInt_ParameterAndOrientation_Orientation1(self, *args)


    def Orientation2(self, *args) -> "TopAbs_Orientation":
        """:rtype: TopAbs_Orientation"""
        return _GeomInt.GeomInt_ParameterAndOrientation_Orientation2(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _GeomInt.GeomInt_ParameterAndOrientation_Parameter(self, *args)


    def SetOrientation1(self, *args) -> "void":
        """
        :param Or:
        	:type Or: TopAbs_Orientation
        	:rtype: None
        """
        return _GeomInt.GeomInt_ParameterAndOrientation_SetOrientation1(self, *args)


    def SetOrientation2(self, *args) -> "void":
        """
        :param Or:
        	:type Or: TopAbs_Orientation
        	:rtype: None
        """
        return _GeomInt.GeomInt_ParameterAndOrientation_SetOrientation2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParameterAndOrientation
GeomInt_ParameterAndOrientation.Orientation1 = new_instancemethod(_GeomInt.GeomInt_ParameterAndOrientation_Orientation1, None, GeomInt_ParameterAndOrientation)
GeomInt_ParameterAndOrientation.Orientation2 = new_instancemethod(_GeomInt.GeomInt_ParameterAndOrientation_Orientation2, None, GeomInt_ParameterAndOrientation)
GeomInt_ParameterAndOrientation.Parameter = new_instancemethod(_GeomInt.GeomInt_ParameterAndOrientation_Parameter, None, GeomInt_ParameterAndOrientation)
GeomInt_ParameterAndOrientation.SetOrientation1 = new_instancemethod(_GeomInt.GeomInt_ParameterAndOrientation_SetOrientation1, None, GeomInt_ParameterAndOrientation)
GeomInt_ParameterAndOrientation.SetOrientation2 = new_instancemethod(_GeomInt.GeomInt_ParameterAndOrientation_SetOrientation2, None, GeomInt_ParameterAndOrientation)
GeomInt_ParameterAndOrientation_swigregister = _GeomInt.GeomInt_ParameterAndOrientation_swigregister
GeomInt_ParameterAndOrientation_swigregister(GeomInt_ParameterAndOrientation)

class GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        * Returns the derivative of the constraint matrix.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param DA:
        	:type DA: math_Matrix
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """:rtype: math_Matrix"""
        return _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        * returns the duale variables of the system.
        	:rtype: math_Vector
        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_Duale(self, *args)


    def __init__(self, *args):
        """
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox(*args))

    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_IsDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.ConstraintDerivative = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_ConstraintDerivative, None, GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.ConstraintMatrix = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_ConstraintMatrix, None, GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.Duale = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_Duale, None, GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.InverseMatrix = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_InverseMatrix, None, GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.IsDone = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_IsDone, None, GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox)
GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        * Returns the derivative of the constraint matrix.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param DA:
        	:type DA: math_Matrix
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """:rtype: math_Matrix"""
        return _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        * returns the duale variables of the system.
        	:rtype: math_Vector
        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_Duale(self, *args)


    def __init__(self, *args):
        """
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox(*args))

    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        * returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.
        	:rtype: math_Matrix
        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_IsDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox
GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.ConstraintDerivative = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_ConstraintDerivative, None, GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.ConstraintMatrix = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_ConstraintMatrix, None, GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.Duale = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_Duale, None, GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.InverseMatrix = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_InverseMatrix, None, GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.IsDone = new_instancemethod(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_IsDone, None, GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox)
GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_TheComputeLineBezierOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ChangeValue(self, *args) -> "AppParCurves_MultiCurve &":
        """
        * returns the result of the approximation.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: AppParCurves_MultiCurve
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_ChangeValue(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the tolerances 2d and 3d of the <Index> MultiCurve.
        	:param Index:
        	:type Index: int
        	:param tol3d:
        	:type tol3d: float
        	:param tol2d:
        	:type tol2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Error(self, *args)


    def __init__(self, *args):
        """
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheComputeLineBezierOfWLApprox(*args))

    def Init(self, *args) -> "void":
        """
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Init(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        * returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        * returns False if the status NoPointsAdded has been sent.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_IsToleranceReached(self, *args)


    def NbMultiCurves(self, *args) -> "Standard_Integer":
        """
        * Returns the number of MultiCurve doing the approximation of the MultiLine.
        	:rtype: int
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_NbMultiCurves(self, *args)


    def Parameters(self, *args) -> "TColStd_Array1OfReal const &":
        """
        * returns the new parameters of the approximation corresponding to the points of the multicurve <Index>.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: TColStd_Array1OfReal
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Parameters(self, *args)


    def Parametrization(self, *args) -> "Approx_ParametrizationType":
        """
        * returns the type of parametrization
        	:rtype: Approx_ParametrizationType
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Parametrization(self, *args)


    def Perform(self, *args) -> "void":
        """
        * runs the algorithm after having initialized the fields.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        * changes the first and the last constraint points.
        	:param firstC:
        	:type firstC: AppParCurves_Constraint
        	:param lastC:
        	:type lastC: AppParCurves_Constraint
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetConstraints(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        * changes the degrees of the approximation.
        	:param degreemin:
        	:type degreemin: int
        	:param degreemax:
        	:type degreemax: int
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetDegrees(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        * Changes the tolerances of the approximation.
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetTolerances(self, *args)


    def SplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SplineValue(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        * returns the result of the approximation.
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: AppParCurves_MultiCurve
        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheComputeLineBezierOfWLApprox
GeomInt_TheComputeLineBezierOfWLApprox.ChangeValue = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_ChangeValue, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Error, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.Init = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Init, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.IsAllApproximated = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_IsAllApproximated, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.IsToleranceReached = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_IsToleranceReached, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.NbMultiCurves = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_NbMultiCurves, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.Parameters = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Parameters, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.Parametrization = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Parametrization, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.Perform = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Perform, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.SetConstraints = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetConstraints, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.SetDegrees = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetDegrees, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.SetTolerances = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetTolerances, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.SplineValue = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SplineValue, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox.Value = new_instancemethod(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Value, None, GeomInt_TheComputeLineBezierOfWLApprox)
GeomInt_TheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_swigregister
GeomInt_TheComputeLineBezierOfWLApprox_swigregister(GeomInt_TheComputeLineBezierOfWLApprox)

class GeomInt_TheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ChangeValue(self, *args) -> "AppParCurves_MultiBSpCurve &":
        """
        * returns the result of the approximation.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_ChangeValue(self, *args)


    def Error(self, *args) -> "void":
        """
        * returns the tolerances 2d and 3d of the MultiBSpCurve.
        	:param tol3d:
        	:type tol3d: float
        	:param tol2d:
        	:type tol2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Error(self, *args)


    def __init__(self, *args):
        """
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all. //! The multiplicities of the internal knots is set by default.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _GeomInt.GeomInt_TheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheComputeLineOfWLApprox(*args))

    def Init(self, *args) -> "void":
        """
        * Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Init(self, *args)


    def Interpol(self, *args) -> "void":
        """
        * Constructs an interpolation of the MultiLine <Line> The result will be a C2 curve of degree 3.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Interpol(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        * returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        * returns False if the status NoPointsAdded has been sent.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_IsToleranceReached(self, *args)


    def Parameters(self, *args) -> "TColStd_Array1OfReal const &":
        """
        * returns the new parameters of the approximation corresponding to the points of the MultiBSpCurve.
        	:rtype: TColStd_Array1OfReal
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Parameters(self, *args)


    def Perform(self, *args) -> "void":
        """
        * runs the algorithm after having initialized the fields.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        * changes the first and the last constraint points.
        	:param firstC:
        	:type firstC: AppParCurves_Constraint
        	:param lastC:
        	:type lastC: AppParCurves_Constraint
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetConstraints(self, *args)


    def SetContinuity(self, *args) -> "void":
        """
        * sets the continuity of the spline. if C = 2, the spline will be C2.
        	:param C:
        	:type C: int
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetContinuity(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        * changes the degrees of the approximation.
        	:param degreemin:
        	:type degreemin: int
        	:param degreemax:
        	:type degreemax: int
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetDegrees(self, *args)


    def SetKnots(self, *args) -> "void":
        """
        * The approximation will be done with the set of knots <Knots>. The multiplicities will be set with the degree and the desired continuity.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetKnots(self, *args)


    def SetKnotsAndMultiplicities(self, *args) -> "void":
        """
        * The approximation will be done with the set of knots <Knots> and the multiplicities <Mults>.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetKnotsAndMultiplicities(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        * The approximation will begin with the set of parameters <ThePar>.
        	:param ThePar:
        	:type ThePar: math_Vector
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetParameters(self, *args)


    def SetPeriodic(self, *args) -> "void":
        """
        * Sets periodic flag. If thePeriodic = Standard_True, algorith tries to build periodic multicurve using corresponding C1 boundary condition for first and last multipoints. Multiline must be closed.
        	:param thePeriodic:
        	:type thePeriodic: bool
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetPeriodic(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        * Changes the tolerances of the approximation.
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetTolerances(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        * returns the result of the approximation.
        	:rtype: AppParCurves_MultiBSpCurve
        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheComputeLineOfWLApprox
GeomInt_TheComputeLineOfWLApprox.ChangeValue = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_ChangeValue, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.Error = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Error, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.Init = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Init, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.Interpol = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Interpol, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.IsAllApproximated = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_IsAllApproximated, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.IsToleranceReached = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_IsToleranceReached, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.Parameters = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Parameters, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.Perform = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Perform, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.SetConstraints = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetConstraints, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.SetContinuity = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetContinuity, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.SetDegrees = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetDegrees, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.SetKnots = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetKnots, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.SetKnotsAndMultiplicities = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetKnotsAndMultiplicities, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.SetParameters = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetParameters, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.SetPeriodic = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetPeriodic, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.SetTolerances = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetTolerances, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox.Value = new_instancemethod(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Value, None, GeomInt_TheComputeLineOfWLApprox)
GeomInt_TheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_TheComputeLineOfWLApprox_swigregister
GeomInt_TheComputeLineOfWLApprox_swigregister(GeomInt_TheComputeLineOfWLApprox)

class GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AuxillarSurface1(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """:rtype: opencascade::handle<Adaptor3d_HSurface>"""
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_AuxillarSurface1(self, *args)


    def AuxillarSurface2(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """:rtype: opencascade::handle<Adaptor3d_HSurface>"""
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_AuxillarSurface2(self, *args)


    def ComputeParameters(self, *args) -> "void":
        """
        :param ChoixIso:
        	:type ChoixIso: IntImp_ConstIsoparametric
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param UVap:
        	:type UVap: math_Vector
        	:param BornInf:
        	:type BornInf: math_Vector
        	:param BornSup:
        	:type BornSup: math_Vector
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_ComputeParameters(self, *args)


    def Direction(self, *args) -> "gp_Dir":
        """:rtype: gp_Dir"""
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Direction(self, *args)


    def DirectionOnS1(self, *args) -> "gp_Dir2d":
        """:rtype: gp_Dir2d"""
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS1(self, *args)


    def DirectionOnS2(self, *args) -> "gp_Dir2d":
        """:rtype: gp_Dir2d"""
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS2(self, *args)


    def __init__(self, *args):
        """
        :param S1:
        	:type S1: Adaptor3d_HSurface
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:rtype: None
        """
        _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox(*args))

    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        :param UVap:
        	:type UVap: math_Vector
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param BestChoix:
        	:type BestChoix: IntImp_ConstIsoparametric
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsTangent(self, *args)


    def Point(self, *args) -> "gp_Pnt":
        """:rtype: gp_Pnt"""
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        * returns somme des fi*fi
        	:rtype: float
        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Root(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.AuxillarSurface1 = new_instancemethod(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_AuxillarSurface1, None, GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.AuxillarSurface2 = new_instancemethod(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_AuxillarSurface2, None, GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.ComputeParameters = new_instancemethod(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_ComputeParameters, None, GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.Direction = new_instancemethod(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Direction, None, GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.DirectionOnS1 = new_instancemethod(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS1, None, GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.DirectionOnS2 = new_instancemethod(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS2, None, GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.IsTangent = new_instancemethod(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsTangent, None, GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.Point = new_instancemethod(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Point, None, GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.Root = new_instancemethod(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Root, None, GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)

class GeomInt_TheImpPrmSvSurfacesOfWLApprox(OCC.Core.ApproxInt.ApproxInt_SvSurfaces):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Surf1:
        	:type Surf1: Adaptor3d_HSurface
        	:param Surf2:
        	:type Surf2: IntSurf_Quadric
        	:rtype: None
        :param Surf1:
        	:type Surf1: IntSurf_Quadric
        	:param Surf2:
        	:type Surf2: Adaptor3d_HSurface
        	:rtype: None
        """
        _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheImpPrmSvSurfacesOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheImpPrmSvSurfacesOfWLApprox
GeomInt_TheImpPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_swigregister
GeomInt_TheImpPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheImpPrmSvSurfacesOfWLApprox)

class GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ChangePoint(self, *args) -> "IntSurf_PntOn2S &":
        """
        * return the intersection point which is enable for changing.
        	:rtype: IntSurf_PntOn2S
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_ChangePoint(self, *args)


    def Direction(self, *args) -> "gp_Dir const":
        """
        * Returns the tangent at the intersection line.
        	:rtype: gp_Dir
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Direction(self, *args)


    def DirectionOnS1(self, *args) -> "gp_Dir2d const":
        """
        * Returns the tangent at the intersection line in the parametric space of the first surface.
        	:rtype: gp_Dir2d
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS1(self, *args)


    def DirectionOnS2(self, *args) -> "gp_Dir2d const":
        """
        * Returns the tangent at the intersection line in the parametric space of the second surface.
        	:rtype: gp_Dir2d
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS2(self, *args)


    def Function(self, *args) -> "GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox &":
        """
        * return the math function which is used to compute the intersection
        	:rtype: GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Function(self, *args)


    def __init__(self, *args):
        """
        * compute the solution point with the close point
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None
        * initialize the parameters to compute the solution point it 's possible to write to optimize: IntImp_Int2S inter(S1,S2,Func,TolTangency); math_FunctionSetRoot rsnld(inter.Function()); while ...{ Param(1)=... Param(2)=... param(3)=... inter.Perform(Param,rsnld); }
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None
        """
        _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the creation completed without failure.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns True when there is no solution to the problem.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsEmpty(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the surfaces are tangent at the intersection point.
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsTangent(self, *args)


    def Perform(self, *args) -> "IntImp_ConstIsoparametric":
        """
        * returns the best constant isoparametric to find the next intersection's point +stores the solution point (the solution point is found with the close point to intersect the isoparametric with the other patch; the choice of the isoparametic is calculated)
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param Rsnld:
        	:type Rsnld: math_FunctionSetRoot
        	:rtype: IntImp_ConstIsoparametric
        * returns the best constant isoparametric to find the next intersection's point +stores the solution point (the solution point is found with the close point to intersect the isoparametric with the other patch; the choice of the isoparametic is given by ChoixIso)
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param Rsnld:
        	:type Rsnld: math_FunctionSetRoot
        	:param ChoixIso:
        	:type ChoixIso: IntImp_ConstIsoparametric
        	:rtype: IntImp_ConstIsoparametric
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Perform(self, *args)


    def Point(self, *args) -> "IntSurf_PntOn2S const &":
        """
        * Returns the intersection point.
        	:rtype: IntSurf_PntOn2S
        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Point(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.ChangePoint = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_ChangePoint, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.Direction = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Direction, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.DirectionOnS1 = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS1, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.DirectionOnS2 = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS2, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.Function = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Function, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.IsDone = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsDone, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.IsEmpty = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsEmpty, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.IsTangent = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsTangent, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.Perform = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Perform, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.Point = new_instancemethod(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Point, None, GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)

class GeomInt_TheMultiLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dump(self, *args) -> "void":
        """
        * Dump of the current multi-line.
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_Dump(self, *args)


    def FirstPoint(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_FirstPoint(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        * The class SvSurfaces is used when the approximation algorithm needs some extra points on the line <line>. A New line is then created which shares the same surfaces and functions. SvSurfaces is a deferred class which allows several implementations of this algorithm with different surfaces (bi-parametric ones, or implicit and biparametric ones)
        	:param line:
        	:type line: IntPatch_WLine
        	:param PtrSvSurfaces:
        	:type PtrSvSurfaces: Standard_Address
        	:param NbP3d:
        	:type NbP3d: int
        	:param NbP2d:
        	:type NbP2d: int
        	:param ApproxU1V1:
        	:type ApproxU1V1: bool
        	:param ApproxU2V2:
        	:type ApproxU2V2: bool
        	:param xo:
        	:type xo: float
        	:param yo:
        	:type yo: float
        	:param zo:
        	:type zo: float
        	:param u1o:
        	:type u1o: float
        	:param v1o:
        	:type v1o: float
        	:param u2o:
        	:type u2o: float
        	:param v2o:
        	:type v2o: float
        	:param P2DOnFirst:
        	:type P2DOnFirst: bool
        	:param IndMin: default value is 0
        	:type IndMin: int
        	:param IndMax: default value is 0
        	:type IndMax: int
        	:rtype: None
        * No Extra points will be added on the current line
        	:param line:
        	:type line: IntPatch_WLine
        	:param NbP3d:
        	:type NbP3d: int
        	:param NbP2d:
        	:type NbP2d: int
        	:param ApproxU1V1:
        	:type ApproxU1V1: bool
        	:param ApproxU2V2:
        	:type ApproxU2V2: bool
        	:param xo:
        	:type xo: float
        	:param yo:
        	:type yo: float
        	:param zo:
        	:type zo: float
        	:param u1o:
        	:type u1o: float
        	:param v1o:
        	:type v1o: float
        	:param u2o:
        	:type u2o: float
        	:param v2o:
        	:type v2o: float
        	:param P2DOnFirst:
        	:type P2DOnFirst: bool
        	:param IndMin: default value is 0
        	:type IndMin: int
        	:param IndMax: default value is 0
        	:type IndMax: int
        	:rtype: None
        """
        _GeomInt.GeomInt_TheMultiLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheMultiLineOfWLApprox(*args))

    def LastPoint(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_LastPoint(self, *args)


    def MakeMLBetween(self, *args) -> "GeomInt_TheMultiLineOfWLApprox":
        """
        * Tries to make a sub-line between <Low> and <High> points of this line by adding <NbPointsToInsert> new points
        	:param Low:
        	:type Low: int
        	:param High:
        	:type High: int
        	:param NbPointsToInsert:
        	:type NbPointsToInsert: int
        	:rtype: GeomInt_TheMultiLineOfWLApprox
        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_MakeMLBetween(self, *args)


    def MakeMLOneMorePoint(self, *args) -> "Standard_Boolean":
        """
        * Tries to make a sub-line between <Low> and <High> points of this line by adding one more point between (indbad-1)-th and indbad-th points
        	:param Low:
        	:type Low: int
        	:param High:
        	:type High: int
        	:param indbad:
        	:type indbad: int
        	:param OtherLine:
        	:type OtherLine: GeomInt_TheMultiLineOfWLApprox
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_MakeMLOneMorePoint(self, *args)


    def NbP2d(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 2d points of a TheLine.
        	:rtype: int
        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_NbP2d(self, *args)


    def NbP3d(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 3d points of a TheLine.
        	:rtype: int
        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_NbP3d(self, *args)


    def Tangency(self, *args) -> "Standard_Boolean":
        """
        * Returns the 3d tangency points of the multipoint <MPointIndex> only when 3d points exist.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:rtype: bool
        * Returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        * Returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_Tangency(self, *args)


    def Value(self, *args) -> "void":
        """
        * Returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:rtype: None
        * Returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: None
        * returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_Value(self, *args)


    def WhatStatus(self, *args) -> "Approx_Status":
        """:rtype: Approx_Status"""
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_WhatStatus(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheMultiLineOfWLApprox
GeomInt_TheMultiLineOfWLApprox.Dump = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_Dump, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox.FirstPoint = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_FirstPoint, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox.LastPoint = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_LastPoint, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox.MakeMLBetween = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_MakeMLBetween, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox.MakeMLOneMorePoint = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_MakeMLOneMorePoint, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox.NbP2d = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_NbP2d, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox.NbP3d = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_NbP3d, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox.Tangency = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_Tangency, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox.Value = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_Value, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox.WhatStatus = new_instancemethod(_GeomInt.GeomInt_TheMultiLineOfWLApprox_WhatStatus, None, GeomInt_TheMultiLineOfWLApprox)
GeomInt_TheMultiLineOfWLApprox_swigregister = _GeomInt.GeomInt_TheMultiLineOfWLApprox_swigregister
GeomInt_TheMultiLineOfWLApprox_swigregister(GeomInt_TheMultiLineOfWLApprox)

class GeomInt_TheMultiLineToolOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Curvature(*args) -> "Standard_Boolean":
        """
        * returns the 3d curvature of the multipoint <MPointIndex> when only 3d points exist.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:rtype: bool
        * returns the 2d curvature points of the multipoint <MPointIndex> only when 2d points exist.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        * returns the 3d and 2d curvature of the multipoint <MPointIndex>.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Curvature(*args)

    Curvature = staticmethod(Curvature)

    def Dump(*args) -> "void":
        """
        * Dump of the current multi-line.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Dump(*args)

    Dump = staticmethod(Dump)

    def FirstPoint(*args) -> "Standard_Integer":
        """
        * Returns the number of multipoints of the TheMultiLine.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:rtype: int
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_FirstPoint(*args)

    FirstPoint = staticmethod(FirstPoint)

    def LastPoint(*args) -> "Standard_Integer":
        """
        * Returns the number of multipoints of the TheMultiLine.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:rtype: int
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_LastPoint(*args)

    LastPoint = staticmethod(LastPoint)

    def MakeMLBetween(*args) -> "GeomInt_TheMultiLineOfWLApprox":
        """
        * Is called if WhatStatus returned 'PointsAdded'.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:param NbPMin:
        	:type NbPMin: int
        	:rtype: GeomInt_TheMultiLineOfWLApprox
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween(*args)

    MakeMLBetween = staticmethod(MakeMLBetween)

    def MakeMLOneMorePoint(*args) -> "Standard_Boolean":
        """
        * Is called when the Bezier curve contains a loop
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:param indbad:
        	:type indbad: int
        	:param OtherLine:
        	:type OtherLine: GeomInt_TheMultiLineOfWLApprox
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint(*args)

    MakeMLOneMorePoint = staticmethod(MakeMLOneMorePoint)

    def NbP2d(*args) -> "Standard_Integer":
        """
        * Returns the number of 2d points of a TheMultiLine.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:rtype: int
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP2d(*args)

    NbP2d = staticmethod(NbP2d)

    def NbP3d(*args) -> "Standard_Integer":
        """
        * Returns the number of 3d points of a TheMultiLine.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:rtype: int
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP3d(*args)

    NbP3d = staticmethod(NbP3d)

    def Tangency(*args) -> "Standard_Boolean":
        """
        * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:rtype: bool
        * returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        * returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabV:
        	:type tabV: TColgp_Array1OfVec
        	:param tabV2d:
        	:type tabV2d: TColgp_Array1OfVec2d
        	:rtype: bool
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Tangency(*args)

    Tangency = staticmethod(Tangency)

    def Value(*args) -> "void":
        """
        * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:rtype: None
        * returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: None
        * returns the 3d and 2d points of the multipoint <MPointIndex>.
        	:param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param MPointIndex:
        	:type MPointIndex: int
        	:param tabPt:
        	:type tabPt: TColgp_Array1OfPnt
        	:param tabPt2d:
        	:type tabPt2d: TColgp_Array1OfPnt2d
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Value(*args)

    Value = staticmethod(Value)

    def WhatStatus(*args) -> "Approx_Status":
        """
        :param ML:
        	:type ML: GeomInt_TheMultiLineOfWLApprox
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:rtype: Approx_Status
        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_WhatStatus(*args)

    WhatStatus = staticmethod(WhatStatus)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheMultiLineToolOfWLApprox())
    __swig_destroy__ = _GeomInt.delete_GeomInt_TheMultiLineToolOfWLApprox
GeomInt_TheMultiLineToolOfWLApprox_swigregister = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_swigregister
GeomInt_TheMultiLineToolOfWLApprox_swigregister(GeomInt_TheMultiLineToolOfWLApprox)

def GeomInt_TheMultiLineToolOfWLApprox_Curvature(*args) -> "Standard_Boolean":
    """
    * returns the 3d curvature of the multipoint <MPointIndex> when only 3d points exist.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:rtype: bool
    * returns the 2d curvature points of the multipoint <MPointIndex> only when 2d points exist.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    * returns the 3d and 2d curvature of the multipoint <MPointIndex>.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Curvature(*args)

def GeomInt_TheMultiLineToolOfWLApprox_Dump(*args) -> "void":
    """
    * Dump of the current multi-line.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:rtype: None
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Dump(*args)

def GeomInt_TheMultiLineToolOfWLApprox_FirstPoint(*args) -> "Standard_Integer":
    """
    * Returns the number of multipoints of the TheMultiLine.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:rtype: int
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_FirstPoint(*args)

def GeomInt_TheMultiLineToolOfWLApprox_LastPoint(*args) -> "Standard_Integer":
    """
    * Returns the number of multipoints of the TheMultiLine.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:rtype: int
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_LastPoint(*args)

def GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween(*args) -> "GeomInt_TheMultiLineOfWLApprox":
    """
    * Is called if WhatStatus returned 'PointsAdded'.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:param NbPMin:
    	:type NbPMin: int
    	:rtype: GeomInt_TheMultiLineOfWLApprox
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween(*args)

def GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint(*args) -> "Standard_Boolean":
    """
    * Is called when the Bezier curve contains a loop
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:param indbad:
    	:type indbad: int
    	:param OtherLine:
    	:type OtherLine: GeomInt_TheMultiLineOfWLApprox
    	:rtype: bool
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint(*args)

def GeomInt_TheMultiLineToolOfWLApprox_NbP2d(*args) -> "Standard_Integer":
    """
    * Returns the number of 2d points of a TheMultiLine.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:rtype: int
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP2d(*args)

def GeomInt_TheMultiLineToolOfWLApprox_NbP3d(*args) -> "Standard_Integer":
    """
    * Returns the number of 3d points of a TheMultiLine.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:rtype: int
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP3d(*args)

def GeomInt_TheMultiLineToolOfWLApprox_Tangency(*args) -> "Standard_Boolean":
    """
    * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:rtype: bool
    * returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    * returns the 3d and 2d points of the multipoint <MPointIndex>.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabV:
    	:type tabV: TColgp_Array1OfVec
    	:param tabV2d:
    	:type tabV2d: TColgp_Array1OfVec2d
    	:rtype: bool
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Tangency(*args)

def GeomInt_TheMultiLineToolOfWLApprox_Value(*args) -> "void":
    """
    * returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabPt:
    	:type tabPt: TColgp_Array1OfPnt
    	:rtype: None
    * returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabPt2d:
    	:type tabPt2d: TColgp_Array1OfPnt2d
    	:rtype: None
    * returns the 3d and 2d points of the multipoint <MPointIndex>.
    	:param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param MPointIndex:
    	:type MPointIndex: int
    	:param tabPt:
    	:type tabPt: TColgp_Array1OfPnt
    	:param tabPt2d:
    	:type tabPt2d: TColgp_Array1OfPnt2d
    	:rtype: None
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Value(*args)

def GeomInt_TheMultiLineToolOfWLApprox_WhatStatus(*args) -> "Approx_Status":
    """
    :param ML:
    	:type ML: GeomInt_TheMultiLineOfWLApprox
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:rtype: Approx_Status
    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_WhatStatus(*args)

class GeomInt_ThePrmPrmSvSurfacesOfWLApprox(OCC.Core.ApproxInt.ApproxInt_SvSurfaces):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param Surf1:
        	:type Surf1: Adaptor3d_HSurface
        	:param Surf2:
        	:type Surf2: Adaptor3d_HSurface
        	:rtype: None
        """
        _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ThePrmPrmSvSurfacesOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ThePrmPrmSvSurfacesOfWLApprox
GeomInt_ThePrmPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_swigregister
GeomInt_ThePrmPrmSvSurfacesOfWLApprox_swigregister(GeomInt_ThePrmPrmSvSurfacesOfWLApprox)

class GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Direction2d(self, *args) -> "gp_Dir2d const":
        """:rtype: gp_Dir2d"""
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Direction2d(self, *args)


    def Direction3d(self, *args) -> "gp_Vec const":
        """:rtype: gp_Vec"""
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Direction3d(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param PS:
        	:type PS: Adaptor3d_HSurface
        	:param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        :param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        """
        _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox(*args))

    def ISurface(self, *args) -> "IntSurf_Quadric const &":
        """:rtype: IntSurf_Quadric"""
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_ISurface(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_IsTangent(self, *args)


    def PSurface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """:rtype: opencascade::handle<Adaptor3d_HSurface>"""
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_PSurface(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Root(self, *args)


    def Set(self, *args) -> "void":
        """
        :param PS:
        	:type PS: Adaptor3d_HSurface
        	:rtype: None
        :param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Set(self, *args)


    def SetImplicitSurface(self, *args) -> "void":
        """
        :param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_SetImplicitSurface(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * Returns the value Tol so that if Abs(Func.Root())<Tol the function is considered null.
        	:rtype: float
        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Tolerance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.Direction2d = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Direction2d, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.Direction3d = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Direction3d, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.ISurface = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_ISurface, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.IsTangent = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_IsTangent, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.PSurface = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_PSurface, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.Point = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Point, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.Root = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Root, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.Set = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Set, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.SetImplicitSurface = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_SetImplicitSurface, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.Tolerance = new_instancemethod(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Tolerance, None, GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_swigregister
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)



