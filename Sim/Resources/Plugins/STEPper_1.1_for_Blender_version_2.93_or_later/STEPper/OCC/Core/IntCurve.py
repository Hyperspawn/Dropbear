# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IntCurve module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_intcurve.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _IntCurve.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntCurve')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntCurve')
    _IntCurve = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntCurve', [dirname(__file__)])
        except ImportError:
            import _IntCurve
            return _IntCurve
        try:
            _mod = imp.load_module('_IntCurve', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntCurve = swig_import_helper()
    del swig_import_helper
else:
    import _IntCurve
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntCurve.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_IntCurve.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_IntCurve.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_IntCurve.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_IntCurve.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_IntCurve.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_IntCurve.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_IntCurve.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_IntCurve.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_IntCurve.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_IntCurve.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_IntCurve.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_IntCurve.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_IntCurve.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_IntCurve.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_IntCurve.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_IntCurve.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _IntCurve.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _IntCurve.process_exception(error, method_name, class_name)
process_exception = _IntCurve.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
import OCC.Core.IntRes2d
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.GeomAbs
class IntCurve_IConicTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def D1(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param T:
        	:type T: gp_Vec2d
        	:rtype: None
        """
        return _IntCurve.IntCurve_IConicTool_D1(self, *args)


    def D2(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param T:
        	:type T: gp_Vec2d
        	:param N:
        	:type N: gp_Vec2d
        	:rtype: None
        """
        return _IntCurve.IntCurve_IConicTool_D2(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        * Computes the value of the signed distance between the point P and the implicit curve.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: float
        """
        return _IntCurve.IntCurve_IConicTool_Distance(self, *args)


    def FindParameter(self, *args) -> "Standard_Real":
        """
        * Returns the parameter U of the point on the implicit curve corresponding to the point P. The correspondance between P and the point P(U) on the implicit curve must be coherent with the way of determination of the signed distance.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: float
        """
        return _IntCurve.IntCurve_IConicTool_FindParameter(self, *args)


    def GradDistance(self, *args) -> "gp_Vec2d":
        """
        * Computes the Gradient of the Signed Distance between a point and the implicit curve, at the point P.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Vec2d
        """
        return _IntCurve.IntCurve_IConicTool_GradDistance(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param IT:
        	:type IT: IntCurve_IConicTool
        	:rtype: None
        :param E:
        	:type E: gp_Elips2d
        	:rtype: None
        :param L:
        	:type L: gp_Lin2d
        	:rtype: None
        :param C:
        	:type C: gp_Circ2d
        	:rtype: None
        :param P:
        	:type P: gp_Parab2d
        	:rtype: None
        :param H:
        	:type H: gp_Hypr2d
        	:rtype: None
        """
        _IntCurve.IntCurve_IConicTool_swiginit(self, _IntCurve.new_IntCurve_IConicTool(*args))

    def Value(self, *args) -> "gp_Pnt2d":
        """
        :param X:
        	:type X: float
        	:rtype: gp_Pnt2d
        """
        return _IntCurve.IntCurve_IConicTool_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurve.delete_IntCurve_IConicTool
IntCurve_IConicTool.D1 = new_instancemethod(_IntCurve.IntCurve_IConicTool_D1, None, IntCurve_IConicTool)
IntCurve_IConicTool.D2 = new_instancemethod(_IntCurve.IntCurve_IConicTool_D2, None, IntCurve_IConicTool)
IntCurve_IConicTool.Distance = new_instancemethod(_IntCurve.IntCurve_IConicTool_Distance, None, IntCurve_IConicTool)
IntCurve_IConicTool.FindParameter = new_instancemethod(_IntCurve.IntCurve_IConicTool_FindParameter, None, IntCurve_IConicTool)
IntCurve_IConicTool.GradDistance = new_instancemethod(_IntCurve.IntCurve_IConicTool_GradDistance, None, IntCurve_IConicTool)
IntCurve_IConicTool.Value = new_instancemethod(_IntCurve.IntCurve_IConicTool_Value, None, IntCurve_IConicTool)
IntCurve_IConicTool_swigregister = _IntCurve.IntCurve_IConicTool_swigregister
IntCurve_IConicTool_swigregister(IntCurve_IConicTool)

class IntCurve_IntConicConic(OCC.Core.IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty Constructor
        	:rtype: None
        * Intersection between 2 lines from gp.
        	:param L1:
        	:type L1: gp_Lin2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param L2:
        	:type L2: gp_Lin2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and a circle. The exception ConstructionError is raised if the method IsClosed of the domain of the circle returns False.
        	:param L:
        	:type L: gp_Lin2d
        	:param DL:
        	:type DL: IntRes2d_Domain
        	:param C:
        	:type C: gp_Circ2d
        	:param DC:
        	:type DC: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and an ellipse. The exception ConstructionError is raised if the method IsClosed of the domain of the ellipse returns False.
        	:param L:
        	:type L: gp_Lin2d
        	:param DL:
        	:type DL: IntRes2d_Domain
        	:param E:
        	:type E: gp_Elips2d
        	:param DE:
        	:type DE: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and a parabola from gp.
        	:param L:
        	:type L: gp_Lin2d
        	:param DL:
        	:type DL: IntRes2d_Domain
        	:param P:
        	:type P: gp_Parab2d
        	:param DP:
        	:type DP: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and an hyperbola.
        	:param L:
        	:type L: gp_Lin2d
        	:param DL:
        	:type DL: IntRes2d_Domain
        	:param H:
        	:type H: gp_Hypr2d
        	:param DH:
        	:type DH: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 circles from gp. The exception ConstructionError is raised if the method IsClosed of one of the domain returns False.
        	:param C1:
        	:type C1: gp_Circ2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param C2:
        	:type C2: gp_Circ2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a circle and an ellipse. The exception ConstructionError is raised if the method IsClosed of one the domain returns False.
        	:param C:
        	:type C: gp_Circ2d
        	:param DC:
        	:type DC: IntRes2d_Domain
        	:param E:
        	:type E: gp_Elips2d
        	:param DE:
        	:type DE: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a circle and a parabola. The exception ConstructionError is raised if the method IsClosed of the domain of the circle returns False.
        	:param C:
        	:type C: gp_Circ2d
        	:param DC:
        	:type DC: IntRes2d_Domain
        	:param P:
        	:type P: gp_Parab2d
        	:param DP:
        	:type DP: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a circle and an hyperbola. The exception ConstructionError is raised if the method IsClosed of the domain of the circle returns False.
        	:param C:
        	:type C: gp_Circ2d
        	:param DC:
        	:type DC: IntRes2d_Domain
        	:param H:
        	:type H: gp_Hypr2d
        	:param DH:
        	:type DH: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 ellipses. The exception ConstructionError is raised if the method IsClosed of one of the domain returns False.
        	:param E1:
        	:type E1: gp_Elips2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param E2:
        	:type E2: gp_Elips2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between an ellipse and a parabola. The exception ConstructionError is raised if the method IsClosed of the domain of the ellipse returns False.
        	:param E:
        	:type E: gp_Elips2d
        	:param DE:
        	:type DE: IntRes2d_Domain
        	:param P:
        	:type P: gp_Parab2d
        	:param DP:
        	:type DP: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between an ellipse and an hyperbola. The exception ConstructionError is raised if the method IsClosed of the domain of the ellipse returns False.
        	:param E:
        	:type E: gp_Elips2d
        	:param DE:
        	:type DE: IntRes2d_Domain
        	:param H:
        	:type H: gp_Hypr2d
        	:param DH:
        	:type DH: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 parabolas.
        	:param P1:
        	:type P1: gp_Parab2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param P2:
        	:type P2: gp_Parab2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a parabola and an hyperbola.
        	:param P:
        	:type P: gp_Parab2d
        	:param DP:
        	:type DP: IntRes2d_Domain
        	:param H:
        	:type H: gp_Hypr2d
        	:param DH:
        	:type DH: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 hyperbolas.
        	:param H1:
        	:type H1: gp_Hypr2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param H2:
        	:type H2: gp_Hypr2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _IntCurve.IntCurve_IntConicConic_swiginit(self, _IntCurve.new_IntCurve_IntConicConic(*args))

    def Perform(self, *args) -> "void":
        """
        * Intersection between 2 lines from gp.
        	:param L1:
        	:type L1: gp_Lin2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param L2:
        	:type L2: gp_Lin2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and a circle. The exception ConstructionError is raised if the method IsClosed of the domain of the circle returns False.
        	:param L:
        	:type L: gp_Lin2d
        	:param DL:
        	:type DL: IntRes2d_Domain
        	:param C:
        	:type C: gp_Circ2d
        	:param DC:
        	:type DC: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and an ellipse. The exception ConstructionError is raised if the method IsClosed of the domain of the ellipse returns False.
        	:param L:
        	:type L: gp_Lin2d
        	:param DL:
        	:type DL: IntRes2d_Domain
        	:param E:
        	:type E: gp_Elips2d
        	:param DE:
        	:type DE: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and a parabola from gp.
        	:param L:
        	:type L: gp_Lin2d
        	:param DL:
        	:type DL: IntRes2d_Domain
        	:param P:
        	:type P: gp_Parab2d
        	:param DP:
        	:type DP: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and an hyperbola.
        	:param L:
        	:type L: gp_Lin2d
        	:param DL:
        	:type DL: IntRes2d_Domain
        	:param H:
        	:type H: gp_Hypr2d
        	:param DH:
        	:type DH: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 circles from gp. The exception ConstructionError is raised if the method IsClosed of the domain of one of the circle returns False.
        	:param C1:
        	:type C1: gp_Circ2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param C2:
        	:type C2: gp_Circ2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a circle and an ellipse. The exception ConstructionError is raised if the method IsClosed of one the domain returns False.
        	:param C:
        	:type C: gp_Circ2d
        	:param DC:
        	:type DC: IntRes2d_Domain
        	:param E:
        	:type E: gp_Elips2d
        	:param DE:
        	:type DE: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a circle and a parabola. The exception ConstructionError is raised if the method IsClosed of the domain of the circle returns False.
        	:param C:
        	:type C: gp_Circ2d
        	:param DC:
        	:type DC: IntRes2d_Domain
        	:param P:
        	:type P: gp_Parab2d
        	:param DP:
        	:type DP: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a circle and an hyperbola. The exception ConstructionError is raised if the method IsClosed of the domain of the circle returns False.
        	:param C:
        	:type C: gp_Circ2d
        	:param DC:
        	:type DC: IntRes2d_Domain
        	:param H:
        	:type H: gp_Hypr2d
        	:param DH:
        	:type DH: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 ellipses. The exception ConstructionError is raised if the method IsClosed of one of the domain returns False.
        	:param E1:
        	:type E1: gp_Elips2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param E2:
        	:type E2: gp_Elips2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between an ellipse and a parabola. The exception ConstructionError is raised if the method IsClosed of the domain of the ellipse returns False.
        	:param E:
        	:type E: gp_Elips2d
        	:param DE:
        	:type DE: IntRes2d_Domain
        	:param P:
        	:type P: gp_Parab2d
        	:param DP:
        	:type DP: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between an ellipse and an hyperbola. The exception ConstructionError is raised if the method IsClosed of the domain of the ellipse returns False.
        	:param E:
        	:type E: gp_Elips2d
        	:param DE:
        	:type DE: IntRes2d_Domain
        	:param H:
        	:type H: gp_Hypr2d
        	:param DH:
        	:type DH: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 parabolas.
        	:param P1:
        	:type P1: gp_Parab2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param P2:
        	:type P2: gp_Parab2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a parabola and an hyperbola.
        	:param P:
        	:type P: gp_Parab2d
        	:param DP:
        	:type DP: IntRes2d_Domain
        	:param H:
        	:type H: gp_Hypr2d
        	:param DH:
        	:type DH: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 hyperbolas.
        	:param H1:
        	:type H1: gp_Hypr2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param H2:
        	:type H2: gp_Hypr2d
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntCurve.IntCurve_IntConicConic_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurve.delete_IntCurve_IntConicConic
IntCurve_IntConicConic.Perform = new_instancemethod(_IntCurve.IntCurve_IntConicConic_Perform, None, IntCurve_IntConicConic)
IntCurve_IntConicConic_swigregister = _IntCurve.IntCurve_IntConicConic_swigregister
IntCurve_IntConicConic_swigregister(IntCurve_IntConicConic)

class IntCurve_IntImpConicParConic(OCC.Core.IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def And_Domaine_Objet1_Intersections(self, *args) -> "void":
        """
        :param TheImpTool:
        	:type TheImpTool: IntCurve_IConicTool
        	:param TheParCurve:
        	:type TheParCurve: IntCurve_PConic
        	:param TheImpCurveDomain:
        	:type TheImpCurveDomain: IntRes2d_Domain
        	:param TheParCurveDomain:
        	:type TheParCurveDomain: IntRes2d_Domain
        	:param NbResultats:
        	:type NbResultats: int
        	:param Inter2_And_Domain2:
        	:type Inter2_And_Domain2: TColStd_Array1OfReal
        	:param Inter1:
        	:type Inter1: TColStd_Array1OfReal
        	:param Resultat1:
        	:type Resultat1: TColStd_Array1OfReal
        	:param Resultat2:
        	:type Resultat2: TColStd_Array1OfReal
        	:param EpsNul:
        	:type EpsNul: float
        	:rtype: None
        """
        return _IntCurve.IntCurve_IntImpConicParConic_And_Domaine_Objet1_Intersections(self, *args)


    def FindU(self, *args) -> "Standard_Real":
        """
        :param parameter:
        	:type parameter: float
        	:param point:
        	:type point: gp_Pnt2d
        	:param TheParCurev:
        	:type TheParCurev: IntCurve_PConic
        	:param TheImpTool:
        	:type TheImpTool: IntCurve_IConicTool
        	:rtype: float
        """
        return _IntCurve.IntCurve_IntImpConicParConic_FindU(self, *args)


    def FindV(self, *args) -> "Standard_Real":
        """
        :param parameter:
        	:type parameter: float
        	:param point:
        	:type point: gp_Pnt2d
        	:param TheImpTool:
        	:type TheImpTool: IntCurve_IConicTool
        	:param ParCurve:
        	:type ParCurve: IntCurve_PConic
        	:param TheParCurveDomain:
        	:type TheParCurveDomain: IntRes2d_Domain
        	:param V0:
        	:type V0: float
        	:param V1:
        	:type V1: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: float
        """
        return _IntCurve.IntCurve_IntImpConicParConic_FindV(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Intersection between an implicit curve and a parametrised curve. The exception ConstructionError is raised if the domain of the parametrised curve does not verify HasFirstPoint and HasLastPoint return True.
        	:param ITool:
        	:type ITool: IntCurve_IConicTool
        	:param Dom1:
        	:type Dom1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: IntCurve_PConic
        	:param Dom2:
        	:type Dom2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _IntCurve.IntCurve_IntImpConicParConic_swiginit(self, _IntCurve.new_IntCurve_IntImpConicParConic(*args))

    def Perform(self, *args) -> "void":
        """
        * Intersection between an implicit curve and a parametrised curve. The exception ConstructionError is raised if the domain of the parametrised curve does not verify HasFirstPoint and HasLastPoint return True.
        	:param ITool:
        	:type ITool: IntCurve_IConicTool
        	:param Dom1:
        	:type Dom1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: IntCurve_PConic
        	:param Dom2:
        	:type Dom2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntCurve.IntCurve_IntImpConicParConic_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurve.delete_IntCurve_IntImpConicParConic
IntCurve_IntImpConicParConic.And_Domaine_Objet1_Intersections = new_instancemethod(_IntCurve.IntCurve_IntImpConicParConic_And_Domaine_Objet1_Intersections, None, IntCurve_IntImpConicParConic)
IntCurve_IntImpConicParConic.FindU = new_instancemethod(_IntCurve.IntCurve_IntImpConicParConic_FindU, None, IntCurve_IntImpConicParConic)
IntCurve_IntImpConicParConic.FindV = new_instancemethod(_IntCurve.IntCurve_IntImpConicParConic_FindV, None, IntCurve_IntImpConicParConic)
IntCurve_IntImpConicParConic.Perform = new_instancemethod(_IntCurve.IntCurve_IntImpConicParConic_Perform, None, IntCurve_IntImpConicParConic)
IntCurve_IntImpConicParConic_swigregister = _IntCurve.IntCurve_IntImpConicParConic_swigregister
IntCurve_IntImpConicParConic_swigregister(IntCurve_IntImpConicParConic)

class IntCurve_MyImpParToolOfIntImpConicParConic(OCC.Core.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor of the class.
        	:param IT:
        	:type IT: IntCurve_IConicTool
        	:param PC:
        	:type PC: IntCurve_PConic
        	:rtype: None
        """
        _IntCurve.IntCurve_MyImpParToolOfIntImpConicParConic_swiginit(self, _IntCurve.new_IntCurve_MyImpParToolOfIntImpConicParConic(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurve.delete_IntCurve_MyImpParToolOfIntImpConicParConic
IntCurve_MyImpParToolOfIntImpConicParConic_swigregister = _IntCurve.IntCurve_MyImpParToolOfIntImpConicParConic_swigregister
IntCurve_MyImpParToolOfIntImpConicParConic_swigregister(IntCurve_MyImpParToolOfIntImpConicParConic)

class IntCurve_PConic(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Accuracy(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _IntCurve.IntCurve_PConic_Accuracy(self, *args)


    def Axis2(self, *args) -> "gp_Ax22d const":
        """:rtype: gp_Ax22d"""
        return _IntCurve.IntCurve_PConic_Axis2(self, *args)


    def EpsX(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntCurve.IntCurve_PConic_EpsX(self, *args)


    def __init__(self, *args):
        """
        :param PC:
        	:type PC: IntCurve_PConic
        	:rtype: None
        :param E:
        	:type E: gp_Elips2d
        	:rtype: None
        :param C:
        	:type C: gp_Circ2d
        	:rtype: None
        :param P:
        	:type P: gp_Parab2d
        	:rtype: None
        :param H:
        	:type H: gp_Hypr2d
        	:rtype: None
        :param L:
        	:type L: gp_Lin2d
        	:rtype: None
        """
        _IntCurve.IntCurve_PConic_swiginit(self, _IntCurve.new_IntCurve_PConic(*args))

    def Param1(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntCurve.IntCurve_PConic_Param1(self, *args)


    def Param2(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntCurve.IntCurve_PConic_Param2(self, *args)


    def SetAccuracy(self, *args) -> "void":
        """
        * Accuracy is the number of samples used to approximate the parametric curve on its domain.
        	:param Nb:
        	:type Nb: int
        	:rtype: None
        """
        return _IntCurve.IntCurve_PConic_SetAccuracy(self, *args)


    def SetEpsX(self, *args) -> "void":
        """
        * EpsX is a internal tolerance used in math algorithms, usually about 1e-10 (See FunctionAllRoots for more details)
        	:param EpsDist:
        	:type EpsDist: float
        	:rtype: None
        """
        return _IntCurve.IntCurve_PConic_SetEpsX(self, *args)


    def TypeCurve(self, *args) -> "GeomAbs_CurveType":
        """
        * The Conics are manipulated as objects which only depend on three parameters : Axis and two Real from Standards. Type Curve is used to select the correct Conic.
        	:rtype: GeomAbs_CurveType
        """
        return _IntCurve.IntCurve_PConic_TypeCurve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurve.delete_IntCurve_PConic
IntCurve_PConic.Accuracy = new_instancemethod(_IntCurve.IntCurve_PConic_Accuracy, None, IntCurve_PConic)
IntCurve_PConic.Axis2 = new_instancemethod(_IntCurve.IntCurve_PConic_Axis2, None, IntCurve_PConic)
IntCurve_PConic.EpsX = new_instancemethod(_IntCurve.IntCurve_PConic_EpsX, None, IntCurve_PConic)
IntCurve_PConic.Param1 = new_instancemethod(_IntCurve.IntCurve_PConic_Param1, None, IntCurve_PConic)
IntCurve_PConic.Param2 = new_instancemethod(_IntCurve.IntCurve_PConic_Param2, None, IntCurve_PConic)
IntCurve_PConic.SetAccuracy = new_instancemethod(_IntCurve.IntCurve_PConic_SetAccuracy, None, IntCurve_PConic)
IntCurve_PConic.SetEpsX = new_instancemethod(_IntCurve.IntCurve_PConic_SetEpsX, None, IntCurve_PConic)
IntCurve_PConic.TypeCurve = new_instancemethod(_IntCurve.IntCurve_PConic_TypeCurve, None, IntCurve_PConic)
IntCurve_PConic_swigregister = _IntCurve.IntCurve_PConic_swigregister
IntCurve_PConic_swigregister(IntCurve_PConic)

class IntCurve_PConicTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def D1(*args) -> "void":
        """
        :param C:
        	:type C: IntCurve_PConic
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param T:
        	:type T: gp_Vec2d
        	:rtype: void
        """
        return _IntCurve.IntCurve_PConicTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        :param C:
        	:type C: IntCurve_PConic
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param T:
        	:type T: gp_Vec2d
        	:param N:
        	:type N: gp_Vec2d
        	:rtype: void
        """
        return _IntCurve.IntCurve_PConicTool_D2(*args)

    D2 = staticmethod(D2)

    def EpsX(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: IntCurve_PConic
        	:rtype: float
        """
        return _IntCurve.IntCurve_PConicTool_EpsX(*args)

    EpsX = staticmethod(EpsX)

    def NbSamples(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: IntCurve_PConic
        	:rtype: int
        :param C:
        	:type C: IntCurve_PConic
        	:param U0:
        	:type U0: float
        	:param U1:
        	:type U1: float
        	:rtype: int
        """
        return _IntCurve.IntCurve_PConicTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Value(*args) -> "gp_Pnt2d":
        """
        :param C:
        	:type C: IntCurve_PConic
        	:param X:
        	:type X: float
        	:rtype: gp_Pnt2d
        """
        return _IntCurve.IntCurve_PConicTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _IntCurve.IntCurve_PConicTool_swiginit(self, _IntCurve.new_IntCurve_PConicTool())
    __swig_destroy__ = _IntCurve.delete_IntCurve_PConicTool
IntCurve_PConicTool_swigregister = _IntCurve.IntCurve_PConicTool_swigregister
IntCurve_PConicTool_swigregister(IntCurve_PConicTool)

def IntCurve_PConicTool_D1(*args) -> "void":
    """
    :param C:
    	:type C: IntCurve_PConic
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param T:
    	:type T: gp_Vec2d
    	:rtype: void
    """
    return _IntCurve.IntCurve_PConicTool_D1(*args)

def IntCurve_PConicTool_D2(*args) -> "void":
    """
    :param C:
    	:type C: IntCurve_PConic
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param T:
    	:type T: gp_Vec2d
    	:param N:
    	:type N: gp_Vec2d
    	:rtype: void
    """
    return _IntCurve.IntCurve_PConicTool_D2(*args)

def IntCurve_PConicTool_EpsX(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: IntCurve_PConic
    	:rtype: float
    """
    return _IntCurve.IntCurve_PConicTool_EpsX(*args)

def IntCurve_PConicTool_NbSamples(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: IntCurve_PConic
    	:rtype: int
    :param C:
    	:type C: IntCurve_PConic
    	:param U0:
    	:type U0: float
    	:param U1:
    	:type U1: float
    	:rtype: int
    """
    return _IntCurve.IntCurve_PConicTool_NbSamples(*args)

def IntCurve_PConicTool_Value(*args) -> "gp_Pnt2d":
    """
    :param C:
    	:type C: IntCurve_PConic
    	:param X:
    	:type X: float
    	:rtype: gp_Pnt2d
    """
    return _IntCurve.IntCurve_PConicTool_Value(*args)

class IntCurve_ProjectOnPConicTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FindParameter(*args) -> "Standard_Real":
        """
        * Returns the parameter V of the point on the parametric curve corresponding to the Point Pnt. The Correspondance between Pnt and the point P(V) on the parametric curve must be coherent with the way of determination of the signed distance between a point and the implicit curve. Tol is the tolerance on the distance between a point and the parametrised curve. In that case, no bounds are given. The research of the rigth parameter has to be made on the natural parametric domain of the curve.
        	:param C:
        	:type C: IntCurve_PConic
        	:param Pnt:
        	:type Pnt: gp_Pnt2d
        	:param Tol:
        	:type Tol: float
        	:rtype: float
        * Returns the parameter V of the point on the parametric curve corresponding to the Point Pnt. The Correspondance between Pnt and the point P(V) on the parametric curve must be coherent with the way of determination of the signed distance between a point and the implicit curve. Tol is the tolerance on the distance between a point and the parametrised curve. LowParameter and HighParameter give the boundaries of the interval in wich the parameter certainly lies. These parameters are given to implement a more efficient algoritm. So, it is not necessary to check that the returned value verifies LowParameter <= Value <= HighParameter.
        	:param C:
        	:type C: IntCurve_PConic
        	:param Pnt:
        	:type Pnt: gp_Pnt2d
        	:param LowParameter:
        	:type LowParameter: float
        	:param HighParameter:
        	:type HighParameter: float
        	:param Tol:
        	:type Tol: float
        	:rtype: float
        """
        return _IntCurve.IntCurve_ProjectOnPConicTool_FindParameter(*args)

    FindParameter = staticmethod(FindParameter)

    __repr__ = _dumps_object


    def __init__(self):
        _IntCurve.IntCurve_ProjectOnPConicTool_swiginit(self, _IntCurve.new_IntCurve_ProjectOnPConicTool())
    __swig_destroy__ = _IntCurve.delete_IntCurve_ProjectOnPConicTool
IntCurve_ProjectOnPConicTool_swigregister = _IntCurve.IntCurve_ProjectOnPConicTool_swigregister
IntCurve_ProjectOnPConicTool_swigregister(IntCurve_ProjectOnPConicTool)

def IntCurve_ProjectOnPConicTool_FindParameter(*args) -> "Standard_Real":
    """
    * Returns the parameter V of the point on the parametric curve corresponding to the Point Pnt. The Correspondance between Pnt and the point P(V) on the parametric curve must be coherent with the way of determination of the signed distance between a point and the implicit curve. Tol is the tolerance on the distance between a point and the parametrised curve. In that case, no bounds are given. The research of the rigth parameter has to be made on the natural parametric domain of the curve.
    	:param C:
    	:type C: IntCurve_PConic
    	:param Pnt:
    	:type Pnt: gp_Pnt2d
    	:param Tol:
    	:type Tol: float
    	:rtype: float
    * Returns the parameter V of the point on the parametric curve corresponding to the Point Pnt. The Correspondance between Pnt and the point P(V) on the parametric curve must be coherent with the way of determination of the signed distance between a point and the implicit curve. Tol is the tolerance on the distance between a point and the parametrised curve. LowParameter and HighParameter give the boundaries of the interval in wich the parameter certainly lies. These parameters are given to implement a more efficient algoritm. So, it is not necessary to check that the returned value verifies LowParameter <= Value <= HighParameter.
    	:param C:
    	:type C: IntCurve_PConic
    	:param Pnt:
    	:type Pnt: gp_Pnt2d
    	:param LowParameter:
    	:type LowParameter: float
    	:param HighParameter:
    	:type HighParameter: float
    	:param Tol:
    	:type Tol: float
    	:rtype: float
    """
    return _IntCurve.IntCurve_ProjectOnPConicTool_FindParameter(*args)



