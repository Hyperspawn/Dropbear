# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
MAT module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_mat.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _MAT.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_MAT')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_MAT')
    _MAT = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_MAT', [dirname(__file__)])
        except ImportError:
            import _MAT
            return _MAT
        try:
            _mod = imp.load_module('_MAT', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _MAT = swig_import_helper()
    del swig_import_helper
else:
    import _MAT
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _MAT.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_MAT.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_MAT.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_MAT.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_MAT.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_MAT.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_MAT.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_MAT.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_MAT.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_MAT.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_MAT.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_MAT.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_MAT.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_MAT.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_MAT.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_MAT.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_MAT.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _MAT.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _MAT.process_exception(error, method_name, class_name)
process_exception = _MAT.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
MAT_Left = _MAT.MAT_Left
MAT_Right = _MAT.MAT_Right

def Handle_MAT_Arc_Create() -> "opencascade::handle< MAT_Arc >":
    return _MAT.Handle_MAT_Arc_Create()
Handle_MAT_Arc_Create = _MAT.Handle_MAT_Arc_Create

def Handle_MAT_Arc_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Arc >":
    return _MAT.Handle_MAT_Arc_DownCast(t)
Handle_MAT_Arc_DownCast = _MAT.Handle_MAT_Arc_DownCast

def Handle_MAT_Arc_IsNull(t: 'opencascade::handle< MAT_Arc > const &') -> "bool":
    return _MAT.Handle_MAT_Arc_IsNull(t)
Handle_MAT_Arc_IsNull = _MAT.Handle_MAT_Arc_IsNull

def Handle_MAT_BasicElt_Create() -> "opencascade::handle< MAT_BasicElt >":
    return _MAT.Handle_MAT_BasicElt_Create()
Handle_MAT_BasicElt_Create = _MAT.Handle_MAT_BasicElt_Create

def Handle_MAT_BasicElt_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_BasicElt >":
    return _MAT.Handle_MAT_BasicElt_DownCast(t)
Handle_MAT_BasicElt_DownCast = _MAT.Handle_MAT_BasicElt_DownCast

def Handle_MAT_BasicElt_IsNull(t: 'opencascade::handle< MAT_BasicElt > const &') -> "bool":
    return _MAT.Handle_MAT_BasicElt_IsNull(t)
Handle_MAT_BasicElt_IsNull = _MAT.Handle_MAT_BasicElt_IsNull

def Handle_MAT_Bisector_Create() -> "opencascade::handle< MAT_Bisector >":
    return _MAT.Handle_MAT_Bisector_Create()
Handle_MAT_Bisector_Create = _MAT.Handle_MAT_Bisector_Create

def Handle_MAT_Bisector_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Bisector >":
    return _MAT.Handle_MAT_Bisector_DownCast(t)
Handle_MAT_Bisector_DownCast = _MAT.Handle_MAT_Bisector_DownCast

def Handle_MAT_Bisector_IsNull(t: 'opencascade::handle< MAT_Bisector > const &') -> "bool":
    return _MAT.Handle_MAT_Bisector_IsNull(t)
Handle_MAT_Bisector_IsNull = _MAT.Handle_MAT_Bisector_IsNull

def Handle_MAT_Edge_Create() -> "opencascade::handle< MAT_Edge >":
    return _MAT.Handle_MAT_Edge_Create()
Handle_MAT_Edge_Create = _MAT.Handle_MAT_Edge_Create

def Handle_MAT_Edge_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Edge >":
    return _MAT.Handle_MAT_Edge_DownCast(t)
Handle_MAT_Edge_DownCast = _MAT.Handle_MAT_Edge_DownCast

def Handle_MAT_Edge_IsNull(t: 'opencascade::handle< MAT_Edge > const &') -> "bool":
    return _MAT.Handle_MAT_Edge_IsNull(t)
Handle_MAT_Edge_IsNull = _MAT.Handle_MAT_Edge_IsNull

def Handle_MAT_Graph_Create() -> "opencascade::handle< MAT_Graph >":
    return _MAT.Handle_MAT_Graph_Create()
Handle_MAT_Graph_Create = _MAT.Handle_MAT_Graph_Create

def Handle_MAT_Graph_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Graph >":
    return _MAT.Handle_MAT_Graph_DownCast(t)
Handle_MAT_Graph_DownCast = _MAT.Handle_MAT_Graph_DownCast

def Handle_MAT_Graph_IsNull(t: 'opencascade::handle< MAT_Graph > const &') -> "bool":
    return _MAT.Handle_MAT_Graph_IsNull(t)
Handle_MAT_Graph_IsNull = _MAT.Handle_MAT_Graph_IsNull

def Handle_MAT_ListOfBisector_Create() -> "opencascade::handle< MAT_ListOfBisector >":
    return _MAT.Handle_MAT_ListOfBisector_Create()
Handle_MAT_ListOfBisector_Create = _MAT.Handle_MAT_ListOfBisector_Create

def Handle_MAT_ListOfBisector_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_ListOfBisector >":
    return _MAT.Handle_MAT_ListOfBisector_DownCast(t)
Handle_MAT_ListOfBisector_DownCast = _MAT.Handle_MAT_ListOfBisector_DownCast

def Handle_MAT_ListOfBisector_IsNull(t: 'opencascade::handle< MAT_ListOfBisector > const &') -> "bool":
    return _MAT.Handle_MAT_ListOfBisector_IsNull(t)
Handle_MAT_ListOfBisector_IsNull = _MAT.Handle_MAT_ListOfBisector_IsNull

def Handle_MAT_ListOfEdge_Create() -> "opencascade::handle< MAT_ListOfEdge >":
    return _MAT.Handle_MAT_ListOfEdge_Create()
Handle_MAT_ListOfEdge_Create = _MAT.Handle_MAT_ListOfEdge_Create

def Handle_MAT_ListOfEdge_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_ListOfEdge >":
    return _MAT.Handle_MAT_ListOfEdge_DownCast(t)
Handle_MAT_ListOfEdge_DownCast = _MAT.Handle_MAT_ListOfEdge_DownCast

def Handle_MAT_ListOfEdge_IsNull(t: 'opencascade::handle< MAT_ListOfEdge > const &') -> "bool":
    return _MAT.Handle_MAT_ListOfEdge_IsNull(t)
Handle_MAT_ListOfEdge_IsNull = _MAT.Handle_MAT_ListOfEdge_IsNull

def Handle_MAT_Node_Create() -> "opencascade::handle< MAT_Node >":
    return _MAT.Handle_MAT_Node_Create()
Handle_MAT_Node_Create = _MAT.Handle_MAT_Node_Create

def Handle_MAT_Node_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Node >":
    return _MAT.Handle_MAT_Node_DownCast(t)
Handle_MAT_Node_DownCast = _MAT.Handle_MAT_Node_DownCast

def Handle_MAT_Node_IsNull(t: 'opencascade::handle< MAT_Node > const &') -> "bool":
    return _MAT.Handle_MAT_Node_IsNull(t)
Handle_MAT_Node_IsNull = _MAT.Handle_MAT_Node_IsNull

def Handle_MAT_TListNodeOfListOfBisector_Create() -> "opencascade::handle< MAT_TListNodeOfListOfBisector >":
    return _MAT.Handle_MAT_TListNodeOfListOfBisector_Create()
Handle_MAT_TListNodeOfListOfBisector_Create = _MAT.Handle_MAT_TListNodeOfListOfBisector_Create

def Handle_MAT_TListNodeOfListOfBisector_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_TListNodeOfListOfBisector >":
    return _MAT.Handle_MAT_TListNodeOfListOfBisector_DownCast(t)
Handle_MAT_TListNodeOfListOfBisector_DownCast = _MAT.Handle_MAT_TListNodeOfListOfBisector_DownCast

def Handle_MAT_TListNodeOfListOfBisector_IsNull(t: 'opencascade::handle< MAT_TListNodeOfListOfBisector > const &') -> "bool":
    return _MAT.Handle_MAT_TListNodeOfListOfBisector_IsNull(t)
Handle_MAT_TListNodeOfListOfBisector_IsNull = _MAT.Handle_MAT_TListNodeOfListOfBisector_IsNull

def Handle_MAT_TListNodeOfListOfEdge_Create() -> "opencascade::handle< MAT_TListNodeOfListOfEdge >":
    return _MAT.Handle_MAT_TListNodeOfListOfEdge_Create()
Handle_MAT_TListNodeOfListOfEdge_Create = _MAT.Handle_MAT_TListNodeOfListOfEdge_Create

def Handle_MAT_TListNodeOfListOfEdge_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_TListNodeOfListOfEdge >":
    return _MAT.Handle_MAT_TListNodeOfListOfEdge_DownCast(t)
Handle_MAT_TListNodeOfListOfEdge_DownCast = _MAT.Handle_MAT_TListNodeOfListOfEdge_DownCast

def Handle_MAT_TListNodeOfListOfEdge_IsNull(t: 'opencascade::handle< MAT_TListNodeOfListOfEdge > const &') -> "bool":
    return _MAT.Handle_MAT_TListNodeOfListOfEdge_IsNull(t)
Handle_MAT_TListNodeOfListOfEdge_IsNull = _MAT.Handle_MAT_TListNodeOfListOfEdge_IsNull

def Handle_MAT_Zone_Create() -> "opencascade::handle< MAT_Zone >":
    return _MAT.Handle_MAT_Zone_Create()
Handle_MAT_Zone_Create = _MAT.Handle_MAT_Zone_Create

def Handle_MAT_Zone_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Zone >":
    return _MAT.Handle_MAT_Zone_DownCast(t)
Handle_MAT_Zone_DownCast = _MAT.Handle_MAT_Zone_DownCast

def Handle_MAT_Zone_IsNull(t: 'opencascade::handle< MAT_Zone > const &') -> "bool":
    return _MAT.Handle_MAT_Zone_IsNull(t)
Handle_MAT_Zone_IsNull = _MAT.Handle_MAT_Zone_IsNull
class MAT_DataMapOfIntegerArc(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MAT.MAT_DataMapOfIntegerArc_swiginit(self, _MAT.new_MAT_DataMapOfIntegerArc(*args))
    __swig_destroy__ = _MAT.delete_MAT_DataMapOfIntegerArc
MAT_DataMapOfIntegerArc.begin = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_begin, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.end = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_end, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.cbegin = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_cbegin, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.cend = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_cend, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Exchange = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Exchange, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Assign = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Assign, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Set = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Set, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.ReSize = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_ReSize, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Bind = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Bind, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Bound = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Bound, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.IsBound = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_IsBound, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.UnBind = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_UnBind, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Seek = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Seek, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Find = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Find, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.ChangeSeek = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_ChangeSeek, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.ChangeFind = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_ChangeFind, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.__call__ = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc___call__, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Clear = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Clear, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Size = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Size, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc.Keys = new_instancemethod(_MAT.MAT_DataMapOfIntegerArc_Keys, None, MAT_DataMapOfIntegerArc)
MAT_DataMapOfIntegerArc_swigregister = _MAT.MAT_DataMapOfIntegerArc_swigregister
MAT_DataMapOfIntegerArc_swigregister(MAT_DataMapOfIntegerArc)

class MAT_DataMapOfIntegerBasicElt(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MAT.MAT_DataMapOfIntegerBasicElt_swiginit(self, _MAT.new_MAT_DataMapOfIntegerBasicElt(*args))
    __swig_destroy__ = _MAT.delete_MAT_DataMapOfIntegerBasicElt
MAT_DataMapOfIntegerBasicElt.begin = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_begin, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.end = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_end, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.cbegin = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_cbegin, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.cend = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_cend, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Exchange = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Exchange, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Assign = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Assign, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Set = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Set, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.ReSize = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_ReSize, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Bind = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Bind, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Bound = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Bound, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.IsBound = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_IsBound, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.UnBind = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_UnBind, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Seek = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Seek, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Find = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Find, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.ChangeSeek = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_ChangeSeek, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.ChangeFind = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_ChangeFind, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.__call__ = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt___call__, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Clear = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Clear, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Size = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Size, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt.Keys = new_instancemethod(_MAT.MAT_DataMapOfIntegerBasicElt_Keys, None, MAT_DataMapOfIntegerBasicElt)
MAT_DataMapOfIntegerBasicElt_swigregister = _MAT.MAT_DataMapOfIntegerBasicElt_swigregister
MAT_DataMapOfIntegerBasicElt_swigregister(MAT_DataMapOfIntegerBasicElt)

class MAT_SequenceOfBasicElt(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MAT.MAT_SequenceOfBasicElt_swiginit(self, _MAT.new_MAT_SequenceOfBasicElt(*args))
    delNode = staticmethod(_MAT.MAT_SequenceOfBasicElt_delNode)
    __swig_destroy__ = _MAT.delete_MAT_SequenceOfBasicElt
MAT_SequenceOfBasicElt.begin = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_begin, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.end = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_end, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.cbegin = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_cbegin, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.cend = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_cend, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Size = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Size, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Length = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Length, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Lower = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Lower, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Upper = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Upper, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.IsEmpty = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_IsEmpty, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Reverse = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Reverse, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Exchange = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Exchange, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Clear = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Clear, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Assign = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Assign, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Set = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Set, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Remove = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Remove, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Append = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Append, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Prepend = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Prepend, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.InsertBefore = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_InsertBefore, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.InsertAfter = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_InsertAfter, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Split = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Split, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.First = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_First, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.ChangeFirst = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_ChangeFirst, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Last = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Last, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.ChangeLast = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_ChangeLast, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.Value = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_Value, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.ChangeValue = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_ChangeValue, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.__call__ = new_instancemethod(_MAT.MAT_SequenceOfBasicElt___call__, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt.SetValue = new_instancemethod(_MAT.MAT_SequenceOfBasicElt_SetValue, None, MAT_SequenceOfBasicElt)
MAT_SequenceOfBasicElt_swigregister = _MAT.MAT_SequenceOfBasicElt_swigregister
MAT_SequenceOfBasicElt_swigregister(MAT_SequenceOfBasicElt)

def MAT_SequenceOfBasicElt_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _MAT.MAT_SequenceOfBasicElt_delNode(theNode, theAl)
MAT_SequenceOfBasicElt_delNode = _MAT.MAT_SequenceOfBasicElt_delNode

class MAT_DataMapOfIntegerBisector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MAT.MAT_DataMapOfIntegerBisector_swiginit(self, _MAT.new_MAT_DataMapOfIntegerBisector(*args))
    __swig_destroy__ = _MAT.delete_MAT_DataMapOfIntegerBisector
MAT_DataMapOfIntegerBisector.begin = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_begin, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.end = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_end, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.cbegin = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_cbegin, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.cend = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_cend, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Exchange = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Exchange, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Assign = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Assign, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Set = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Set, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.ReSize = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_ReSize, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Bind = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Bind, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Bound = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Bound, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.IsBound = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_IsBound, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.UnBind = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_UnBind, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Seek = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Seek, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Find = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Find, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.ChangeSeek = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_ChangeSeek, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.ChangeFind = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_ChangeFind, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.__call__ = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector___call__, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Clear = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Clear, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Size = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Size, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector.Keys = new_instancemethod(_MAT.MAT_DataMapOfIntegerBisector_Keys, None, MAT_DataMapOfIntegerBisector)
MAT_DataMapOfIntegerBisector_swigregister = _MAT.MAT_DataMapOfIntegerBisector_swigregister
MAT_DataMapOfIntegerBisector_swigregister(MAT_DataMapOfIntegerBisector)

class MAT_SequenceOfArc(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MAT.MAT_SequenceOfArc_swiginit(self, _MAT.new_MAT_SequenceOfArc(*args))
    delNode = staticmethod(_MAT.MAT_SequenceOfArc_delNode)
    __swig_destroy__ = _MAT.delete_MAT_SequenceOfArc
MAT_SequenceOfArc.begin = new_instancemethod(_MAT.MAT_SequenceOfArc_begin, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.end = new_instancemethod(_MAT.MAT_SequenceOfArc_end, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.cbegin = new_instancemethod(_MAT.MAT_SequenceOfArc_cbegin, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.cend = new_instancemethod(_MAT.MAT_SequenceOfArc_cend, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Size = new_instancemethod(_MAT.MAT_SequenceOfArc_Size, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Length = new_instancemethod(_MAT.MAT_SequenceOfArc_Length, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Lower = new_instancemethod(_MAT.MAT_SequenceOfArc_Lower, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Upper = new_instancemethod(_MAT.MAT_SequenceOfArc_Upper, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.IsEmpty = new_instancemethod(_MAT.MAT_SequenceOfArc_IsEmpty, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Reverse = new_instancemethod(_MAT.MAT_SequenceOfArc_Reverse, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Exchange = new_instancemethod(_MAT.MAT_SequenceOfArc_Exchange, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Clear = new_instancemethod(_MAT.MAT_SequenceOfArc_Clear, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Assign = new_instancemethod(_MAT.MAT_SequenceOfArc_Assign, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Set = new_instancemethod(_MAT.MAT_SequenceOfArc_Set, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Remove = new_instancemethod(_MAT.MAT_SequenceOfArc_Remove, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Append = new_instancemethod(_MAT.MAT_SequenceOfArc_Append, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Prepend = new_instancemethod(_MAT.MAT_SequenceOfArc_Prepend, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.InsertBefore = new_instancemethod(_MAT.MAT_SequenceOfArc_InsertBefore, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.InsertAfter = new_instancemethod(_MAT.MAT_SequenceOfArc_InsertAfter, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Split = new_instancemethod(_MAT.MAT_SequenceOfArc_Split, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.First = new_instancemethod(_MAT.MAT_SequenceOfArc_First, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.ChangeFirst = new_instancemethod(_MAT.MAT_SequenceOfArc_ChangeFirst, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Last = new_instancemethod(_MAT.MAT_SequenceOfArc_Last, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.ChangeLast = new_instancemethod(_MAT.MAT_SequenceOfArc_ChangeLast, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.Value = new_instancemethod(_MAT.MAT_SequenceOfArc_Value, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.ChangeValue = new_instancemethod(_MAT.MAT_SequenceOfArc_ChangeValue, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.__call__ = new_instancemethod(_MAT.MAT_SequenceOfArc___call__, None, MAT_SequenceOfArc)
MAT_SequenceOfArc.SetValue = new_instancemethod(_MAT.MAT_SequenceOfArc_SetValue, None, MAT_SequenceOfArc)
MAT_SequenceOfArc_swigregister = _MAT.MAT_SequenceOfArc_swigregister
MAT_SequenceOfArc_swigregister(MAT_SequenceOfArc)

def MAT_SequenceOfArc_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _MAT.MAT_SequenceOfArc_delNode(theNode, theAl)
MAT_SequenceOfArc_delNode = _MAT.MAT_SequenceOfArc_delNode

class MAT_DataMapOfIntegerNode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MAT.MAT_DataMapOfIntegerNode_swiginit(self, _MAT.new_MAT_DataMapOfIntegerNode(*args))
    __swig_destroy__ = _MAT.delete_MAT_DataMapOfIntegerNode
MAT_DataMapOfIntegerNode.begin = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_begin, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.end = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_end, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.cbegin = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_cbegin, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.cend = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_cend, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Exchange = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Exchange, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Assign = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Assign, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Set = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Set, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.ReSize = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_ReSize, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Bind = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Bind, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Bound = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Bound, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.IsBound = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_IsBound, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.UnBind = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_UnBind, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Seek = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Seek, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Find = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Find, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.ChangeSeek = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_ChangeSeek, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.ChangeFind = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_ChangeFind, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.__call__ = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode___call__, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Clear = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Clear, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Size = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Size, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode.Keys = new_instancemethod(_MAT.MAT_DataMapOfIntegerNode_Keys, None, MAT_DataMapOfIntegerNode)
MAT_DataMapOfIntegerNode_swigregister = _MAT.MAT_DataMapOfIntegerNode_swigregister
MAT_DataMapOfIntegerNode_swigregister(MAT_DataMapOfIntegerNode)

class MAT_Arc(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstElement(self, *args) -> "opencascade::handle< MAT_BasicElt >":
        """
        * Returns one of the BasicElt equidistant from <self>.
        	:rtype: opencascade::handle<MAT_BasicElt>
        """
        return _MAT.MAT_Arc_FirstElement(self, *args)


    def FirstNode(self, *args) -> "opencascade::handle< MAT_Node >":
        """
        * Returns one Node extremity of <self>.
        	:rtype: opencascade::handle<MAT_Node>
        """
        return _MAT.MAT_Arc_FirstNode(self, *args)


    def GeomIndex(self, *args) -> "Standard_Integer":
        """
        * Returns the index associated of the geometric representation of <self>.
        	:rtype: int
        """
        return _MAT.MAT_Arc_GeomIndex(self, *args)


    def HasNeighbour(self, *args) -> "Standard_Boolean":
        """
        * Returnst True is there is an arc linked to the Node <aNode> located on the side <aSide> of <self>; if <aNode> is not on <self>
        	:param aNode:
        	:type aNode: MAT_Node
        	:param aSide:
        	:type aSide: MAT_Side
        	:rtype: bool
        """
        return _MAT.MAT_Arc_HasNeighbour(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        * Returns the index of <self> in Graph.theArcs.
        	:rtype: int
        """
        return _MAT.MAT_Arc_Index(self, *args)


    def __init__(self, *args):
        """
        :param ArcIndex:
        	:type ArcIndex: int
        	:param GeomIndex:
        	:type GeomIndex: int
        	:param FirstElement:
        	:type FirstElement: MAT_BasicElt
        	:param SecondElement:
        	:type SecondElement: MAT_BasicElt
        	:rtype: None
        """
        _MAT.MAT_Arc_swiginit(self, _MAT.new_MAT_Arc(*args))

    def Neighbour(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        * Returns the first arc linked to the Node <aNode> located on the side <aSide> of <self>; if HasNeighbour() returns False.
        	:param aNode:
        	:type aNode: MAT_Node
        	:param aSide:
        	:type aSide: MAT_Side
        	:rtype: opencascade::handle<MAT_Arc>
        """
        return _MAT.MAT_Arc_Neighbour(self, *args)


    def SecondElement(self, *args) -> "opencascade::handle< MAT_BasicElt >":
        """
        * Returns the other BasicElt equidistant from <self>.
        	:rtype: opencascade::handle<MAT_BasicElt>
        """
        return _MAT.MAT_Arc_SecondElement(self, *args)


    def SecondNode(self, *args) -> "opencascade::handle< MAT_Node >":
        """
        * Returns the other Node extremity of <self>.
        	:rtype: opencascade::handle<MAT_Node>
        """
        return _MAT.MAT_Arc_SecondNode(self, *args)


    def SetFirstArc(self, *args) -> "void":
        """
        :param aSide:
        	:type aSide: MAT_Side
        	:param anArc:
        	:type anArc: MAT_Arc
        	:rtype: None
        """
        return _MAT.MAT_Arc_SetFirstArc(self, *args)


    def SetFirstElement(self, *args) -> "void":
        """
        :param aBasicElt:
        	:type aBasicElt: MAT_BasicElt
        	:rtype: None
        """
        return _MAT.MAT_Arc_SetFirstElement(self, *args)


    def SetFirstNode(self, *args) -> "void":
        """
        :param aNode:
        	:type aNode: MAT_Node
        	:rtype: None
        """
        return _MAT.MAT_Arc_SetFirstNode(self, *args)


    def SetGeomIndex(self, *args) -> "void":
        """
        :param anInteger:
        	:type anInteger: int
        	:rtype: None
        """
        return _MAT.MAT_Arc_SetGeomIndex(self, *args)


    def SetIndex(self, *args) -> "void":
        """
        :param anInteger:
        	:type anInteger: int
        	:rtype: None
        """
        return _MAT.MAT_Arc_SetIndex(self, *args)


    def SetNeighbour(self, *args) -> "void":
        """
        :param aSide:
        	:type aSide: MAT_Side
        	:param aNode:
        	:type aNode: MAT_Node
        	:param anArc:
        	:type anArc: MAT_Arc
        	:rtype: None
        """
        return _MAT.MAT_Arc_SetNeighbour(self, *args)


    def SetSecondArc(self, *args) -> "void":
        """
        :param aSide:
        	:type aSide: MAT_Side
        	:param anArc:
        	:type anArc: MAT_Arc
        	:rtype: None
        """
        return _MAT.MAT_Arc_SetSecondArc(self, *args)


    def SetSecondElement(self, *args) -> "void":
        """
        :param aBasicElt:
        	:type aBasicElt: MAT_BasicElt
        	:rtype: None
        """
        return _MAT.MAT_Arc_SetSecondElement(self, *args)


    def SetSecondNode(self, *args) -> "void":
        """
        :param aNode:
        	:type aNode: MAT_Node
        	:rtype: None
        """
        return _MAT.MAT_Arc_SetSecondNode(self, *args)


    def TheOtherNode(self, *args) -> "opencascade::handle< MAT_Node >":
        """
        * an Arc has two Node, if <aNode> egal one Returns the other. //! if <aNode> is not oh <self>
        	:param aNode:
        	:type aNode: MAT_Node
        	:rtype: opencascade::handle<MAT_Node>
        """
        return _MAT.MAT_Arc_TheOtherNode(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Arc_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Arc
MAT_Arc.FirstElement = new_instancemethod(_MAT.MAT_Arc_FirstElement, None, MAT_Arc)
MAT_Arc.FirstNode = new_instancemethod(_MAT.MAT_Arc_FirstNode, None, MAT_Arc)
MAT_Arc.GeomIndex = new_instancemethod(_MAT.MAT_Arc_GeomIndex, None, MAT_Arc)
MAT_Arc.HasNeighbour = new_instancemethod(_MAT.MAT_Arc_HasNeighbour, None, MAT_Arc)
MAT_Arc.Index = new_instancemethod(_MAT.MAT_Arc_Index, None, MAT_Arc)
MAT_Arc.Neighbour = new_instancemethod(_MAT.MAT_Arc_Neighbour, None, MAT_Arc)
MAT_Arc.SecondElement = new_instancemethod(_MAT.MAT_Arc_SecondElement, None, MAT_Arc)
MAT_Arc.SecondNode = new_instancemethod(_MAT.MAT_Arc_SecondNode, None, MAT_Arc)
MAT_Arc.SetFirstArc = new_instancemethod(_MAT.MAT_Arc_SetFirstArc, None, MAT_Arc)
MAT_Arc.SetFirstElement = new_instancemethod(_MAT.MAT_Arc_SetFirstElement, None, MAT_Arc)
MAT_Arc.SetFirstNode = new_instancemethod(_MAT.MAT_Arc_SetFirstNode, None, MAT_Arc)
MAT_Arc.SetGeomIndex = new_instancemethod(_MAT.MAT_Arc_SetGeomIndex, None, MAT_Arc)
MAT_Arc.SetIndex = new_instancemethod(_MAT.MAT_Arc_SetIndex, None, MAT_Arc)
MAT_Arc.SetNeighbour = new_instancemethod(_MAT.MAT_Arc_SetNeighbour, None, MAT_Arc)
MAT_Arc.SetSecondArc = new_instancemethod(_MAT.MAT_Arc_SetSecondArc, None, MAT_Arc)
MAT_Arc.SetSecondElement = new_instancemethod(_MAT.MAT_Arc_SetSecondElement, None, MAT_Arc)
MAT_Arc.SetSecondNode = new_instancemethod(_MAT.MAT_Arc_SetSecondNode, None, MAT_Arc)
MAT_Arc.TheOtherNode = new_instancemethod(_MAT.MAT_Arc_TheOtherNode, None, MAT_Arc)
MAT_Arc_swigregister = _MAT.MAT_Arc_swigregister
MAT_Arc_swigregister(MAT_Arc)

class MAT_BasicElt(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def EndArc(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        * Return <endArcLeft> or <endArcRight> corresponding to <aSide>.
        	:rtype: opencascade::handle<MAT_Arc>
        """
        return _MAT.MAT_BasicElt_EndArc(self, *args)


    def GeomIndex(self, *args) -> "Standard_Integer":
        """
        * Return the <GeomIndex> of <self>.
        	:rtype: int
        """
        return _MAT.MAT_BasicElt_GeomIndex(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        * Return the <index> of <self> in Graph.TheBasicElts.
        	:rtype: int
        """
        return _MAT.MAT_BasicElt_Index(self, *args)


    def __init__(self, *args):
        """
        * Constructor, <anInteger> is the <index> of <self>.
        	:param anInteger:
        	:type anInteger: int
        	:rtype: None
        """
        _MAT.MAT_BasicElt_swiginit(self, _MAT.new_MAT_BasicElt(*args))

    def SetEndArc(self, *args) -> "void":
        """
        :param anArc:
        	:type anArc: MAT_Arc
        	:rtype: None
        """
        return _MAT.MAT_BasicElt_SetEndArc(self, *args)


    def SetGeomIndex(self, *args) -> "void":
        """
        :param anInteger:
        	:type anInteger: int
        	:rtype: None
        """
        return _MAT.MAT_BasicElt_SetGeomIndex(self, *args)


    def SetIndex(self, *args) -> "void":
        """
        :param anInteger:
        	:type anInteger: int
        	:rtype: None
        """
        return _MAT.MAT_BasicElt_SetIndex(self, *args)


    def SetStartArc(self, *args) -> "void":
        """
        :param anArc:
        	:type anArc: MAT_Arc
        	:rtype: None
        """
        return _MAT.MAT_BasicElt_SetStartArc(self, *args)


    def StartArc(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        * Return <startArcLeft> or <startArcRight> corresponding to <aSide>.
        	:rtype: opencascade::handle<MAT_Arc>
        """
        return _MAT.MAT_BasicElt_StartArc(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_BasicElt_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_BasicElt
MAT_BasicElt.EndArc = new_instancemethod(_MAT.MAT_BasicElt_EndArc, None, MAT_BasicElt)
MAT_BasicElt.GeomIndex = new_instancemethod(_MAT.MAT_BasicElt_GeomIndex, None, MAT_BasicElt)
MAT_BasicElt.Index = new_instancemethod(_MAT.MAT_BasicElt_Index, None, MAT_BasicElt)
MAT_BasicElt.SetEndArc = new_instancemethod(_MAT.MAT_BasicElt_SetEndArc, None, MAT_BasicElt)
MAT_BasicElt.SetGeomIndex = new_instancemethod(_MAT.MAT_BasicElt_SetGeomIndex, None, MAT_BasicElt)
MAT_BasicElt.SetIndex = new_instancemethod(_MAT.MAT_BasicElt_SetIndex, None, MAT_BasicElt)
MAT_BasicElt.SetStartArc = new_instancemethod(_MAT.MAT_BasicElt_SetStartArc, None, MAT_BasicElt)
MAT_BasicElt.StartArc = new_instancemethod(_MAT.MAT_BasicElt_StartArc, None, MAT_BasicElt)
MAT_BasicElt_swigregister = _MAT.MAT_BasicElt_swigregister
MAT_BasicElt_swigregister(MAT_BasicElt)

class MAT_Bisector(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddBisector(self, *args) -> "void":
        """
        :param abisector:
        	:type abisector: MAT_Bisector
        	:rtype: None
        """
        return _MAT.MAT_Bisector_AddBisector(self, *args)


    def BisectorNumber(self, *args) -> "Standard_Integer":
        """
        :param anumber:
        	:type anumber: int
        	:rtype: None
        :rtype: int
        """
        return _MAT.MAT_Bisector_BisectorNumber(self, *args)


    def DistIssuePoint(self, *args) -> "Standard_Real":
        """
        :param areal:
        	:type areal: float
        	:rtype: None
        :rtype: float
        """
        return _MAT.MAT_Bisector_DistIssuePoint(self, *args)


    def Dump(self, *args) -> "void":
        """
        :param ashift:
        	:type ashift: int
        	:param alevel:
        	:type alevel: int
        	:rtype: None
        """
        return _MAT.MAT_Bisector_Dump(self, *args)


    def EndPoint(self, *args) -> "Standard_Integer":
        """
        :param apoint:
        	:type apoint: int
        	:rtype: None
        :rtype: int
        """
        return _MAT.MAT_Bisector_EndPoint(self, *args)


    def FirstBisector(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """:rtype: opencascade::handle<MAT_Bisector>"""
        return _MAT.MAT_Bisector_FirstBisector(self, *args)


    def FirstEdge(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        :param anedge:
        	:type anedge: MAT_Edge
        	:rtype: None
        :rtype: opencascade::handle<MAT_Edge>
        """
        return _MAT.MAT_Bisector_FirstEdge(self, *args)


    def FirstParameter(self, *args) -> "Standard_Real":
        """
        :param aparameter:
        	:type aparameter: float
        	:rtype: None
        :rtype: float
        """
        return _MAT.MAT_Bisector_FirstParameter(self, *args)


    def FirstVector(self, *args) -> "Standard_Integer":
        """
        :param avector:
        	:type avector: int
        	:rtype: None
        :rtype: int
        """
        return _MAT.MAT_Bisector_FirstVector(self, *args)


    def IndexNumber(self, *args) -> "Standard_Integer":
        """
        :param anumber:
        	:type anumber: int
        	:rtype: None
        :rtype: int
        """
        return _MAT.MAT_Bisector_IndexNumber(self, *args)


    def IssuePoint(self, *args) -> "Standard_Integer":
        """
        :param apoint:
        	:type apoint: int
        	:rtype: None
        :rtype: int
        """
        return _MAT.MAT_Bisector_IssuePoint(self, *args)


    def LastBisector(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """:rtype: opencascade::handle<MAT_Bisector>"""
        return _MAT.MAT_Bisector_LastBisector(self, *args)


    def List(self, *args) -> "opencascade::handle< MAT_ListOfBisector >":
        """:rtype: opencascade::handle<MAT_ListOfBisector>"""
        return _MAT.MAT_Bisector_List(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _MAT.MAT_Bisector_swiginit(self, _MAT.new_MAT_Bisector(*args))

    def SecondEdge(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        :param anedge:
        	:type anedge: MAT_Edge
        	:rtype: None
        :rtype: opencascade::handle<MAT_Edge>
        """
        return _MAT.MAT_Bisector_SecondEdge(self, *args)


    def SecondParameter(self, *args) -> "Standard_Real":
        """
        :param aparameter:
        	:type aparameter: float
        	:rtype: None
        :rtype: float
        """
        return _MAT.MAT_Bisector_SecondParameter(self, *args)


    def SecondVector(self, *args) -> "Standard_Integer":
        """
        :param avector:
        	:type avector: int
        	:rtype: None
        :rtype: int
        """
        return _MAT.MAT_Bisector_SecondVector(self, *args)


    def Sense(self, *args) -> "Standard_Real":
        """
        :param asense:
        	:type asense: float
        	:rtype: None
        :rtype: float
        """
        return _MAT.MAT_Bisector_Sense(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Bisector_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Bisector
MAT_Bisector.AddBisector = new_instancemethod(_MAT.MAT_Bisector_AddBisector, None, MAT_Bisector)
MAT_Bisector.BisectorNumber = new_instancemethod(_MAT.MAT_Bisector_BisectorNumber, None, MAT_Bisector)
MAT_Bisector.DistIssuePoint = new_instancemethod(_MAT.MAT_Bisector_DistIssuePoint, None, MAT_Bisector)
MAT_Bisector.Dump = new_instancemethod(_MAT.MAT_Bisector_Dump, None, MAT_Bisector)
MAT_Bisector.EndPoint = new_instancemethod(_MAT.MAT_Bisector_EndPoint, None, MAT_Bisector)
MAT_Bisector.FirstBisector = new_instancemethod(_MAT.MAT_Bisector_FirstBisector, None, MAT_Bisector)
MAT_Bisector.FirstEdge = new_instancemethod(_MAT.MAT_Bisector_FirstEdge, None, MAT_Bisector)
MAT_Bisector.FirstParameter = new_instancemethod(_MAT.MAT_Bisector_FirstParameter, None, MAT_Bisector)
MAT_Bisector.FirstVector = new_instancemethod(_MAT.MAT_Bisector_FirstVector, None, MAT_Bisector)
MAT_Bisector.IndexNumber = new_instancemethod(_MAT.MAT_Bisector_IndexNumber, None, MAT_Bisector)
MAT_Bisector.IssuePoint = new_instancemethod(_MAT.MAT_Bisector_IssuePoint, None, MAT_Bisector)
MAT_Bisector.LastBisector = new_instancemethod(_MAT.MAT_Bisector_LastBisector, None, MAT_Bisector)
MAT_Bisector.List = new_instancemethod(_MAT.MAT_Bisector_List, None, MAT_Bisector)
MAT_Bisector.SecondEdge = new_instancemethod(_MAT.MAT_Bisector_SecondEdge, None, MAT_Bisector)
MAT_Bisector.SecondParameter = new_instancemethod(_MAT.MAT_Bisector_SecondParameter, None, MAT_Bisector)
MAT_Bisector.SecondVector = new_instancemethod(_MAT.MAT_Bisector_SecondVector, None, MAT_Bisector)
MAT_Bisector.Sense = new_instancemethod(_MAT.MAT_Bisector_Sense, None, MAT_Bisector)
MAT_Bisector_swigregister = _MAT.MAT_Bisector_swigregister
MAT_Bisector_swigregister(MAT_Bisector)

class MAT_Edge(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Distance(self, *args) -> "Standard_Real":
        """
        :param adistance:
        	:type adistance: float
        	:rtype: None
        :rtype: float
        """
        return _MAT.MAT_Edge_Distance(self, *args)


    def Dump(self, *args) -> "void":
        """
        :param ashift:
        	:type ashift: int
        	:param alevel:
        	:type alevel: int
        	:rtype: None
        """
        return _MAT.MAT_Edge_Dump(self, *args)


    def EdgeNumber(self, *args) -> "Standard_Integer":
        """
        :param anumber:
        	:type anumber: int
        	:rtype: None
        :rtype: int
        """
        return _MAT.MAT_Edge_EdgeNumber(self, *args)


    def FirstBisector(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        :param abisector:
        	:type abisector: MAT_Bisector
        	:rtype: None
        :rtype: opencascade::handle<MAT_Bisector>
        """
        return _MAT.MAT_Edge_FirstBisector(self, *args)


    def IntersectionPoint(self, *args) -> "Standard_Integer":
        """
        :param apoint:
        	:type apoint: int
        	:rtype: None
        :rtype: int
        """
        return _MAT.MAT_Edge_IntersectionPoint(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _MAT.MAT_Edge_swiginit(self, _MAT.new_MAT_Edge(*args))

    def SecondBisector(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        :param abisector:
        	:type abisector: MAT_Bisector
        	:rtype: None
        :rtype: opencascade::handle<MAT_Bisector>
        """
        return _MAT.MAT_Edge_SecondBisector(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Edge_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Edge
MAT_Edge.Distance = new_instancemethod(_MAT.MAT_Edge_Distance, None, MAT_Edge)
MAT_Edge.Dump = new_instancemethod(_MAT.MAT_Edge_Dump, None, MAT_Edge)
MAT_Edge.EdgeNumber = new_instancemethod(_MAT.MAT_Edge_EdgeNumber, None, MAT_Edge)
MAT_Edge.FirstBisector = new_instancemethod(_MAT.MAT_Edge_FirstBisector, None, MAT_Edge)
MAT_Edge.IntersectionPoint = new_instancemethod(_MAT.MAT_Edge_IntersectionPoint, None, MAT_Edge)
MAT_Edge.SecondBisector = new_instancemethod(_MAT.MAT_Edge_SecondBisector, None, MAT_Edge)
MAT_Edge_swigregister = _MAT.MAT_Edge_swigregister
MAT_Edge_swigregister(MAT_Edge)

class MAT_Graph(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Arc(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        * Return the Arc of index <Index> in <theArcs>.
        	:param Index:
        	:type Index: int
        	:rtype: opencascade::handle<MAT_Arc>
        """
        return _MAT.MAT_Graph_Arc(self, *args)


    def BasicElt(self, *args) -> "opencascade::handle< MAT_BasicElt >":
        """
        * Return the BasicElt of index <Index> in <theBasicElts>.
        	:param Index:
        	:type Index: int
        	:rtype: opencascade::handle<MAT_BasicElt>
        """
        return _MAT.MAT_Graph_BasicElt(self, *args)


    def ChangeBasicElt(self, *args) -> "opencascade::handle< MAT_BasicElt >":
        """
        :param Index:
        	:type Index: int
        	:rtype: opencascade::handle<MAT_BasicElt>
        """
        return _MAT.MAT_Graph_ChangeBasicElt(self, *args)


    def ChangeBasicElts(self, *args) -> "void":
        """
        :param NewMap:
        	:type NewMap: MAT_DataMapOfIntegerBasicElt
        	:rtype: None
        """
        return _MAT.MAT_Graph_ChangeBasicElts(self, *args)


    def CompactArcs(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_Graph_CompactArcs(self, *args)


    def CompactNodes(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_Graph_CompactNodes(self, *args)


    def FusionOfBasicElts(self, *args) -> "void":
        """
        * Merge two BasicElts. The End of the BasicElt Elt1 of IndexElt1 becomes The End of the BasicElt Elt2 of IndexElt2. Elt2 is replaced in the arcs by Elt1, Elt2 is eliminated. //! <MergeArc1> is True if the fusion of the BasicElts => a fusion of two Arcs which separated the same elements. In this case <GeomIndexArc1> and <GeomIndexArc2> are the Geometric Index of this arcs. //! If the BasicElt corresponds to a close line , the StartArc and the EndArc of Elt1 can separate the same elements . In this case there is a fusion of this arcs, <MergeArc2> is true and <GeomIndexArc3> and <GeomIndexArc4> are the Geometric Index of this arcs.
        	:param IndexElt1:
        	:type IndexElt1: int
        	:param IndexElt2:
        	:type IndexElt2: int
        	:param MergeArc1:
        	:type MergeArc1: bool
        	:param GeomIndexArc1:
        	:type GeomIndexArc1: int
        	:param GeomIndexArc2:
        	:type GeomIndexArc2: int
        	:param MergeArc2:
        	:type MergeArc2: bool
        	:param GeomIndexArc3:
        	:type GeomIndexArc3: int
        	:param GeomIndexArc4:
        	:type GeomIndexArc4: int
        	:rtype: None
        """
        return _MAT.MAT_Graph_FusionOfBasicElts(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        """
        _MAT.MAT_Graph_swiginit(self, _MAT.new_MAT_Graph(*args))

    def Node(self, *args) -> "opencascade::handle< MAT_Node >":
        """
        * Return the Node of index <Index> in <theNodes>.
        	:param Index:
        	:type Index: int
        	:rtype: opencascade::handle<MAT_Node>
        """
        return _MAT.MAT_Graph_Node(self, *args)


    def NumberOfArcs(self, *args) -> "Standard_Integer":
        """
        * Return the number of arcs of <self>.
        	:rtype: int
        """
        return _MAT.MAT_Graph_NumberOfArcs(self, *args)


    def NumberOfBasicElts(self, *args) -> "Standard_Integer":
        """
        * Return the number of basic elements of <self>.
        	:rtype: int
        """
        return _MAT.MAT_Graph_NumberOfBasicElts(self, *args)


    def NumberOfInfiniteNodes(self, *args) -> "Standard_Integer":
        """
        * Return the number of infinites nodes of <self>.
        	:rtype: int
        """
        return _MAT.MAT_Graph_NumberOfInfiniteNodes(self, *args)


    def NumberOfNodes(self, *args) -> "Standard_Integer":
        """
        * Return the number of nodes of <self>.
        	:rtype: int
        """
        return _MAT.MAT_Graph_NumberOfNodes(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Construct <self> from the result of the method <CreateMat> of the class <MAT> from <MAT>. //! <SemiInfinite> : if some bisector are infinites. <TheRoots> : Set of the bisectors. <NbBasicElts> : Number of Basic Elements. <NbArcs> : Number of Arcs = Number of Bisectors.
        	:param SemiInfinite:
        	:type SemiInfinite: bool
        	:param TheRoots:
        	:type TheRoots: MAT_ListOfBisector
        	:param NbBasicElts:
        	:type NbBasicElts: int
        	:param NbArcs:
        	:type NbArcs: int
        	:rtype: None
        """
        return _MAT.MAT_Graph_Perform(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Graph_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Graph
MAT_Graph.Arc = new_instancemethod(_MAT.MAT_Graph_Arc, None, MAT_Graph)
MAT_Graph.BasicElt = new_instancemethod(_MAT.MAT_Graph_BasicElt, None, MAT_Graph)
MAT_Graph.ChangeBasicElt = new_instancemethod(_MAT.MAT_Graph_ChangeBasicElt, None, MAT_Graph)
MAT_Graph.ChangeBasicElts = new_instancemethod(_MAT.MAT_Graph_ChangeBasicElts, None, MAT_Graph)
MAT_Graph.CompactArcs = new_instancemethod(_MAT.MAT_Graph_CompactArcs, None, MAT_Graph)
MAT_Graph.CompactNodes = new_instancemethod(_MAT.MAT_Graph_CompactNodes, None, MAT_Graph)
MAT_Graph.FusionOfBasicElts = new_instancemethod(_MAT.MAT_Graph_FusionOfBasicElts, None, MAT_Graph)
MAT_Graph.Node = new_instancemethod(_MAT.MAT_Graph_Node, None, MAT_Graph)
MAT_Graph.NumberOfArcs = new_instancemethod(_MAT.MAT_Graph_NumberOfArcs, None, MAT_Graph)
MAT_Graph.NumberOfBasicElts = new_instancemethod(_MAT.MAT_Graph_NumberOfBasicElts, None, MAT_Graph)
MAT_Graph.NumberOfInfiniteNodes = new_instancemethod(_MAT.MAT_Graph_NumberOfInfiniteNodes, None, MAT_Graph)
MAT_Graph.NumberOfNodes = new_instancemethod(_MAT.MAT_Graph_NumberOfNodes, None, MAT_Graph)
MAT_Graph.Perform = new_instancemethod(_MAT.MAT_Graph_Perform, None, MAT_Graph)
MAT_Graph_swigregister = _MAT.MAT_Graph_swigregister
MAT_Graph_swigregister(MAT_Graph)

class MAT_ListOfBisector(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BackAdd(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Bisector
        	:rtype: None
        """
        return _MAT.MAT_ListOfBisector_BackAdd(self, *args)


    def Brackets(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        :param anindex:
        	:type anindex: int
        	:rtype: opencascade::handle<MAT_Bisector>
        """
        return _MAT.MAT_ListOfBisector_Brackets(self, *args)


    def Current(self, *args) -> "void":
        """
        :rtype: opencascade::handle<MAT_Bisector>
        :param anitem:
        	:type anitem: MAT_Bisector
        	:rtype: None
        """
        return _MAT.MAT_ListOfBisector_Current(self, *args)


    def Dump(self, *args) -> "void":
        """
        :param ashift:
        	:type ashift: int
        	:param alevel:
        	:type alevel: int
        	:rtype: None
        """
        return _MAT.MAT_ListOfBisector_Dump(self, *args)


    def First(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfBisector_First(self, *args)


    def FirstItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """:rtype: opencascade::handle<MAT_Bisector>"""
        return _MAT.MAT_ListOfBisector_FirstItem(self, *args)


    def FrontAdd(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Bisector
        	:rtype: None
        """
        return _MAT.MAT_ListOfBisector_FrontAdd(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _MAT.MAT_ListOfBisector_Index(self, *args)


    def Init(self, *args) -> "void":
        """
        :param aniten:
        	:type aniten: MAT_Bisector
        	:rtype: None
        """
        return _MAT.MAT_ListOfBisector_Init(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _MAT.MAT_ListOfBisector_IsEmpty(self, *args)


    def Last(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfBisector_Last(self, *args)


    def LastItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """:rtype: opencascade::handle<MAT_Bisector>"""
        return _MAT.MAT_ListOfBisector_LastItem(self, *args)


    def LinkAfter(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Bisector
        	:rtype: None
        """
        return _MAT.MAT_ListOfBisector_LinkAfter(self, *args)


    def LinkBefore(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Bisector
        	:rtype: None
        """
        return _MAT.MAT_ListOfBisector_LinkBefore(self, *args)


    def Loop(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfBisector_Loop(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _MAT.MAT_ListOfBisector_swiginit(self, _MAT.new_MAT_ListOfBisector(*args))

    def More(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _MAT.MAT_ListOfBisector_More(self, *args)


    def Next(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfBisector_Next(self, *args)


    def NextItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """:rtype: opencascade::handle<MAT_Bisector>"""
        return _MAT.MAT_ListOfBisector_NextItem(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _MAT.MAT_ListOfBisector_Number(self, *args)


    def Permute(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfBisector_Permute(self, *args)


    def Previous(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfBisector_Previous(self, *args)


    def PreviousItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """:rtype: opencascade::handle<MAT_Bisector>"""
        return _MAT.MAT_ListOfBisector_PreviousItem(self, *args)


    def Unlink(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfBisector_Unlink(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_ListOfBisector_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_ListOfBisector
MAT_ListOfBisector.BackAdd = new_instancemethod(_MAT.MAT_ListOfBisector_BackAdd, None, MAT_ListOfBisector)
MAT_ListOfBisector.Brackets = new_instancemethod(_MAT.MAT_ListOfBisector_Brackets, None, MAT_ListOfBisector)
MAT_ListOfBisector.Current = new_instancemethod(_MAT.MAT_ListOfBisector_Current, None, MAT_ListOfBisector)
MAT_ListOfBisector.Dump = new_instancemethod(_MAT.MAT_ListOfBisector_Dump, None, MAT_ListOfBisector)
MAT_ListOfBisector.First = new_instancemethod(_MAT.MAT_ListOfBisector_First, None, MAT_ListOfBisector)
MAT_ListOfBisector.FirstItem = new_instancemethod(_MAT.MAT_ListOfBisector_FirstItem, None, MAT_ListOfBisector)
MAT_ListOfBisector.FrontAdd = new_instancemethod(_MAT.MAT_ListOfBisector_FrontAdd, None, MAT_ListOfBisector)
MAT_ListOfBisector.Index = new_instancemethod(_MAT.MAT_ListOfBisector_Index, None, MAT_ListOfBisector)
MAT_ListOfBisector.Init = new_instancemethod(_MAT.MAT_ListOfBisector_Init, None, MAT_ListOfBisector)
MAT_ListOfBisector.IsEmpty = new_instancemethod(_MAT.MAT_ListOfBisector_IsEmpty, None, MAT_ListOfBisector)
MAT_ListOfBisector.Last = new_instancemethod(_MAT.MAT_ListOfBisector_Last, None, MAT_ListOfBisector)
MAT_ListOfBisector.LastItem = new_instancemethod(_MAT.MAT_ListOfBisector_LastItem, None, MAT_ListOfBisector)
MAT_ListOfBisector.LinkAfter = new_instancemethod(_MAT.MAT_ListOfBisector_LinkAfter, None, MAT_ListOfBisector)
MAT_ListOfBisector.LinkBefore = new_instancemethod(_MAT.MAT_ListOfBisector_LinkBefore, None, MAT_ListOfBisector)
MAT_ListOfBisector.Loop = new_instancemethod(_MAT.MAT_ListOfBisector_Loop, None, MAT_ListOfBisector)
MAT_ListOfBisector.More = new_instancemethod(_MAT.MAT_ListOfBisector_More, None, MAT_ListOfBisector)
MAT_ListOfBisector.Next = new_instancemethod(_MAT.MAT_ListOfBisector_Next, None, MAT_ListOfBisector)
MAT_ListOfBisector.NextItem = new_instancemethod(_MAT.MAT_ListOfBisector_NextItem, None, MAT_ListOfBisector)
MAT_ListOfBisector.Number = new_instancemethod(_MAT.MAT_ListOfBisector_Number, None, MAT_ListOfBisector)
MAT_ListOfBisector.Permute = new_instancemethod(_MAT.MAT_ListOfBisector_Permute, None, MAT_ListOfBisector)
MAT_ListOfBisector.Previous = new_instancemethod(_MAT.MAT_ListOfBisector_Previous, None, MAT_ListOfBisector)
MAT_ListOfBisector.PreviousItem = new_instancemethod(_MAT.MAT_ListOfBisector_PreviousItem, None, MAT_ListOfBisector)
MAT_ListOfBisector.Unlink = new_instancemethod(_MAT.MAT_ListOfBisector_Unlink, None, MAT_ListOfBisector)
MAT_ListOfBisector_swigregister = _MAT.MAT_ListOfBisector_swigregister
MAT_ListOfBisector_swigregister(MAT_ListOfBisector)

class MAT_ListOfEdge(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BackAdd(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Edge
        	:rtype: None
        """
        return _MAT.MAT_ListOfEdge_BackAdd(self, *args)


    def Brackets(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        :param anindex:
        	:type anindex: int
        	:rtype: opencascade::handle<MAT_Edge>
        """
        return _MAT.MAT_ListOfEdge_Brackets(self, *args)


    def Current(self, *args) -> "void":
        """
        :rtype: opencascade::handle<MAT_Edge>
        :param anitem:
        	:type anitem: MAT_Edge
        	:rtype: None
        """
        return _MAT.MAT_ListOfEdge_Current(self, *args)


    def Dump(self, *args) -> "void":
        """
        :param ashift:
        	:type ashift: int
        	:param alevel:
        	:type alevel: int
        	:rtype: None
        """
        return _MAT.MAT_ListOfEdge_Dump(self, *args)


    def First(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfEdge_First(self, *args)


    def FirstItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """:rtype: opencascade::handle<MAT_Edge>"""
        return _MAT.MAT_ListOfEdge_FirstItem(self, *args)


    def FrontAdd(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Edge
        	:rtype: None
        """
        return _MAT.MAT_ListOfEdge_FrontAdd(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _MAT.MAT_ListOfEdge_Index(self, *args)


    def Init(self, *args) -> "void":
        """
        :param aniten:
        	:type aniten: MAT_Edge
        	:rtype: None
        """
        return _MAT.MAT_ListOfEdge_Init(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _MAT.MAT_ListOfEdge_IsEmpty(self, *args)


    def Last(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfEdge_Last(self, *args)


    def LastItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """:rtype: opencascade::handle<MAT_Edge>"""
        return _MAT.MAT_ListOfEdge_LastItem(self, *args)


    def LinkAfter(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Edge
        	:rtype: None
        """
        return _MAT.MAT_ListOfEdge_LinkAfter(self, *args)


    def LinkBefore(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Edge
        	:rtype: None
        """
        return _MAT.MAT_ListOfEdge_LinkBefore(self, *args)


    def Loop(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfEdge_Loop(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _MAT.MAT_ListOfEdge_swiginit(self, _MAT.new_MAT_ListOfEdge(*args))

    def More(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _MAT.MAT_ListOfEdge_More(self, *args)


    def Next(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfEdge_Next(self, *args)


    def NextItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """:rtype: opencascade::handle<MAT_Edge>"""
        return _MAT.MAT_ListOfEdge_NextItem(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _MAT.MAT_ListOfEdge_Number(self, *args)


    def Permute(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfEdge_Permute(self, *args)


    def Previous(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfEdge_Previous(self, *args)


    def PreviousItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """:rtype: opencascade::handle<MAT_Edge>"""
        return _MAT.MAT_ListOfEdge_PreviousItem(self, *args)


    def Unlink(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_ListOfEdge_Unlink(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_ListOfEdge_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_ListOfEdge
MAT_ListOfEdge.BackAdd = new_instancemethod(_MAT.MAT_ListOfEdge_BackAdd, None, MAT_ListOfEdge)
MAT_ListOfEdge.Brackets = new_instancemethod(_MAT.MAT_ListOfEdge_Brackets, None, MAT_ListOfEdge)
MAT_ListOfEdge.Current = new_instancemethod(_MAT.MAT_ListOfEdge_Current, None, MAT_ListOfEdge)
MAT_ListOfEdge.Dump = new_instancemethod(_MAT.MAT_ListOfEdge_Dump, None, MAT_ListOfEdge)
MAT_ListOfEdge.First = new_instancemethod(_MAT.MAT_ListOfEdge_First, None, MAT_ListOfEdge)
MAT_ListOfEdge.FirstItem = new_instancemethod(_MAT.MAT_ListOfEdge_FirstItem, None, MAT_ListOfEdge)
MAT_ListOfEdge.FrontAdd = new_instancemethod(_MAT.MAT_ListOfEdge_FrontAdd, None, MAT_ListOfEdge)
MAT_ListOfEdge.Index = new_instancemethod(_MAT.MAT_ListOfEdge_Index, None, MAT_ListOfEdge)
MAT_ListOfEdge.Init = new_instancemethod(_MAT.MAT_ListOfEdge_Init, None, MAT_ListOfEdge)
MAT_ListOfEdge.IsEmpty = new_instancemethod(_MAT.MAT_ListOfEdge_IsEmpty, None, MAT_ListOfEdge)
MAT_ListOfEdge.Last = new_instancemethod(_MAT.MAT_ListOfEdge_Last, None, MAT_ListOfEdge)
MAT_ListOfEdge.LastItem = new_instancemethod(_MAT.MAT_ListOfEdge_LastItem, None, MAT_ListOfEdge)
MAT_ListOfEdge.LinkAfter = new_instancemethod(_MAT.MAT_ListOfEdge_LinkAfter, None, MAT_ListOfEdge)
MAT_ListOfEdge.LinkBefore = new_instancemethod(_MAT.MAT_ListOfEdge_LinkBefore, None, MAT_ListOfEdge)
MAT_ListOfEdge.Loop = new_instancemethod(_MAT.MAT_ListOfEdge_Loop, None, MAT_ListOfEdge)
MAT_ListOfEdge.More = new_instancemethod(_MAT.MAT_ListOfEdge_More, None, MAT_ListOfEdge)
MAT_ListOfEdge.Next = new_instancemethod(_MAT.MAT_ListOfEdge_Next, None, MAT_ListOfEdge)
MAT_ListOfEdge.NextItem = new_instancemethod(_MAT.MAT_ListOfEdge_NextItem, None, MAT_ListOfEdge)
MAT_ListOfEdge.Number = new_instancemethod(_MAT.MAT_ListOfEdge_Number, None, MAT_ListOfEdge)
MAT_ListOfEdge.Permute = new_instancemethod(_MAT.MAT_ListOfEdge_Permute, None, MAT_ListOfEdge)
MAT_ListOfEdge.Previous = new_instancemethod(_MAT.MAT_ListOfEdge_Previous, None, MAT_ListOfEdge)
MAT_ListOfEdge.PreviousItem = new_instancemethod(_MAT.MAT_ListOfEdge_PreviousItem, None, MAT_ListOfEdge)
MAT_ListOfEdge.Unlink = new_instancemethod(_MAT.MAT_ListOfEdge_Unlink, None, MAT_ListOfEdge)
MAT_ListOfEdge_swigregister = _MAT.MAT_ListOfEdge_swigregister
MAT_ListOfEdge_swigregister(MAT_ListOfEdge)

class MAT_Node(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Distance(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _MAT.MAT_Node_Distance(self, *args)


    def GeomIndex(self, *args) -> "Standard_Integer":
        """
        * Returns the index associated of the geometric representation of <self>.
        	:rtype: int
        """
        return _MAT.MAT_Node_GeomIndex(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        * Returns the index associated of the node
        	:rtype: int
        """
        return _MAT.MAT_Node_Index(self, *args)


    def Infinite(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the distance of <self> is Infinite
        	:rtype: bool
        """
        return _MAT.MAT_Node_Infinite(self, *args)


    def LinkedArcs(self, *args) -> "void":
        """
        * Returns in <S> the Arcs linked to <self>.
        	:param S:
        	:type S: MAT_SequenceOfArc
        	:rtype: None
        """
        return _MAT.MAT_Node_LinkedArcs(self, *args)


    def __init__(self, *args):
        """
        :param GeomIndex:
        	:type GeomIndex: int
        	:param LinkedArc:
        	:type LinkedArc: MAT_Arc
        	:param Distance:
        	:type Distance: float
        	:rtype: None
        """
        _MAT.MAT_Node_swiginit(self, _MAT.new_MAT_Node(*args))

    def NearElts(self, *args) -> "void":
        """
        * Returns in <S> the BasicElts equidistant to <self>.
        	:param S:
        	:type S: MAT_SequenceOfBasicElt
        	:rtype: None
        """
        return _MAT.MAT_Node_NearElts(self, *args)


    def OnBasicElt(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <self> belongs to the figure.
        	:rtype: bool
        """
        return _MAT.MAT_Node_OnBasicElt(self, *args)


    def PendingNode(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <self> is a pending Node. (ie : the number of Arc Linked = 1)
        	:rtype: bool
        """
        return _MAT.MAT_Node_PendingNode(self, *args)


    def SetIndex(self, *args) -> "void":
        """
        * Set the index associated of the node
        	:param anIndex:
        	:type anIndex: int
        	:rtype: None
        """
        return _MAT.MAT_Node_SetIndex(self, *args)


    def SetLinkedArc(self, *args) -> "void":
        """
        :param anArc:
        	:type anArc: MAT_Arc
        	:rtype: None
        """
        return _MAT.MAT_Node_SetLinkedArc(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Node_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Node
MAT_Node.Distance = new_instancemethod(_MAT.MAT_Node_Distance, None, MAT_Node)
MAT_Node.GeomIndex = new_instancemethod(_MAT.MAT_Node_GeomIndex, None, MAT_Node)
MAT_Node.Index = new_instancemethod(_MAT.MAT_Node_Index, None, MAT_Node)
MAT_Node.Infinite = new_instancemethod(_MAT.MAT_Node_Infinite, None, MAT_Node)
MAT_Node.LinkedArcs = new_instancemethod(_MAT.MAT_Node_LinkedArcs, None, MAT_Node)
MAT_Node.NearElts = new_instancemethod(_MAT.MAT_Node_NearElts, None, MAT_Node)
MAT_Node.OnBasicElt = new_instancemethod(_MAT.MAT_Node_OnBasicElt, None, MAT_Node)
MAT_Node.PendingNode = new_instancemethod(_MAT.MAT_Node_PendingNode, None, MAT_Node)
MAT_Node.SetIndex = new_instancemethod(_MAT.MAT_Node_SetIndex, None, MAT_Node)
MAT_Node.SetLinkedArc = new_instancemethod(_MAT.MAT_Node_SetLinkedArc, None, MAT_Node)
MAT_Node_swigregister = _MAT.MAT_Node_swigregister
MAT_Node_swigregister(MAT_Node)

class MAT_TListNodeOfListOfBisector(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dummy(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_TListNodeOfListOfBisector_Dummy(self, *args)


    def GetItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """:rtype: opencascade::handle<MAT_Bisector>"""
        return _MAT.MAT_TListNodeOfListOfBisector_GetItem(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param anitem:
        	:type anitem: MAT_Bisector
        	:rtype: None
        """
        _MAT.MAT_TListNodeOfListOfBisector_swiginit(self, _MAT.new_MAT_TListNodeOfListOfBisector(*args))

    def Next(self, *args) -> "void":
        """
        :rtype: opencascade::handle<MAT_TListNodeOfListOfBisector>
        :param atlistnode:
        	:type atlistnode: MAT_TListNodeOfListOfBisector
        	:rtype: None
        """
        return _MAT.MAT_TListNodeOfListOfBisector_Next(self, *args)


    def Previous(self, *args) -> "void":
        """
        :rtype: opencascade::handle<MAT_TListNodeOfListOfBisector>
        :param atlistnode:
        	:type atlistnode: MAT_TListNodeOfListOfBisector
        	:rtype: None
        """
        return _MAT.MAT_TListNodeOfListOfBisector_Previous(self, *args)


    def SetItem(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Bisector
        	:rtype: None
        """
        return _MAT.MAT_TListNodeOfListOfBisector_SetItem(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_TListNodeOfListOfBisector_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_TListNodeOfListOfBisector
MAT_TListNodeOfListOfBisector.Dummy = new_instancemethod(_MAT.MAT_TListNodeOfListOfBisector_Dummy, None, MAT_TListNodeOfListOfBisector)
MAT_TListNodeOfListOfBisector.GetItem = new_instancemethod(_MAT.MAT_TListNodeOfListOfBisector_GetItem, None, MAT_TListNodeOfListOfBisector)
MAT_TListNodeOfListOfBisector.Next = new_instancemethod(_MAT.MAT_TListNodeOfListOfBisector_Next, None, MAT_TListNodeOfListOfBisector)
MAT_TListNodeOfListOfBisector.Previous = new_instancemethod(_MAT.MAT_TListNodeOfListOfBisector_Previous, None, MAT_TListNodeOfListOfBisector)
MAT_TListNodeOfListOfBisector.SetItem = new_instancemethod(_MAT.MAT_TListNodeOfListOfBisector_SetItem, None, MAT_TListNodeOfListOfBisector)
MAT_TListNodeOfListOfBisector_swigregister = _MAT.MAT_TListNodeOfListOfBisector_swigregister
MAT_TListNodeOfListOfBisector_swigregister(MAT_TListNodeOfListOfBisector)

class MAT_TListNodeOfListOfEdge(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dummy(self, *args) -> "void":
        """:rtype: None"""
        return _MAT.MAT_TListNodeOfListOfEdge_Dummy(self, *args)


    def GetItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """:rtype: opencascade::handle<MAT_Edge>"""
        return _MAT.MAT_TListNodeOfListOfEdge_GetItem(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param anitem:
        	:type anitem: MAT_Edge
        	:rtype: None
        """
        _MAT.MAT_TListNodeOfListOfEdge_swiginit(self, _MAT.new_MAT_TListNodeOfListOfEdge(*args))

    def Next(self, *args) -> "void":
        """
        :rtype: opencascade::handle<MAT_TListNodeOfListOfEdge>
        :param atlistnode:
        	:type atlistnode: MAT_TListNodeOfListOfEdge
        	:rtype: None
        """
        return _MAT.MAT_TListNodeOfListOfEdge_Next(self, *args)


    def Previous(self, *args) -> "void":
        """
        :rtype: opencascade::handle<MAT_TListNodeOfListOfEdge>
        :param atlistnode:
        	:type atlistnode: MAT_TListNodeOfListOfEdge
        	:rtype: None
        """
        return _MAT.MAT_TListNodeOfListOfEdge_Previous(self, *args)


    def SetItem(self, *args) -> "void":
        """
        :param anitem:
        	:type anitem: MAT_Edge
        	:rtype: None
        """
        return _MAT.MAT_TListNodeOfListOfEdge_SetItem(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_TListNodeOfListOfEdge_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_TListNodeOfListOfEdge
MAT_TListNodeOfListOfEdge.Dummy = new_instancemethod(_MAT.MAT_TListNodeOfListOfEdge_Dummy, None, MAT_TListNodeOfListOfEdge)
MAT_TListNodeOfListOfEdge.GetItem = new_instancemethod(_MAT.MAT_TListNodeOfListOfEdge_GetItem, None, MAT_TListNodeOfListOfEdge)
MAT_TListNodeOfListOfEdge.Next = new_instancemethod(_MAT.MAT_TListNodeOfListOfEdge_Next, None, MAT_TListNodeOfListOfEdge)
MAT_TListNodeOfListOfEdge.Previous = new_instancemethod(_MAT.MAT_TListNodeOfListOfEdge_Previous, None, MAT_TListNodeOfListOfEdge)
MAT_TListNodeOfListOfEdge.SetItem = new_instancemethod(_MAT.MAT_TListNodeOfListOfEdge_SetItem, None, MAT_TListNodeOfListOfEdge)
MAT_TListNodeOfListOfEdge_swigregister = _MAT.MAT_TListNodeOfListOfEdge_swigregister
MAT_TListNodeOfListOfEdge_swigregister(MAT_TListNodeOfListOfEdge)

class MAT_Zone(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ArcOnFrontier(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        * Return the Arc number <Index> on the frontier. of <self>.
        	:param Index:
        	:type Index: int
        	:rtype: opencascade::handle<MAT_Arc>
        """
        return _MAT.MAT_Zone_ArcOnFrontier(self, *args)


    def Limited(self, *args) -> "Standard_Boolean":
        """
        * Return True if <self> is Limited.
        	:rtype: bool
        """
        return _MAT.MAT_Zone_Limited(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        * Compute the frontier of the Zone of proximity.
        	:param aBasicElt:
        	:type aBasicElt: MAT_BasicElt
        	:rtype: None
        """
        _MAT.MAT_Zone_swiginit(self, _MAT.new_MAT_Zone(*args))

    def NoEmptyZone(self, *args) -> "Standard_Boolean":
        """
        * Return True if <self> is not empty .
        	:rtype: bool
        """
        return _MAT.MAT_Zone_NoEmptyZone(self, *args)


    def NumberOfArcs(self, *args) -> "Standard_Integer":
        """
        * Return the number Of Arcs On the frontier of <self>.
        	:rtype: int
        """
        return _MAT.MAT_Zone_NumberOfArcs(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Compute the frontier of the Zone of proximity.
        	:param aBasicElt:
        	:type aBasicElt: MAT_BasicElt
        	:rtype: None
        """
        return _MAT.MAT_Zone_Perform(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Zone_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Zone
MAT_Zone.ArcOnFrontier = new_instancemethod(_MAT.MAT_Zone_ArcOnFrontier, None, MAT_Zone)
MAT_Zone.Limited = new_instancemethod(_MAT.MAT_Zone_Limited, None, MAT_Zone)
MAT_Zone.NoEmptyZone = new_instancemethod(_MAT.MAT_Zone_NoEmptyZone, None, MAT_Zone)
MAT_Zone.NumberOfArcs = new_instancemethod(_MAT.MAT_Zone_NumberOfArcs, None, MAT_Zone)
MAT_Zone.Perform = new_instancemethod(_MAT.MAT_Zone_Perform, None, MAT_Zone)
MAT_Zone_swigregister = _MAT.MAT_Zone_swigregister
MAT_Zone_swigregister(MAT_Zone)



