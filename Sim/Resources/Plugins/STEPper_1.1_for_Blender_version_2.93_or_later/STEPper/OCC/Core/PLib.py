# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
PLib module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_plib.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _PLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_PLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_PLib')
    _PLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_PLib', [dirname(__file__)])
        except ImportError:
            import _PLib
            return _PLib
        try:
            _mod = imp.load_module('_PLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _PLib = swig_import_helper()
    del swig_import_helper
else:
    import _PLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _PLib.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_PLib.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_PLib.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_PLib.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_PLib.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_PLib.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_PLib.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_PLib.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_PLib.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_PLib.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_PLib.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_PLib.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_PLib.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_PLib.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_PLib.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_PLib.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_PLib.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _PLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _PLib.process_exception(error, method_name, class_name)
process_exception = _PLib.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.GeomAbs
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.gp

def Handle_PLib_Base_Create() -> "opencascade::handle< PLib_Base >":
    return _PLib.Handle_PLib_Base_Create()
Handle_PLib_Base_Create = _PLib.Handle_PLib_Base_Create

def Handle_PLib_Base_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< PLib_Base >":
    return _PLib.Handle_PLib_Base_DownCast(t)
Handle_PLib_Base_DownCast = _PLib.Handle_PLib_Base_DownCast

def Handle_PLib_Base_IsNull(t: 'opencascade::handle< PLib_Base > const &') -> "bool":
    return _PLib.Handle_PLib_Base_IsNull(t)
Handle_PLib_Base_IsNull = _PLib.Handle_PLib_Base_IsNull

def Handle_PLib_HermitJacobi_Create() -> "opencascade::handle< PLib_HermitJacobi >":
    return _PLib.Handle_PLib_HermitJacobi_Create()
Handle_PLib_HermitJacobi_Create = _PLib.Handle_PLib_HermitJacobi_Create

def Handle_PLib_HermitJacobi_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< PLib_HermitJacobi >":
    return _PLib.Handle_PLib_HermitJacobi_DownCast(t)
Handle_PLib_HermitJacobi_DownCast = _PLib.Handle_PLib_HermitJacobi_DownCast

def Handle_PLib_HermitJacobi_IsNull(t: 'opencascade::handle< PLib_HermitJacobi > const &') -> "bool":
    return _PLib.Handle_PLib_HermitJacobi_IsNull(t)
Handle_PLib_HermitJacobi_IsNull = _PLib.Handle_PLib_HermitJacobi_IsNull

def Handle_PLib_JacobiPolynomial_Create() -> "opencascade::handle< PLib_JacobiPolynomial >":
    return _PLib.Handle_PLib_JacobiPolynomial_Create()
Handle_PLib_JacobiPolynomial_Create = _PLib.Handle_PLib_JacobiPolynomial_Create

def Handle_PLib_JacobiPolynomial_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< PLib_JacobiPolynomial >":
    return _PLib.Handle_PLib_JacobiPolynomial_DownCast(t)
Handle_PLib_JacobiPolynomial_DownCast = _PLib.Handle_PLib_JacobiPolynomial_DownCast

def Handle_PLib_JacobiPolynomial_IsNull(t: 'opencascade::handle< PLib_JacobiPolynomial > const &') -> "bool":
    return _PLib.Handle_PLib_JacobiPolynomial_IsNull(t)
Handle_PLib_JacobiPolynomial_IsNull = _PLib.Handle_PLib_JacobiPolynomial_IsNull
class plib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bin(*args) -> "Standard_Real":
        """
        * Returns the Binomial Cnp. N should be <= BSplCLib::MaxDegree().
        	:param N:
        	:type N: int
        	:param P:
        	:type P: int
        	:rtype: float
        """
        return _PLib.plib_Bin(*args)

    Bin = staticmethod(Bin)

    def CoefficientsPoles(*args) -> "void":
        """
        :param Coefs:
        	:type Coefs: TColgp_Array1OfPnt
        	:param WCoefs:
        	:type WCoefs: TColStd_Array1OfReal *
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param WPoles:
        	:type WPoles: TColStd_Array1OfReal *
        	:rtype: void
        :param Coefs:
        	:type Coefs: TColgp_Array1OfPnt2d
        	:param WCoefs:
        	:type WCoefs: TColStd_Array1OfReal *
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param WPoles:
        	:type WPoles: TColStd_Array1OfReal *
        	:rtype: void
        :param Coefs:
        	:type Coefs: TColStd_Array1OfReal
        	:param WCoefs:
        	:type WCoefs: TColStd_Array1OfReal *
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param WPoles:
        	:type WPoles: TColStd_Array1OfReal *
        	:rtype: void
        :param dim:
        	:type dim: int
        	:param Coefs:
        	:type Coefs: TColStd_Array1OfReal
        	:param WCoefs:
        	:type WCoefs: TColStd_Array1OfReal *
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param WPoles:
        	:type WPoles: TColStd_Array1OfReal *
        	:rtype: void
        :param Coefs:
        	:type Coefs: TColgp_Array2OfPnt
        	:param WCoefs:
        	:type WCoefs: TColStd_Array2OfReal *
        	:param Poles:
        	:type Poles: TColgp_Array2OfPnt
        	:param WPoles:
        	:type WPoles: TColStd_Array2OfReal *
        	:rtype: void
        """
        return _PLib.plib_CoefficientsPoles(*args)

    CoefficientsPoles = staticmethod(CoefficientsPoles)

    def ConstraintOrder(*args) -> "GeomAbs_Shape":
        """
        * translates from Integer to GeomAbs_Shape
        	:param NivConstr:
        	:type NivConstr: int
        	:rtype: GeomAbs_Shape
        """
        return _PLib.plib_ConstraintOrder(*args)

    ConstraintOrder = staticmethod(ConstraintOrder)

    def EvalCubicHermite(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
        """
        * Performs the Cubic Hermite Interpolation of given series of points with given parameters with the requested derivative order. ValueArray stores the value at the first and last parameter. It has the following format : [0], [Dimension-1]  : value at first param [Dimension], [Dimension + Dimension-1] : value at last param Derivative array stores the value of the derivatives at the first parameter and at the last parameter in the following format [0], [Dimension-1]  : derivative at first param [Dimension], [Dimension + Dimension-1] : derivative at last param //! ParameterArray stores the first and last parameter in the following format : [0] : first parameter [1] : last parameter //! Results will store things in the following format with d = DerivativeOrder //! [0], [Dimension-1]  : value [Dimension], [Dimension + Dimension-1] : first derivative //! [d *Dimension], [d*Dimension + Dimension-1]: dth derivative
        	:param U:
        	:type U: float
        	:param DerivativeOrder:
        	:type DerivativeOrder: int
        	:param Dimension:
        	:type Dimension: int
        	:param ValueArray:
        	:type ValueArray: float
        	:param DerivativeArray:
        	:type DerivativeArray: float
        	:param ParameterArray:
        	:type ParameterArray: float
        	:param Results:
        	:type Results: float
        	:rtype: int
        """
        return _PLib.plib_EvalCubicHermite(*args)

    EvalCubicHermite = staticmethod(EvalCubicHermite)

    def EvalLagrange(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        * Performs the Lagrange Interpolation of given series of points with given parameters with the requested derivative order Results will store things in the following format with d = DerivativeOrder //! [0], [Dimension-1]  : value [Dimension], [Dimension + Dimension-1] : first derivative //! [d *Dimension], [d*Dimension + Dimension-1]: dth derivative
        	:param U:
        	:type U: float
        	:param DerivativeOrder:
        	:type DerivativeOrder: int
        	:param Degree:
        	:type Degree: int
        	:param Dimension:
        	:type Dimension: int
        	:param ValueArray:
        	:type ValueArray: float
        	:param ParameterArray:
        	:type ParameterArray: float
        	:param Results:
        	:type Results: float
        	:rtype: int
        """
        return _PLib.plib_EvalLagrange(*args)

    EvalLagrange = staticmethod(EvalLagrange)

    def EvalLength(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        :param Degree:
        	:type Degree: int
        	:param Dimension:
        	:type Dimension: int
        	:param PolynomialCoeff:
        	:type PolynomialCoeff: float
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Length:
        	:type Length: float
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param Dimension:
        	:type Dimension: int
        	:param PolynomialCoeff:
        	:type PolynomialCoeff: float
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Tol:
        	:type Tol: float
        	:param Length:
        	:type Length: float
        	:param Error:
        	:type Error: float
        	:rtype: void
        """
        return _PLib.plib_EvalLength(*args)

    EvalLength = staticmethod(EvalLength)

    def EvalPoly2Var(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Applies EvalPolynomial twice to evaluate the derivative of orders UDerivativeOrder in U, VDerivativeOrder in V at parameters U,V //! PolynomialCoeff are stored in the following fashion c00(1) .... c00(Dimension) c10(1) .... c10(Dimension) .... cm0(1) .... cm0(Dimension) .... c01(1) .... c01(Dimension) c11(1) .... c11(Dimension) .... cm1(1) .... cm1(Dimension) .... c0n(1) .... c0n(Dimension) c1n(1) .... c1n(Dimension) .... cmn(1) .... cmn(Dimension) //! where the polynomial is defined as : 2  m c00 + c10 U + c20 U + .... + cm0 U 2  m + c01 V + c11 UV + c21 U V + .... + cm1 U V n m n + .... + c0n V + .... + cmn U V //! with m = UDegree and n = VDegree //! Results stores the result in the following format //! f(1) f(2) .... f(Dimension) //! Warning: <Results> and <PolynomialCoeff> must be dimensioned properly
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param UDerivativeOrder:
        	:type UDerivativeOrder: int
        	:param VDerivativeOrder:
        	:type VDerivativeOrder: int
        	:param UDegree:
        	:type UDegree: int
        	:param VDegree:
        	:type VDegree: int
        	:param Dimension:
        	:type Dimension: int
        	:param PolynomialCoeff:
        	:type PolynomialCoeff: float
        	:param Results:
        	:type Results: float
        	:rtype: void
        """
        return _PLib.plib_EvalPoly2Var(*args)

    EvalPoly2Var = staticmethod(EvalPoly2Var)

    def EvalPolynomial(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Performs Horner method with synthethic division for derivatives parameter <U>, with <Degree> and <Dimension>. PolynomialCoeff are stored in the following fashion c0(1) c0(2) .... c0(Dimension) c1(1) c1(2) .... c1(Dimension) //! cDegree(1) cDegree(2) .... cDegree(Dimension) where the polynomial is defined as : //! 2 Degree c0 + c1 X + c2 X + .... cDegree X //! Results stores the result in the following format //! f(1) f(2) .... f(Dimension) (1)  (1)  (1) f (1) f (2) .... f (Dimension) //! (DerivativeRequest) (DerivativeRequest) f (1)  f (Dimension) //! this just evaluates the point at parameter U //! Warning: <Results> and <PolynomialCoeff> must be dimensioned properly
        	:param U:
        	:type U: float
        	:param DerivativeOrder:
        	:type DerivativeOrder: int
        	:param Degree:
        	:type Degree: int
        	:param Dimension:
        	:type Dimension: int
        	:param PolynomialCoeff:
        	:type PolynomialCoeff: float
        	:param Results:
        	:type Results: float
        	:rtype: void
        """
        return _PLib.plib_EvalPolynomial(*args)

    EvalPolynomial = staticmethod(EvalPolynomial)

    def GetPoles(*args) -> "void":
        """
        * Get from FP the coordinates of the poles.
        	:param FP:
        	:type FP: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:rtype: void
        * Get from FP the coordinates of the poles.
        	:param FP:
        	:type FP: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:rtype: void
        * Get from FP the coordinates of the poles.
        	:param FP:
        	:type FP: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:rtype: void
        * Get from FP the coordinates of the poles.
        	:param FP:
        	:type FP: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:rtype: void
        """
        return _PLib.plib_GetPoles(*args)

    GetPoles = staticmethod(GetPoles)

    def HermiteCoefficients(*args) -> "Standard_Boolean":
        """
        * This build the coefficient of Hermite's polynomes on [FirstParameter, LastParameter] //! if j <= FirstOrder+1 then //! MatrixCoefs[i, j] = ith coefficient of the polynome H0,j-1 //! else //! MatrixCoefs[i, j] = ith coefficient of the polynome H1,k with k = j - FirstOrder - 2 //! return false if - |FirstParameter| > 100 - |LastParameter| > 100 - |FirstParameter| +|LastParameter| < 1/100 - |LastParameter - FirstParameter| / (|FirstParameter| +|LastParameter|) < 1/100
        	:param FirstParameter:
        	:type FirstParameter: float
        	:param LastParameter:
        	:type LastParameter: float
        	:param FirstOrder:
        	:type FirstOrder: int
        	:param LastOrder:
        	:type LastOrder: int
        	:param MatrixCoefs:
        	:type MatrixCoefs: math_Matrix
        	:rtype: bool
        """
        return _PLib.plib_HermiteCoefficients(*args)

    HermiteCoefficients = staticmethod(HermiteCoefficients)

    def HermiteInterpolate(*args) -> "Standard_Boolean":
        """
        * Compute the coefficients in the canonical base of the polynomial satisfying the given constraints at the given parameters The array FirstContr(i,j) i=1,Dimension j=0,FirstOrder contains the values of the constraint at parameter FirstParameter idem for LastConstr
        	:param Dimension:
        	:type Dimension: int
        	:param FirstParameter:
        	:type FirstParameter: float
        	:param LastParameter:
        	:type LastParameter: float
        	:param FirstOrder:
        	:type FirstOrder: int
        	:param LastOrder:
        	:type LastOrder: int
        	:param FirstConstr:
        	:type FirstConstr: TColStd_Array2OfReal
        	:param LastConstr:
        	:type LastConstr: TColStd_Array2OfReal
        	:param Coefficients:
        	:type Coefficients: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _PLib.plib_HermiteInterpolate(*args)

    HermiteInterpolate = staticmethod(HermiteInterpolate)

    def JacobiParameters(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * Compute the number of points used for integral computations (NbGaussPoints) and the degree of Jacobi Polynomial (WorkDegree). ConstraintOrder has to be GeomAbs_C0, GeomAbs_C1 or GeomAbs_C2 Code: Code d' init. des parametres de discretisation. = -5 = -4 = -3 = -2 = -1 = 1 calcul rapide avec precision moyenne. = 2 calcul rapide avec meilleure precision. = 3 calcul un peu plus lent avec bonne precision. = 4 calcul lent avec la meilleure precision possible.
        	:param ConstraintOrder:
        	:type ConstraintOrder: GeomAbs_Shape
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param Code:
        	:type Code: int
        	:param NbGaussPoints:
        	:type NbGaussPoints: int
        	:param WorkDegree:
        	:type WorkDegree: int
        	:rtype: void
        """
        return _PLib.plib_JacobiParameters(*args)

    JacobiParameters = staticmethod(JacobiParameters)

    def NivConstr(*args) -> "Standard_Integer":
        """
        * translates from GeomAbs_Shape to Integer
        	:param ConstraintOrder:
        	:type ConstraintOrder: GeomAbs_Shape
        	:rtype: int
        """
        return _PLib.plib_NivConstr(*args)

    NivConstr = staticmethod(NivConstr)

    def NoDerivativeEvalPolynomial(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Same as above with DerivativeOrder = 0;
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param Dimension:
        	:type Dimension: int
        	:param DegreeDimension:
        	:type DegreeDimension: int
        	:param PolynomialCoeff:
        	:type PolynomialCoeff: float
        	:param Results:
        	:type Results: float
        	:rtype: void
        """
        return _PLib.plib_NoDerivativeEvalPolynomial(*args)

    NoDerivativeEvalPolynomial = staticmethod(NoDerivativeEvalPolynomial)

    def NoWeights(*args) -> "TColStd_Array1OfReal *":
        """
        * Used as argument for a non rational functions
        	:rtype: inline TColStd_Array1OfReal *
        """
        return _PLib.plib_NoWeights(*args)

    NoWeights = staticmethod(NoWeights)

    def NoWeights2(*args) -> "TColStd_Array2OfReal *":
        """
        * Used as argument for a non rational functions
        	:rtype: inline TColStd_Array2OfReal *
        """
        return _PLib.plib_NoWeights2(*args)

    NoWeights2 = staticmethod(NoWeights2)

    def RationalDerivative(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Computes the derivatives of a ratio at order <N> in dimension <Dimension>. //! <Ders> is an array containing the values of the input derivatives from 0 to Min(<N>,<Degree>). For orders higher than <Degree> the inputcd /s2d1/BMDL/ derivatives are assumed to be 0. //! Content of <Ders> : //! x(1),x(2),...,x(Dimension),w x'(1),x'(2),...,x'(Dimension),w' x''(1),x''(2),...,x''(Dimension),w'' //! If <All> is false, only the derivative at order <N> is computed. <RDers> is an array of length Dimension which will contain the result : //! x(1)/w , x(2)/w , ... derivated <N> times //! If <All> is true all the derivatives up to order <N> are computed. <RDers> is an array of length Dimension * (N+1) which will contains : //! x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated <1> times x(1)/w , x(2)/w , ... derivated <2> times ... x(1)/w , x(2)/w , ... derivated <N> times //! Warning: <RDers> must be dimensionned properly.
        	:param Degree:
        	:type Degree: int
        	:param N:
        	:type N: int
        	:param Dimension:
        	:type Dimension: int
        	:param Ders:
        	:type Ders: float
        	:param RDers:
        	:type RDers: float
        	:param All: default value is Standard_True
        	:type All: bool
        	:rtype: void
        """
        return _PLib.plib_RationalDerivative(*args)

    RationalDerivative = staticmethod(RationalDerivative)

    def RationalDerivatives(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        * Computes DerivativesRequest derivatives of a ratio at of a BSpline function of degree <Degree> dimension <Dimension>. //! <PolesDerivatives> is an array containing the values of the input derivatives from 0 to <DerivativeRequest> For orders higher than <Degree> the input derivatives are assumed to be 0. //! Content of <PoleasDerivatives> : //! x(1),x(2),...,x(Dimension) x'(1),x'(2),...,x'(Dimension) x''(1),x''(2),...,x''(Dimension) //! WeightsDerivatives is an array that contains derivatives from 0 to <DerivativeRequest> After returning from the routine the array RationalDerivatives contains the following x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated once x(1)/w , x(2)/w , ... twice x(1)/w , x(2)/w , ... derivated <DerivativeRequest> times //! The array RationalDerivatives and PolesDerivatives can be same since the overwrite is non destructive within the algorithm //! Warning: <RationalDerivates> must be dimensionned properly.
        	:param DerivativesRequest:
        	:type DerivativesRequest: int
        	:param Dimension:
        	:type Dimension: int
        	:param PolesDerivatives:
        	:type PolesDerivatives: float
        	:param WeightsDerivatives:
        	:type WeightsDerivatives: float
        	:param RationalDerivates:
        	:type RationalDerivates: float
        	:rtype: void
        """
        return _PLib.plib_RationalDerivatives(*args)

    RationalDerivatives = staticmethod(RationalDerivatives)

    def SetPoles(*args) -> "void":
        """
        * Copy in FP the coordinates of the poles.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param FP:
        	:type FP: TColStd_Array1OfReal
        	:rtype: void
        * Copy in FP the coordinates of the poles.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param FP:
        	:type FP: TColStd_Array1OfReal
        	:rtype: void
        * Copy in FP the coordinates of the poles.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param FP:
        	:type FP: TColStd_Array1OfReal
        	:rtype: void
        * Copy in FP the coordinates of the poles.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param FP:
        	:type FP: TColStd_Array1OfReal
        	:rtype: void
        """
        return _PLib.plib_SetPoles(*args)

    SetPoles = staticmethod(SetPoles)

    def Trimming(*args) -> "void":
        """
        :param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Coeffs:
        	:type Coeffs: TColgp_Array1OfPnt
        	:param WCoeffs:
        	:type WCoeffs: TColStd_Array1OfReal *
        	:rtype: void
        :param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Coeffs:
        	:type Coeffs: TColgp_Array1OfPnt2d
        	:param WCoeffs:
        	:type WCoeffs: TColStd_Array1OfReal *
        	:rtype: void
        :param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Coeffs:
        	:type Coeffs: TColStd_Array1OfReal
        	:param WCoeffs:
        	:type WCoeffs: TColStd_Array1OfReal *
        	:rtype: void
        :param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param dim:
        	:type dim: int
        	:param Coeffs:
        	:type Coeffs: TColStd_Array1OfReal
        	:param WCoeffs:
        	:type WCoeffs: TColStd_Array1OfReal *
        	:rtype: void
        """
        return _PLib.plib_Trimming(*args)

    Trimming = staticmethod(Trimming)

    def UTrimming(*args) -> "void":
        """
        :param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Coeffs:
        	:type Coeffs: TColgp_Array2OfPnt
        	:param WCoeffs:
        	:type WCoeffs: TColStd_Array2OfReal *
        	:rtype: void
        """
        return _PLib.plib_UTrimming(*args)

    UTrimming = staticmethod(UTrimming)

    def VTrimming(*args) -> "void":
        """
        :param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:param Coeffs:
        	:type Coeffs: TColgp_Array2OfPnt
        	:param WCoeffs:
        	:type WCoeffs: TColStd_Array2OfReal *
        	:rtype: void
        """
        return _PLib.plib_VTrimming(*args)

    VTrimming = staticmethod(VTrimming)

    __repr__ = _dumps_object


    def __init__(self):
        _PLib.plib_swiginit(self, _PLib.new_plib())
    __swig_destroy__ = _PLib.delete_plib
plib_swigregister = _PLib.plib_swigregister
plib_swigregister(plib)

def plib_Bin(*args) -> "Standard_Real":
    """
    * Returns the Binomial Cnp. N should be <= BSplCLib::MaxDegree().
    	:param N:
    	:type N: int
    	:param P:
    	:type P: int
    	:rtype: float
    """
    return _PLib.plib_Bin(*args)

def plib_CoefficientsPoles(*args) -> "void":
    """
    :param Coefs:
    	:type Coefs: TColgp_Array1OfPnt
    	:param WCoefs:
    	:type WCoefs: TColStd_Array1OfReal *
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param WPoles:
    	:type WPoles: TColStd_Array1OfReal *
    	:rtype: void
    :param Coefs:
    	:type Coefs: TColgp_Array1OfPnt2d
    	:param WCoefs:
    	:type WCoefs: TColStd_Array1OfReal *
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param WPoles:
    	:type WPoles: TColStd_Array1OfReal *
    	:rtype: void
    :param Coefs:
    	:type Coefs: TColStd_Array1OfReal
    	:param WCoefs:
    	:type WCoefs: TColStd_Array1OfReal *
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param WPoles:
    	:type WPoles: TColStd_Array1OfReal *
    	:rtype: void
    :param dim:
    	:type dim: int
    	:param Coefs:
    	:type Coefs: TColStd_Array1OfReal
    	:param WCoefs:
    	:type WCoefs: TColStd_Array1OfReal *
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param WPoles:
    	:type WPoles: TColStd_Array1OfReal *
    	:rtype: void
    :param Coefs:
    	:type Coefs: TColgp_Array2OfPnt
    	:param WCoefs:
    	:type WCoefs: TColStd_Array2OfReal *
    	:param Poles:
    	:type Poles: TColgp_Array2OfPnt
    	:param WPoles:
    	:type WPoles: TColStd_Array2OfReal *
    	:rtype: void
    """
    return _PLib.plib_CoefficientsPoles(*args)

def plib_ConstraintOrder(*args) -> "GeomAbs_Shape":
    """
    * translates from Integer to GeomAbs_Shape
    	:param NivConstr:
    	:type NivConstr: int
    	:rtype: GeomAbs_Shape
    """
    return _PLib.plib_ConstraintOrder(*args)

def plib_EvalCubicHermite(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
    """
    * Performs the Cubic Hermite Interpolation of given series of points with given parameters with the requested derivative order. ValueArray stores the value at the first and last parameter. It has the following format : [0], [Dimension-1]  : value at first param [Dimension], [Dimension + Dimension-1] : value at last param Derivative array stores the value of the derivatives at the first parameter and at the last parameter in the following format [0], [Dimension-1]  : derivative at first param [Dimension], [Dimension + Dimension-1] : derivative at last param //! ParameterArray stores the first and last parameter in the following format : [0] : first parameter [1] : last parameter //! Results will store things in the following format with d = DerivativeOrder //! [0], [Dimension-1]  : value [Dimension], [Dimension + Dimension-1] : first derivative //! [d *Dimension], [d*Dimension + Dimension-1]: dth derivative
    	:param U:
    	:type U: float
    	:param DerivativeOrder:
    	:type DerivativeOrder: int
    	:param Dimension:
    	:type Dimension: int
    	:param ValueArray:
    	:type ValueArray: float
    	:param DerivativeArray:
    	:type DerivativeArray: float
    	:param ParameterArray:
    	:type ParameterArray: float
    	:param Results:
    	:type Results: float
    	:rtype: int
    """
    return _PLib.plib_EvalCubicHermite(*args)

def plib_EvalLagrange(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    * Performs the Lagrange Interpolation of given series of points with given parameters with the requested derivative order Results will store things in the following format with d = DerivativeOrder //! [0], [Dimension-1]  : value [Dimension], [Dimension + Dimension-1] : first derivative //! [d *Dimension], [d*Dimension + Dimension-1]: dth derivative
    	:param U:
    	:type U: float
    	:param DerivativeOrder:
    	:type DerivativeOrder: int
    	:param Degree:
    	:type Degree: int
    	:param Dimension:
    	:type Dimension: int
    	:param ValueArray:
    	:type ValueArray: float
    	:param ParameterArray:
    	:type ParameterArray: float
    	:param Results:
    	:type Results: float
    	:rtype: int
    """
    return _PLib.plib_EvalLagrange(*args)

def plib_EvalLength(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    :param Degree:
    	:type Degree: int
    	:param Dimension:
    	:type Dimension: int
    	:param PolynomialCoeff:
    	:type PolynomialCoeff: float
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Length:
    	:type Length: float
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param Dimension:
    	:type Dimension: int
    	:param PolynomialCoeff:
    	:type PolynomialCoeff: float
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Tol:
    	:type Tol: float
    	:param Length:
    	:type Length: float
    	:param Error:
    	:type Error: float
    	:rtype: void
    """
    return _PLib.plib_EvalLength(*args)

def plib_EvalPoly2Var(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Applies EvalPolynomial twice to evaluate the derivative of orders UDerivativeOrder in U, VDerivativeOrder in V at parameters U,V //! PolynomialCoeff are stored in the following fashion c00(1) .... c00(Dimension) c10(1) .... c10(Dimension) .... cm0(1) .... cm0(Dimension) .... c01(1) .... c01(Dimension) c11(1) .... c11(Dimension) .... cm1(1) .... cm1(Dimension) .... c0n(1) .... c0n(Dimension) c1n(1) .... c1n(Dimension) .... cmn(1) .... cmn(Dimension) //! where the polynomial is defined as : 2  m c00 + c10 U + c20 U + .... + cm0 U 2  m + c01 V + c11 UV + c21 U V + .... + cm1 U V n m n + .... + c0n V + .... + cmn U V //! with m = UDegree and n = VDegree //! Results stores the result in the following format //! f(1) f(2) .... f(Dimension) //! Warning: <Results> and <PolynomialCoeff> must be dimensioned properly
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param UDerivativeOrder:
    	:type UDerivativeOrder: int
    	:param VDerivativeOrder:
    	:type VDerivativeOrder: int
    	:param UDegree:
    	:type UDegree: int
    	:param VDegree:
    	:type VDegree: int
    	:param Dimension:
    	:type Dimension: int
    	:param PolynomialCoeff:
    	:type PolynomialCoeff: float
    	:param Results:
    	:type Results: float
    	:rtype: void
    """
    return _PLib.plib_EvalPoly2Var(*args)

def plib_EvalPolynomial(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Performs Horner method with synthethic division for derivatives parameter <U>, with <Degree> and <Dimension>. PolynomialCoeff are stored in the following fashion c0(1) c0(2) .... c0(Dimension) c1(1) c1(2) .... c1(Dimension) //! cDegree(1) cDegree(2) .... cDegree(Dimension) where the polynomial is defined as : //! 2 Degree c0 + c1 X + c2 X + .... cDegree X //! Results stores the result in the following format //! f(1) f(2) .... f(Dimension) (1)  (1)  (1) f (1) f (2) .... f (Dimension) //! (DerivativeRequest) (DerivativeRequest) f (1)  f (Dimension) //! this just evaluates the point at parameter U //! Warning: <Results> and <PolynomialCoeff> must be dimensioned properly
    	:param U:
    	:type U: float
    	:param DerivativeOrder:
    	:type DerivativeOrder: int
    	:param Degree:
    	:type Degree: int
    	:param Dimension:
    	:type Dimension: int
    	:param PolynomialCoeff:
    	:type PolynomialCoeff: float
    	:param Results:
    	:type Results: float
    	:rtype: void
    """
    return _PLib.plib_EvalPolynomial(*args)

def plib_GetPoles(*args) -> "void":
    """
    * Get from FP the coordinates of the poles.
    	:param FP:
    	:type FP: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:rtype: void
    * Get from FP the coordinates of the poles.
    	:param FP:
    	:type FP: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:rtype: void
    * Get from FP the coordinates of the poles.
    	:param FP:
    	:type FP: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:rtype: void
    * Get from FP the coordinates of the poles.
    	:param FP:
    	:type FP: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:rtype: void
    """
    return _PLib.plib_GetPoles(*args)

def plib_HermiteCoefficients(*args) -> "Standard_Boolean":
    """
    * This build the coefficient of Hermite's polynomes on [FirstParameter, LastParameter] //! if j <= FirstOrder+1 then //! MatrixCoefs[i, j] = ith coefficient of the polynome H0,j-1 //! else //! MatrixCoefs[i, j] = ith coefficient of the polynome H1,k with k = j - FirstOrder - 2 //! return false if - |FirstParameter| > 100 - |LastParameter| > 100 - |FirstParameter| +|LastParameter| < 1/100 - |LastParameter - FirstParameter| / (|FirstParameter| +|LastParameter|) < 1/100
    	:param FirstParameter:
    	:type FirstParameter: float
    	:param LastParameter:
    	:type LastParameter: float
    	:param FirstOrder:
    	:type FirstOrder: int
    	:param LastOrder:
    	:type LastOrder: int
    	:param MatrixCoefs:
    	:type MatrixCoefs: math_Matrix
    	:rtype: bool
    """
    return _PLib.plib_HermiteCoefficients(*args)

def plib_HermiteInterpolate(*args) -> "Standard_Boolean":
    """
    * Compute the coefficients in the canonical base of the polynomial satisfying the given constraints at the given parameters The array FirstContr(i,j) i=1,Dimension j=0,FirstOrder contains the values of the constraint at parameter FirstParameter idem for LastConstr
    	:param Dimension:
    	:type Dimension: int
    	:param FirstParameter:
    	:type FirstParameter: float
    	:param LastParameter:
    	:type LastParameter: float
    	:param FirstOrder:
    	:type FirstOrder: int
    	:param LastOrder:
    	:type LastOrder: int
    	:param FirstConstr:
    	:type FirstConstr: TColStd_Array2OfReal
    	:param LastConstr:
    	:type LastConstr: TColStd_Array2OfReal
    	:param Coefficients:
    	:type Coefficients: TColStd_Array1OfReal
    	:rtype: bool
    """
    return _PLib.plib_HermiteInterpolate(*args)

def plib_JacobiParameters(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * Compute the number of points used for integral computations (NbGaussPoints) and the degree of Jacobi Polynomial (WorkDegree). ConstraintOrder has to be GeomAbs_C0, GeomAbs_C1 or GeomAbs_C2 Code: Code d' init. des parametres de discretisation. = -5 = -4 = -3 = -2 = -1 = 1 calcul rapide avec precision moyenne. = 2 calcul rapide avec meilleure precision. = 3 calcul un peu plus lent avec bonne precision. = 4 calcul lent avec la meilleure precision possible.
    	:param ConstraintOrder:
    	:type ConstraintOrder: GeomAbs_Shape
    	:param MaxDegree:
    	:type MaxDegree: int
    	:param Code:
    	:type Code: int
    	:param NbGaussPoints:
    	:type NbGaussPoints: int
    	:param WorkDegree:
    	:type WorkDegree: int
    	:rtype: void
    """
    return _PLib.plib_JacobiParameters(*args)

def plib_NivConstr(*args) -> "Standard_Integer":
    """
    * translates from GeomAbs_Shape to Integer
    	:param ConstraintOrder:
    	:type ConstraintOrder: GeomAbs_Shape
    	:rtype: int
    """
    return _PLib.plib_NivConstr(*args)

def plib_NoDerivativeEvalPolynomial(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Same as above with DerivativeOrder = 0;
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param Dimension:
    	:type Dimension: int
    	:param DegreeDimension:
    	:type DegreeDimension: int
    	:param PolynomialCoeff:
    	:type PolynomialCoeff: float
    	:param Results:
    	:type Results: float
    	:rtype: void
    """
    return _PLib.plib_NoDerivativeEvalPolynomial(*args)

def plib_NoWeights(*args) -> "TColStd_Array1OfReal *":
    """
    * Used as argument for a non rational functions
    	:rtype: inline TColStd_Array1OfReal *
    """
    return _PLib.plib_NoWeights(*args)

def plib_NoWeights2(*args) -> "TColStd_Array2OfReal *":
    """
    * Used as argument for a non rational functions
    	:rtype: inline TColStd_Array2OfReal *
    """
    return _PLib.plib_NoWeights2(*args)

def plib_RationalDerivative(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Computes the derivatives of a ratio at order <N> in dimension <Dimension>. //! <Ders> is an array containing the values of the input derivatives from 0 to Min(<N>,<Degree>). For orders higher than <Degree> the inputcd /s2d1/BMDL/ derivatives are assumed to be 0. //! Content of <Ders> : //! x(1),x(2),...,x(Dimension),w x'(1),x'(2),...,x'(Dimension),w' x''(1),x''(2),...,x''(Dimension),w'' //! If <All> is false, only the derivative at order <N> is computed. <RDers> is an array of length Dimension which will contain the result : //! x(1)/w , x(2)/w , ... derivated <N> times //! If <All> is true all the derivatives up to order <N> are computed. <RDers> is an array of length Dimension * (N+1) which will contains : //! x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated <1> times x(1)/w , x(2)/w , ... derivated <2> times ... x(1)/w , x(2)/w , ... derivated <N> times //! Warning: <RDers> must be dimensionned properly.
    	:param Degree:
    	:type Degree: int
    	:param N:
    	:type N: int
    	:param Dimension:
    	:type Dimension: int
    	:param Ders:
    	:type Ders: float
    	:param RDers:
    	:type RDers: float
    	:param All: default value is Standard_True
    	:type All: bool
    	:rtype: void
    """
    return _PLib.plib_RationalDerivative(*args)

def plib_RationalDerivatives(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    * Computes DerivativesRequest derivatives of a ratio at of a BSpline function of degree <Degree> dimension <Dimension>. //! <PolesDerivatives> is an array containing the values of the input derivatives from 0 to <DerivativeRequest> For orders higher than <Degree> the input derivatives are assumed to be 0. //! Content of <PoleasDerivatives> : //! x(1),x(2),...,x(Dimension) x'(1),x'(2),...,x'(Dimension) x''(1),x''(2),...,x''(Dimension) //! WeightsDerivatives is an array that contains derivatives from 0 to <DerivativeRequest> After returning from the routine the array RationalDerivatives contains the following x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated once x(1)/w , x(2)/w , ... twice x(1)/w , x(2)/w , ... derivated <DerivativeRequest> times //! The array RationalDerivatives and PolesDerivatives can be same since the overwrite is non destructive within the algorithm //! Warning: <RationalDerivates> must be dimensionned properly.
    	:param DerivativesRequest:
    	:type DerivativesRequest: int
    	:param Dimension:
    	:type Dimension: int
    	:param PolesDerivatives:
    	:type PolesDerivatives: float
    	:param WeightsDerivatives:
    	:type WeightsDerivatives: float
    	:param RationalDerivates:
    	:type RationalDerivates: float
    	:rtype: void
    """
    return _PLib.plib_RationalDerivatives(*args)

def plib_SetPoles(*args) -> "void":
    """
    * Copy in FP the coordinates of the poles.
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param FP:
    	:type FP: TColStd_Array1OfReal
    	:rtype: void
    * Copy in FP the coordinates of the poles.
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:param FP:
    	:type FP: TColStd_Array1OfReal
    	:rtype: void
    * Copy in FP the coordinates of the poles.
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param FP:
    	:type FP: TColStd_Array1OfReal
    	:rtype: void
    * Copy in FP the coordinates of the poles.
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:param FP:
    	:type FP: TColStd_Array1OfReal
    	:rtype: void
    """
    return _PLib.plib_SetPoles(*args)

def plib_Trimming(*args) -> "void":
    """
    :param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Coeffs:
    	:type Coeffs: TColgp_Array1OfPnt
    	:param WCoeffs:
    	:type WCoeffs: TColStd_Array1OfReal *
    	:rtype: void
    :param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Coeffs:
    	:type Coeffs: TColgp_Array1OfPnt2d
    	:param WCoeffs:
    	:type WCoeffs: TColStd_Array1OfReal *
    	:rtype: void
    :param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Coeffs:
    	:type Coeffs: TColStd_Array1OfReal
    	:param WCoeffs:
    	:type WCoeffs: TColStd_Array1OfReal *
    	:rtype: void
    :param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param dim:
    	:type dim: int
    	:param Coeffs:
    	:type Coeffs: TColStd_Array1OfReal
    	:param WCoeffs:
    	:type WCoeffs: TColStd_Array1OfReal *
    	:rtype: void
    """
    return _PLib.plib_Trimming(*args)

def plib_UTrimming(*args) -> "void":
    """
    :param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Coeffs:
    	:type Coeffs: TColgp_Array2OfPnt
    	:param WCoeffs:
    	:type WCoeffs: TColStd_Array2OfReal *
    	:rtype: void
    """
    return _PLib.plib_UTrimming(*args)

def plib_VTrimming(*args) -> "void":
    """
    :param V1:
    	:type V1: float
    	:param V2:
    	:type V2: float
    	:param Coeffs:
    	:type Coeffs: TColgp_Array2OfPnt
    	:param WCoeffs:
    	:type WCoeffs: TColStd_Array2OfReal *
    	:rtype: void
    """
    return _PLib.plib_VTrimming(*args)

class PLib_Base(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def D0(self, *args) -> "void":
        """
        * Compute the values of the basis functions in u
        	:param U:
        	:type U: float
        	:param BasisValue:
        	:type BasisValue: TColStd_Array1OfReal
        	:rtype: void
        """
        return _PLib.PLib_Base_D0(self, *args)


    def D1(self, *args) -> "void":
        """
        * Compute the values and the derivatives values of the basis functions in u
        	:param U:
        	:type U: float
        	:param BasisValue:
        	:type BasisValue: TColStd_Array1OfReal
        	:param BasisD1:
        	:type BasisD1: TColStd_Array1OfReal
        	:rtype: void
        """
        return _PLib.PLib_Base_D1(self, *args)


    def D2(self, *args) -> "void":
        """
        * Compute the values and the derivatives values of the basis functions in u
        	:param U:
        	:type U: float
        	:param BasisValue:
        	:type BasisValue: TColStd_Array1OfReal
        	:param BasisD1:
        	:type BasisD1: TColStd_Array1OfReal
        	:param BasisD2:
        	:type BasisD2: TColStd_Array1OfReal
        	:rtype: void
        """
        return _PLib.PLib_Base_D2(self, *args)


    def D3(self, *args) -> "void":
        """
        * Compute the values and the derivatives values of the basis functions in u
        	:param U:
        	:type U: float
        	:param BasisValue:
        	:type BasisValue: TColStd_Array1OfReal
        	:param BasisD1:
        	:type BasisD1: TColStd_Array1OfReal
        	:param BasisD2:
        	:type BasisD2: TColStd_Array1OfReal
        	:param BasisD3:
        	:type BasisD3: TColStd_Array1OfReal
        	:rtype: void
        """
        return _PLib.PLib_Base_D3(self, *args)


    def ReduceDegree(self, *args) -> "void":
        """
        * Compute NewDegree <= MaxDegree so that MaxError is lower than Tol. MaxError can be greater than Tol if it is not possible to find a NewDegree <= MaxDegree. In this case NewDegree = MaxDegree
        	:param Dimension:
        	:type Dimension: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param Tol:
        	:type Tol: float
        	:param BaseCoeff:
        	:type BaseCoeff: float
        	:param NewDegree:
        	:type NewDegree: int
        	:param MaxError:
        	:type MaxError: float
        	:rtype: void
        """
        return _PLib.PLib_Base_ReduceDegree(self, *args)


    def ToCoefficients(self, *args) -> "void":
        """
        * Convert the polynomial P(t) in the canonical base.
        	:param Dimension:
        	:type Dimension: int
        	:param Degree:
        	:type Degree: int
        	:param CoeffinBase:
        	:type CoeffinBase: TColStd_Array1OfReal
        	:param Coefficients:
        	:type Coefficients: TColStd_Array1OfReal
        	:rtype: void
        """
        return _PLib.PLib_Base_ToCoefficients(self, *args)


    def WorkDegree(self, *args) -> "Standard_Integer":
        """
        * returns WorkDegree
        	:rtype: int
        """
        return _PLib.PLib_Base_WorkDegree(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_PLib_Base_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _PLib.delete_PLib_Base
PLib_Base.D0 = new_instancemethod(_PLib.PLib_Base_D0, None, PLib_Base)
PLib_Base.D1 = new_instancemethod(_PLib.PLib_Base_D1, None, PLib_Base)
PLib_Base.D2 = new_instancemethod(_PLib.PLib_Base_D2, None, PLib_Base)
PLib_Base.D3 = new_instancemethod(_PLib.PLib_Base_D3, None, PLib_Base)
PLib_Base.ReduceDegree = new_instancemethod(_PLib.PLib_Base_ReduceDegree, None, PLib_Base)
PLib_Base.ToCoefficients = new_instancemethod(_PLib.PLib_Base_ToCoefficients, None, PLib_Base)
PLib_Base.WorkDegree = new_instancemethod(_PLib.PLib_Base_WorkDegree, None, PLib_Base)
PLib_Base_swigregister = _PLib.PLib_Base_swigregister
PLib_Base_swigregister(PLib_Base)

class PLib_DoubleJacobiPolynomial(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AverageError(self, *args) -> "Standard_Real":
        """
        :param Dimension:
        	:type Dimension: int
        	:param DegreeU:
        	:type DegreeU: int
        	:param DegreeV:
        	:type DegreeV: int
        	:param dJacCoeff:
        	:type dJacCoeff: int
        	:param JacCoeff:
        	:type JacCoeff: TColStd_Array1OfReal
        	:rtype: float
        """
        return _PLib.PLib_DoubleJacobiPolynomial_AverageError(self, *args)


    def MaxError(self, *args) -> "Standard_Real":
        """
        :param Dimension:
        	:type Dimension: int
        	:param MinDegreeU:
        	:type MinDegreeU: int
        	:param MaxDegreeU:
        	:type MaxDegreeU: int
        	:param MinDegreeV:
        	:type MinDegreeV: int
        	:param MaxDegreeV:
        	:type MaxDegreeV: int
        	:param dJacCoeff:
        	:type dJacCoeff: int
        	:param JacCoeff:
        	:type JacCoeff: TColStd_Array1OfReal
        	:param Error:
        	:type Error: float
        	:rtype: float
        """
        return _PLib.PLib_DoubleJacobiPolynomial_MaxError(self, *args)


    def MaxErrorU(self, *args) -> "Standard_Real":
        """
        :param Dimension:
        	:type Dimension: int
        	:param DegreeU:
        	:type DegreeU: int
        	:param DegreeV:
        	:type DegreeV: int
        	:param dJacCoeff:
        	:type dJacCoeff: int
        	:param JacCoeff:
        	:type JacCoeff: TColStd_Array1OfReal
        	:rtype: float
        """
        return _PLib.PLib_DoubleJacobiPolynomial_MaxErrorU(self, *args)


    def MaxErrorV(self, *args) -> "Standard_Real":
        """
        :param Dimension:
        	:type Dimension: int
        	:param DegreeU:
        	:type DegreeU: int
        	:param DegreeV:
        	:type DegreeV: int
        	:param dJacCoeff:
        	:type dJacCoeff: int
        	:param JacCoeff:
        	:type JacCoeff: TColStd_Array1OfReal
        	:rtype: float
        """
        return _PLib.PLib_DoubleJacobiPolynomial_MaxErrorV(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param JacPolU:
        	:type JacPolU: PLib_JacobiPolynomial
        	:param JacPolV:
        	:type JacPolV: PLib_JacobiPolynomial
        	:rtype: None
        """
        _PLib.PLib_DoubleJacobiPolynomial_swiginit(self, _PLib.new_PLib_DoubleJacobiPolynomial(*args))

    def ReduceDegree(self, *args) -> "void":
        """
        :param Dimension:
        	:type Dimension: int
        	:param MinDegreeU:
        	:type MinDegreeU: int
        	:param MaxDegreeU:
        	:type MaxDegreeU: int
        	:param MinDegreeV:
        	:type MinDegreeV: int
        	:param MaxDegreeV:
        	:type MaxDegreeV: int
        	:param dJacCoeff:
        	:type dJacCoeff: int
        	:param JacCoeff:
        	:type JacCoeff: TColStd_Array1OfReal
        	:param EpmsCut:
        	:type EpmsCut: float
        	:param MaxError:
        	:type MaxError: float
        	:param NewDegreeU:
        	:type NewDegreeU: int
        	:param NewDegreeV:
        	:type NewDegreeV: int
        	:rtype: None
        """
        return _PLib.PLib_DoubleJacobiPolynomial_ReduceDegree(self, *args)


    def TabMaxU(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal >":
        """
        * returns myTabMaxU;
        	:rtype: opencascade::handle<TColStd_HArray1OfReal>
        """
        return _PLib.PLib_DoubleJacobiPolynomial_TabMaxU(self, *args)


    def TabMaxV(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal >":
        """
        * returns myTabMaxV;
        	:rtype: opencascade::handle<TColStd_HArray1OfReal>
        """
        return _PLib.PLib_DoubleJacobiPolynomial_TabMaxV(self, *args)


    def U(self, *args) -> "opencascade::handle< PLib_JacobiPolynomial >":
        """
        * returns myJacPolU;
        	:rtype: opencascade::handle<PLib_JacobiPolynomial>
        """
        return _PLib.PLib_DoubleJacobiPolynomial_U(self, *args)


    def V(self, *args) -> "opencascade::handle< PLib_JacobiPolynomial >":
        """
        * returns myJacPolV;
        	:rtype: opencascade::handle<PLib_JacobiPolynomial>
        """
        return _PLib.PLib_DoubleJacobiPolynomial_V(self, *args)


    def WDoubleJacobiToCoefficients(self, *args) -> "void":
        """
        :param Dimension:
        	:type Dimension: int
        	:param DegreeU:
        	:type DegreeU: int
        	:param DegreeV:
        	:type DegreeV: int
        	:param JacCoeff:
        	:type JacCoeff: TColStd_Array1OfReal
        	:param Coefficients:
        	:type Coefficients: TColStd_Array1OfReal
        	:rtype: None
        """
        return _PLib.PLib_DoubleJacobiPolynomial_WDoubleJacobiToCoefficients(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _PLib.delete_PLib_DoubleJacobiPolynomial
PLib_DoubleJacobiPolynomial.AverageError = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_AverageError, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial.MaxError = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_MaxError, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial.MaxErrorU = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_MaxErrorU, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial.MaxErrorV = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_MaxErrorV, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial.ReduceDegree = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_ReduceDegree, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial.TabMaxU = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_TabMaxU, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial.TabMaxV = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_TabMaxV, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial.U = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_U, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial.V = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_V, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial.WDoubleJacobiToCoefficients = new_instancemethod(_PLib.PLib_DoubleJacobiPolynomial_WDoubleJacobiToCoefficients, None, PLib_DoubleJacobiPolynomial)
PLib_DoubleJacobiPolynomial_swigregister = _PLib.PLib_DoubleJacobiPolynomial_swigregister
PLib_DoubleJacobiPolynomial_swigregister(PLib_DoubleJacobiPolynomial)

class PLib_HermitJacobi(PLib_Base):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AverageError(self, *args) -> "Standard_Real":
        """
        :param Dimension:
        	:type Dimension: int
        	:param HermJacCoeff:
        	:type HermJacCoeff: float
        	:param NewDegree:
        	:type NewDegree: int
        	:rtype: float
        """
        return _PLib.PLib_HermitJacobi_AverageError(self, *args)


    def MaxError(self, *args) -> "Standard_Real":
        """
        * This method computes the maximum error on the polynomial W(t) Q(t) obtained by missing the coefficients of JacCoeff from NewDegree +1 to Degree
        	:param Dimension:
        	:type Dimension: int
        	:param HermJacCoeff:
        	:type HermJacCoeff: float
        	:param NewDegree:
        	:type NewDegree: int
        	:rtype: float
        """
        return _PLib.PLib_HermitJacobi_MaxError(self, *args)


    def NivConstr(self, *args) -> "Standard_Integer":
        """
        * returns NivConstr
        	:rtype: int
        """
        return _PLib.PLib_HermitJacobi_NivConstr(self, *args)


    def __init__(self, *args):
        """
        * Initialize the polynomial class Degree has to be <= 30 ConstraintOrder has to be GeomAbs_C0 GeomAbs_C1 GeomAbs_C2
        	:param WorkDegree:
        	:type WorkDegree: int
        	:param ConstraintOrder:
        	:type ConstraintOrder: GeomAbs_Shape
        	:rtype: None
        """
        _PLib.PLib_HermitJacobi_swiginit(self, _PLib.new_PLib_HermitJacobi(*args))


    @staticmethod
    def DownCast(t):
      return Handle_PLib_HermitJacobi_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _PLib.delete_PLib_HermitJacobi
PLib_HermitJacobi.AverageError = new_instancemethod(_PLib.PLib_HermitJacobi_AverageError, None, PLib_HermitJacobi)
PLib_HermitJacobi.MaxError = new_instancemethod(_PLib.PLib_HermitJacobi_MaxError, None, PLib_HermitJacobi)
PLib_HermitJacobi.NivConstr = new_instancemethod(_PLib.PLib_HermitJacobi_NivConstr, None, PLib_HermitJacobi)
PLib_HermitJacobi_swigregister = _PLib.PLib_HermitJacobi_swigregister
PLib_HermitJacobi_swigregister(PLib_HermitJacobi)

class PLib_JacobiPolynomial(PLib_Base):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AverageError(self, *args) -> "Standard_Real":
        """
        :param Dimension:
        	:type Dimension: int
        	:param JacCoeff:
        	:type JacCoeff: float
        	:param NewDegree:
        	:type NewDegree: int
        	:rtype: float
        """
        return _PLib.PLib_JacobiPolynomial_AverageError(self, *args)


    def MaxError(self, *args) -> "Standard_Real":
        """
        * This method computes the maximum error on the polynomial W(t) Q(t) obtained by missing the coefficients of JacCoeff from NewDegree +1 to Degree
        	:param Dimension:
        	:type Dimension: int
        	:param JacCoeff:
        	:type JacCoeff: float
        	:param NewDegree:
        	:type NewDegree: int
        	:rtype: float
        """
        return _PLib.PLib_JacobiPolynomial_MaxError(self, *args)


    def MaxValue(self, *args) -> "void":
        """
        * this method loads for k=0,q the maximum value of abs ( W(t)*Jk(t) )for t bellonging to [-1,1] This values are loaded is the array TabMax(0,myWorkDegree-2*(myNivConst+1)) MaxValue ( me ; TabMaxPointer : in out Real );
        	:param TabMax:
        	:type TabMax: TColStd_Array1OfReal
        	:rtype: None
        """
        return _PLib.PLib_JacobiPolynomial_MaxValue(self, *args)


    def NivConstr(self, *args) -> "Standard_Integer":
        """
        * returns NivConstr
        	:rtype: int
        """
        return _PLib.PLib_JacobiPolynomial_NivConstr(self, *args)


    def __init__(self, *args):
        """
        * Initialize the polynomial class Degree has to be <= 30 ConstraintOrder has to be GeomAbs_C0 GeomAbs_C1 GeomAbs_C2
        	:param WorkDegree:
        	:type WorkDegree: int
        	:param ConstraintOrder:
        	:type ConstraintOrder: GeomAbs_Shape
        	:rtype: None
        """
        _PLib.PLib_JacobiPolynomial_swiginit(self, _PLib.new_PLib_JacobiPolynomial(*args))

    def Points(self, *args) -> "void":
        """
        * returns the Jacobi Points for Gauss integration ie the positive values of the Legendre roots by increasing values NbGaussPoints is the number of points choosen for the integral computation. TabPoints (0,NbGaussPoints/2) TabPoints (0) is loaded only for the odd values of NbGaussPoints The possible values for NbGaussPoints are : 8, 10, 15, 20, 25, 30, 35, 40, 50, 61 NbGaussPoints must be greater than Degree
        	:param NbGaussPoints:
        	:type NbGaussPoints: int
        	:param TabPoints:
        	:type TabPoints: TColStd_Array1OfReal
        	:rtype: None
        """
        return _PLib.PLib_JacobiPolynomial_Points(self, *args)


    def Weights(self, *args) -> "void":
        """
        * returns the Jacobi weigths for Gauss integration only for the positive values of the Legendre roots in the order they are given by the method Points NbGaussPoints is the number of points choosen for the integral computation. TabWeights (0,NbGaussPoints/2,0,Degree) TabWeights (0,.) are only loaded for the odd values of NbGaussPoints The possible values for NbGaussPoints are : 8 , 10 , 15 ,20 ,25 , 30, 35 , 40 , 50 , 61 NbGaussPoints must be greater than Degree
        	:param NbGaussPoints:
        	:type NbGaussPoints: int
        	:param TabWeights:
        	:type TabWeights: TColStd_Array2OfReal
        	:rtype: None
        """
        return _PLib.PLib_JacobiPolynomial_Weights(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_PLib_JacobiPolynomial_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _PLib.delete_PLib_JacobiPolynomial
PLib_JacobiPolynomial.AverageError = new_instancemethod(_PLib.PLib_JacobiPolynomial_AverageError, None, PLib_JacobiPolynomial)
PLib_JacobiPolynomial.MaxError = new_instancemethod(_PLib.PLib_JacobiPolynomial_MaxError, None, PLib_JacobiPolynomial)
PLib_JacobiPolynomial.MaxValue = new_instancemethod(_PLib.PLib_JacobiPolynomial_MaxValue, None, PLib_JacobiPolynomial)
PLib_JacobiPolynomial.NivConstr = new_instancemethod(_PLib.PLib_JacobiPolynomial_NivConstr, None, PLib_JacobiPolynomial)
PLib_JacobiPolynomial.Points = new_instancemethod(_PLib.PLib_JacobiPolynomial_Points, None, PLib_JacobiPolynomial)
PLib_JacobiPolynomial.Weights = new_instancemethod(_PLib.PLib_JacobiPolynomial_Weights, None, PLib_JacobiPolynomial)
PLib_JacobiPolynomial_swigregister = _PLib.PLib_JacobiPolynomial_swigregister
PLib_JacobiPolynomial_swigregister(PLib_JacobiPolynomial)



