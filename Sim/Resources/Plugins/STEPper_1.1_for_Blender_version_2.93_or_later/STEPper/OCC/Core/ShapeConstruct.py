# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
ShapeConstruct module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_shapeconstruct.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _ShapeConstruct.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ShapeConstruct')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ShapeConstruct')
    _ShapeConstruct = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ShapeConstruct', [dirname(__file__)])
        except ImportError:
            import _ShapeConstruct
            return _ShapeConstruct
        try:
            _mod = imp.load_module('_ShapeConstruct', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ShapeConstruct = swig_import_helper()
    del swig_import_helper
else:
    import _ShapeConstruct
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ShapeConstruct.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_ShapeConstruct.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_ShapeConstruct.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_ShapeConstruct.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_ShapeConstruct.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_ShapeConstruct.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_ShapeConstruct.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_ShapeConstruct.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_ShapeConstruct.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_ShapeConstruct.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_ShapeConstruct.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _ShapeConstruct.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _ShapeConstruct.process_exception(error, method_name, class_name)
process_exception = _ShapeConstruct.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Geom2d
import OCC.Core.TopAbs
import OCC.Core.TopTools
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TopLoc
import OCC.Core.BRepBuilderAPI
import OCC.Core.BRepTools
import OCC.Core.Bnd
import OCC.Core.BVH
import OCC.Core.BRep
import OCC.Core.Poly
import OCC.Core.TShort
import OCC.Core.ShapeAnalysis
import OCC.Core.ShapeExtend
import OCC.Core.TColGeom
import OCC.Core.Adaptor3d
import OCC.Core.Adaptor2d
import OCC.Core.math
import OCC.Core.GeomAdaptor
import OCC.Core.IntRes2d

def Handle_ShapeConstruct_ProjectCurveOnSurface_Create() -> "opencascade::handle< ShapeConstruct_ProjectCurveOnSurface >":
    return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_Create()
Handle_ShapeConstruct_ProjectCurveOnSurface_Create = _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_Create

def Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ShapeConstruct_ProjectCurveOnSurface >":
    return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast(t)
Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast = _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast

def Handle_ShapeConstruct_ProjectCurveOnSurface_IsNull(t: 'opencascade::handle< ShapeConstruct_ProjectCurveOnSurface > const &') -> "bool":
    return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_IsNull(t)
Handle_ShapeConstruct_ProjectCurveOnSurface_IsNull = _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_IsNull
class shapeconstruct(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ConvertCurveToBSpline(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        * Tool for wire triangulation
        	:param C3D:
        	:type C3D: Geom_Curve
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Tol3d:
        	:type Tol3d: float
        	:param Continuity:
        	:type Continuity: GeomAbs_Shape
        	:param MaxSegments:
        	:type MaxSegments: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:rtype: opencascade::handle<Geom_BSplineCurve>
        :param C2D:
        	:type C2D: Geom2d_Curve
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param Continuity:
        	:type Continuity: GeomAbs_Shape
        	:param MaxSegments:
        	:type MaxSegments: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _ShapeConstruct.shapeconstruct_ConvertCurveToBSpline(*args)

    ConvertCurveToBSpline = staticmethod(ConvertCurveToBSpline)

    def ConvertSurfaceToBSpline(*args) -> "opencascade::handle< Geom_BSplineSurface >":
        """
        :param surf:
        	:type surf: Geom_Surface
        	:param UF:
        	:type UF: float
        	:param UL:
        	:type UL: float
        	:param VF:
        	:type VF: float
        	:param VL:
        	:type VL: float
        	:param Tol3d:
        	:type Tol3d: float
        	:param Continuity:
        	:type Continuity: GeomAbs_Shape
        	:param MaxSegments:
        	:type MaxSegments: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:rtype: opencascade::handle<Geom_BSplineSurface>
        """
        return _ShapeConstruct.shapeconstruct_ConvertSurfaceToBSpline(*args)

    ConvertSurfaceToBSpline = staticmethod(ConvertSurfaceToBSpline)

    def JoinCurves(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Boolean &, Standard_Boolean &":
        """
        * Method for joininig curves 3D. Parameters : c3d1,ac3d2 - initial curves Orient1, Orient2 - initial edges orientations. first1,last1,first2,last2 - parameters for trimming curves (re-calculate with account of orientation edges) c3dOut - result curve isRev1,isRev2 - out parameters indicative on possible errors. Return value : True - if curves were joined successfully, else - False.
        	:param c3d1:
        	:type c3d1: Geom_Curve
        	:param ac3d2:
        	:type ac3d2: Geom_Curve
        	:param Orient1:
        	:type Orient1: TopAbs_Orientation
        	:param Orient2:
        	:type Orient2: TopAbs_Orientation
        	:param first1:
        	:type first1: float
        	:param last1:
        	:type last1: float
        	:param first2:
        	:type first2: float
        	:param last2:
        	:type last2: float
        	:param c3dOut:
        	:type c3dOut: Geom_Curve
        	:param isRev1:
        	:type isRev1: bool
        	:param isRev2:
        	:type isRev2: bool
        	:rtype: bool
        * Method for joininig curves 3D. Parameters : c3d1,ac3d2 - initial curves Orient1, Orient2 - initial edges orientations. first1,last1,first2,last2 - parameters for trimming curves (re-calculate with account of orientation edges) c3dOut - result curve isRev1,isRev2 - out parameters indicative on possible errors. isError - input parameter indicative possible errors due to that one from edges have one vertex Return value : True - if curves were joined successfully, else - False.
        	:param c2d1:
        	:type c2d1: Geom2d_Curve
        	:param ac2d2:
        	:type ac2d2: Geom2d_Curve
        	:param Orient1:
        	:type Orient1: TopAbs_Orientation
        	:param Orient2:
        	:type Orient2: TopAbs_Orientation
        	:param first1:
        	:type first1: float
        	:param last1:
        	:type last1: float
        	:param first2:
        	:type first2: float
        	:param last2:
        	:type last2: float
        	:param c2dOut:
        	:type c2dOut: Geom2d_Curve
        	:param isRev1:
        	:type isRev1: bool
        	:param isRev2:
        	:type isRev2: bool
        	:param isError: default value is Standard_False
        	:type isError: bool
        	:rtype: bool
        """
        return _ShapeConstruct.shapeconstruct_JoinCurves(*args)

    JoinCurves = staticmethod(JoinCurves)

    def JoinPCurves(*args) -> "Standard_Boolean":
        """
        * join pcurves of the <theEdge> on the <theFace> try to use pcurves from originas edges <theEdges> Returns false if cannot join pcurves
        	:param theEdges:
        	:type theEdges: TopTools_HSequenceOfShape
        	:param theFace:
        	:type theFace: TopoDS_Face
        	:param theEdge:
        	:type theEdge: TopoDS_Edge
        	:rtype: bool
        """
        return _ShapeConstruct.shapeconstruct_JoinPCurves(*args)

    JoinPCurves = staticmethod(JoinPCurves)

    __repr__ = _dumps_object


    def __init__(self):
        _ShapeConstruct.shapeconstruct_swiginit(self, _ShapeConstruct.new_shapeconstruct())
    __swig_destroy__ = _ShapeConstruct.delete_shapeconstruct
shapeconstruct_swigregister = _ShapeConstruct.shapeconstruct_swigregister
shapeconstruct_swigregister(shapeconstruct)

def shapeconstruct_ConvertCurveToBSpline(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
    """
    * Tool for wire triangulation
    	:param C3D:
    	:type C3D: Geom_Curve
    	:param First:
    	:type First: float
    	:param Last:
    	:type Last: float
    	:param Tol3d:
    	:type Tol3d: float
    	:param Continuity:
    	:type Continuity: GeomAbs_Shape
    	:param MaxSegments:
    	:type MaxSegments: int
    	:param MaxDegree:
    	:type MaxDegree: int
    	:rtype: opencascade::handle<Geom_BSplineCurve>
    :param C2D:
    	:type C2D: Geom2d_Curve
    	:param First:
    	:type First: float
    	:param Last:
    	:type Last: float
    	:param Tol2d:
    	:type Tol2d: float
    	:param Continuity:
    	:type Continuity: GeomAbs_Shape
    	:param MaxSegments:
    	:type MaxSegments: int
    	:param MaxDegree:
    	:type MaxDegree: int
    	:rtype: opencascade::handle<Geom2d_BSplineCurve>
    """
    return _ShapeConstruct.shapeconstruct_ConvertCurveToBSpline(*args)

def shapeconstruct_ConvertSurfaceToBSpline(*args) -> "opencascade::handle< Geom_BSplineSurface >":
    """
    :param surf:
    	:type surf: Geom_Surface
    	:param UF:
    	:type UF: float
    	:param UL:
    	:type UL: float
    	:param VF:
    	:type VF: float
    	:param VL:
    	:type VL: float
    	:param Tol3d:
    	:type Tol3d: float
    	:param Continuity:
    	:type Continuity: GeomAbs_Shape
    	:param MaxSegments:
    	:type MaxSegments: int
    	:param MaxDegree:
    	:type MaxDegree: int
    	:rtype: opencascade::handle<Geom_BSplineSurface>
    """
    return _ShapeConstruct.shapeconstruct_ConvertSurfaceToBSpline(*args)

def shapeconstruct_JoinCurves(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Boolean &, Standard_Boolean &":
    """
    * Method for joininig curves 3D. Parameters : c3d1,ac3d2 - initial curves Orient1, Orient2 - initial edges orientations. first1,last1,first2,last2 - parameters for trimming curves (re-calculate with account of orientation edges) c3dOut - result curve isRev1,isRev2 - out parameters indicative on possible errors. Return value : True - if curves were joined successfully, else - False.
    	:param c3d1:
    	:type c3d1: Geom_Curve
    	:param ac3d2:
    	:type ac3d2: Geom_Curve
    	:param Orient1:
    	:type Orient1: TopAbs_Orientation
    	:param Orient2:
    	:type Orient2: TopAbs_Orientation
    	:param first1:
    	:type first1: float
    	:param last1:
    	:type last1: float
    	:param first2:
    	:type first2: float
    	:param last2:
    	:type last2: float
    	:param c3dOut:
    	:type c3dOut: Geom_Curve
    	:param isRev1:
    	:type isRev1: bool
    	:param isRev2:
    	:type isRev2: bool
    	:rtype: bool
    * Method for joininig curves 3D. Parameters : c3d1,ac3d2 - initial curves Orient1, Orient2 - initial edges orientations. first1,last1,first2,last2 - parameters for trimming curves (re-calculate with account of orientation edges) c3dOut - result curve isRev1,isRev2 - out parameters indicative on possible errors. isError - input parameter indicative possible errors due to that one from edges have one vertex Return value : True - if curves were joined successfully, else - False.
    	:param c2d1:
    	:type c2d1: Geom2d_Curve
    	:param ac2d2:
    	:type ac2d2: Geom2d_Curve
    	:param Orient1:
    	:type Orient1: TopAbs_Orientation
    	:param Orient2:
    	:type Orient2: TopAbs_Orientation
    	:param first1:
    	:type first1: float
    	:param last1:
    	:type last1: float
    	:param first2:
    	:type first2: float
    	:param last2:
    	:type last2: float
    	:param c2dOut:
    	:type c2dOut: Geom2d_Curve
    	:param isRev1:
    	:type isRev1: bool
    	:param isRev2:
    	:type isRev2: bool
    	:param isError: default value is Standard_False
    	:type isError: bool
    	:rtype: bool
    """
    return _ShapeConstruct.shapeconstruct_JoinCurves(*args)

def shapeconstruct_JoinPCurves(*args) -> "Standard_Boolean":
    """
    * join pcurves of the <theEdge> on the <theFace> try to use pcurves from originas edges <theEdges> Returns false if cannot join pcurves
    	:param theEdges:
    	:type theEdges: TopTools_HSequenceOfShape
    	:param theFace:
    	:type theFace: TopoDS_Face
    	:param theEdge:
    	:type theEdge: TopoDS_Edge
    	:rtype: bool
    """
    return _ShapeConstruct.shapeconstruct_JoinPCurves(*args)

class ShapeConstruct_Curve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AdjustCurve(self, *args) -> "Standard_Boolean":
        """
        * Modifies a curve in order to make its bounds confused with given points. Works only on lines and B-Splines, returns True in this case, else returns False. For line considers both bounding points, for B-Splines only specified. //! Warning : Does not check if curve should be reversed
        	:param C3D:
        	:type C3D: Geom_Curve
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:param take1: default value is Standard_True
        	:type take1: bool
        	:param take2: default value is Standard_True
        	:type take2: bool
        	:rtype: bool
        """
        return _ShapeConstruct.ShapeConstruct_Curve_AdjustCurve(self, *args)


    def AdjustCurve2d(self, *args) -> "Standard_Boolean":
        """
        * Modifies a curve in order to make its bounds confused with given points. Works only on lines and B-Splines, returns True in this case, else returns False. //! For line considers both bounding points, for B-Splines only specified. //! Warning : Does not check if curve should be reversed
        	:param C2D:
        	:type C2D: Geom2d_Curve
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:param take1: default value is Standard_True
        	:type take1: bool
        	:param take2: default value is Standard_True
        	:type take2: bool
        	:rtype: bool
        """
        return _ShapeConstruct.ShapeConstruct_Curve_AdjustCurve2d(self, *args)


    def AdjustCurveSegment(self, *args) -> "Standard_Boolean":
        """
        * Modifies a curve in order to make its bounds confused with given points. Works only on lines and B-Splines. //! For lines works as previous method, B-Splines are segmented at the given values and then are adjusted to the points.
        	:param C3D:
        	:type C3D: Geom_Curve
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:rtype: bool
        """
        return _ShapeConstruct.ShapeConstruct_Curve_AdjustCurveSegment(self, *args)


    def ConvertToBSpline(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        * Converts a curve of any type (only part from first to last) to bspline. The method of conversion depends on the type of original curve: BSpline -> C.Segment(first,last) Bezier and Line -> GeomConvert::CurveToBSplineCurve(C).Segment(first,last) Conic and Other -> Approx_Curve3d(C[first,last],prec,C1,9,1000)
        	:param C:
        	:type C: Geom_Curve
        	:param first:
        	:type first: float
        	:param last:
        	:type last: float
        	:param prec:
        	:type prec: float
        	:rtype: opencascade::handle<Geom_BSplineCurve>
        * Converts a curve of any type (only part from first to last) to bspline. The method of conversion depends on the type of original curve: BSpline -> C.Segment(first,last) Bezier and Line -> GeomConvert::CurveToBSplineCurve(C).Segment(first,last) Conic and Other -> Approx_Curve2d(C[first,last],prec,C1,9,1000)
        	:param C:
        	:type C: Geom2d_Curve
        	:param first:
        	:type first: float
        	:param last:
        	:type last: float
        	:param prec:
        	:type prec: float
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _ShapeConstruct.ShapeConstruct_Curve_ConvertToBSpline(self, *args)


    def FixKnots(*args) -> "Standard_Boolean":
        """
        :param knots:
        	:type knots: TColStd_HArray1OfReal
        	:rtype: bool
        * Fix bspline knots to ensure that there is enough gap between neighbouring values Returns True if something fixed (by shifting knot)
        	:param knots:
        	:type knots: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _ShapeConstruct.ShapeConstruct_Curve_FixKnots(*args)

    FixKnots = staticmethod(FixKnots)

    __repr__ = _dumps_object


    def __init__(self):
        _ShapeConstruct.ShapeConstruct_Curve_swiginit(self, _ShapeConstruct.new_ShapeConstruct_Curve())
    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_Curve
ShapeConstruct_Curve.AdjustCurve = new_instancemethod(_ShapeConstruct.ShapeConstruct_Curve_AdjustCurve, None, ShapeConstruct_Curve)
ShapeConstruct_Curve.AdjustCurve2d = new_instancemethod(_ShapeConstruct.ShapeConstruct_Curve_AdjustCurve2d, None, ShapeConstruct_Curve)
ShapeConstruct_Curve.AdjustCurveSegment = new_instancemethod(_ShapeConstruct.ShapeConstruct_Curve_AdjustCurveSegment, None, ShapeConstruct_Curve)
ShapeConstruct_Curve.ConvertToBSpline = new_instancemethod(_ShapeConstruct.ShapeConstruct_Curve_ConvertToBSpline, None, ShapeConstruct_Curve)
ShapeConstruct_Curve_swigregister = _ShapeConstruct.ShapeConstruct_Curve_swigregister
ShapeConstruct_Curve_swigregister(ShapeConstruct_Curve)

def ShapeConstruct_Curve_FixKnots(*args) -> "Standard_Boolean":
    """
    :param knots:
    	:type knots: TColStd_HArray1OfReal
    	:rtype: bool
    * Fix bspline knots to ensure that there is enough gap between neighbouring values Returns True if something fixed (by shifting knot)
    	:param knots:
    	:type knots: TColStd_Array1OfReal
    	:rtype: bool
    """
    return _ShapeConstruct.ShapeConstruct_Curve_FixKnots(*args)

class ShapeConstruct_MakeTriangulation(OCC.Core.BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param pnts:
        	:type pnts: TColgp_Array1OfPnt
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: None
        :param wire:
        	:type wire: TopoDS_Wire
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: None
        """
        _ShapeConstruct.ShapeConstruct_MakeTriangulation_swiginit(self, _ShapeConstruct.new_ShapeConstruct_MakeTriangulation(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_MakeTriangulation
ShapeConstruct_MakeTriangulation_swigregister = _ShapeConstruct.ShapeConstruct_MakeTriangulation_swigregister
ShapeConstruct_MakeTriangulation_swigregister(ShapeConstruct_MakeTriangulation)

class ShapeConstruct_ProjectCurveOnSurface(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetAdjustOverDegenMode(self) -> "Standard_Integer":
        """GetAdjustOverDegenMode(ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Integer"""
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_GetAdjustOverDegenMode(self)


    def SetAdjustOverDegenMode(self, value: 'Standard_Integer') -> "void":
        """SetAdjustOverDegenMode(ShapeConstruct_ProjectCurveOnSurface self, Standard_Integer value)"""
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetAdjustOverDegenMode(self, value)


    def GetBuildCurveMode(self) -> "Standard_Boolean":
        """GetBuildCurveMode(ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Boolean"""
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_GetBuildCurveMode(self)


    def SetBuildCurveMode(self, value: 'Standard_Boolean') -> "void":
        """SetBuildCurveMode(ShapeConstruct_ProjectCurveOnSurface self, Standard_Boolean value)"""
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetBuildCurveMode(self, value)


    def Init(self, *args) -> "void":
        """
        * Initializes the object with all necessary parameters, i.e. surface and precision
        	:param surf:
        	:type surf: Geom_Surface
        	:param preci:
        	:type preci: float
        	:rtype: void
        * Initializes the object with all necessary parameters, i.e. surface and precision
        	:param surf:
        	:type surf: ShapeAnalysis_Surface
        	:param preci:
        	:type preci: float
        	:rtype: void
        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Init(self, *args)


    def Perform(self, *args) -> "Standard_Boolean":
        """
        * Computes the projection of 3d curve onto a surface using the specialized algorithm. Returns False if projector fails, otherwise, if pcurve computed successfully, returns True. The output curve 2D is guaranteed to be same-parameter with input curve 3D on the interval [First, Last]. If the output curve lies on a direct line the infinite line is returned, in the case same-parameter condition is satisfied. TolFirst and TolLast are the tolerances at the ends of input curve 3D.
        	:param c3d:
        	:type c3d: Geom_Curve
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param c2d:
        	:type c2d: Geom2d_Curve
        	:param TolFirst: default value is -1
        	:type TolFirst: float
        	:param TolLast: default value is -1
        	:type TolLast: float
        	:rtype: bool
        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Perform(self, *args)


    def PerformByProjLib(self, *args) -> "Standard_Boolean":
        """
        * Computes the projection of 3d curve onto a surface using the standard algorithm from ProjLib. Returns False if standard projector fails or raises an exception or cuts the curve by parametrical bounds of the surface. Else, if pcurve computed successfully, returns True. The continuity, maxdeg and nbinterval are parameters of call to Approx_CurveOnSurface. If nbinterval is equal to -1 (default), this value is computed depending on source 3d curve and surface.
        	:param c3d:
        	:type c3d: Geom_Curve
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param c2d:
        	:type c2d: Geom2d_Curve
        	:param continuity: default value is GeomAbs_C1
        	:type continuity: GeomAbs_Shape
        	:param maxdeg: default value is 12
        	:type maxdeg: int
        	:param nbinterval: default value is -1
        	:type nbinterval: int
        	:rtype: bool
        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_PerformByProjLib(self, *args)


    def SetPrecision(self, *args) -> "void":
        """
        * Sets value for current precision
        	:param preci:
        	:type preci: float
        	:rtype: None
        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetPrecision(self, *args)


    def SetSurface(self, *args) -> "void":
        """
        * Loads a surface (in the form of Geom_Surface) to project on
        	:param surf:
        	:type surf: Geom_Surface
        	:rtype: None
        * Loads a surface (in the form of ShapeAnalysis_Surface) to project on
        	:param surf:
        	:type surf: ShapeAnalysis_Surface
        	:rtype: None
        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetSurface(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        """
        _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_swiginit(self, _ShapeConstruct.new_ShapeConstruct_ProjectCurveOnSurface(*args))

    def Status(self, *args) -> "Standard_Boolean":
        """
        * Returns the status of last Peform
        	:param theStatus:
        	:type theStatus: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Status(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_ProjectCurveOnSurface
ShapeConstruct_ProjectCurveOnSurface.GetAdjustOverDegenMode = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_GetAdjustOverDegenMode, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.SetAdjustOverDegenMode = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetAdjustOverDegenMode, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.GetBuildCurveMode = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_GetBuildCurveMode, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.SetBuildCurveMode = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetBuildCurveMode, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.Init = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Init, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.Perform = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Perform, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.PerformByProjLib = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_PerformByProjLib, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.SetPrecision = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetPrecision, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.SetSurface = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetSurface, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface.Status = new_instancemethod(_ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Status, None, ShapeConstruct_ProjectCurveOnSurface)
ShapeConstruct_ProjectCurveOnSurface_swigregister = _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_swigregister
ShapeConstruct_ProjectCurveOnSurface_swigregister(ShapeConstruct_ProjectCurveOnSurface)



