# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Transfer module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_transfer.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Transfer.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Transfer')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Transfer')
    _Transfer = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Transfer', [dirname(__file__)])
        except ImportError:
            import _Transfer
            return _Transfer
        try:
            _mod = imp.load_module('_Transfer', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Transfer = swig_import_helper()
    del swig_import_helper
else:
    import _Transfer
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Transfer.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Transfer.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Transfer.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Transfer.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Transfer.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Transfer.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Transfer.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Transfer.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Transfer.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Transfer.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Transfer.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Transfer.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Transfer.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Transfer.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Transfer.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Transfer.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Transfer.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Transfer.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _Transfer.process_exception(error, method_name, class_name)
process_exception = _Transfer.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Interface
import OCC.Core.TCollection
import OCC.Core.TColStd
import OCC.Core.Message
import OCC.Core.MoniTool
import OCC.Core.TopoDS
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.OSD
Transfer_StatusInitial = _Transfer.Transfer_StatusInitial
Transfer_StatusRun = _Transfer.Transfer_StatusRun
Transfer_StatusDone = _Transfer.Transfer_StatusDone
Transfer_StatusError = _Transfer.Transfer_StatusError
Transfer_StatusLoop = _Transfer.Transfer_StatusLoop
Transfer_UndefIgnore = _Transfer.Transfer_UndefIgnore
Transfer_UndefFailure = _Transfer.Transfer_UndefFailure
Transfer_UndefContent = _Transfer.Transfer_UndefContent
Transfer_UndefUser = _Transfer.Transfer_UndefUser
Transfer_StatusVoid = _Transfer.Transfer_StatusVoid
Transfer_StatusDefined = _Transfer.Transfer_StatusDefined
Transfer_StatusUsed = _Transfer.Transfer_StatusUsed

def Handle_Transfer_ActorOfProcessForFinder_Create() -> "opencascade::handle< Transfer_ActorOfProcessForFinder >":
    return _Transfer.Handle_Transfer_ActorOfProcessForFinder_Create()
Handle_Transfer_ActorOfProcessForFinder_Create = _Transfer.Handle_Transfer_ActorOfProcessForFinder_Create

def Handle_Transfer_ActorOfProcessForFinder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_ActorOfProcessForFinder >":
    return _Transfer.Handle_Transfer_ActorOfProcessForFinder_DownCast(t)
Handle_Transfer_ActorOfProcessForFinder_DownCast = _Transfer.Handle_Transfer_ActorOfProcessForFinder_DownCast

def Handle_Transfer_ActorOfProcessForFinder_IsNull(t: 'opencascade::handle< Transfer_ActorOfProcessForFinder > const &') -> "bool":
    return _Transfer.Handle_Transfer_ActorOfProcessForFinder_IsNull(t)
Handle_Transfer_ActorOfProcessForFinder_IsNull = _Transfer.Handle_Transfer_ActorOfProcessForFinder_IsNull

def Handle_Transfer_ActorOfProcessForTransient_Create() -> "opencascade::handle< Transfer_ActorOfProcessForTransient >":
    return _Transfer.Handle_Transfer_ActorOfProcessForTransient_Create()
Handle_Transfer_ActorOfProcessForTransient_Create = _Transfer.Handle_Transfer_ActorOfProcessForTransient_Create

def Handle_Transfer_ActorOfProcessForTransient_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_ActorOfProcessForTransient >":
    return _Transfer.Handle_Transfer_ActorOfProcessForTransient_DownCast(t)
Handle_Transfer_ActorOfProcessForTransient_DownCast = _Transfer.Handle_Transfer_ActorOfProcessForTransient_DownCast

def Handle_Transfer_ActorOfProcessForTransient_IsNull(t: 'opencascade::handle< Transfer_ActorOfProcessForTransient > const &') -> "bool":
    return _Transfer.Handle_Transfer_ActorOfProcessForTransient_IsNull(t)
Handle_Transfer_ActorOfProcessForTransient_IsNull = _Transfer.Handle_Transfer_ActorOfProcessForTransient_IsNull

def Handle_Transfer_Binder_Create() -> "opencascade::handle< Transfer_Binder >":
    return _Transfer.Handle_Transfer_Binder_Create()
Handle_Transfer_Binder_Create = _Transfer.Handle_Transfer_Binder_Create

def Handle_Transfer_Binder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_Binder >":
    return _Transfer.Handle_Transfer_Binder_DownCast(t)
Handle_Transfer_Binder_DownCast = _Transfer.Handle_Transfer_Binder_DownCast

def Handle_Transfer_Binder_IsNull(t: 'opencascade::handle< Transfer_Binder > const &') -> "bool":
    return _Transfer.Handle_Transfer_Binder_IsNull(t)
Handle_Transfer_Binder_IsNull = _Transfer.Handle_Transfer_Binder_IsNull

def Handle_Transfer_DispatchControl_Create() -> "opencascade::handle< Transfer_DispatchControl >":
    return _Transfer.Handle_Transfer_DispatchControl_Create()
Handle_Transfer_DispatchControl_Create = _Transfer.Handle_Transfer_DispatchControl_Create

def Handle_Transfer_DispatchControl_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_DispatchControl >":
    return _Transfer.Handle_Transfer_DispatchControl_DownCast(t)
Handle_Transfer_DispatchControl_DownCast = _Transfer.Handle_Transfer_DispatchControl_DownCast

def Handle_Transfer_DispatchControl_IsNull(t: 'opencascade::handle< Transfer_DispatchControl > const &') -> "bool":
    return _Transfer.Handle_Transfer_DispatchControl_IsNull(t)
Handle_Transfer_DispatchControl_IsNull = _Transfer.Handle_Transfer_DispatchControl_IsNull

def Handle_Transfer_Finder_Create() -> "opencascade::handle< Transfer_Finder >":
    return _Transfer.Handle_Transfer_Finder_Create()
Handle_Transfer_Finder_Create = _Transfer.Handle_Transfer_Finder_Create

def Handle_Transfer_Finder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_Finder >":
    return _Transfer.Handle_Transfer_Finder_DownCast(t)
Handle_Transfer_Finder_DownCast = _Transfer.Handle_Transfer_Finder_DownCast

def Handle_Transfer_Finder_IsNull(t: 'opencascade::handle< Transfer_Finder > const &') -> "bool":
    return _Transfer.Handle_Transfer_Finder_IsNull(t)
Handle_Transfer_Finder_IsNull = _Transfer.Handle_Transfer_Finder_IsNull

def Handle_Transfer_MapContainer_Create() -> "opencascade::handle< Transfer_MapContainer >":
    return _Transfer.Handle_Transfer_MapContainer_Create()
Handle_Transfer_MapContainer_Create = _Transfer.Handle_Transfer_MapContainer_Create

def Handle_Transfer_MapContainer_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_MapContainer >":
    return _Transfer.Handle_Transfer_MapContainer_DownCast(t)
Handle_Transfer_MapContainer_DownCast = _Transfer.Handle_Transfer_MapContainer_DownCast

def Handle_Transfer_MapContainer_IsNull(t: 'opencascade::handle< Transfer_MapContainer > const &') -> "bool":
    return _Transfer.Handle_Transfer_MapContainer_IsNull(t)
Handle_Transfer_MapContainer_IsNull = _Transfer.Handle_Transfer_MapContainer_IsNull

def Handle_Transfer_ProcessForTransient_Create() -> "opencascade::handle< Transfer_ProcessForTransient >":
    return _Transfer.Handle_Transfer_ProcessForTransient_Create()
Handle_Transfer_ProcessForTransient_Create = _Transfer.Handle_Transfer_ProcessForTransient_Create

def Handle_Transfer_ProcessForTransient_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_ProcessForTransient >":
    return _Transfer.Handle_Transfer_ProcessForTransient_DownCast(t)
Handle_Transfer_ProcessForTransient_DownCast = _Transfer.Handle_Transfer_ProcessForTransient_DownCast

def Handle_Transfer_ProcessForTransient_IsNull(t: 'opencascade::handle< Transfer_ProcessForTransient > const &') -> "bool":
    return _Transfer.Handle_Transfer_ProcessForTransient_IsNull(t)
Handle_Transfer_ProcessForTransient_IsNull = _Transfer.Handle_Transfer_ProcessForTransient_IsNull

def Handle_Transfer_ResultFromModel_Create() -> "opencascade::handle< Transfer_ResultFromModel >":
    return _Transfer.Handle_Transfer_ResultFromModel_Create()
Handle_Transfer_ResultFromModel_Create = _Transfer.Handle_Transfer_ResultFromModel_Create

def Handle_Transfer_ResultFromModel_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_ResultFromModel >":
    return _Transfer.Handle_Transfer_ResultFromModel_DownCast(t)
Handle_Transfer_ResultFromModel_DownCast = _Transfer.Handle_Transfer_ResultFromModel_DownCast

def Handle_Transfer_ResultFromModel_IsNull(t: 'opencascade::handle< Transfer_ResultFromModel > const &') -> "bool":
    return _Transfer.Handle_Transfer_ResultFromModel_IsNull(t)
Handle_Transfer_ResultFromModel_IsNull = _Transfer.Handle_Transfer_ResultFromModel_IsNull

def Handle_Transfer_ResultFromTransient_Create() -> "opencascade::handle< Transfer_ResultFromTransient >":
    return _Transfer.Handle_Transfer_ResultFromTransient_Create()
Handle_Transfer_ResultFromTransient_Create = _Transfer.Handle_Transfer_ResultFromTransient_Create

def Handle_Transfer_ResultFromTransient_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_ResultFromTransient >":
    return _Transfer.Handle_Transfer_ResultFromTransient_DownCast(t)
Handle_Transfer_ResultFromTransient_DownCast = _Transfer.Handle_Transfer_ResultFromTransient_DownCast

def Handle_Transfer_ResultFromTransient_IsNull(t: 'opencascade::handle< Transfer_ResultFromTransient > const &') -> "bool":
    return _Transfer.Handle_Transfer_ResultFromTransient_IsNull(t)
Handle_Transfer_ResultFromTransient_IsNull = _Transfer.Handle_Transfer_ResultFromTransient_IsNull

def Handle_Transfer_ActorOfFinderProcess_Create() -> "opencascade::handle< Transfer_ActorOfFinderProcess >":
    return _Transfer.Handle_Transfer_ActorOfFinderProcess_Create()
Handle_Transfer_ActorOfFinderProcess_Create = _Transfer.Handle_Transfer_ActorOfFinderProcess_Create

def Handle_Transfer_ActorOfFinderProcess_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_ActorOfFinderProcess >":
    return _Transfer.Handle_Transfer_ActorOfFinderProcess_DownCast(t)
Handle_Transfer_ActorOfFinderProcess_DownCast = _Transfer.Handle_Transfer_ActorOfFinderProcess_DownCast

def Handle_Transfer_ActorOfFinderProcess_IsNull(t: 'opencascade::handle< Transfer_ActorOfFinderProcess > const &') -> "bool":
    return _Transfer.Handle_Transfer_ActorOfFinderProcess_IsNull(t)
Handle_Transfer_ActorOfFinderProcess_IsNull = _Transfer.Handle_Transfer_ActorOfFinderProcess_IsNull

def Handle_Transfer_ActorOfTransientProcess_Create() -> "opencascade::handle< Transfer_ActorOfTransientProcess >":
    return _Transfer.Handle_Transfer_ActorOfTransientProcess_Create()
Handle_Transfer_ActorOfTransientProcess_Create = _Transfer.Handle_Transfer_ActorOfTransientProcess_Create

def Handle_Transfer_ActorOfTransientProcess_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_ActorOfTransientProcess >":
    return _Transfer.Handle_Transfer_ActorOfTransientProcess_DownCast(t)
Handle_Transfer_ActorOfTransientProcess_DownCast = _Transfer.Handle_Transfer_ActorOfTransientProcess_DownCast

def Handle_Transfer_ActorOfTransientProcess_IsNull(t: 'opencascade::handle< Transfer_ActorOfTransientProcess > const &') -> "bool":
    return _Transfer.Handle_Transfer_ActorOfTransientProcess_IsNull(t)
Handle_Transfer_ActorOfTransientProcess_IsNull = _Transfer.Handle_Transfer_ActorOfTransientProcess_IsNull

def Handle_Transfer_FinderProcess_Create() -> "opencascade::handle< Transfer_FinderProcess >":
    return _Transfer.Handle_Transfer_FinderProcess_Create()
Handle_Transfer_FinderProcess_Create = _Transfer.Handle_Transfer_FinderProcess_Create

def Handle_Transfer_FinderProcess_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_FinderProcess >":
    return _Transfer.Handle_Transfer_FinderProcess_DownCast(t)
Handle_Transfer_FinderProcess_DownCast = _Transfer.Handle_Transfer_FinderProcess_DownCast

def Handle_Transfer_FinderProcess_IsNull(t: 'opencascade::handle< Transfer_FinderProcess > const &') -> "bool":
    return _Transfer.Handle_Transfer_FinderProcess_IsNull(t)
Handle_Transfer_FinderProcess_IsNull = _Transfer.Handle_Transfer_FinderProcess_IsNull

def Handle_Transfer_MultipleBinder_Create() -> "opencascade::handle< Transfer_MultipleBinder >":
    return _Transfer.Handle_Transfer_MultipleBinder_Create()
Handle_Transfer_MultipleBinder_Create = _Transfer.Handle_Transfer_MultipleBinder_Create

def Handle_Transfer_MultipleBinder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_MultipleBinder >":
    return _Transfer.Handle_Transfer_MultipleBinder_DownCast(t)
Handle_Transfer_MultipleBinder_DownCast = _Transfer.Handle_Transfer_MultipleBinder_DownCast

def Handle_Transfer_MultipleBinder_IsNull(t: 'opencascade::handle< Transfer_MultipleBinder > const &') -> "bool":
    return _Transfer.Handle_Transfer_MultipleBinder_IsNull(t)
Handle_Transfer_MultipleBinder_IsNull = _Transfer.Handle_Transfer_MultipleBinder_IsNull

def Handle_Transfer_SimpleBinderOfTransient_Create() -> "opencascade::handle< Transfer_SimpleBinderOfTransient >":
    return _Transfer.Handle_Transfer_SimpleBinderOfTransient_Create()
Handle_Transfer_SimpleBinderOfTransient_Create = _Transfer.Handle_Transfer_SimpleBinderOfTransient_Create

def Handle_Transfer_SimpleBinderOfTransient_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_SimpleBinderOfTransient >":
    return _Transfer.Handle_Transfer_SimpleBinderOfTransient_DownCast(t)
Handle_Transfer_SimpleBinderOfTransient_DownCast = _Transfer.Handle_Transfer_SimpleBinderOfTransient_DownCast

def Handle_Transfer_SimpleBinderOfTransient_IsNull(t: 'opencascade::handle< Transfer_SimpleBinderOfTransient > const &') -> "bool":
    return _Transfer.Handle_Transfer_SimpleBinderOfTransient_IsNull(t)
Handle_Transfer_SimpleBinderOfTransient_IsNull = _Transfer.Handle_Transfer_SimpleBinderOfTransient_IsNull

def Handle_Transfer_TransientListBinder_Create() -> "opencascade::handle< Transfer_TransientListBinder >":
    return _Transfer.Handle_Transfer_TransientListBinder_Create()
Handle_Transfer_TransientListBinder_Create = _Transfer.Handle_Transfer_TransientListBinder_Create

def Handle_Transfer_TransientListBinder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_TransientListBinder >":
    return _Transfer.Handle_Transfer_TransientListBinder_DownCast(t)
Handle_Transfer_TransientListBinder_DownCast = _Transfer.Handle_Transfer_TransientListBinder_DownCast

def Handle_Transfer_TransientListBinder_IsNull(t: 'opencascade::handle< Transfer_TransientListBinder > const &') -> "bool":
    return _Transfer.Handle_Transfer_TransientListBinder_IsNull(t)
Handle_Transfer_TransientListBinder_IsNull = _Transfer.Handle_Transfer_TransientListBinder_IsNull

def Handle_Transfer_TransientMapper_Create() -> "opencascade::handle< Transfer_TransientMapper >":
    return _Transfer.Handle_Transfer_TransientMapper_Create()
Handle_Transfer_TransientMapper_Create = _Transfer.Handle_Transfer_TransientMapper_Create

def Handle_Transfer_TransientMapper_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_TransientMapper >":
    return _Transfer.Handle_Transfer_TransientMapper_DownCast(t)
Handle_Transfer_TransientMapper_DownCast = _Transfer.Handle_Transfer_TransientMapper_DownCast

def Handle_Transfer_TransientMapper_IsNull(t: 'opencascade::handle< Transfer_TransientMapper > const &') -> "bool":
    return _Transfer.Handle_Transfer_TransientMapper_IsNull(t)
Handle_Transfer_TransientMapper_IsNull = _Transfer.Handle_Transfer_TransientMapper_IsNull

def Handle_Transfer_TransientProcess_Create() -> "opencascade::handle< Transfer_TransientProcess >":
    return _Transfer.Handle_Transfer_TransientProcess_Create()
Handle_Transfer_TransientProcess_Create = _Transfer.Handle_Transfer_TransientProcess_Create

def Handle_Transfer_TransientProcess_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_TransientProcess >":
    return _Transfer.Handle_Transfer_TransientProcess_DownCast(t)
Handle_Transfer_TransientProcess_DownCast = _Transfer.Handle_Transfer_TransientProcess_DownCast

def Handle_Transfer_TransientProcess_IsNull(t: 'opencascade::handle< Transfer_TransientProcess > const &') -> "bool":
    return _Transfer.Handle_Transfer_TransientProcess_IsNull(t)
Handle_Transfer_TransientProcess_IsNull = _Transfer.Handle_Transfer_TransientProcess_IsNull

def Handle_Transfer_VoidBinder_Create() -> "opencascade::handle< Transfer_VoidBinder >":
    return _Transfer.Handle_Transfer_VoidBinder_Create()
Handle_Transfer_VoidBinder_Create = _Transfer.Handle_Transfer_VoidBinder_Create

def Handle_Transfer_VoidBinder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_VoidBinder >":
    return _Transfer.Handle_Transfer_VoidBinder_DownCast(t)
Handle_Transfer_VoidBinder_DownCast = _Transfer.Handle_Transfer_VoidBinder_DownCast

def Handle_Transfer_VoidBinder_IsNull(t: 'opencascade::handle< Transfer_VoidBinder > const &') -> "bool":
    return _Transfer.Handle_Transfer_VoidBinder_IsNull(t)
Handle_Transfer_VoidBinder_IsNull = _Transfer.Handle_Transfer_VoidBinder_IsNull

def Handle_Transfer_ActorDispatch_Create() -> "opencascade::handle< Transfer_ActorDispatch >":
    return _Transfer.Handle_Transfer_ActorDispatch_Create()
Handle_Transfer_ActorDispatch_Create = _Transfer.Handle_Transfer_ActorDispatch_Create

def Handle_Transfer_ActorDispatch_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_ActorDispatch >":
    return _Transfer.Handle_Transfer_ActorDispatch_DownCast(t)
Handle_Transfer_ActorDispatch_DownCast = _Transfer.Handle_Transfer_ActorDispatch_DownCast

def Handle_Transfer_ActorDispatch_IsNull(t: 'opencascade::handle< Transfer_ActorDispatch > const &') -> "bool":
    return _Transfer.Handle_Transfer_ActorDispatch_IsNull(t)
Handle_Transfer_ActorDispatch_IsNull = _Transfer.Handle_Transfer_ActorDispatch_IsNull

def Handle_Transfer_BinderOfTransientInteger_Create() -> "opencascade::handle< Transfer_BinderOfTransientInteger >":
    return _Transfer.Handle_Transfer_BinderOfTransientInteger_Create()
Handle_Transfer_BinderOfTransientInteger_Create = _Transfer.Handle_Transfer_BinderOfTransientInteger_Create

def Handle_Transfer_BinderOfTransientInteger_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_BinderOfTransientInteger >":
    return _Transfer.Handle_Transfer_BinderOfTransientInteger_DownCast(t)
Handle_Transfer_BinderOfTransientInteger_DownCast = _Transfer.Handle_Transfer_BinderOfTransientInteger_DownCast

def Handle_Transfer_BinderOfTransientInteger_IsNull(t: 'opencascade::handle< Transfer_BinderOfTransientInteger > const &') -> "bool":
    return _Transfer.Handle_Transfer_BinderOfTransientInteger_IsNull(t)
Handle_Transfer_BinderOfTransientInteger_IsNull = _Transfer.Handle_Transfer_BinderOfTransientInteger_IsNull

def Handle_Transfer_HSequenceOfBinder_Create() -> "opencascade::handle< Transfer_HSequenceOfBinder >":
    return _Transfer.Handle_Transfer_HSequenceOfBinder_Create()
Handle_Transfer_HSequenceOfBinder_Create = _Transfer.Handle_Transfer_HSequenceOfBinder_Create

def Handle_Transfer_HSequenceOfBinder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_HSequenceOfBinder >":
    return _Transfer.Handle_Transfer_HSequenceOfBinder_DownCast(t)
Handle_Transfer_HSequenceOfBinder_DownCast = _Transfer.Handle_Transfer_HSequenceOfBinder_DownCast

def Handle_Transfer_HSequenceOfBinder_IsNull(t: 'opencascade::handle< Transfer_HSequenceOfBinder > const &') -> "bool":
    return _Transfer.Handle_Transfer_HSequenceOfBinder_IsNull(t)
Handle_Transfer_HSequenceOfBinder_IsNull = _Transfer.Handle_Transfer_HSequenceOfBinder_IsNull

def Handle_Transfer_HSequenceOfFinder_Create() -> "opencascade::handle< Transfer_HSequenceOfFinder >":
    return _Transfer.Handle_Transfer_HSequenceOfFinder_Create()
Handle_Transfer_HSequenceOfFinder_Create = _Transfer.Handle_Transfer_HSequenceOfFinder_Create

def Handle_Transfer_HSequenceOfFinder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Transfer_HSequenceOfFinder >":
    return _Transfer.Handle_Transfer_HSequenceOfFinder_DownCast(t)
Handle_Transfer_HSequenceOfFinder_DownCast = _Transfer.Handle_Transfer_HSequenceOfFinder_DownCast

def Handle_Transfer_HSequenceOfFinder_IsNull(t: 'opencascade::handle< Transfer_HSequenceOfFinder > const &') -> "bool":
    return _Transfer.Handle_Transfer_HSequenceOfFinder_IsNull(t)
Handle_Transfer_HSequenceOfFinder_IsNull = _Transfer.Handle_Transfer_HSequenceOfFinder_IsNull
class Transfer_TransferMapOfProcessForTransient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Transfer.Transfer_TransferMapOfProcessForTransient_swiginit(self, _Transfer.new_Transfer_TransferMapOfProcessForTransient(*args))
    __swig_destroy__ = _Transfer.delete_Transfer_TransferMapOfProcessForTransient
Transfer_TransferMapOfProcessForTransient.begin = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_begin, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.end = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_end, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.cbegin = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_cbegin, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.cend = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_cend, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Exchange = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Exchange, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Assign = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Assign, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Set = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Set, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.ReSize = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_ReSize, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Add = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Add, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Contains = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Contains, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Substitute = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Substitute, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Swap = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Swap, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.RemoveLast = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_RemoveLast, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.RemoveFromIndex = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_RemoveFromIndex, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.RemoveKey = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_RemoveKey, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.FindKey = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_FindKey, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.FindFromIndex = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_FindFromIndex, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.ChangeFromIndex = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_ChangeFromIndex, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.__call__ = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient___call__, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.FindIndex = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_FindIndex, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.ChangeFromKey = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_ChangeFromKey, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Seek = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Seek, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.ChangeSeek = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_ChangeSeek, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.FindFromKey = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_FindFromKey, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Clear = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Clear, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient.Size = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForTransient_Size, None, Transfer_TransferMapOfProcessForTransient)
Transfer_TransferMapOfProcessForTransient_swigregister = _Transfer.Transfer_TransferMapOfProcessForTransient_swigregister
Transfer_TransferMapOfProcessForTransient_swigregister(Transfer_TransferMapOfProcessForTransient)

class Transfer_SequenceOfBinder(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Transfer.Transfer_SequenceOfBinder_swiginit(self, _Transfer.new_Transfer_SequenceOfBinder(*args))
    delNode = staticmethod(_Transfer.Transfer_SequenceOfBinder_delNode)
    __swig_destroy__ = _Transfer.delete_Transfer_SequenceOfBinder
Transfer_SequenceOfBinder.begin = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_begin, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.end = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_end, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.cbegin = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_cbegin, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.cend = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_cend, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Size = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Size, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Length = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Length, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Lower = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Lower, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Upper = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Upper, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.IsEmpty = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_IsEmpty, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Reverse = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Reverse, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Exchange = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Exchange, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Clear = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Clear, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Assign = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Assign, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Set = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Set, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Remove = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Remove, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Append = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Append, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Prepend = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Prepend, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.InsertBefore = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_InsertBefore, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.InsertAfter = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_InsertAfter, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Split = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Split, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.First = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_First, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.ChangeFirst = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_ChangeFirst, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Last = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Last, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.ChangeLast = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_ChangeLast, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.Value = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_Value, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.ChangeValue = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_ChangeValue, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.__call__ = new_instancemethod(_Transfer.Transfer_SequenceOfBinder___call__, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder.SetValue = new_instancemethod(_Transfer.Transfer_SequenceOfBinder_SetValue, None, Transfer_SequenceOfBinder)
Transfer_SequenceOfBinder_swigregister = _Transfer.Transfer_SequenceOfBinder_swigregister
Transfer_SequenceOfBinder_swigregister(Transfer_SequenceOfBinder)

def Transfer_SequenceOfBinder_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _Transfer.Transfer_SequenceOfBinder_delNode(theNode, theAl)
Transfer_SequenceOfBinder_delNode = _Transfer.Transfer_SequenceOfBinder_delNode

class Transfer_SequenceOfFinder(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Transfer.Transfer_SequenceOfFinder_swiginit(self, _Transfer.new_Transfer_SequenceOfFinder(*args))
    delNode = staticmethod(_Transfer.Transfer_SequenceOfFinder_delNode)
    __swig_destroy__ = _Transfer.delete_Transfer_SequenceOfFinder
Transfer_SequenceOfFinder.begin = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_begin, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.end = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_end, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.cbegin = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_cbegin, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.cend = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_cend, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Size = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Size, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Length = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Length, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Lower = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Lower, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Upper = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Upper, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.IsEmpty = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_IsEmpty, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Reverse = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Reverse, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Exchange = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Exchange, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Clear = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Clear, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Assign = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Assign, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Set = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Set, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Remove = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Remove, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Append = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Append, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Prepend = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Prepend, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.InsertBefore = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_InsertBefore, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.InsertAfter = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_InsertAfter, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Split = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Split, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.First = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_First, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.ChangeFirst = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_ChangeFirst, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Last = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Last, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.ChangeLast = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_ChangeLast, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.Value = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_Value, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.ChangeValue = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_ChangeValue, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.__call__ = new_instancemethod(_Transfer.Transfer_SequenceOfFinder___call__, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder.SetValue = new_instancemethod(_Transfer.Transfer_SequenceOfFinder_SetValue, None, Transfer_SequenceOfFinder)
Transfer_SequenceOfFinder_swigregister = _Transfer.Transfer_SequenceOfFinder_swigregister
Transfer_SequenceOfFinder_swigregister(Transfer_SequenceOfFinder)

def Transfer_SequenceOfFinder_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _Transfer.Transfer_SequenceOfFinder_delNode(theNode, theAl)
Transfer_SequenceOfFinder_delNode = _Transfer.Transfer_SequenceOfFinder_delNode

class Transfer_TransferMapOfProcessForFinder(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Transfer.Transfer_TransferMapOfProcessForFinder_swiginit(self, _Transfer.new_Transfer_TransferMapOfProcessForFinder(*args))
    __swig_destroy__ = _Transfer.delete_Transfer_TransferMapOfProcessForFinder
Transfer_TransferMapOfProcessForFinder.begin = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_begin, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.end = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_end, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.cbegin = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_cbegin, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.cend = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_cend, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Exchange = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Exchange, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Assign = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Assign, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Set = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Set, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.ReSize = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_ReSize, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Add = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Add, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Contains = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Contains, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Substitute = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Substitute, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Swap = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Swap, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.RemoveLast = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_RemoveLast, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.RemoveFromIndex = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_RemoveFromIndex, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.RemoveKey = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_RemoveKey, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.FindKey = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_FindKey, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.FindFromIndex = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_FindFromIndex, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.ChangeFromIndex = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_ChangeFromIndex, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.__call__ = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder___call__, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.FindIndex = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_FindIndex, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.ChangeFromKey = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_ChangeFromKey, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Seek = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Seek, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.ChangeSeek = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_ChangeSeek, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.FindFromKey = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_FindFromKey, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Clear = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Clear, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder.Size = new_instancemethod(_Transfer.Transfer_TransferMapOfProcessForFinder_Size, None, Transfer_TransferMapOfProcessForFinder)
Transfer_TransferMapOfProcessForFinder_swigregister = _Transfer.Transfer_TransferMapOfProcessForFinder_swigregister
Transfer_TransferMapOfProcessForFinder_swigregister(Transfer_TransferMapOfProcessForFinder)

class Transfer_ActorOfProcessForFinder(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsLast(self, *args) -> "Standard_Boolean":
        """
        * Returns the Last status (see SetLast).
        	:rtype: bool
        """
        return _Transfer.Transfer_ActorOfProcessForFinder_IsLast(self, *args)


    def Next(self, *args) -> "opencascade::handle< Transfer_ActorOfProcessForFinder >":
        """
        * Returns the Actor defined as Next, or a Null Handle
        	:rtype: opencascade::handle<Transfer_ActorOfProcessForFinder>
        """
        return _Transfer.Transfer_ActorOfProcessForFinder_Next(self, *args)


    def NullResult(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Returns a Binder for No Result, i.e. a Null Handle
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ActorOfProcessForFinder_NullResult(self, *args)


    def Recognize(self, *args) -> "Standard_Boolean":
        """
        * Prerequesite for Transfer : the method Transfer is called on a starting object only if Recognize has returned True on it This allows to define a list of Actors, each one processing a definite kind of data TransferProcess calls Recognize on each one before calling Transfer. But even if Recognize has returned True, Transfer can reject by returning a Null Binder (afterwards rejection), the next actor is then invoked //! The provided default returns True, can be redefined
        	:param start:
        	:type start: Transfer_Finder
        	:rtype: bool
        """
        return _Transfer.Transfer_ActorOfProcessForFinder_Recognize(self, *args)


    def SetLast(self, *args) -> "void":
        """
        * If <mode> is True, commands an Actor to be set at the end of the list of Actors (see SetNext) If it is False (creation default), each add Actor is set at the beginning of the list This allows to define default Actors (which are Last)
        	:param mode: default value is Standard_True
        	:type mode: bool
        	:rtype: None
        """
        return _Transfer.Transfer_ActorOfProcessForFinder_SetLast(self, *args)


    def SetNext(self, *args) -> "void":
        """
        * Defines a Next Actor : it can then be asked to work if <self> produces no result for a given type of Object. If Next is already set and is not 'Last', calls SetNext on it. If Next defined and 'Last', the new actor is added before it in the list
        	:param next:
        	:type next: Transfer_ActorOfProcessForFinder
        	:rtype: None
        """
        return _Transfer.Transfer_ActorOfProcessForFinder_SetNext(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _Transfer.Transfer_ActorOfProcessForFinder_swiginit(self, _Transfer.new_Transfer_ActorOfProcessForFinder(*args))

    def Transferring(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Specific action of Transfer. The Result is stored in the returned Binder, or a Null Handle for 'No result' (Default defined as doing nothing; should be deffered) 'mutable' allows the Actor to record intermediate information, in addition to those of TransferProcess
        	:param start:
        	:type start: Transfer_Finder
        	:param TP:
        	:type TP: Transfer_ProcessForFinder
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ActorOfProcessForFinder_Transferring(self, *args)


    def TransientResult(self, *args) -> "opencascade::handle< Transfer_SimpleBinderOfTransient >":
        """
        * Prepares and Returns a Binder for a Transient Result Returns a Null Handle if <res> is itself Null
        	:param res:
        	:type res: Standard_Transient
        	:rtype: opencascade::handle<Transfer_SimpleBinderOfTransient>
        """
        return _Transfer.Transfer_ActorOfProcessForFinder_TransientResult(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_ActorOfProcessForFinder_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_ActorOfProcessForFinder
Transfer_ActorOfProcessForFinder.IsLast = new_instancemethod(_Transfer.Transfer_ActorOfProcessForFinder_IsLast, None, Transfer_ActorOfProcessForFinder)
Transfer_ActorOfProcessForFinder.Next = new_instancemethod(_Transfer.Transfer_ActorOfProcessForFinder_Next, None, Transfer_ActorOfProcessForFinder)
Transfer_ActorOfProcessForFinder.NullResult = new_instancemethod(_Transfer.Transfer_ActorOfProcessForFinder_NullResult, None, Transfer_ActorOfProcessForFinder)
Transfer_ActorOfProcessForFinder.Recognize = new_instancemethod(_Transfer.Transfer_ActorOfProcessForFinder_Recognize, None, Transfer_ActorOfProcessForFinder)
Transfer_ActorOfProcessForFinder.SetLast = new_instancemethod(_Transfer.Transfer_ActorOfProcessForFinder_SetLast, None, Transfer_ActorOfProcessForFinder)
Transfer_ActorOfProcessForFinder.SetNext = new_instancemethod(_Transfer.Transfer_ActorOfProcessForFinder_SetNext, None, Transfer_ActorOfProcessForFinder)
Transfer_ActorOfProcessForFinder.Transferring = new_instancemethod(_Transfer.Transfer_ActorOfProcessForFinder_Transferring, None, Transfer_ActorOfProcessForFinder)
Transfer_ActorOfProcessForFinder.TransientResult = new_instancemethod(_Transfer.Transfer_ActorOfProcessForFinder_TransientResult, None, Transfer_ActorOfProcessForFinder)
Transfer_ActorOfProcessForFinder_swigregister = _Transfer.Transfer_ActorOfProcessForFinder_swigregister
Transfer_ActorOfProcessForFinder_swigregister(Transfer_ActorOfProcessForFinder)

class Transfer_ActorOfProcessForTransient(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsLast(self, *args) -> "Standard_Boolean":
        """
        * Returns the Last status (see SetLast).
        	:rtype: bool
        """
        return _Transfer.Transfer_ActorOfProcessForTransient_IsLast(self, *args)


    def Next(self, *args) -> "opencascade::handle< Transfer_ActorOfProcessForTransient >":
        """
        * Returns the Actor defined as Next, or a Null Handle
        	:rtype: opencascade::handle<Transfer_ActorOfProcessForTransient>
        """
        return _Transfer.Transfer_ActorOfProcessForTransient_Next(self, *args)


    def NullResult(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Returns a Binder for No Result, i.e. a Null Handle
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ActorOfProcessForTransient_NullResult(self, *args)


    def Recognize(self, *args) -> "Standard_Boolean":
        """
        * Prerequesite for Transfer : the method Transfer is called on a starting object only if Recognize has returned True on it This allows to define a list of Actors, each one processing a definite kind of data TransferProcess calls Recognize on each one before calling Transfer. But even if Recognize has returned True, Transfer can reject by returning a Null Binder (afterwards rejection), the next actor is then invoked //! The provided default returns True, can be redefined
        	:param start:
        	:type start: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_ActorOfProcessForTransient_Recognize(self, *args)


    def SetLast(self, *args) -> "void":
        """
        * If <mode> is True, commands an Actor to be set at the end of the list of Actors (see SetNext) If it is False (creation default), each add Actor is set at the beginning of the list This allows to define default Actors (which are Last)
        	:param mode: default value is Standard_True
        	:type mode: bool
        	:rtype: None
        """
        return _Transfer.Transfer_ActorOfProcessForTransient_SetLast(self, *args)


    def SetNext(self, *args) -> "void":
        """
        * Defines a Next Actor : it can then be asked to work if <self> produces no result for a given type of Object. If Next is already set and is not 'Last', calls SetNext on it. If Next defined and 'Last', the new actor is added before it in the list
        	:param next:
        	:type next: Transfer_ActorOfProcessForTransient
        	:rtype: None
        """
        return _Transfer.Transfer_ActorOfProcessForTransient_SetNext(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _Transfer.Transfer_ActorOfProcessForTransient_swiginit(self, _Transfer.new_Transfer_ActorOfProcessForTransient(*args))

    def Transferring(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Specific action of Transfer. The Result is stored in the returned Binder, or a Null Handle for 'No result' (Default defined as doing nothing; should be deffered) 'mutable' allows the Actor to record intermediate information, in addition to those of TransferProcess
        	:param start:
        	:type start: Standard_Transient
        	:param TP:
        	:type TP: Transfer_ProcessForTransient
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ActorOfProcessForTransient_Transferring(self, *args)


    def TransientResult(self, *args) -> "opencascade::handle< Transfer_SimpleBinderOfTransient >":
        """
        * Prepares and Returns a Binder for a Transient Result Returns a Null Handle if <res> is itself Null
        	:param res:
        	:type res: Standard_Transient
        	:rtype: opencascade::handle<Transfer_SimpleBinderOfTransient>
        """
        return _Transfer.Transfer_ActorOfProcessForTransient_TransientResult(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_ActorOfProcessForTransient_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_ActorOfProcessForTransient
Transfer_ActorOfProcessForTransient.IsLast = new_instancemethod(_Transfer.Transfer_ActorOfProcessForTransient_IsLast, None, Transfer_ActorOfProcessForTransient)
Transfer_ActorOfProcessForTransient.Next = new_instancemethod(_Transfer.Transfer_ActorOfProcessForTransient_Next, None, Transfer_ActorOfProcessForTransient)
Transfer_ActorOfProcessForTransient.NullResult = new_instancemethod(_Transfer.Transfer_ActorOfProcessForTransient_NullResult, None, Transfer_ActorOfProcessForTransient)
Transfer_ActorOfProcessForTransient.Recognize = new_instancemethod(_Transfer.Transfer_ActorOfProcessForTransient_Recognize, None, Transfer_ActorOfProcessForTransient)
Transfer_ActorOfProcessForTransient.SetLast = new_instancemethod(_Transfer.Transfer_ActorOfProcessForTransient_SetLast, None, Transfer_ActorOfProcessForTransient)
Transfer_ActorOfProcessForTransient.SetNext = new_instancemethod(_Transfer.Transfer_ActorOfProcessForTransient_SetNext, None, Transfer_ActorOfProcessForTransient)
Transfer_ActorOfProcessForTransient.Transferring = new_instancemethod(_Transfer.Transfer_ActorOfProcessForTransient_Transferring, None, Transfer_ActorOfProcessForTransient)
Transfer_ActorOfProcessForTransient.TransientResult = new_instancemethod(_Transfer.Transfer_ActorOfProcessForTransient_TransientResult, None, Transfer_ActorOfProcessForTransient)
Transfer_ActorOfProcessForTransient_swigregister = _Transfer.Transfer_ActorOfProcessForTransient_swigregister
Transfer_ActorOfProcessForTransient_swigregister(Transfer_ActorOfProcessForTransient)

class Transfer_Binder(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddFail(self, *args) -> "void":
        """
        * Used to declare an individual transfer as beeing erroneous (Status is set to Void, StatusExec is set to Error, <errmess> is added to Check's list of Fails) It is possible to record several messages of error //! It has same effect for TransferProcess as raising an exception during the operation of Transfer, except the Transfer tries to continue (as if ErrorHandle had been set)
        	:param mess:
        	:type mess: char *
        	:param orig: default value is 
        	:type orig: char *
        	:rtype: None
        """
        return _Transfer.Transfer_Binder_AddFail(self, *args)


    def AddResult(self, *args) -> "void":
        """
        * Adds a next result (at the end of the list) Remark : this information is not processed by Merge
        	:param next:
        	:type next: Transfer_Binder
        	:rtype: None
        """
        return _Transfer.Transfer_Binder_AddResult(self, *args)


    def AddWarning(self, *args) -> "void":
        """
        * Used to attach a Warning Message to an individual Transfer It has no effect on the Status
        	:param mess:
        	:type mess: char *
        	:param orig: default value is 
        	:type orig: char *
        	:rtype: None
        """
        return _Transfer.Transfer_Binder_AddWarning(self, *args)


    def CCheck(self, *args) -> "opencascade::handle< Interface_Check >":
        """
        * Returns Check which stores Fail messages, in order to modify it (adding messages, or replacing it)
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Transfer.Transfer_Binder_CCheck(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check > const":
        """
        * Returns Check which stores Fail messages Note that no Entity is associated in this Check
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Transfer.Transfer_Binder_Check(self, *args)


    def HasResult(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a Result is available (StatusResult = Defined) A Unique Result will be gotten by Result (which must be defined in each sub-class according to result type) For a Multiple Result, see class MultipleBinder For other case, specific access has to be forecast
        	:rtype: bool
        """
        return _Transfer.Transfer_Binder_HasResult(self, *args)


    def IsMultiple(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a Binder has several results, either by itself or because it has next results Can be defined by sub-classes.
        	:rtype: bool
        """
        return _Transfer.Transfer_Binder_IsMultiple(self, *args)


    def Merge(self, *args) -> "void":
        """
        * Merges basic data (Check, ExecStatus) from another Binder but keeps its result. Used when a binder is replaced by another one, this allows to keep messages
        	:param other:
        	:type other: Transfer_Binder
        	:rtype: None
        """
        return _Transfer.Transfer_Binder_Merge(self, *args)


    def NextResult(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Returns the next result, Null if none
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_Binder_NextResult(self, *args)


    def ResultType(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns the Type which characterizes the Result (if known)
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _Transfer.Transfer_Binder_ResultType(self, *args)


    def ResultTypeName(self, *args) -> "char const *":
        """
        * Returns the Name of the Type which characterizes the Result Can be returned even if ResultType itself is unknown
        	:rtype: char *
        """
        return _Transfer.Transfer_Binder_ResultTypeName(self, *args)


    def SetAlreadyUsed(self, *args) -> "void":
        """
        * Declares that result is now used by another one, it means that it cannot be modified (by Rebind)
        	:rtype: None
        """
        return _Transfer.Transfer_Binder_SetAlreadyUsed(self, *args)


    def SetStatusExec(self, *args) -> "void":
        """
        * Modifies execution status; called by TransferProcess only (for StatusError, rather use SetError, below)
        	:param stat:
        	:type stat: Transfer_StatusExec
        	:rtype: None
        """
        return _Transfer.Transfer_Binder_SetStatusExec(self, *args)


    def Status(self, *args) -> "Transfer_StatusResult":
        """
        * Returns status, which can be Initial (not yet done), Made (a result is recorded, not yet shared), Used (it is shared and cannot be modified)
        	:rtype: Transfer_StatusResult
        """
        return _Transfer.Transfer_Binder_Status(self, *args)


    def StatusExec(self, *args) -> "Transfer_StatusExec":
        """
        * Returns execution status
        	:rtype: Transfer_StatusExec
        """
        return _Transfer.Transfer_Binder_StatusExec(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_Binder_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_Binder
Transfer_Binder.AddFail = new_instancemethod(_Transfer.Transfer_Binder_AddFail, None, Transfer_Binder)
Transfer_Binder.AddResult = new_instancemethod(_Transfer.Transfer_Binder_AddResult, None, Transfer_Binder)
Transfer_Binder.AddWarning = new_instancemethod(_Transfer.Transfer_Binder_AddWarning, None, Transfer_Binder)
Transfer_Binder.CCheck = new_instancemethod(_Transfer.Transfer_Binder_CCheck, None, Transfer_Binder)
Transfer_Binder.Check = new_instancemethod(_Transfer.Transfer_Binder_Check, None, Transfer_Binder)
Transfer_Binder.HasResult = new_instancemethod(_Transfer.Transfer_Binder_HasResult, None, Transfer_Binder)
Transfer_Binder.IsMultiple = new_instancemethod(_Transfer.Transfer_Binder_IsMultiple, None, Transfer_Binder)
Transfer_Binder.Merge = new_instancemethod(_Transfer.Transfer_Binder_Merge, None, Transfer_Binder)
Transfer_Binder.NextResult = new_instancemethod(_Transfer.Transfer_Binder_NextResult, None, Transfer_Binder)
Transfer_Binder.ResultType = new_instancemethod(_Transfer.Transfer_Binder_ResultType, None, Transfer_Binder)
Transfer_Binder.ResultTypeName = new_instancemethod(_Transfer.Transfer_Binder_ResultTypeName, None, Transfer_Binder)
Transfer_Binder.SetAlreadyUsed = new_instancemethod(_Transfer.Transfer_Binder_SetAlreadyUsed, None, Transfer_Binder)
Transfer_Binder.SetStatusExec = new_instancemethod(_Transfer.Transfer_Binder_SetStatusExec, None, Transfer_Binder)
Transfer_Binder.Status = new_instancemethod(_Transfer.Transfer_Binder_Status, None, Transfer_Binder)
Transfer_Binder.StatusExec = new_instancemethod(_Transfer.Transfer_Binder_StatusExec, None, Transfer_Binder)
Transfer_Binder_swigregister = _Transfer.Transfer_Binder_swigregister
Transfer_Binder_swigregister(Transfer_Binder)

class Transfer_DataInfo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Type(*args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns the Type attached to an object Here, the Dynamic Type of a Transient. Null Type if unknown
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _Transfer.Transfer_DataInfo_Type(*args)

    Type = staticmethod(Type)

    def TypeName(*args) -> "char const *":
        """
        * Returns Type Name (string) Allows to name type of non-handled objects
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: char *
        """
        return _Transfer.Transfer_DataInfo_TypeName(*args)

    TypeName = staticmethod(TypeName)

    __repr__ = _dumps_object


    def __init__(self):
        _Transfer.Transfer_DataInfo_swiginit(self, _Transfer.new_Transfer_DataInfo())
    __swig_destroy__ = _Transfer.delete_Transfer_DataInfo
Transfer_DataInfo_swigregister = _Transfer.Transfer_DataInfo_swigregister
Transfer_DataInfo_swigregister(Transfer_DataInfo)

def Transfer_DataInfo_Type(*args) -> "opencascade::handle< Standard_Type >":
    """
    * Returns the Type attached to an object Here, the Dynamic Type of a Transient. Null Type if unknown
    	:param ent:
    	:type ent: Standard_Transient
    	:rtype: opencascade::handle<Standard_Type>
    """
    return _Transfer.Transfer_DataInfo_Type(*args)

def Transfer_DataInfo_TypeName(*args) -> "char const *":
    """
    * Returns Type Name (string) Allows to name type of non-handled objects
    	:param ent:
    	:type ent: Standard_Transient
    	:rtype: char *
    """
    return _Transfer.Transfer_DataInfo_TypeName(*args)

class Transfer_DispatchControl(OCC.Core.Interface.Interface_CopyControl):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def StartingModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel > const &":
        """
        * Returns the Model from which the transfer is to be done
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Transfer.Transfer_DispatchControl_StartingModel(self, *args)


    def __init__(self, *args):
        """
        * Creates the DispatchControl, ready for use
        	:param model:
        	:type model: Interface_InterfaceModel
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:rtype: None
        """
        _Transfer.Transfer_DispatchControl_swiginit(self, _Transfer.new_Transfer_DispatchControl(*args))

    def TransientProcess(self, *args) -> "opencascade::handle< Transfer_TransientProcess > const &":
        """
        * Returns the content of the DispatchControl : it can be used for a direct call, if the basic methods do not suffice
        	:rtype: opencascade::handle<Transfer_TransientProcess>
        """
        return _Transfer.Transfer_DispatchControl_TransientProcess(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_DispatchControl_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_DispatchControl
Transfer_DispatchControl.StartingModel = new_instancemethod(_Transfer.Transfer_DispatchControl_StartingModel, None, Transfer_DispatchControl)
Transfer_DispatchControl.TransientProcess = new_instancemethod(_Transfer.Transfer_DispatchControl_TransientProcess, None, Transfer_DispatchControl)
Transfer_DispatchControl_swigregister = _Transfer.Transfer_DispatchControl_swigregister
Transfer_DispatchControl_swigregister(Transfer_DispatchControl)

class Transfer_FindHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args) -> "Standard_Integer":
        """
        * Returns hash code for the given finder, in the range [1, theUpperBound]. Asks the finder its hash code, then transforms it to be in the required range @param theFinder the finder which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
        	:param theFinder:
        	:type theFinder: Transfer_Finder
        	:param theUpperBound:
        	:type theUpperBound: int
        	:rtype: int
        """
        return _Transfer.Transfer_FindHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        * Returns True if two keys are the same. The test does not work on the Finders themselves but by calling their methods Equates
        	:param K1:
        	:type K1: Transfer_Finder
        	:param K2:
        	:type K2: Transfer_Finder
        	:rtype: bool
        """
        return _Transfer.Transfer_FindHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object


    def __init__(self):
        _Transfer.Transfer_FindHasher_swiginit(self, _Transfer.new_Transfer_FindHasher())
    __swig_destroy__ = _Transfer.delete_Transfer_FindHasher
Transfer_FindHasher_swigregister = _Transfer.Transfer_FindHasher_swigregister
Transfer_FindHasher_swigregister(Transfer_FindHasher)

def Transfer_FindHasher_HashCode(*args) -> "Standard_Integer":
    """
    * Returns hash code for the given finder, in the range [1, theUpperBound]. Asks the finder its hash code, then transforms it to be in the required range @param theFinder the finder which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
    	:param theFinder:
    	:type theFinder: Transfer_Finder
    	:param theUpperBound:
    	:type theUpperBound: int
    	:rtype: int
    """
    return _Transfer.Transfer_FindHasher_HashCode(*args)

def Transfer_FindHasher_IsEqual(*args) -> "Standard_Boolean":
    """
    * Returns True if two keys are the same. The test does not work on the Finders themselves but by calling their methods Equates
    	:param K1:
    	:type K1: Transfer_Finder
    	:param K2:
    	:type K2: Transfer_Finder
    	:rtype: bool
    """
    return _Transfer.Transfer_FindHasher_IsEqual(*args)

class Transfer_Finder(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AttrList(self, *args) -> "NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &":
        """
        * Returns the exhaustive list of attributes
        	:rtype: NCollection_DataMap<TCollection_AsciiString, opencascade::handle<Standard_Transient> >
        """
        return _Transfer.Transfer_Finder_AttrList(self, *args)


    def Attribute(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns an attribute from its name. Null Handle if not recorded (whatever Transient, Integer, Real ...)
        	:param name:
        	:type name: char *
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_Finder_Attribute(self, *args)


    def AttributeType(self, *args) -> "Interface_ParamType":
        """
        * Returns the type of an attribute : ParamInt , ParamReal , ParamText (String) , ParamIdent (any) or ParamVoid (not recorded)
        	:param name:
        	:type name: char *
        	:rtype: Interface_ParamType
        """
        return _Transfer.Transfer_Finder_AttributeType(self, *args)


    def Equates(self, *args) -> "Standard_Boolean":
        """
        * Specific testof equallity : to be defined by each sub-class, must be False if Finders have not the same true Type, else their contents must be compared
        	:param other:
        	:type other: Transfer_Finder
        	:rtype: bool
        """
        return _Transfer.Transfer_Finder_Equates(self, *args)


    def GetAttribute(self, *args) -> "Standard_Boolean":
        """
        * Returns an attribute from its name, filtered by a type If no attribute has this name, or if it is not kind of this type, <val> is Null and returned value is False Else, it is True
        	:param name:
        	:type name: char *
        	:param type:
        	:type type: Standard_Type
        	:param val:
        	:type val: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_Finder_GetAttribute(self, *args)


    def GetAttributes(self, *args) -> "void":
        """
        * Gets the list of attributes from <other>, by copying it By default, considers all the attributes from <other> If <fromname> is given, considers only the attributes with name beginning by <fromname> //! For each attribute, if <copied> is True (D), its value is also copied if it is a basic type (Integer,Real,String), else it remains shared between <other> and <self> //! These new attributes are added to the existing ones in <self>, in case of same name, they replace the existing ones
        	:param other:
        	:type other: Transfer_Finder
        	:param fromname: default value is 
        	:type fromname: char *
        	:param copied: default value is Standard_True
        	:type copied: bool
        	:rtype: None
        """
        return _Transfer.Transfer_Finder_GetAttributes(self, *args)


    def GetHashCode(self, *args) -> "Standard_Integer":
        """
        * Returns the HashCode which has been stored by SetHashCode (remark that HashCode could be deferred then be defined by sub-classes, the result is the same)
        	:rtype: int
        """
        return _Transfer.Transfer_Finder_GetHashCode(self, *args)


    def GetIntegerAttribute(self, *args) -> "Standard_Boolean":
        """
        * Returns an attribute from its name, as integer If no attribute has this name, or not an integer, <val> is 0 and returned value is False Else, it is True
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: int
        	:rtype: bool
        """
        return _Transfer.Transfer_Finder_GetIntegerAttribute(self, *args)


    def GetRealAttribute(self, *args) -> "Standard_Boolean":
        """
        * Returns an attribute from its name, as real If no attribute has this name, or not a real <val> is 0.0 and returned value is False Else, it is True
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: float
        	:rtype: bool
        """
        return _Transfer.Transfer_Finder_GetRealAttribute(self, *args)


    def GetStringAttribute(self, *args) -> "Standard_Boolean":
        """
        * Returns an attribute from its name, as String If no attribute has this name, or not a String <val> is 0.0 and returned value is False Else, it is True
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: char *
        	:rtype: bool
        """
        return _Transfer.Transfer_Finder_GetStringAttribute(self, *args)


    def IntegerAttribute(self, *args) -> "Standard_Integer":
        """
        * Returns an integer attribute from its name. 0 if not recorded
        	:param name:
        	:type name: char *
        	:rtype: int
        """
        return _Transfer.Transfer_Finder_IntegerAttribute(self, *args)


    def RealAttribute(self, *args) -> "Standard_Real":
        """
        * Returns a real attribute from its name. 0.0 if not recorded
        	:param name:
        	:type name: char *
        	:rtype: float
        """
        return _Transfer.Transfer_Finder_RealAttribute(self, *args)


    def RemoveAttribute(self, *args) -> "Standard_Boolean":
        """
        * Removes an attribute Returns True when done, False if this attribute did not exist
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _Transfer.Transfer_Finder_RemoveAttribute(self, *args)


    def SameAttributes(self, *args) -> "void":
        """
        * Gets the list of attributes from <other>, as such, i.e. not copied : attributes are shared, any attribute edited, added, or removed in <other> is also in <self> and vice versa The former list of attributes of <self> is dropped
        	:param other:
        	:type other: Transfer_Finder
        	:rtype: None
        """
        return _Transfer.Transfer_Finder_SameAttributes(self, *args)


    def SetAttribute(self, *args) -> "void":
        """
        * Adds an attribute with a given name (replaces the former one with the same name if already exists)
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_Finder_SetAttribute(self, *args)


    def SetIntegerAttribute(self, *args) -> "void":
        """
        * Adds an integer value for an attribute
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: int
        	:rtype: None
        """
        return _Transfer.Transfer_Finder_SetIntegerAttribute(self, *args)


    def SetRealAttribute(self, *args) -> "void":
        """
        * Adds a real value for an attribute
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: float
        	:rtype: None
        """
        return _Transfer.Transfer_Finder_SetRealAttribute(self, *args)


    def SetStringAttribute(self, *args) -> "void":
        """
        * Adds a String value for an attribute
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: char *
        	:rtype: None
        """
        return _Transfer.Transfer_Finder_SetStringAttribute(self, *args)


    def StringAttribute(self, *args) -> "char const *":
        """
        * Returns a String attribute from its name. '' if not recorded
        	:param name:
        	:type name: char *
        	:rtype: char *
        """
        return _Transfer.Transfer_Finder_StringAttribute(self, *args)


    def ValueType(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns the Type of the Value. By default, returns the DynamicType of <self>, but can be redefined
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _Transfer.Transfer_Finder_ValueType(self, *args)


    def ValueTypeName(self, *args) -> "char const *":
        """
        * Returns the name of the Type of the Value. Default is name of ValueType, unless it is for a non-handled object
        	:rtype: char *
        """
        return _Transfer.Transfer_Finder_ValueTypeName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_Finder_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_Finder
Transfer_Finder.AttrList = new_instancemethod(_Transfer.Transfer_Finder_AttrList, None, Transfer_Finder)
Transfer_Finder.Attribute = new_instancemethod(_Transfer.Transfer_Finder_Attribute, None, Transfer_Finder)
Transfer_Finder.AttributeType = new_instancemethod(_Transfer.Transfer_Finder_AttributeType, None, Transfer_Finder)
Transfer_Finder.Equates = new_instancemethod(_Transfer.Transfer_Finder_Equates, None, Transfer_Finder)
Transfer_Finder.GetAttribute = new_instancemethod(_Transfer.Transfer_Finder_GetAttribute, None, Transfer_Finder)
Transfer_Finder.GetAttributes = new_instancemethod(_Transfer.Transfer_Finder_GetAttributes, None, Transfer_Finder)
Transfer_Finder.GetHashCode = new_instancemethod(_Transfer.Transfer_Finder_GetHashCode, None, Transfer_Finder)
Transfer_Finder.GetIntegerAttribute = new_instancemethod(_Transfer.Transfer_Finder_GetIntegerAttribute, None, Transfer_Finder)
Transfer_Finder.GetRealAttribute = new_instancemethod(_Transfer.Transfer_Finder_GetRealAttribute, None, Transfer_Finder)
Transfer_Finder.GetStringAttribute = new_instancemethod(_Transfer.Transfer_Finder_GetStringAttribute, None, Transfer_Finder)
Transfer_Finder.IntegerAttribute = new_instancemethod(_Transfer.Transfer_Finder_IntegerAttribute, None, Transfer_Finder)
Transfer_Finder.RealAttribute = new_instancemethod(_Transfer.Transfer_Finder_RealAttribute, None, Transfer_Finder)
Transfer_Finder.RemoveAttribute = new_instancemethod(_Transfer.Transfer_Finder_RemoveAttribute, None, Transfer_Finder)
Transfer_Finder.SameAttributes = new_instancemethod(_Transfer.Transfer_Finder_SameAttributes, None, Transfer_Finder)
Transfer_Finder.SetAttribute = new_instancemethod(_Transfer.Transfer_Finder_SetAttribute, None, Transfer_Finder)
Transfer_Finder.SetIntegerAttribute = new_instancemethod(_Transfer.Transfer_Finder_SetIntegerAttribute, None, Transfer_Finder)
Transfer_Finder.SetRealAttribute = new_instancemethod(_Transfer.Transfer_Finder_SetRealAttribute, None, Transfer_Finder)
Transfer_Finder.SetStringAttribute = new_instancemethod(_Transfer.Transfer_Finder_SetStringAttribute, None, Transfer_Finder)
Transfer_Finder.StringAttribute = new_instancemethod(_Transfer.Transfer_Finder_StringAttribute, None, Transfer_Finder)
Transfer_Finder.ValueType = new_instancemethod(_Transfer.Transfer_Finder_ValueType, None, Transfer_Finder)
Transfer_Finder.ValueTypeName = new_instancemethod(_Transfer.Transfer_Finder_ValueTypeName, None, Transfer_Finder)
Transfer_Finder_swigregister = _Transfer.Transfer_Finder_swigregister
Transfer_Finder_swigregister(Transfer_Finder)

class Transfer_MapContainer(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetMapObjects(self, *args) -> "TColStd_DataMapOfTransientTransient &":
        """
        * Get map already translated geometry objects.
        	:rtype: TColStd_DataMapOfTransientTransient
        """
        return _Transfer.Transfer_MapContainer_GetMapObjects(self, *args)


    def SetMapObjects(self, *args) -> "void":
        """
        * Set map already translated geometry objects.
        	:param theMapObjects:
        	:type theMapObjects: TColStd_DataMapOfTransientTransient
        	:rtype: None
        """
        return _Transfer.Transfer_MapContainer_SetMapObjects(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _Transfer.Transfer_MapContainer_swiginit(self, _Transfer.new_Transfer_MapContainer(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_MapContainer_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_MapContainer
Transfer_MapContainer.GetMapObjects = new_instancemethod(_Transfer.Transfer_MapContainer_GetMapObjects, None, Transfer_MapContainer)
Transfer_MapContainer.SetMapObjects = new_instancemethod(_Transfer.Transfer_MapContainer_SetMapObjects, None, Transfer_MapContainer)
Transfer_MapContainer_swigregister = _Transfer.Transfer_MapContainer_swigregister
Transfer_MapContainer_swigregister(Transfer_MapContainer)

class Transfer_ProcessForTransient(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AbnormalResult(self, *args) -> "Transfer_IteratorOfProcessForTransient":
        """
        * Returns Binders which are neither 'Done' nor 'Initial', that is Error,Loop or Run (abnormal states at end of Transfer) Starting Objects are given in correspondance in the iterator
        	:rtype: Transfer_IteratorOfProcessForTransient
        """
        return _Transfer.Transfer_ProcessForTransient_AbnormalResult(self, *args)


    def Actor(self, *args) -> "opencascade::handle< Transfer_ActorOfProcessForTransient >":
        """
        * Returns the defined Actor. Returns a Null Handle if not set.
        	:rtype: opencascade::handle<Transfer_ActorOfProcessForTransient>
        """
        return _Transfer.Transfer_ProcessForTransient_Actor(self, *args)


    def AddError(self, *args) -> "void":
        """
        * (other name of AddFail, maintained for compatibility)
        	:param start:
        	:type start: Standard_Transient
        	:param mess:
        	:type mess: char *
        	:param orig: default value is 
        	:type orig: char *
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_AddError(self, *args)


    def AddFail(self, *args) -> "void":
        """
        * Adds an Error message to a starting entity (to the check of its Binder of category 0, as a Fail)
        	:param start:
        	:type start: Standard_Transient
        	:param mess:
        	:type mess: char *
        	:param orig: default value is 
        	:type orig: char *
        	:rtype: None
        * Adds an Error Message to a starting entity from the definition of a Msg (Original+Value)
        	:param start:
        	:type start: Standard_Transient
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_AddFail(self, *args)


    def AddMultiple(self, *args) -> "void":
        """
        * Adds an item to a list of results bound to a starting object. Considers a category number, by default 0, for all results
        	:param start:
        	:type start: Standard_Transient
        	:param res:
        	:type res: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_AddMultiple(self, *args)


    def AddWarning(self, *args) -> "void":
        """
        * Adds a Warning message to a starting entity (to the check of its Binder of category 0)
        	:param start:
        	:type start: Standard_Transient
        	:param mess:
        	:type mess: char *
        	:param orig: default value is 
        	:type orig: char *
        	:rtype: None
        * Adds a Warning Message to a starting entity from the definition of a Msg (Original+Value)
        	:param start:
        	:type start: Standard_Transient
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_AddWarning(self, *args)


    def Bind(self, *args) -> "void":
        """
        * Creates a Link a starting Object with a Binder. This Binder can either bring a Result (effective Binding) or none (it can be set later : pre-binding). Considers a category number, by default 0
        	:param start:
        	:type start: Standard_Transient
        	:param binder:
        	:type binder: Transfer_Binder
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_Bind(self, *args)


    def BindMultiple(self, *args) -> "void":
        """
        * Prepares an object <start> to be bound with several results. If no Binder is yet attached to <obj>, a MultipleBinder is created, empty. If a Binder is already set, it must accept Multiple Binding. Considers a category number, by default 0
        	:param start:
        	:type start: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_BindMultiple(self, *args)


    def BindTransient(self, *args) -> "void":
        """
        * Binds a starting object with a Transient Result. Uses a SimpleBinderOfTransient to work. If there is already one but with no Result set, sets its Result. Considers a category number, by default 0
        	:param start:
        	:type start: Standard_Transient
        	:param res:
        	:type res: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_BindTransient(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check >":
        """
        * Returns the Check attached to a starting entity. If <start> is unknown, returns an empty Check Adds a case name to a starting entity Adds a case value to a starting entity Returns the complete case list for an entity. Null Handle if empty In the list of mapped items (between 1 and NbMapped), searches for the first item which follows <num0>(not included) and which has an attribute named <name> Attributes are brought by Binders Hence, allows such an iteration //! for (num = TP->NextItemWithAttribute(name,0); num > 0; num = TP->NextItemWithAttribute(name,num) { .. process mapped item <num> } Returns the type of an Attribute attached to binders If this name gives no Attribute, returns ParamVoid If this name gives several different types, returns ParamMisc Else, returns the effective type (ParamInteger, ParamReal, ParamIdent, or ParamText) Returns the list of recorded Attribute Names, as a Dictionary of Integer : each value gives the count of items which bring this attribute name By default, considers all the attribute names If <rootname> is given, considers only the attribute names which begin by <rootname>
        	:param start:
        	:type start: Standard_Transient
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Transfer.Transfer_ProcessForTransient_Check(self, *args)


    def CheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns a CheckList as a list of Check : each one is for a starting entity which have either check (warning or fail) messages are attached, or are in abnormal state : that case gives a specific message If <erronly> is True, checks with Warnings only are ignored
        	:param erronly:
        	:type erronly: bool
        	:rtype: Interface_CheckIterator
        """
        return _Transfer.Transfer_ProcessForTransient_CheckList(self, *args)


    def CheckListOne(self, *args) -> "Interface_CheckIterator":
        """
        * Returns a CheckList for one starting object <level> interpreted as by ResultOne If <erronly> is True, checks with Warnings only are ignored
        	:param start:
        	:type start: Standard_Transient
        	:param level:
        	:type level: int
        	:param erronly:
        	:type erronly: bool
        	:rtype: Interface_CheckIterator
        """
        return _Transfer.Transfer_ProcessForTransient_CheckListOne(self, *args)


    def CheckNum(self, *args) -> "Standard_Integer":
        """
        * Computes a number to be associated to a starting object in a check or a check-list By default, returns 0; can be redefined
        	:param start:
        	:type start: Standard_Transient
        	:rtype: int
        """
        return _Transfer.Transfer_ProcessForTransient_CheckNum(self, *args)


    def Clean(self, *args) -> "void":
        """
        * Rebuilds the Map and the roots to really remove Unbound items Because Unbind keeps the entity in place, even if not bound Hence, working by checking new items is meaningless if a formerly unbound item is rebound
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_Clean(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Resets a TransferProcess as ready for a completely new work. Clears general data (roots) and the Map
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_Clear(self, *args)


    def CompleteResult(self, *args) -> "Transfer_IteratorOfProcessForTransient":
        """
        * Returns, as an Iterator, the entire log of transfer (list of created objects and Binders which can bring errors) If withstart is given True, Starting Objets are also returned
        	:param withstart: default value is Standard_False
        	:type withstart: bool
        	:rtype: Transfer_IteratorOfProcessForTransient
        """
        return _Transfer.Transfer_ProcessForTransient_CompleteResult(self, *args)


    def Find(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Returns the Binder which is linked with a starting Object It can either bring a Result (Transfer done) or none (for a pre-binding). If no Binder is linked with <start>, returns a Null Handle Considers a category number, by default 0
        	:param start:
        	:type start: Standard_Transient
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ProcessForTransient_Find(self, *args)


    def FindElseBind(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Returns a Binder for a starting entity, as follows : Tries to Find the already bound one If none found, creates a VoidBinder and Binds it
        	:param start:
        	:type start: Standard_Transient
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ProcessForTransient_FindElseBind(self, *args)


    def FindTransient(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the Result of the Transfer of an object <start> as a Transient Result. Returns a Null Handle if there is no Transient Result Considers a category number, by default 0 Warning : Supposes that Binding is done with a SimpleBinderOfTransient
        	:param start:
        	:type start: Standard_Transient
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_ProcessForTransient_FindTransient(self, *args)


    def FindTypedTransient(self, *args) -> "Standard_Boolean":
        """
        * Searches for a transient result attached to a starting object, according to its type, by criterium IsKind(atype) //! In case of multiple result, explores the list and gives in <val> the first transient result IsKind(atype) Returns True and fills <val> if found Else, returns False (<val> is not touched, not even nullified) //! This syntactic form avoids to do DownCast : if a result is found with the good type, it is loaded in <val> and can be immediately used, well initialised
        	:param start:
        	:type start: Standard_Transient
        	:param atype:
        	:type atype: Standard_Type
        	:param val:
        	:type val: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_ProcessForTransient_FindTypedTransient(self, *args)


    def GetProgress(self, *args) -> "opencascade::handle< Message_ProgressIndicator >":
        """
        * Gets Progress indicator
        	:rtype: opencascade::handle<Message_ProgressIndicator>
        """
        return _Transfer.Transfer_ProcessForTransient_GetProgress(self, *args)


    def GetTypedTransient(self, *args) -> "Standard_Boolean":
        """
        * Searches for a transient result recorded in a Binder, whatever this Binder is recorded or not in <self> //! This is strictly equivalent to the class method GetTypedResult from class SimpleBinderOfTransient, but is just lighter to call //! Apart from this, works as FindTypedTransient
        	:param binder:
        	:type binder: Transfer_Binder
        	:param atype:
        	:type atype: Standard_Type
        	:param val:
        	:type val: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_ProcessForTransient_GetTypedTransient(self, *args)


    def IsAlreadyUsed(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the result of the transfer of an object is already used in other ones. If it is, Rebind cannot change it. Considers a category number, by default 0
        	:param start:
        	:type start: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_ProcessForTransient_IsAlreadyUsed(self, *args)


    def IsBound(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a Result (whatever its form) is Bound with a starting Object. I.e., if a Binder with a Result set, is linked with it Considers a category number, by default 0
        	:param start:
        	:type start: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_ProcessForTransient_IsBound(self, *args)


    def IsCheckListEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns True if no check message is attached to a starting object. <level> interpreted as by ResultOne If <erronly> is True, checks with Warnings only are ignored
        	:param start:
        	:type start: Standard_Transient
        	:param level:
        	:type level: int
        	:param erronly:
        	:type erronly: bool
        	:rtype: bool
        """
        return _Transfer.Transfer_ProcessForTransient_IsCheckListEmpty(self, *args)


    def IsLooping(self, *args) -> "Standard_Boolean":
        """
        * Returns True if we are surely in a DeadLoop. Evaluation is not exact, it is a 'majorant' which must be computed fast. This 'majorant' is : <alevel> greater than NbMapped.
        	:param alevel:
        	:type alevel: int
        	:rtype: bool
        """
        return _Transfer.Transfer_ProcessForTransient_IsLooping(self, *args)


    def MapIndex(self, *args) -> "Standard_Integer":
        """
        * Returns the Index value bound to a Starting Object, 0 if none
        	:param start:
        	:type start: Standard_Transient
        	:rtype: int
        """
        return _Transfer.Transfer_ProcessForTransient_MapIndex(self, *args)


    def MapItem(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Returns the Binder bound to an Index Considers a category number, by default 0
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ProcessForTransient_MapItem(self, *args)


    def Mapped(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the Starting Object bound to an Index,
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_ProcessForTransient_Mapped(self, *args)


    def Mend(self, *args) -> "void":
        """
        :param start:
        	:type start: Standard_Transient
        	:param pref: default value is 
        	:type pref: char *
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_Mend(self, *args)


    def Messenger(self, *args) -> "opencascade::handle< Message_Messenger >":
        """
        * Returns Messenger used for outputting messages. The returned object is guaranteed to be non-null; default is Message::Messenger().
        	:rtype: opencascade::handle<Message_Messenger>
        """
        return _Transfer.Transfer_ProcessForTransient_Messenger(self, *args)


    def NbMapped(self, *args) -> "Standard_Integer":
        """
        * Returns the maximum possible value for Map Index (no result can be bound with a value greater than it)
        	:rtype: int
        """
        return _Transfer.Transfer_ProcessForTransient_NbMapped(self, *args)


    def NbRoots(self, *args) -> "Standard_Integer":
        """
        * Returns the count of recorded Roots
        	:rtype: int
        """
        return _Transfer.Transfer_ProcessForTransient_NbRoots(self, *args)


    def NestingLevel(self, *args) -> "Standard_Integer":
        """
        * Returns Nesting Level of Transfers (managed by methods TranscriptWith & Co). Starts to zero. If no automatic Transfer is used, it remains to zero. Zero means Root Level.
        	:rtype: int
        """
        return _Transfer.Transfer_ProcessForTransient_NestingLevel(self, *args)


    def PrintTrace(self, *args) -> "void":
        """
        * Prints a short information on a starting object. By default prints its Dynamic Type. Can be redefined
        	:param start:
        	:type start: Standard_Transient
        	:param S:
        	:type S: Message_Messenger
        	:rtype: void
        """
        return _Transfer.Transfer_ProcessForTransient_PrintTrace(self, *args)


    def Rebind(self, *args) -> "void":
        """
        * Changes the Binder linked with a starting Object for its unitary transfer. This it can be useful when the exact form of the result is known once the transfer is widely engaged. This can be done only on first transfer. Considers a category number, by default 0
        	:param start:
        	:type start: Standard_Transient
        	:param binder:
        	:type binder: Transfer_Binder
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_Rebind(self, *args)


    def Recognize(self, *args) -> "Standard_Boolean":
        """
        * Tells if <start> has been recognized as good candidate for Transfer. i.e. queries the Actor and its Nexts
        	:param start:
        	:type start: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_ProcessForTransient_Recognize(self, *args)


    def RemoveResult(self, *args) -> "void":
        """
        * Removes Results attached to (== Unbinds) a given object and, according <level> : <level> = 0 : only it <level> = 1 : it plus its immediately owned sub-results(scope) <level> = 2 : it plus all its owned sub-results(scope)
        	:param start:
        	:type start: Standard_Transient
        	:param level:
        	:type level: int
        	:param compute: default value is Standard_True
        	:type compute: bool
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_RemoveResult(self, *args)


    def ResetNestingLevel(self, *args) -> "void":
        """
        * Resets Nesting Level of Transfers to Zero (Root Level), whatever its current value.
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_ResetNestingLevel(self, *args)


    def Resize(self, *args) -> "void":
        """
        * Resizes the Map as required (if a new reliable value has been determined). Acts only if <nb> is greater than actual NbMapped
        	:param nb:
        	:type nb: int
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_Resize(self, *args)


    def ResultOne(self, *args) -> "Transfer_IteratorOfProcessForTransient":
        """
        * Returns, as an Iterator, the log of transfer for one object <level> = 0 : this object only and if <start> is a scope owner (else, <level> is ignored) : <level> = 1 : object plus its immediate scoped ones <level> = 2 : object plus all its scoped ones
        	:param start:
        	:type start: Standard_Transient
        	:param level:
        	:type level: int
        	:param withstart: default value is Standard_False
        	:type withstart: bool
        	:rtype: Transfer_IteratorOfProcessForTransient
        """
        return _Transfer.Transfer_ProcessForTransient_ResultOne(self, *args)


    def Root(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns a Root Entity given its number in the list (1-NbRoots)
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_ProcessForTransient_Root(self, *args)


    def RootIndex(self, *args) -> "Standard_Integer":
        """
        * Returns the index in the list of roots for a starting item, or 0 if it is not recorded as a root
        	:param start:
        	:type start: Standard_Transient
        	:rtype: int
        """
        return _Transfer.Transfer_ProcessForTransient_RootIndex(self, *args)


    def RootItem(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Returns the Binder bound with a Root Entity given its number Considers a category number, by default 0
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ProcessForTransient_RootItem(self, *args)


    def RootResult(self, *args) -> "Transfer_IteratorOfProcessForTransient":
        """
        * Returns, as an iterator, the log of root transfer, i.e. the created objects and Binders bound to starting roots If withstart is given True, Starting Objets are also returned
        	:param withstart: default value is Standard_False
        	:type withstart: bool
        	:rtype: Transfer_IteratorOfProcessForTransient
        """
        return _Transfer.Transfer_ProcessForTransient_RootResult(self, *args)


    def SendFail(self, *args) -> "void":
        """
        * New name for AddFail (Msg)
        	:param start:
        	:type start: Standard_Transient
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_SendFail(self, *args)


    def SendMsg(self, *args) -> "void":
        """
        * Adds an information message Trace is filled if trace level is at least 3
        	:param start:
        	:type start: Standard_Transient
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_SendMsg(self, *args)


    def SendWarning(self, *args) -> "void":
        """
        * New name for AddWarning (Msg)
        	:param start:
        	:type start: Standard_Transient
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_SendWarning(self, *args)


    def SetActor(self, *args) -> "void":
        """
        * Defines an Actor, which is used for automatic Transfer If already defined, the new Actor is cumulated (see SetNext from Actor)
        	:param actor:
        	:type actor: Transfer_ActorOfProcessForTransient
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_SetActor(self, *args)


    def SetMessenger(self, *args) -> "void":
        """
        * Sets Messenger used for outputting messages.
        	:param messenger:
        	:type messenger: Message_Messenger
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_SetMessenger(self, *args)


    def SetProgress(self, *args) -> "void":
        """
        * Sets Progress indicator
        	:param theProgress:
        	:type theProgress: Message_ProgressIndicator
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_SetProgress(self, *args)


    def SetRoot(self, *args) -> "void":
        """
        * Declares <obj> (and its Result) as Root. This status will be later exploited by RootResult, see below (Result can be produced at any time)
        	:param start:
        	:type start: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_SetRoot(self, *args)


    def SetRootManagement(self, *args) -> "void":
        """
        * Enable (if <stat> True) or Disables (if <stat> False) Root Management. If it is set, Transfers are considered as stacked (a first Transfer commands other Transfers, and so on) and the Transfers commanded by an external caller are 'Root'. Remark : SetRoot can be called whatever this status, on every object. Default is set to True.
        	:param stat:
        	:type stat: bool
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_SetRootManagement(self, *args)


    def SetTraceLevel(self, *args) -> "void":
        """
        * Sets trace level used for outputting messages: <trace> = 0 : no trace at all <trace> = 1 : handled exceptions and calls to AddError <trace> = 2 : also calls to AddWarning <trace> = 3 : also traces new Roots (uses method ErrorTrace). Default is 1 : Errors traced
        	:param tracelev:
        	:type tracelev: int
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_SetTraceLevel(self, *args)


    def StartTrace(self, *args) -> "void":
        """
        * Method called when trace is asked Calls PrintTrace to display information relevant for starting objects (which can be redefined) <level> is Nesting Level of Transfer (0 = root) <mode> controls the way the trace is done : 0 neutral, 1 for Error, 2 for Warning message, 3 for new Root
        	:param binder:
        	:type binder: Transfer_Binder
        	:param start:
        	:type start: Standard_Transient
        	:param level:
        	:type level: int
        	:param mode:
        	:type mode: int
        	:rtype: None
        """
        return _Transfer.Transfer_ProcessForTransient_StartTrace(self, *args)


    def TraceLevel(self, *args) -> "Standard_Integer":
        """
        * Returns trace level used for outputting messages.
        	:rtype: int
        """
        return _Transfer.Transfer_ProcessForTransient_TraceLevel(self, *args)


    def Transfer(self, *args) -> "Standard_Boolean":
        """
        * Same as Transferring but does not return the Binder. Simply returns True in case of success (for user call)
        	:param start:
        	:type start: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_ProcessForTransient_Transfer(self, *args)


    def __init__(self, *args):
        """
        * Sets TransferProcess at initial state. Gives an Initial size (indicative) for the Map when known (default is 10000). Sets default trace file as a printer and default trace level (see Message_TraceFile).
        	:param nb: default value is 10000
        	:type nb: int
        	:rtype: None
        * Sets TransferProcess at initial state. Gives an Initial size (indicative) for the Map when known (default is 10000). Sets a specified printer.
        	:param printer:
        	:type printer: Message_Messenger
        	:param nb: default value is 10000
        	:type nb: int
        	:rtype: None
        """
        _Transfer.Transfer_ProcessForTransient_swiginit(self, _Transfer.new_Transfer_ProcessForTransient(*args))

    def Transferring(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Performs the Transfer of a Starting Object, by calling the method TransferProduct (see below). Mapping and Roots are managed : nothing is done if a Result is already Bound, an exception is raised in case of error.
        	:param start:
        	:type start: Standard_Transient
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ProcessForTransient_Transferring(self, *args)


    def Unbind(self, *args) -> "Standard_Boolean":
        """
        * Removes the Binder linked with a starting object If this Binder brings a non-empty Check, it is replaced by a VoidBinder. Also removes from the list of Roots as required. Returns True if done, False if <start> was not bound Considers a category number, by default 0
        	:param start:
        	:type start: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_ProcessForTransient_Unbind(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_ProcessForTransient_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_ProcessForTransient
Transfer_ProcessForTransient.AbnormalResult = new_instancemethod(_Transfer.Transfer_ProcessForTransient_AbnormalResult, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Actor = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Actor, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.AddError = new_instancemethod(_Transfer.Transfer_ProcessForTransient_AddError, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.AddFail = new_instancemethod(_Transfer.Transfer_ProcessForTransient_AddFail, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.AddMultiple = new_instancemethod(_Transfer.Transfer_ProcessForTransient_AddMultiple, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.AddWarning = new_instancemethod(_Transfer.Transfer_ProcessForTransient_AddWarning, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Bind = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Bind, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.BindMultiple = new_instancemethod(_Transfer.Transfer_ProcessForTransient_BindMultiple, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.BindTransient = new_instancemethod(_Transfer.Transfer_ProcessForTransient_BindTransient, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Check = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Check, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.CheckList = new_instancemethod(_Transfer.Transfer_ProcessForTransient_CheckList, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.CheckListOne = new_instancemethod(_Transfer.Transfer_ProcessForTransient_CheckListOne, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.CheckNum = new_instancemethod(_Transfer.Transfer_ProcessForTransient_CheckNum, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Clean = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Clean, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Clear = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Clear, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.CompleteResult = new_instancemethod(_Transfer.Transfer_ProcessForTransient_CompleteResult, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Find = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Find, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.FindElseBind = new_instancemethod(_Transfer.Transfer_ProcessForTransient_FindElseBind, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.FindTransient = new_instancemethod(_Transfer.Transfer_ProcessForTransient_FindTransient, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.FindTypedTransient = new_instancemethod(_Transfer.Transfer_ProcessForTransient_FindTypedTransient, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.GetProgress = new_instancemethod(_Transfer.Transfer_ProcessForTransient_GetProgress, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.GetTypedTransient = new_instancemethod(_Transfer.Transfer_ProcessForTransient_GetTypedTransient, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.IsAlreadyUsed = new_instancemethod(_Transfer.Transfer_ProcessForTransient_IsAlreadyUsed, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.IsBound = new_instancemethod(_Transfer.Transfer_ProcessForTransient_IsBound, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.IsCheckListEmpty = new_instancemethod(_Transfer.Transfer_ProcessForTransient_IsCheckListEmpty, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.IsLooping = new_instancemethod(_Transfer.Transfer_ProcessForTransient_IsLooping, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.MapIndex = new_instancemethod(_Transfer.Transfer_ProcessForTransient_MapIndex, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.MapItem = new_instancemethod(_Transfer.Transfer_ProcessForTransient_MapItem, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Mapped = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Mapped, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Mend = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Mend, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Messenger = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Messenger, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.NbMapped = new_instancemethod(_Transfer.Transfer_ProcessForTransient_NbMapped, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.NbRoots = new_instancemethod(_Transfer.Transfer_ProcessForTransient_NbRoots, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.NestingLevel = new_instancemethod(_Transfer.Transfer_ProcessForTransient_NestingLevel, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.PrintTrace = new_instancemethod(_Transfer.Transfer_ProcessForTransient_PrintTrace, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Rebind = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Rebind, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Recognize = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Recognize, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.RemoveResult = new_instancemethod(_Transfer.Transfer_ProcessForTransient_RemoveResult, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.ResetNestingLevel = new_instancemethod(_Transfer.Transfer_ProcessForTransient_ResetNestingLevel, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Resize = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Resize, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.ResultOne = new_instancemethod(_Transfer.Transfer_ProcessForTransient_ResultOne, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Root = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Root, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.RootIndex = new_instancemethod(_Transfer.Transfer_ProcessForTransient_RootIndex, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.RootItem = new_instancemethod(_Transfer.Transfer_ProcessForTransient_RootItem, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.RootResult = new_instancemethod(_Transfer.Transfer_ProcessForTransient_RootResult, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.SendFail = new_instancemethod(_Transfer.Transfer_ProcessForTransient_SendFail, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.SendMsg = new_instancemethod(_Transfer.Transfer_ProcessForTransient_SendMsg, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.SendWarning = new_instancemethod(_Transfer.Transfer_ProcessForTransient_SendWarning, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.SetActor = new_instancemethod(_Transfer.Transfer_ProcessForTransient_SetActor, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.SetMessenger = new_instancemethod(_Transfer.Transfer_ProcessForTransient_SetMessenger, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.SetProgress = new_instancemethod(_Transfer.Transfer_ProcessForTransient_SetProgress, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.SetRoot = new_instancemethod(_Transfer.Transfer_ProcessForTransient_SetRoot, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.SetRootManagement = new_instancemethod(_Transfer.Transfer_ProcessForTransient_SetRootManagement, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.SetTraceLevel = new_instancemethod(_Transfer.Transfer_ProcessForTransient_SetTraceLevel, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.StartTrace = new_instancemethod(_Transfer.Transfer_ProcessForTransient_StartTrace, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.TraceLevel = new_instancemethod(_Transfer.Transfer_ProcessForTransient_TraceLevel, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Transfer = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Transfer, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Transferring = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Transferring, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient.Unbind = new_instancemethod(_Transfer.Transfer_ProcessForTransient_Unbind, None, Transfer_ProcessForTransient)
Transfer_ProcessForTransient_swigregister = _Transfer.Transfer_ProcessForTransient_swigregister
Transfer_ProcessForTransient_swigregister(Transfer_ProcessForTransient)

class Transfer_ResultFromModel(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns the check-list of this set of results <erronly> true : only fails are considered <level> = 0 : considers only main binder <level> = 1 : considers main binder plus immediate subs <level> = 2 (D) : considers all checks
        	:param erronly:
        	:type erronly: bool
        	:param level: default value is 2
        	:type level: int
        	:rtype: Interface_CheckIterator
        """
        return _Transfer.Transfer_ResultFromModel_CheckList(self, *args)


    def CheckStatus(self, *args) -> "Interface_CheckStatus":
        """
        * Returns the check status with corresponds to the content of this ResultFromModel; considers all levels of transfer (worst status). Returns CheckAny if not yet computed Reads it from recorded status if already computed, else recomputes one
        	:rtype: Interface_CheckStatus
        """
        return _Transfer.Transfer_ResultFromModel_CheckStatus(self, *args)


    def CheckedList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the list of starting entities to which a check status is attached. <check> = -2 , all entities whatever the check (see result) <check> = -1 , entities with no fail (warning allowed) <check> = 0 , entities with no check at all <check> = 1 , entities with warning but no fail <check> = 2 , entities with fail <result> : if True, only entities with an attached result Remark : result True and check=0 will give an empty list
        	:param check:
        	:type check: Interface_CheckStatus
        	:param result:
        	:type result: bool
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _Transfer.Transfer_ResultFromModel_CheckedList(self, *args)


    def ComputeCheckStatus(self, *args) -> "Interface_CheckStatus":
        """
        * Computes and records check status (see CheckStatus) Does not computes it if already done and <enforce> False
        	:param enforce:
        	:type enforce: bool
        	:rtype: Interface_CheckStatus
        """
        return _Transfer.Transfer_ResultFromModel_ComputeCheckStatus(self, *args)


    def FileName(self, *args) -> "char const *":
        """
        * Returns starting File Name (empty if not set)
        	:rtype: char *
        """
        return _Transfer.Transfer_ResultFromModel_FileName(self, *args)


    def Fill(self, *args) -> "Standard_Boolean":
        """
        * Fills from a TransientProcess, with the result attached to a starting entity. Considers its Model if it is set. This action produces a structured set of ResultFromTransient, considering scopes, starting by that of <ent>. If <ent> has no recorded result, it remains empty Returns True if a result is recorded, False else
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_ResultFromModel_Fill(self, *args)


    def FillBack(self, *args) -> "void":
        """
        * Fills back a TransientProcess from the structured set of binders. Also sets the Model.
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromModel_FillBack(self, *args)


    def HasResult(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a Result is recorded
        	:rtype: bool
        """
        return _Transfer.Transfer_ResultFromModel_HasResult(self, *args)


    def MainLabel(self, *args) -> "char const *":
        """
        * Returns the label in starting model attached to main entity (updated by Fill or SetMainResult, if Model is known)
        	:rtype: char *
        """
        return _Transfer.Transfer_ResultFromModel_MainLabel(self, *args)


    def MainNumber(self, *args) -> "Standard_Integer":
        """
        * Returns the label in starting model attached to main entity
        	:rtype: int
        """
        return _Transfer.Transfer_ResultFromModel_MainNumber(self, *args)


    def MainResult(self, *args) -> "opencascade::handle< Transfer_ResultFromTransient >":
        """
        * Returns the main recorded ResultFromTransient, or a null
        	:rtype: opencascade::handle<Transfer_ResultFromTransient>
        """
        return _Transfer.Transfer_ResultFromModel_MainResult(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns starting Model (null if not set)
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Transfer.Transfer_ResultFromModel_Model(self, *args)


    def ResultFromKey(self, *args) -> "opencascade::handle< Transfer_ResultFromTransient >":
        """
        * Searches for a key (starting entity) and returns its result Returns a null handle if not found
        	:param start:
        	:type start: Standard_Transient
        	:rtype: opencascade::handle<Transfer_ResultFromTransient>
        """
        return _Transfer.Transfer_ResultFromModel_ResultFromKey(self, *args)


    def Results(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Internal method which returns the list of ResultFromTransient, according level (2:complete; 1:sub-level 1; 0:main only)
        	:param level:
        	:type level: int
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _Transfer.Transfer_ResultFromModel_Results(self, *args)


    def SetFileName(self, *args) -> "void":
        """
        * Sets starting File Name
        	:param filename:
        	:type filename: char *
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromModel_SetFileName(self, *args)


    def SetMainResult(self, *args) -> "void":
        """
        * Sets a new value for the main recorded ResultFromTransient
        	:param amain:
        	:type amain: Transfer_ResultFromTransient
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromModel_SetMainResult(self, *args)


    def SetModel(self, *args) -> "void":
        """
        * Sets starting Model
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromModel_SetModel(self, *args)


    def Strip(self, *args) -> "void":
        """
        * Clears some data attached to binders used by TransientProcess, which become useless once the transfer has been done, by calling Strip on its ResultFromTransient //! mode = 0 : minimum, clears data remaining from TransferProcess mode = 10 : just keeps file name, label, check status ..., and MainResult but only the result (Binder) mode = 11 : also clears MainResult (status and names remain)
        	:param mode:
        	:type mode: int
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromModel_Strip(self, *args)


    def __init__(self, *args):
        """
        * Creates a ResultFromModel, empty
        	:rtype: None
        """
        _Transfer.Transfer_ResultFromModel_swiginit(self, _Transfer.new_Transfer_ResultFromModel(*args))

    def TransferredList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the list of recorded starting entities, ending by the root. Entities with check but no transfer result are ignored <level> = 2 (D), considers the complete list <level> = 1 considers the main result plus immediate subs <level> = 0 just the main result
        	:param level: default value is 2
        	:type level: int
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _Transfer.Transfer_ResultFromModel_TransferredList(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_ResultFromModel_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_ResultFromModel
Transfer_ResultFromModel.CheckList = new_instancemethod(_Transfer.Transfer_ResultFromModel_CheckList, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.CheckStatus = new_instancemethod(_Transfer.Transfer_ResultFromModel_CheckStatus, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.CheckedList = new_instancemethod(_Transfer.Transfer_ResultFromModel_CheckedList, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.ComputeCheckStatus = new_instancemethod(_Transfer.Transfer_ResultFromModel_ComputeCheckStatus, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.FileName = new_instancemethod(_Transfer.Transfer_ResultFromModel_FileName, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.Fill = new_instancemethod(_Transfer.Transfer_ResultFromModel_Fill, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.FillBack = new_instancemethod(_Transfer.Transfer_ResultFromModel_FillBack, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.HasResult = new_instancemethod(_Transfer.Transfer_ResultFromModel_HasResult, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.MainLabel = new_instancemethod(_Transfer.Transfer_ResultFromModel_MainLabel, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.MainNumber = new_instancemethod(_Transfer.Transfer_ResultFromModel_MainNumber, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.MainResult = new_instancemethod(_Transfer.Transfer_ResultFromModel_MainResult, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.Model = new_instancemethod(_Transfer.Transfer_ResultFromModel_Model, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.ResultFromKey = new_instancemethod(_Transfer.Transfer_ResultFromModel_ResultFromKey, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.Results = new_instancemethod(_Transfer.Transfer_ResultFromModel_Results, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.SetFileName = new_instancemethod(_Transfer.Transfer_ResultFromModel_SetFileName, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.SetMainResult = new_instancemethod(_Transfer.Transfer_ResultFromModel_SetMainResult, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.SetModel = new_instancemethod(_Transfer.Transfer_ResultFromModel_SetModel, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.Strip = new_instancemethod(_Transfer.Transfer_ResultFromModel_Strip, None, Transfer_ResultFromModel)
Transfer_ResultFromModel.TransferredList = new_instancemethod(_Transfer.Transfer_ResultFromModel_TransferredList, None, Transfer_ResultFromModel)
Transfer_ResultFromModel_swigregister = _Transfer.Transfer_ResultFromModel_swigregister
Transfer_ResultFromModel_swigregister(Transfer_ResultFromModel)

class Transfer_ResultFromTransient(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddSubResult(self, *args) -> "void":
        """
        * Adds a sub-result
        	:param sub:
        	:type sub: Transfer_ResultFromTransient
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromTransient_AddSubResult(self, *args)


    def Binder(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        * Returns the binder
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ResultFromTransient_Binder(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check > const":
        """
        * Returns the check (or an empty one if no binder)
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Transfer.Transfer_ResultFromTransient_Check(self, *args)


    def CheckStatus(self, *args) -> "Interface_CheckStatus":
        """
        * Returns the check status
        	:rtype: Interface_CheckStatus
        """
        return _Transfer.Transfer_ResultFromTransient_CheckStatus(self, *args)


    def ClearSubs(self, *args) -> "void":
        """
        * Clears the list of (immediate) sub-results
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromTransient_ClearSubs(self, *args)


    def Fill(self, *args) -> "void":
        """
        * Fills from a TransientProcess, with the starting entity which must have been set before. It works with scopes, calls Fill on each of its sub-results
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromTransient_Fill(self, *args)


    def FillBack(self, *args) -> "void":
        """
        * Fills back a TransientProcess with definition of a ResultFromTransient, respectfully to its structuration in scopes
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromTransient_FillBack(self, *args)


    def FillMap(self, *args) -> "void":
        """
        * This method is used by ResultFromModel to collate the list of ResultFromTransient, avoiding duplications with a map Remark : <self> is already in the map and has not to be bound
        	:param map:
        	:type map: TColStd_IndexedMapOfTransient
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromTransient_FillMap(self, *args)


    def HasResult(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a result is recorded
        	:rtype: bool
        """
        return _Transfer.Transfer_ResultFromTransient_HasResult(self, *args)


    def NbSubResults(self, *args) -> "Standard_Integer":
        """
        * Returns the count of recorded sub-results
        	:rtype: int
        """
        return _Transfer.Transfer_ResultFromTransient_NbSubResults(self, *args)


    def ResultFromKey(self, *args) -> "opencascade::handle< Transfer_ResultFromTransient >":
        """
        * Returns the ResultFromTransient attached to a given starting entity (the key). Returns a null handle if not found
        	:param key:
        	:type key: Standard_Transient
        	:rtype: opencascade::handle<Transfer_ResultFromTransient>
        """
        return _Transfer.Transfer_ResultFromTransient_ResultFromKey(self, *args)


    def SetBinder(self, *args) -> "void":
        """
        * Sets Binder (for result plus individual check)
        	:param binder:
        	:type binder: Transfer_Binder
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromTransient_SetBinder(self, *args)


    def SetStart(self, *args) -> "void":
        """
        * Sets starting entity
        	:param start:
        	:type start: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromTransient_SetStart(self, *args)


    def Start(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns the starting entity
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_ResultFromTransient_Start(self, *args)


    def Strip(self, *args) -> "void":
        """
        * Clears some data attached to binders used by TransientProcess, which become useless once the transfer has been done : the list of sub-scoped binders, which is now recorded as sub-results
        	:rtype: None
        """
        return _Transfer.Transfer_ResultFromTransient_Strip(self, *args)


    def SubResult(self, *args) -> "opencascade::handle< Transfer_ResultFromTransient >":
        """
        * Returns a sub-result, given its rank
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Transfer_ResultFromTransient>
        """
        return _Transfer.Transfer_ResultFromTransient_SubResult(self, *args)


    def __init__(self, *args):
        """
        * Creates a ResultFromTransient, empty
        	:rtype: None
        """
        _Transfer.Transfer_ResultFromTransient_swiginit(self, _Transfer.new_Transfer_ResultFromTransient(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_ResultFromTransient_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_ResultFromTransient
Transfer_ResultFromTransient.AddSubResult = new_instancemethod(_Transfer.Transfer_ResultFromTransient_AddSubResult, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.Binder = new_instancemethod(_Transfer.Transfer_ResultFromTransient_Binder, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.Check = new_instancemethod(_Transfer.Transfer_ResultFromTransient_Check, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.CheckStatus = new_instancemethod(_Transfer.Transfer_ResultFromTransient_CheckStatus, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.ClearSubs = new_instancemethod(_Transfer.Transfer_ResultFromTransient_ClearSubs, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.Fill = new_instancemethod(_Transfer.Transfer_ResultFromTransient_Fill, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.FillBack = new_instancemethod(_Transfer.Transfer_ResultFromTransient_FillBack, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.FillMap = new_instancemethod(_Transfer.Transfer_ResultFromTransient_FillMap, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.HasResult = new_instancemethod(_Transfer.Transfer_ResultFromTransient_HasResult, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.NbSubResults = new_instancemethod(_Transfer.Transfer_ResultFromTransient_NbSubResults, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.ResultFromKey = new_instancemethod(_Transfer.Transfer_ResultFromTransient_ResultFromKey, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.SetBinder = new_instancemethod(_Transfer.Transfer_ResultFromTransient_SetBinder, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.SetStart = new_instancemethod(_Transfer.Transfer_ResultFromTransient_SetStart, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.Start = new_instancemethod(_Transfer.Transfer_ResultFromTransient_Start, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.Strip = new_instancemethod(_Transfer.Transfer_ResultFromTransient_Strip, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient.SubResult = new_instancemethod(_Transfer.Transfer_ResultFromTransient_SubResult, None, Transfer_ResultFromTransient)
Transfer_ResultFromTransient_swigregister = _Transfer.Transfer_ResultFromTransient_swigregister
Transfer_ResultFromTransient_swigregister(Transfer_ResultFromTransient)

class Transfer_TransferDispatch(OCC.Core.Interface.Interface_CopyTool):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a TransferDispatch from a Model. Works with a General Service Library, given as an Argument A TransferDispatch is created as a CopyTool in which the Control is set to TransientProcess
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param lib:
        	:type lib: Interface_GeneralLib
        	:rtype: None
        * Same as above, but Library is defined through a Protocol
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:rtype: None
        * Same as above, but works with the Active Protocol
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        """
        _Transfer.Transfer_TransferDispatch_swiginit(self, _Transfer.new_Transfer_TransferDispatch(*args))

    def TransientProcess(self, *args) -> "opencascade::handle< Transfer_TransientProcess >":
        """
        * Returns the content of Control Object, as a TransientProcess
        	:rtype: opencascade::handle<Transfer_TransientProcess>
        """
        return _Transfer.Transfer_TransferDispatch_TransientProcess(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_TransferDispatch
Transfer_TransferDispatch.TransientProcess = new_instancemethod(_Transfer.Transfer_TransferDispatch_TransientProcess, None, Transfer_TransferDispatch)
Transfer_TransferDispatch_swigregister = _Transfer.Transfer_TransferDispatch_swigregister
Transfer_TransferDispatch_swigregister(Transfer_TransferDispatch)

class Transfer_TransferInput(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Entities(self, *args) -> "Interface_EntityIterator":
        """
        * Takes the transient items stored in a TransferIterator
        	:param list:
        	:type list: Transfer_TransferIterator
        	:rtype: Interface_EntityIterator
        """
        return _Transfer.Transfer_TransferInput_Entities(self, *args)


    def FillModel(self, *args) -> "void":
        """
        * Fills an InterfaceModel with the Complete Result of a Transfer stored in a TransientProcess (Starting Objects are Transient) The complete result is exactly added to the model
        	:param proc:
        	:type proc: Transfer_TransientProcess
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        * Fills an InterfaceModel with results of the Transfer recorded in a TransientProcess (Starting Objects are Transient) : Root Result if <roots> is True (Default), Complete Result else The entities added to the model are determined from the result by by adding the referenced entities
        	:param proc:
        	:type proc: Transfer_TransientProcess
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param proto:
        	:type proto: Interface_Protocol
        	:param roots: default value is Standard_True
        	:type roots: bool
        	:rtype: None
        * Fills an InterfaceModel with the Complete Result of a Transfer stored in a TransientProcess (Starting Objects are Transient) The complete result is exactly added to the model
        	:param proc:
        	:type proc: Transfer_FinderProcess
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        * Fills an InterfaceModel with results of the Transfer recorded in a TransientProcess (Starting Objects are Transient) : Root Result if <roots> is True (Default), Complete Result else The entities added to the model are determined from the result by by adding the referenced entities
        	:param proc:
        	:type proc: Transfer_FinderProcess
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param proto:
        	:type proto: Interface_Protocol
        	:param roots: default value is Standard_True
        	:type roots: bool
        	:rtype: None
        """
        return _Transfer.Transfer_TransferInput_FillModel(self, *args)


    def __init__(self, *args):
        """
        * Creates a TransferInput ready to use
        	:rtype: None
        """
        _Transfer.Transfer_TransferInput_swiginit(self, _Transfer.new_Transfer_TransferInput(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_TransferInput
Transfer_TransferInput.Entities = new_instancemethod(_Transfer.Transfer_TransferInput_Entities, None, Transfer_TransferInput)
Transfer_TransferInput.FillModel = new_instancemethod(_Transfer.Transfer_TransferInput_FillModel, None, Transfer_TransferInput)
Transfer_TransferInput_swigregister = _Transfer.Transfer_TransferInput_swigregister
Transfer_TransferInput_swigregister(Transfer_TransferInput)

class Transfer_TransferIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddItem(self, *args) -> "void":
        """
        * Adds a Binder to the iteration list (construction)
        	:param atr:
        	:type atr: Transfer_Binder
        	:rtype: None
        """
        return _Transfer.Transfer_TransferIterator_AddItem(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check > const":
        """
        * Returns Check associated to current Binder (in case of error, it brings Fail messages) (in case of warnings, it brings Warning messages)
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Transfer.Transfer_TransferIterator_Check(self, *args)


    def HasFails(self, *args) -> "Standard_Boolean":
        """
        * Returns True if Fail Messages are recorded with the current Binder. They can then be read through Check (see below)
        	:rtype: bool
        """
        return _Transfer.Transfer_TransferIterator_HasFails(self, *args)


    def HasResult(self, *args) -> "Standard_Boolean":
        """
        * Returns True if current Item brings a Result, Transient (Handle) or not or Multiple. That is to say, if it corresponds to a normally acheived Transfer, Transient Result is read by specific TransientResult below. Other kind of Result must be read specifically from its Binder
        	:rtype: bool
        """
        return _Transfer.Transfer_TransferIterator_HasResult(self, *args)


    def HasTransientResult(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the current Item has a Transient Unique Result (if yes, use TransientResult to get it)
        	:rtype: bool
        """
        return _Transfer.Transfer_TransferIterator_HasTransientResult(self, *args)


    def HasUniqueResult(self, *args) -> "Standard_Boolean":
        """
        * Returns True if Current Item has a Unique Result
        	:rtype: bool
        """
        return _Transfer.Transfer_TransferIterator_HasUniqueResult(self, *args)


    def HasWarnings(self, *args) -> "Standard_Boolean":
        """
        * Returns True if Warning Messages are recorded with the current Binder. They can then be read through Check (see below)
        	:rtype: bool
        """
        return _Transfer.Transfer_TransferIterator_HasWarnings(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there are other Items to iterate
        	:rtype: bool
        """
        return _Transfer.Transfer_TransferIterator_More(self, *args)


    def Next(self, *args) -> "void":
        """
        * Sets Iteration to the next Item
        	:rtype: None
        """
        return _Transfer.Transfer_TransferIterator_Next(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        * Returns count of Binders to be iterated
        	:rtype: int
        """
        return _Transfer.Transfer_TransferIterator_Number(self, *args)


    def ResultType(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns the Type of the Result of the current Item, if Unique. If No Unique Result (Error Transfert or Multiple Result), returns a Null Handle The Type is : the Dynamic Type for a Transient Result, the Type defined by the Binder Class else
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _Transfer.Transfer_TransferIterator_ResultType(self, *args)


    def SelectBinder(self, *args) -> "void":
        """
        * Selects Items on the Type of Binder : keep only Binders which are of a given Type (if keep is True) or reject only them (if keep is False)
        	:param atype:
        	:type atype: Standard_Type
        	:param keep:
        	:type keep: bool
        	:rtype: None
        """
        return _Transfer.Transfer_TransferIterator_SelectBinder(self, *args)


    def SelectItem(self, *args) -> "void":
        """
        * Selects/Unselect (according to <keep> an item designated by its rank <num> in the list Used by sub-classes which have specific criteria
        	:param num:
        	:type num: int
        	:param keep:
        	:type keep: bool
        	:rtype: None
        """
        return _Transfer.Transfer_TransferIterator_SelectItem(self, *args)


    def SelectResult(self, *args) -> "void":
        """
        * Selects Items on the Type of Result. Considers only Unique Results. Considers Dynamic Type for Transient Result, Static Type (the one given to define the Binder) else. //! Results which are of a given Type (if keep is True) or reject only them (if keep is False)
        	:param atype:
        	:type atype: Standard_Type
        	:param keep:
        	:type keep: bool
        	:rtype: None
        """
        return _Transfer.Transfer_TransferIterator_SelectResult(self, *args)


    def SelectUnique(self, *args) -> "void":
        """
        * Select Items according Unicity : keep only Unique Results (if keep is True) or keep only Multiple Results (if keep is False)
        	:param keep:
        	:type keep: bool
        	:rtype: None
        """
        return _Transfer.Transfer_TransferIterator_SelectUnique(self, *args)


    def Start(self, *args) -> "void":
        """
        * Clears Iteration in progress, to allow it to be restarted
        	:rtype: None
        """
        return _Transfer.Transfer_TransferIterator_Start(self, *args)


    def Status(self, *args) -> "Transfer_StatusExec":
        """
        * Returns Execution Status of current Binder Normal transfer corresponds to StatusDone
        	:rtype: Transfer_StatusExec
        """
        return _Transfer.Transfer_TransferIterator_Status(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty Iterator
        	:rtype: None
        """
        _Transfer.Transfer_TransferIterator_swiginit(self, _Transfer.new_Transfer_TransferIterator(*args))

    def TransientResult(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the Transient Result of the current Item if there is (else, returns a null Handle) Supposes that Binding is done by a SimpleBinderOfTransient
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_TransferIterator_TransientResult(self, *args)


    def Value(self, *args) -> "opencascade::handle< Transfer_Binder > const &":
        """
        * Returns the current Binder
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_TransferIterator_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_TransferIterator
Transfer_TransferIterator.AddItem = new_instancemethod(_Transfer.Transfer_TransferIterator_AddItem, None, Transfer_TransferIterator)
Transfer_TransferIterator.Check = new_instancemethod(_Transfer.Transfer_TransferIterator_Check, None, Transfer_TransferIterator)
Transfer_TransferIterator.HasFails = new_instancemethod(_Transfer.Transfer_TransferIterator_HasFails, None, Transfer_TransferIterator)
Transfer_TransferIterator.HasResult = new_instancemethod(_Transfer.Transfer_TransferIterator_HasResult, None, Transfer_TransferIterator)
Transfer_TransferIterator.HasTransientResult = new_instancemethod(_Transfer.Transfer_TransferIterator_HasTransientResult, None, Transfer_TransferIterator)
Transfer_TransferIterator.HasUniqueResult = new_instancemethod(_Transfer.Transfer_TransferIterator_HasUniqueResult, None, Transfer_TransferIterator)
Transfer_TransferIterator.HasWarnings = new_instancemethod(_Transfer.Transfer_TransferIterator_HasWarnings, None, Transfer_TransferIterator)
Transfer_TransferIterator.More = new_instancemethod(_Transfer.Transfer_TransferIterator_More, None, Transfer_TransferIterator)
Transfer_TransferIterator.Next = new_instancemethod(_Transfer.Transfer_TransferIterator_Next, None, Transfer_TransferIterator)
Transfer_TransferIterator.Number = new_instancemethod(_Transfer.Transfer_TransferIterator_Number, None, Transfer_TransferIterator)
Transfer_TransferIterator.ResultType = new_instancemethod(_Transfer.Transfer_TransferIterator_ResultType, None, Transfer_TransferIterator)
Transfer_TransferIterator.SelectBinder = new_instancemethod(_Transfer.Transfer_TransferIterator_SelectBinder, None, Transfer_TransferIterator)
Transfer_TransferIterator.SelectItem = new_instancemethod(_Transfer.Transfer_TransferIterator_SelectItem, None, Transfer_TransferIterator)
Transfer_TransferIterator.SelectResult = new_instancemethod(_Transfer.Transfer_TransferIterator_SelectResult, None, Transfer_TransferIterator)
Transfer_TransferIterator.SelectUnique = new_instancemethod(_Transfer.Transfer_TransferIterator_SelectUnique, None, Transfer_TransferIterator)
Transfer_TransferIterator.Start = new_instancemethod(_Transfer.Transfer_TransferIterator_Start, None, Transfer_TransferIterator)
Transfer_TransferIterator.Status = new_instancemethod(_Transfer.Transfer_TransferIterator_Status, None, Transfer_TransferIterator)
Transfer_TransferIterator.TransientResult = new_instancemethod(_Transfer.Transfer_TransferIterator_TransientResult, None, Transfer_TransferIterator)
Transfer_TransferIterator.Value = new_instancemethod(_Transfer.Transfer_TransferIterator_Value, None, Transfer_TransferIterator)
Transfer_TransferIterator_swigregister = _Transfer.Transfer_TransferIterator_swigregister
Transfer_TransferIterator_swigregister(Transfer_TransferIterator)

class Transfer_TransferOutput(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ListForStatus(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of Starting Entities with these criteria : - <normal> False, gives the entities bound with ABNORMAL STATUS (e.g. : Fail recorded, Exception raised during Transfer) - <normal> True, gives Entities with or without a Result, but with no Fail, no Exception (Warnings are not counted) - <roots> False, considers all entities recorded (either for Result, or for at least one Fail or Warning message) - <roots> True (Default), considers only roots of Transfer (the Entities recorded at highest level) This method is based on AbnormalResult from TransferProcess
        	:param normal:
        	:type normal: bool
        	:param roots: default value is Standard_True
        	:type roots: bool
        	:rtype: Interface_EntityIterator
        """
        return _Transfer.Transfer_TransferOutput_ListForStatus(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the Starting Model
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Transfer.Transfer_TransferOutput_Model(self, *args)


    def ModelForStatus(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Fills a Model with the list determined by ListForStatus This model starts from scratch (made by NewEmptyModel from the current Model), then is filled by AddWithRefs //! Useful to get separately from a transfer, the entities which have caused problem, in order to furtherly analyse them (with normal = False), or the 'good' entities, to obtain a data set 'which works well' (with normal = True)
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:param normal:
        	:type normal: bool
        	:param roots: default value is Standard_True
        	:type roots: bool
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Transfer.Transfer_TransferOutput_ModelForStatus(self, *args)


    def Transfer(self, *args) -> "void":
        """
        * Transfer checks that all taken Entities come from the same Model, then calls Transfer from TransientProcess
        	:param obj:
        	:type obj: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_TransferOutput_Transfer(self, *args)


    def TransferRoots(self, *args) -> "void":
        """
        * Runs transfer on the roots of the Interface Model The Roots are computed with a ShareFlags created from a Protocol given as Argument
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:rtype: None
        * Runs transfer on the roots defined by a Graph of dependences (which detains also a Model and its Entities) Roots are computed with a ShareFlags created from the Graph
        	:param G:
        	:type G: Interface_Graph
        	:rtype: None
        * Runs transfer on the roots of the Interface Model Remark : the Roots are computed with a ShareFlags created from the Active Protocol
        	:rtype: None
        """
        return _Transfer.Transfer_TransferOutput_TransferRoots(self, *args)


    def __init__(self, *args):
        """
        * Creates a TransferOutput ready to use, with a TransientProcess
        	:param actor:
        	:type actor: Transfer_ActorOfTransientProcess
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        * Creates a TransferOutput from an already existing TransientProcess, and a Model Returns (by Reference, hence can be changed) the Mode for Scope Management. False (D) means Scope is ignored. True means that each individual Transfer (direct or through TransferRoots) is regarded as one Scope
        	:param proc:
        	:type proc: Transfer_TransientProcess
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        """
        _Transfer.Transfer_TransferOutput_swiginit(self, _Transfer.new_Transfer_TransferOutput(*args))

    def TransientProcess(self, *args) -> "opencascade::handle< Transfer_TransientProcess >":
        """
        * Returns the TransientProcess used to work
        	:rtype: opencascade::handle<Transfer_TransientProcess>
        """
        return _Transfer.Transfer_TransferOutput_TransientProcess(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_TransferOutput
Transfer_TransferOutput.ListForStatus = new_instancemethod(_Transfer.Transfer_TransferOutput_ListForStatus, None, Transfer_TransferOutput)
Transfer_TransferOutput.Model = new_instancemethod(_Transfer.Transfer_TransferOutput_Model, None, Transfer_TransferOutput)
Transfer_TransferOutput.ModelForStatus = new_instancemethod(_Transfer.Transfer_TransferOutput_ModelForStatus, None, Transfer_TransferOutput)
Transfer_TransferOutput.Transfer = new_instancemethod(_Transfer.Transfer_TransferOutput_Transfer, None, Transfer_TransferOutput)
Transfer_TransferOutput.TransferRoots = new_instancemethod(_Transfer.Transfer_TransferOutput_TransferRoots, None, Transfer_TransferOutput)
Transfer_TransferOutput.TransientProcess = new_instancemethod(_Transfer.Transfer_TransferOutput_TransientProcess, None, Transfer_TransferOutput)
Transfer_TransferOutput_swigregister = _Transfer.Transfer_TransferOutput_swigregister
Transfer_TransferOutput_swigregister(Transfer_TransferOutput)

class Transfer_ActorOfFinderProcess(Transfer_ActorOfProcessForFinder):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetModeTrans(self) -> "Standard_Integer":
        """GetModeTrans(Transfer_ActorOfFinderProcess self) -> Standard_Integer"""
        return _Transfer.Transfer_ActorOfFinderProcess_GetModeTrans(self)


    def SetModeTrans(self, value: 'Standard_Integer') -> "void":
        """SetModeTrans(Transfer_ActorOfFinderProcess self, Standard_Integer value)"""
        return _Transfer.Transfer_ActorOfFinderProcess_SetModeTrans(self, value)


    def Transfer(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        :param start:
        	:type start: Transfer_Finder
        	:param TP:
        	:type TP: Transfer_FinderProcess
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ActorOfFinderProcess_Transfer(self, *args)


    def TransferTransient(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        :param start:
        	:type start: Standard_Transient
        	:param TP:
        	:type TP: Transfer_FinderProcess
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_ActorOfFinderProcess_TransferTransient(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _Transfer.Transfer_ActorOfFinderProcess_swiginit(self, _Transfer.new_Transfer_ActorOfFinderProcess(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_ActorOfFinderProcess_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_ActorOfFinderProcess
Transfer_ActorOfFinderProcess.GetModeTrans = new_instancemethod(_Transfer.Transfer_ActorOfFinderProcess_GetModeTrans, None, Transfer_ActorOfFinderProcess)
Transfer_ActorOfFinderProcess.SetModeTrans = new_instancemethod(_Transfer.Transfer_ActorOfFinderProcess_SetModeTrans, None, Transfer_ActorOfFinderProcess)
Transfer_ActorOfFinderProcess.Transfer = new_instancemethod(_Transfer.Transfer_ActorOfFinderProcess_Transfer, None, Transfer_ActorOfFinderProcess)
Transfer_ActorOfFinderProcess.TransferTransient = new_instancemethod(_Transfer.Transfer_ActorOfFinderProcess_TransferTransient, None, Transfer_ActorOfFinderProcess)
Transfer_ActorOfFinderProcess_swigregister = _Transfer.Transfer_ActorOfFinderProcess_swigregister
Transfer_ActorOfFinderProcess_swigregister(Transfer_ActorOfFinderProcess)

class Transfer_ActorOfTransientProcess(Transfer_ActorOfProcessForTransient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Transfer(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        :param start:
        	:type start: Standard_Transient
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _Transfer.Transfer_ActorOfTransientProcess_Transfer(self, *args)


    def TransferTransient(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        :param start:
        	:type start: Standard_Transient
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_ActorOfTransientProcess_TransferTransient(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _Transfer.Transfer_ActorOfTransientProcess_swiginit(self, _Transfer.new_Transfer_ActorOfTransientProcess(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_ActorOfTransientProcess_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_ActorOfTransientProcess
Transfer_ActorOfTransientProcess.Transfer = new_instancemethod(_Transfer.Transfer_ActorOfTransientProcess_Transfer, None, Transfer_ActorOfTransientProcess)
Transfer_ActorOfTransientProcess.TransferTransient = new_instancemethod(_Transfer.Transfer_ActorOfTransientProcess_TransferTransient, None, Transfer_ActorOfTransientProcess)
Transfer_ActorOfTransientProcess_swigregister = _Transfer.Transfer_ActorOfTransientProcess_swigregister
Transfer_ActorOfTransientProcess_swigregister(Transfer_ActorOfTransientProcess)

class Transfer_FinderProcess(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the Model which can be used for context
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Transfer.Transfer_FinderProcess_Model(self, *args)


    def NextMappedWithAttribute(self, *args) -> "Standard_Integer":
        """
        * In the list of mapped items (between 1 and NbMapped), searches for the first mapped item which follows <num0> (not included) and which has an attribute named <name> The considered Attributes are those brought by Finders,i.e. by Input data. While NextItemWithAttribute works on Result data (Binders) //! Hence, allows such an iteration //! for (num = FP->NextMappedWithAttribute(name,0); num > 0; num = FP->NextMappedWithAttribute(name,num) { .. process mapped item <num> }
        	:param name:
        	:type name: char *
        	:param num0:
        	:type num0: int
        	:rtype: int
        """
        return _Transfer.Transfer_FinderProcess_NextMappedWithAttribute(self, *args)


    def PrintStats(self, *args) -> "void":
        """
        * Prints statistics on a given output, according mode
        	:param mode:
        	:type mode: int
        	:param S:
        	:type S: Message_Messenger
        	:rtype: None
        """
        return _Transfer.Transfer_FinderProcess_PrintStats(self, *args)


    def PrintTrace(self, *args) -> "void":
        """
        * Specific printing to trace a Finder (by its method ValueType)
        	:param start:
        	:type start: Transfer_Finder
        	:param S:
        	:type S: Message_Messenger
        	:rtype: void
        """
        return _Transfer.Transfer_FinderProcess_PrintTrace(self, *args)


    def SetModel(self, *args) -> "void":
        """
        * Sets an InterfaceModel, which can be used during transfer for instance if a context must be managed, it is in the Model
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: None
        """
        return _Transfer.Transfer_FinderProcess_SetModel(self, *args)


    def __init__(self, *args):
        """
        * Sets FinderProcess at initial state, with an initial size
        	:param nb: default value is 10000
        	:type nb: int
        	:rtype: None
        """
        _Transfer.Transfer_FinderProcess_swiginit(self, _Transfer.new_Transfer_FinderProcess(*args))

    def TransientMapper(self, *args) -> "opencascade::handle< Transfer_TransientMapper >":
        """
        * Returns a TransientMapper for a given Transient Object Either <obj> is already mapped, then its Mapper is returned Or it is not, then a new one is created then returned, BUT it is not mapped here (use Bind or FindElseBind to do this)
        	:param obj:
        	:type obj: Standard_Transient
        	:rtype: opencascade::handle<Transfer_TransientMapper>
        """
        return _Transfer.Transfer_FinderProcess_TransientMapper(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_FinderProcess_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_FinderProcess
Transfer_FinderProcess.Model = new_instancemethod(_Transfer.Transfer_FinderProcess_Model, None, Transfer_FinderProcess)
Transfer_FinderProcess.NextMappedWithAttribute = new_instancemethod(_Transfer.Transfer_FinderProcess_NextMappedWithAttribute, None, Transfer_FinderProcess)
Transfer_FinderProcess.PrintStats = new_instancemethod(_Transfer.Transfer_FinderProcess_PrintStats, None, Transfer_FinderProcess)
Transfer_FinderProcess.PrintTrace = new_instancemethod(_Transfer.Transfer_FinderProcess_PrintTrace, None, Transfer_FinderProcess)
Transfer_FinderProcess.SetModel = new_instancemethod(_Transfer.Transfer_FinderProcess_SetModel, None, Transfer_FinderProcess)
Transfer_FinderProcess.TransientMapper = new_instancemethod(_Transfer.Transfer_FinderProcess_TransientMapper, None, Transfer_FinderProcess)
Transfer_FinderProcess_swigregister = _Transfer.Transfer_FinderProcess_swigregister
Transfer_FinderProcess_swigregister(Transfer_FinderProcess)

class Transfer_IteratorOfProcessForFinder(Transfer_TransferIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a Binder to the iteration list (construction) with no corresponding Starting Object (note that Result is brought by Binder)
        	:param binder:
        	:type binder: Transfer_Binder
        	:rtype: None
        * Adds a Binder to the iteration list, associated with its corresponding Starting Object 'start' Starting Object is ignored if not required at Creation time
        	:param binder:
        	:type binder: Transfer_Binder
        	:param start:
        	:type start: Transfer_Finder
        	:rtype: None
        """
        return _Transfer.Transfer_IteratorOfProcessForFinder_Add(self, *args)


    def Filter(self, *args) -> "void":
        """
        * After having added all items, keeps or rejects items which are attached to starting data given by <only> <keep> = True (D) : keeps. <keep> = False : rejects Does nothing if <withstarts> was False
        	:param list:
        	:type list: Transfer_HSequenceOfFinder
        	:param keep: default value is Standard_True
        	:type keep: bool
        	:rtype: None
        """
        return _Transfer.Transfer_IteratorOfProcessForFinder_Filter(self, *args)


    def HasStarting(self, *args) -> "Standard_Boolean":
        """
        * Returns True if Starting Object is available (defined at Creation Time)
        	:rtype: bool
        """
        return _Transfer.Transfer_IteratorOfProcessForFinder_HasStarting(self, *args)


    def Starting(self, *args) -> "opencascade::handle< Transfer_Finder > const &":
        """
        * Returns corresponding Starting Object
        	:rtype: opencascade::handle<Transfer_Finder>
        """
        return _Transfer.Transfer_IteratorOfProcessForFinder_Starting(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty Iterator if withstarts is True, each Binder to be iterated will be associated to its corresponding Starting Object
        	:param withstarts:
        	:type withstarts: bool
        	:rtype: None
        """
        _Transfer.Transfer_IteratorOfProcessForFinder_swiginit(self, _Transfer.new_Transfer_IteratorOfProcessForFinder(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_IteratorOfProcessForFinder
Transfer_IteratorOfProcessForFinder.Add = new_instancemethod(_Transfer.Transfer_IteratorOfProcessForFinder_Add, None, Transfer_IteratorOfProcessForFinder)
Transfer_IteratorOfProcessForFinder.Filter = new_instancemethod(_Transfer.Transfer_IteratorOfProcessForFinder_Filter, None, Transfer_IteratorOfProcessForFinder)
Transfer_IteratorOfProcessForFinder.HasStarting = new_instancemethod(_Transfer.Transfer_IteratorOfProcessForFinder_HasStarting, None, Transfer_IteratorOfProcessForFinder)
Transfer_IteratorOfProcessForFinder.Starting = new_instancemethod(_Transfer.Transfer_IteratorOfProcessForFinder_Starting, None, Transfer_IteratorOfProcessForFinder)
Transfer_IteratorOfProcessForFinder_swigregister = _Transfer.Transfer_IteratorOfProcessForFinder_swigregister
Transfer_IteratorOfProcessForFinder_swigregister(Transfer_IteratorOfProcessForFinder)

class Transfer_IteratorOfProcessForTransient(Transfer_TransferIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a Binder to the iteration list (construction) with no corresponding Starting Object (note that Result is brought by Binder)
        	:param binder:
        	:type binder: Transfer_Binder
        	:rtype: None
        * Adds a Binder to the iteration list, associated with its corresponding Starting Object 'start' Starting Object is ignored if not required at Creation time
        	:param binder:
        	:type binder: Transfer_Binder
        	:param start:
        	:type start: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_IteratorOfProcessForTransient_Add(self, *args)


    def Filter(self, *args) -> "void":
        """
        * After having added all items, keeps or rejects items which are attached to starting data given by <only> <keep> = True (D) : keeps. <keep> = False : rejects Does nothing if <withstarts> was False
        	:param list:
        	:type list: TColStd_HSequenceOfTransient
        	:param keep: default value is Standard_True
        	:type keep: bool
        	:rtype: None
        """
        return _Transfer.Transfer_IteratorOfProcessForTransient_Filter(self, *args)


    def HasStarting(self, *args) -> "Standard_Boolean":
        """
        * Returns True if Starting Object is available (defined at Creation Time)
        	:rtype: bool
        """
        return _Transfer.Transfer_IteratorOfProcessForTransient_HasStarting(self, *args)


    def Starting(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns corresponding Starting Object
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_IteratorOfProcessForTransient_Starting(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty Iterator if withstarts is True, each Binder to be iterated will be associated to its corresponding Starting Object
        	:param withstarts:
        	:type withstarts: bool
        	:rtype: None
        """
        _Transfer.Transfer_IteratorOfProcessForTransient_swiginit(self, _Transfer.new_Transfer_IteratorOfProcessForTransient(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_IteratorOfProcessForTransient
Transfer_IteratorOfProcessForTransient.Add = new_instancemethod(_Transfer.Transfer_IteratorOfProcessForTransient_Add, None, Transfer_IteratorOfProcessForTransient)
Transfer_IteratorOfProcessForTransient.Filter = new_instancemethod(_Transfer.Transfer_IteratorOfProcessForTransient_Filter, None, Transfer_IteratorOfProcessForTransient)
Transfer_IteratorOfProcessForTransient.HasStarting = new_instancemethod(_Transfer.Transfer_IteratorOfProcessForTransient_HasStarting, None, Transfer_IteratorOfProcessForTransient)
Transfer_IteratorOfProcessForTransient.Starting = new_instancemethod(_Transfer.Transfer_IteratorOfProcessForTransient_Starting, None, Transfer_IteratorOfProcessForTransient)
Transfer_IteratorOfProcessForTransient_swigregister = _Transfer.Transfer_IteratorOfProcessForTransient_swigregister
Transfer_IteratorOfProcessForTransient_swigregister(Transfer_IteratorOfProcessForTransient)

class Transfer_MultipleBinder(Transfer_Binder):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddResult(self, *args) -> "void":
        """
        * Adds a new Item to the Multiple Result
        	:param res:
        	:type res: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_MultipleBinder_AddResult(self, *args)


    def MultipleResult(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the Multiple Result, if it is defined (at least one Item). Else, returns a Null Handle
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _Transfer.Transfer_MultipleBinder_MultipleResult(self, *args)


    def NbResults(self, *args) -> "Standard_Integer":
        """
        * Returns the actual count of recorded (Transient) results
        	:rtype: int
        """
        return _Transfer.Transfer_MultipleBinder_NbResults(self, *args)


    def ResultValue(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns the value of the recorded result n0 <num>
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_MultipleBinder_ResultValue(self, *args)


    def SetMultipleResult(self, *args) -> "void":
        """
        * Defines a Binding with a Multiple Result, given as a Sequence Error if a Unique Result has yet been defined
        	:param mulres:
        	:type mulres: TColStd_HSequenceOfTransient
        	:rtype: None
        """
        return _Transfer.Transfer_MultipleBinder_SetMultipleResult(self, *args)


    def __init__(self, *args):
        """
        * normal standard constructor, creates an empty MultipleBinder
        	:rtype: None
        """
        _Transfer.Transfer_MultipleBinder_swiginit(self, _Transfer.new_Transfer_MultipleBinder(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_MultipleBinder_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_MultipleBinder
Transfer_MultipleBinder.AddResult = new_instancemethod(_Transfer.Transfer_MultipleBinder_AddResult, None, Transfer_MultipleBinder)
Transfer_MultipleBinder.MultipleResult = new_instancemethod(_Transfer.Transfer_MultipleBinder_MultipleResult, None, Transfer_MultipleBinder)
Transfer_MultipleBinder.NbResults = new_instancemethod(_Transfer.Transfer_MultipleBinder_NbResults, None, Transfer_MultipleBinder)
Transfer_MultipleBinder.ResultValue = new_instancemethod(_Transfer.Transfer_MultipleBinder_ResultValue, None, Transfer_MultipleBinder)
Transfer_MultipleBinder.SetMultipleResult = new_instancemethod(_Transfer.Transfer_MultipleBinder_SetMultipleResult, None, Transfer_MultipleBinder)
Transfer_MultipleBinder_swigregister = _Transfer.Transfer_MultipleBinder_swigregister
Transfer_MultipleBinder_swigregister(Transfer_MultipleBinder)

class Transfer_SimpleBinderOfTransient(Transfer_Binder):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetTypedResult(*args) -> "Standard_Boolean":
        """
        * Returns a transient result according to its type (IsKind) i.e. the result itself if IsKind(atype), else searches in NextResult, until first found, then returns True If not found, returns False (res is NOT touched) //! This syntactic form avoids to do DownCast : if a result is found with the good type, it is loaded in <res> and can be immediately used, well initialised
        	:param bnd:
        	:type bnd: Transfer_Binder
        	:param atype:
        	:type atype: Standard_Type
        	:param res:
        	:type res: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_SimpleBinderOfTransient_GetTypedResult(*args)

    GetTypedResult = staticmethod(GetTypedResult)

    def Result(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the defined Result, if there is one
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_SimpleBinderOfTransient_Result(self, *args)


    def SetResult(self, *args) -> "void":
        """
        * Defines the Result
        	:param res:
        	:type res: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_SimpleBinderOfTransient_SetResult(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty SimpleBinderOfTransient Returns True if a starting object is bound with SEVERAL results : Here, returns allways False See Binder itself
        	:rtype: None
        """
        _Transfer.Transfer_SimpleBinderOfTransient_swiginit(self, _Transfer.new_Transfer_SimpleBinderOfTransient(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_SimpleBinderOfTransient_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_SimpleBinderOfTransient
Transfer_SimpleBinderOfTransient.Result = new_instancemethod(_Transfer.Transfer_SimpleBinderOfTransient_Result, None, Transfer_SimpleBinderOfTransient)
Transfer_SimpleBinderOfTransient.SetResult = new_instancemethod(_Transfer.Transfer_SimpleBinderOfTransient_SetResult, None, Transfer_SimpleBinderOfTransient)
Transfer_SimpleBinderOfTransient_swigregister = _Transfer.Transfer_SimpleBinderOfTransient_swigregister
Transfer_SimpleBinderOfTransient_swigregister(Transfer_SimpleBinderOfTransient)

def Transfer_SimpleBinderOfTransient_GetTypedResult(*args) -> "Standard_Boolean":
    """
    * Returns a transient result according to its type (IsKind) i.e. the result itself if IsKind(atype), else searches in NextResult, until first found, then returns True If not found, returns False (res is NOT touched) //! This syntactic form avoids to do DownCast : if a result is found with the good type, it is loaded in <res> and can be immediately used, well initialised
    	:param bnd:
    	:type bnd: Transfer_Binder
    	:param atype:
    	:type atype: Standard_Type
    	:param res:
    	:type res: Standard_Transient
    	:rtype: bool
    """
    return _Transfer.Transfer_SimpleBinderOfTransient_GetTypedResult(*args)

class Transfer_TransientListBinder(Transfer_Binder):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddResult(self, *args) -> "void":
        """
        * Adds an item to the result list
        	:param res:
        	:type res: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_TransientListBinder_AddResult(self, *args)


    def NbTransients(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Transfer.Transfer_TransientListBinder_NbTransients(self, *args)


    def Result(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """:rtype: opencascade::handle<TColStd_HSequenceOfTransient>"""
        return _Transfer.Transfer_TransientListBinder_Result(self, *args)


    def SetResult(self, *args) -> "void":
        """
        * Changes an already defined sub-result
        	:param num:
        	:type num: int
        	:param res:
        	:type res: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_TransientListBinder_SetResult(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param list:
        	:type list: TColStd_HSequenceOfTransient
        	:rtype: None
        """
        _Transfer.Transfer_TransientListBinder_swiginit(self, _Transfer.new_Transfer_TransientListBinder(*args))

    def Transient(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        :param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_TransientListBinder_Transient(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_TransientListBinder_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_TransientListBinder
Transfer_TransientListBinder.AddResult = new_instancemethod(_Transfer.Transfer_TransientListBinder_AddResult, None, Transfer_TransientListBinder)
Transfer_TransientListBinder.NbTransients = new_instancemethod(_Transfer.Transfer_TransientListBinder_NbTransients, None, Transfer_TransientListBinder)
Transfer_TransientListBinder.Result = new_instancemethod(_Transfer.Transfer_TransientListBinder_Result, None, Transfer_TransientListBinder)
Transfer_TransientListBinder.SetResult = new_instancemethod(_Transfer.Transfer_TransientListBinder_SetResult, None, Transfer_TransientListBinder)
Transfer_TransientListBinder.Transient = new_instancemethod(_Transfer.Transfer_TransientListBinder_Transient, None, Transfer_TransientListBinder)
Transfer_TransientListBinder_swigregister = _Transfer.Transfer_TransientListBinder_swigregister
Transfer_TransientListBinder_swigregister(Transfer_TransientListBinder)

class Transfer_TransientMapper(Transfer_Finder):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a Mapper with a Value. This Value can then not be changed. It is used by the Hasher to compute the HashCode, which will then be stored for an immediate reading.
        	:param akey:
        	:type akey: Standard_Transient
        	:rtype: None
        """
        _Transfer.Transfer_TransientMapper_swiginit(self, _Transfer.new_Transfer_TransientMapper(*args))

    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the contained value
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Transfer.Transfer_TransientMapper_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_TransientMapper_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_TransientMapper
Transfer_TransientMapper.Value = new_instancemethod(_Transfer.Transfer_TransientMapper_Value, None, Transfer_TransientMapper)
Transfer_TransientMapper_swigregister = _Transfer.Transfer_TransientMapper_swigregister
Transfer_TransientMapper_swigregister(Transfer_TransientMapper)

class Transfer_TransientProcess(Transfer_ProcessForTransient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Context(self, *args) -> "NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &":
        """
        * Returns (modifiable) the whole definition of Context Rather for internal use (ex.: preparing and setting in once)
        	:rtype: NCollection_DataMap<TCollection_AsciiString, opencascade::handle<Standard_Transient> >
        """
        return _Transfer.Transfer_TransientProcess_Context(self, *args)


    def GetContext(self, *args) -> "Standard_Boolean":
        """
        * Returns the Context attached to a name, if set and if it is Kind of the type, else a Null Handle Returns True if OK, False if no Context
        	:param name:
        	:type name: char *
        	:param type:
        	:type type: Standard_Type
        	:param ctx:
        	:type ctx: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_TransientProcess_GetContext(self, *args)


    def Graph(self, *args) -> "Interface_Graph const &":
        """:rtype: Interface_Graph"""
        return _Transfer.Transfer_TransientProcess_Graph(self, *args)


    def HGraph(self, *args) -> "opencascade::handle< Interface_HGraph >":
        """:rtype: opencascade::handle<Interface_HGraph>"""
        return _Transfer.Transfer_TransientProcess_HGraph(self, *args)


    def HasGraph(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Transfer.Transfer_TransientProcess_HasGraph(self, *args)


    def IsDataFail(self, *args) -> "Standard_Boolean":
        """
        * Tells if an entity fails on data checking (load time, syntactic, or semantic check). Normally, should answer False. It is not prudent to try transferring an entity which fails on data checking
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_TransientProcess_IsDataFail(self, *args)


    def IsDataLoaded(self, *args) -> "Standard_Boolean":
        """
        * Tells if an entity is well loaded from file (even if its data fail on checking, they are present). Mostly often, answers True. Else, there was a syntactic error in the file. A non-loaded entity MAY NOT BE transferred, unless its Report (in the model) is interpreted
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Transfer.Transfer_TransientProcess_IsDataLoaded(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the Model used for StartTrace
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Transfer.Transfer_TransientProcess_Model(self, *args)


    def PrintStats(self, *args) -> "void":
        """
        * Prints statistics on a given output, according mode
        	:param mode:
        	:type mode: int
        	:param S:
        	:type S: Message_Messenger
        	:rtype: None
        """
        return _Transfer.Transfer_TransientProcess_PrintStats(self, *args)


    def RootsForTransfer(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """:rtype: opencascade::handle<TColStd_HSequenceOfTransient>"""
        return _Transfer.Transfer_TransientProcess_RootsForTransfer(self, *args)


    def SetContext(self, *args) -> "void":
        """
        * Sets a Context : according to receiving appli, to be interpreted by the Actor
        	:param name:
        	:type name: char *
        	:param ctx:
        	:type ctx: Standard_Transient
        	:rtype: None
        """
        return _Transfer.Transfer_TransientProcess_SetContext(self, *args)


    def SetGraph(self, *args) -> "void":
        """
        * Sets a Graph : superseedes SetModel if already done
        	:param HG:
        	:type HG: Interface_HGraph
        	:rtype: None
        """
        return _Transfer.Transfer_TransientProcess_SetGraph(self, *args)


    def SetModel(self, *args) -> "void":
        """
        * Sets an InterfaceModel, used by StartTrace, CheckList, queries on Integrity, to give informations significant for each norm.
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: None
        """
        return _Transfer.Transfer_TransientProcess_SetModel(self, *args)


    def __init__(self, *args):
        """
        * Sets TransientProcess at initial state, with an initial size
        	:param nb: default value is 10000
        	:type nb: int
        	:rtype: None
        """
        _Transfer.Transfer_TransientProcess_swiginit(self, _Transfer.new_Transfer_TransientProcess(*args))

    def TypedSharings(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of sharings entities, AT ANY LEVEL, which are kind of a given type. Calls TypedSharings from Graph Returns an empty list if the Graph has not been aknowledged
        	:param start:
        	:type start: Standard_Transient
        	:param type:
        	:type type: Standard_Type
        	:rtype: Interface_EntityIterator
        """
        return _Transfer.Transfer_TransientProcess_TypedSharings(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Transfer_TransientProcess_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_TransientProcess
Transfer_TransientProcess.Context = new_instancemethod(_Transfer.Transfer_TransientProcess_Context, None, Transfer_TransientProcess)
Transfer_TransientProcess.GetContext = new_instancemethod(_Transfer.Transfer_TransientProcess_GetContext, None, Transfer_TransientProcess)
Transfer_TransientProcess.Graph = new_instancemethod(_Transfer.Transfer_TransientProcess_Graph, None, Transfer_TransientProcess)
Transfer_TransientProcess.HGraph = new_instancemethod(_Transfer.Transfer_TransientProcess_HGraph, None, Transfer_TransientProcess)
Transfer_TransientProcess.HasGraph = new_instancemethod(_Transfer.Transfer_TransientProcess_HasGraph, None, Transfer_TransientProcess)
Transfer_TransientProcess.IsDataFail = new_instancemethod(_Transfer.Transfer_TransientProcess_IsDataFail, None, Transfer_TransientProcess)
Transfer_TransientProcess.IsDataLoaded = new_instancemethod(_Transfer.Transfer_TransientProcess_IsDataLoaded, None, Transfer_TransientProcess)
Transfer_TransientProcess.Model = new_instancemethod(_Transfer.Transfer_TransientProcess_Model, None, Transfer_TransientProcess)
Transfer_TransientProcess.PrintStats = new_instancemethod(_Transfer.Transfer_TransientProcess_PrintStats, None, Transfer_TransientProcess)
Transfer_TransientProcess.RootsForTransfer = new_instancemethod(_Transfer.Transfer_TransientProcess_RootsForTransfer, None, Transfer_TransientProcess)
Transfer_TransientProcess.SetContext = new_instancemethod(_Transfer.Transfer_TransientProcess_SetContext, None, Transfer_TransientProcess)
Transfer_TransientProcess.SetGraph = new_instancemethod(_Transfer.Transfer_TransientProcess_SetGraph, None, Transfer_TransientProcess)
Transfer_TransientProcess.SetModel = new_instancemethod(_Transfer.Transfer_TransientProcess_SetModel, None, Transfer_TransientProcess)
Transfer_TransientProcess.TypedSharings = new_instancemethod(_Transfer.Transfer_TransientProcess_TypedSharings, None, Transfer_TransientProcess)
Transfer_TransientProcess_swigregister = _Transfer.Transfer_TransientProcess_swigregister
Transfer_TransientProcess_swigregister(Transfer_TransientProcess)

class Transfer_VoidBinder(Transfer_Binder):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * a VoidBinder is not Multiple (Remark : it is not Simple too) But it can bring next results ...
        	:rtype: None
        """
        _Transfer.Transfer_VoidBinder_swiginit(self, _Transfer.new_Transfer_VoidBinder(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_VoidBinder_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_VoidBinder
Transfer_VoidBinder_swigregister = _Transfer.Transfer_VoidBinder_swigregister
Transfer_VoidBinder_swigregister(Transfer_VoidBinder)

class Transfer_ActorDispatch(Transfer_ActorOfTransientProcess):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddActor(self, *args) -> "void":
        """
        * Utility which adds an actor to the default <self> (it calls SetActor from the TransientProcess)
        	:param actor:
        	:type actor: Transfer_ActorOfTransientProcess
        	:rtype: None
        """
        return _Transfer.Transfer_ActorDispatch_AddActor(self, *args)


    def TransferDispatch(self, *args) -> "Transfer_TransferDispatch &":
        """
        * Returns the TransferDispatch, which does the work, records the intermediate data, etc... See TransferDispatch & CopyTool, to see the available methods
        	:rtype: Transfer_TransferDispatch
        """
        return _Transfer.Transfer_ActorDispatch_TransferDispatch(self, *args)


    def __init__(self, *args):
        """
        * Creates an ActorDispatch from a Model. Works with a General Service Library, given as an Argument This causes TransferDispatch and its TransientProcess to be created, with default actor <self>
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param lib:
        	:type lib: Interface_GeneralLib
        	:rtype: None
        * Same as above, but Library is defined through a Protocol
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:rtype: None
        * Same as above, but works with the Active Protocol
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        """
        _Transfer.Transfer_ActorDispatch_swiginit(self, _Transfer.new_Transfer_ActorDispatch(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_ActorDispatch_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_ActorDispatch
Transfer_ActorDispatch.AddActor = new_instancemethod(_Transfer.Transfer_ActorDispatch_AddActor, None, Transfer_ActorDispatch)
Transfer_ActorDispatch.TransferDispatch = new_instancemethod(_Transfer.Transfer_ActorDispatch_TransferDispatch, None, Transfer_ActorDispatch)
Transfer_ActorDispatch_swigregister = _Transfer.Transfer_ActorDispatch_swigregister
Transfer_ActorDispatch_swigregister(Transfer_ActorDispatch)

class Transfer_BinderOfTransientInteger(Transfer_SimpleBinderOfTransient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Integer(self, *args) -> "Standard_Integer":
        """
        * Returns the value set for the integer part
        	:rtype: int
        """
        return _Transfer.Transfer_BinderOfTransientInteger_Integer(self, *args)


    def SetInteger(self, *args) -> "void":
        """
        * Sets a value for the integer part
        	:param value:
        	:type value: int
        	:rtype: None
        """
        return _Transfer.Transfer_BinderOfTransientInteger_SetInteger(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty BinderOfTransientInteger; Default value for the integer part is zero
        	:rtype: None
        """
        _Transfer.Transfer_BinderOfTransientInteger_swiginit(self, _Transfer.new_Transfer_BinderOfTransientInteger(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_BinderOfTransientInteger_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Transfer.delete_Transfer_BinderOfTransientInteger
Transfer_BinderOfTransientInteger.Integer = new_instancemethod(_Transfer.Transfer_BinderOfTransientInteger_Integer, None, Transfer_BinderOfTransientInteger)
Transfer_BinderOfTransientInteger.SetInteger = new_instancemethod(_Transfer.Transfer_BinderOfTransientInteger_SetInteger, None, Transfer_BinderOfTransientInteger)
Transfer_BinderOfTransientInteger_swigregister = _Transfer.Transfer_BinderOfTransientInteger_swigregister
Transfer_BinderOfTransientInteger_swigregister(Transfer_BinderOfTransientInteger)

class Transfer_HSequenceOfBinder(Transfer_SequenceOfBinder, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Transfer.Transfer_HSequenceOfBinder_swiginit(self, _Transfer.new_Transfer_HSequenceOfBinder(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_HSequenceOfBinder_DownCast(t)

    __swig_destroy__ = _Transfer.delete_Transfer_HSequenceOfBinder
Transfer_HSequenceOfBinder.Sequence = new_instancemethod(_Transfer.Transfer_HSequenceOfBinder_Sequence, None, Transfer_HSequenceOfBinder)
Transfer_HSequenceOfBinder.Append = new_instancemethod(_Transfer.Transfer_HSequenceOfBinder_Append, None, Transfer_HSequenceOfBinder)
Transfer_HSequenceOfBinder.ChangeSequence = new_instancemethod(_Transfer.Transfer_HSequenceOfBinder_ChangeSequence, None, Transfer_HSequenceOfBinder)
Transfer_HSequenceOfBinder_swigregister = _Transfer.Transfer_HSequenceOfBinder_swigregister
Transfer_HSequenceOfBinder_swigregister(Transfer_HSequenceOfBinder)

class Transfer_HSequenceOfFinder(Transfer_SequenceOfFinder, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Transfer.Transfer_HSequenceOfFinder_swiginit(self, _Transfer.new_Transfer_HSequenceOfFinder(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Transfer_HSequenceOfFinder_DownCast(t)

    __swig_destroy__ = _Transfer.delete_Transfer_HSequenceOfFinder
Transfer_HSequenceOfFinder.Sequence = new_instancemethod(_Transfer.Transfer_HSequenceOfFinder_Sequence, None, Transfer_HSequenceOfFinder)
Transfer_HSequenceOfFinder.Append = new_instancemethod(_Transfer.Transfer_HSequenceOfFinder_Append, None, Transfer_HSequenceOfFinder)
Transfer_HSequenceOfFinder.ChangeSequence = new_instancemethod(_Transfer.Transfer_HSequenceOfFinder_ChangeSequence, None, Transfer_HSequenceOfFinder)
Transfer_HSequenceOfFinder_swigregister = _Transfer.Transfer_HSequenceOfFinder_swigregister
Transfer_HSequenceOfFinder_swigregister(Transfer_HSequenceOfFinder)



