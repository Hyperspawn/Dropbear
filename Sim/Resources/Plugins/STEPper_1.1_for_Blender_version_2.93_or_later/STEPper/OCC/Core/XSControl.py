# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
XSControl module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_xscontrol.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _XSControl.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_XSControl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_XSControl')
    _XSControl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_XSControl', [dirname(__file__)])
        except ImportError:
            import _XSControl
            return _XSControl
        try:
            _mod = imp.load_module('_XSControl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _XSControl = swig_import_helper()
    del swig_import_helper
else:
    import _XSControl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _XSControl.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_XSControl.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_XSControl.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_XSControl.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_XSControl.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_XSControl.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_XSControl.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_XSControl.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_XSControl.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_XSControl.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_XSControl.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_XSControl.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_XSControl.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_XSControl.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_XSControl.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_XSControl.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_XSControl.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _XSControl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _XSControl.process_exception(error, method_name, class_name)
process_exception = _XSControl.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.IFSelect
import OCC.Core.Interface
import OCC.Core.TCollection
import OCC.Core.TColStd
import OCC.Core.Message
import OCC.Core.MoniTool
import OCC.Core.TopoDS
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.OSD
import OCC.Core.Transfer
import OCC.Core.TopTools
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.Geom2d

def Handle_XSControl_ConnectedShapes_Create() -> "opencascade::handle< XSControl_ConnectedShapes >":
    return _XSControl.Handle_XSControl_ConnectedShapes_Create()
Handle_XSControl_ConnectedShapes_Create = _XSControl.Handle_XSControl_ConnectedShapes_Create

def Handle_XSControl_ConnectedShapes_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< XSControl_ConnectedShapes >":
    return _XSControl.Handle_XSControl_ConnectedShapes_DownCast(t)
Handle_XSControl_ConnectedShapes_DownCast = _XSControl.Handle_XSControl_ConnectedShapes_DownCast

def Handle_XSControl_ConnectedShapes_IsNull(t: 'opencascade::handle< XSControl_ConnectedShapes > const &') -> "bool":
    return _XSControl.Handle_XSControl_ConnectedShapes_IsNull(t)
Handle_XSControl_ConnectedShapes_IsNull = _XSControl.Handle_XSControl_ConnectedShapes_IsNull

def Handle_XSControl_Controller_Create() -> "opencascade::handle< XSControl_Controller >":
    return _XSControl.Handle_XSControl_Controller_Create()
Handle_XSControl_Controller_Create = _XSControl.Handle_XSControl_Controller_Create

def Handle_XSControl_Controller_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< XSControl_Controller >":
    return _XSControl.Handle_XSControl_Controller_DownCast(t)
Handle_XSControl_Controller_DownCast = _XSControl.Handle_XSControl_Controller_DownCast

def Handle_XSControl_Controller_IsNull(t: 'opencascade::handle< XSControl_Controller > const &') -> "bool":
    return _XSControl.Handle_XSControl_Controller_IsNull(t)
Handle_XSControl_Controller_IsNull = _XSControl.Handle_XSControl_Controller_IsNull

def Handle_XSControl_SelectForTransfer_Create() -> "opencascade::handle< XSControl_SelectForTransfer >":
    return _XSControl.Handle_XSControl_SelectForTransfer_Create()
Handle_XSControl_SelectForTransfer_Create = _XSControl.Handle_XSControl_SelectForTransfer_Create

def Handle_XSControl_SelectForTransfer_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< XSControl_SelectForTransfer >":
    return _XSControl.Handle_XSControl_SelectForTransfer_DownCast(t)
Handle_XSControl_SelectForTransfer_DownCast = _XSControl.Handle_XSControl_SelectForTransfer_DownCast

def Handle_XSControl_SelectForTransfer_IsNull(t: 'opencascade::handle< XSControl_SelectForTransfer > const &') -> "bool":
    return _XSControl.Handle_XSControl_SelectForTransfer_IsNull(t)
Handle_XSControl_SelectForTransfer_IsNull = _XSControl.Handle_XSControl_SelectForTransfer_IsNull

def Handle_XSControl_SignTransferStatus_Create() -> "opencascade::handle< XSControl_SignTransferStatus >":
    return _XSControl.Handle_XSControl_SignTransferStatus_Create()
Handle_XSControl_SignTransferStatus_Create = _XSControl.Handle_XSControl_SignTransferStatus_Create

def Handle_XSControl_SignTransferStatus_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< XSControl_SignTransferStatus >":
    return _XSControl.Handle_XSControl_SignTransferStatus_DownCast(t)
Handle_XSControl_SignTransferStatus_DownCast = _XSControl.Handle_XSControl_SignTransferStatus_DownCast

def Handle_XSControl_SignTransferStatus_IsNull(t: 'opencascade::handle< XSControl_SignTransferStatus > const &') -> "bool":
    return _XSControl.Handle_XSControl_SignTransferStatus_IsNull(t)
Handle_XSControl_SignTransferStatus_IsNull = _XSControl.Handle_XSControl_SignTransferStatus_IsNull

def Handle_XSControl_TransferReader_Create() -> "opencascade::handle< XSControl_TransferReader >":
    return _XSControl.Handle_XSControl_TransferReader_Create()
Handle_XSControl_TransferReader_Create = _XSControl.Handle_XSControl_TransferReader_Create

def Handle_XSControl_TransferReader_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< XSControl_TransferReader >":
    return _XSControl.Handle_XSControl_TransferReader_DownCast(t)
Handle_XSControl_TransferReader_DownCast = _XSControl.Handle_XSControl_TransferReader_DownCast

def Handle_XSControl_TransferReader_IsNull(t: 'opencascade::handle< XSControl_TransferReader > const &') -> "bool":
    return _XSControl.Handle_XSControl_TransferReader_IsNull(t)
Handle_XSControl_TransferReader_IsNull = _XSControl.Handle_XSControl_TransferReader_IsNull

def Handle_XSControl_TransferWriter_Create() -> "opencascade::handle< XSControl_TransferWriter >":
    return _XSControl.Handle_XSControl_TransferWriter_Create()
Handle_XSControl_TransferWriter_Create = _XSControl.Handle_XSControl_TransferWriter_Create

def Handle_XSControl_TransferWriter_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< XSControl_TransferWriter >":
    return _XSControl.Handle_XSControl_TransferWriter_DownCast(t)
Handle_XSControl_TransferWriter_DownCast = _XSControl.Handle_XSControl_TransferWriter_DownCast

def Handle_XSControl_TransferWriter_IsNull(t: 'opencascade::handle< XSControl_TransferWriter > const &') -> "bool":
    return _XSControl.Handle_XSControl_TransferWriter_IsNull(t)
Handle_XSControl_TransferWriter_IsNull = _XSControl.Handle_XSControl_TransferWriter_IsNull

def Handle_XSControl_Vars_Create() -> "opencascade::handle< XSControl_Vars >":
    return _XSControl.Handle_XSControl_Vars_Create()
Handle_XSControl_Vars_Create = _XSControl.Handle_XSControl_Vars_Create

def Handle_XSControl_Vars_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< XSControl_Vars >":
    return _XSControl.Handle_XSControl_Vars_DownCast(t)
Handle_XSControl_Vars_DownCast = _XSControl.Handle_XSControl_Vars_DownCast

def Handle_XSControl_Vars_IsNull(t: 'opencascade::handle< XSControl_Vars > const &') -> "bool":
    return _XSControl.Handle_XSControl_Vars_IsNull(t)
Handle_XSControl_Vars_IsNull = _XSControl.Handle_XSControl_Vars_IsNull

def Handle_XSControl_WorkSession_Create() -> "opencascade::handle< XSControl_WorkSession >":
    return _XSControl.Handle_XSControl_WorkSession_Create()
Handle_XSControl_WorkSession_Create = _XSControl.Handle_XSControl_WorkSession_Create

def Handle_XSControl_WorkSession_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< XSControl_WorkSession >":
    return _XSControl.Handle_XSControl_WorkSession_DownCast(t)
Handle_XSControl_WorkSession_DownCast = _XSControl.Handle_XSControl_WorkSession_DownCast

def Handle_XSControl_WorkSession_IsNull(t: 'opencascade::handle< XSControl_WorkSession > const &') -> "bool":
    return _XSControl.Handle_XSControl_WorkSession_IsNull(t)
Handle_XSControl_WorkSession_IsNull = _XSControl.Handle_XSControl_WorkSession_IsNull
class xscontrol(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Session(*args) -> "opencascade::handle< XSControl_WorkSession >":
        """
        * Returns the WorkSession of a SessionPilot, but casts it as from XSControl : it then gives access to Control & Transfers
        	:param pilot:
        	:type pilot: IFSelect_SessionPilot
        	:rtype: opencascade::handle<XSControl_WorkSession>
        """
        return _XSControl.xscontrol_Session(*args)

    Session = staticmethod(Session)

    def Vars(*args) -> "opencascade::handle< XSControl_Vars >":
        """
        * Returns the Vars of a SessionPilot, it is brought by Session it provides access to external variables
        	:param pilot:
        	:type pilot: IFSelect_SessionPilot
        	:rtype: opencascade::handle<XSControl_Vars>
        """
        return _XSControl.xscontrol_Vars(*args)

    Vars = staticmethod(Vars)

    __repr__ = _dumps_object


    def __init__(self):
        _XSControl.xscontrol_swiginit(self, _XSControl.new_xscontrol())
    __swig_destroy__ = _XSControl.delete_xscontrol
xscontrol_swigregister = _XSControl.xscontrol_swigregister
xscontrol_swigregister(xscontrol)

def xscontrol_Session(*args) -> "opencascade::handle< XSControl_WorkSession >":
    """
    * Returns the WorkSession of a SessionPilot, but casts it as from XSControl : it then gives access to Control & Transfers
    	:param pilot:
    	:type pilot: IFSelect_SessionPilot
    	:rtype: opencascade::handle<XSControl_WorkSession>
    """
    return _XSControl.xscontrol_Session(*args)

def xscontrol_Vars(*args) -> "opencascade::handle< XSControl_Vars >":
    """
    * Returns the Vars of a SessionPilot, it is brought by Session it provides access to external variables
    	:param pilot:
    	:type pilot: IFSelect_SessionPilot
    	:rtype: opencascade::handle<XSControl_Vars>
    """
    return _XSControl.xscontrol_Vars(*args)

class XSControl_ConnectedShapes(OCC.Core.IFSelect.IFSelect_SelectExplore):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AdjacentEntities(*args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * This functions considers a shape from a transfer and performs the search function explained above
        	:param ashape:
        	:type ashape: TopoDS_Shape
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:param type:
        	:type type: TopAbs_ShapeEnum
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _XSControl.XSControl_ConnectedShapes_AdjacentEntities(*args)

    AdjacentEntities = staticmethod(AdjacentEntities)

    def SetReader(self, *args) -> "void":
        """
        * Sets a TransferReader to sort entities : it brings the TransferProcess which may change, while the TransferReader does not
        	:param TR:
        	:type TR: XSControl_TransferReader
        	:rtype: None
        """
        return _XSControl.XSControl_ConnectedShapes_SetReader(self, *args)


    def __init__(self, *args):
        """
        * Creates a Selection ConnectedShapes. It remains to be set a TransferReader
        	:rtype: None
        * Creates a Selection ConnectedShapes, which will work with the current TransferProcess brought by the TransferReader
        	:param TR:
        	:type TR: XSControl_TransferReader
        	:rtype: None
        """
        _XSControl.XSControl_ConnectedShapes_swiginit(self, _XSControl.new_XSControl_ConnectedShapes(*args))


    @staticmethod
    def DownCast(t):
      return Handle_XSControl_ConnectedShapes_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_ConnectedShapes
XSControl_ConnectedShapes.SetReader = new_instancemethod(_XSControl.XSControl_ConnectedShapes_SetReader, None, XSControl_ConnectedShapes)
XSControl_ConnectedShapes_swigregister = _XSControl.XSControl_ConnectedShapes_swigregister
XSControl_ConnectedShapes_swigregister(XSControl_ConnectedShapes)

def XSControl_ConnectedShapes_AdjacentEntities(*args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
    """
    * This functions considers a shape from a transfer and performs the search function explained above
    	:param ashape:
    	:type ashape: TopoDS_Shape
    	:param TP:
    	:type TP: Transfer_TransientProcess
    	:param type:
    	:type type: TopAbs_ShapeEnum
    	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
    """
    return _XSControl.XSControl_ConnectedShapes_AdjacentEntities(*args)

class XSControl_Controller(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ActorRead(self, *args) -> "opencascade::handle< Transfer_ActorOfTransientProcess >":
        """
        * Returns the Actor for Read attached to the pair (norm,appli) It can be adapted for data of the input Model, as required Can be read from field then adapted with Model as required
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: opencascade::handle<Transfer_ActorOfTransientProcess>
        """
        return _XSControl.XSControl_Controller_ActorRead(self, *args)


    def ActorWrite(self, *args) -> "opencascade::handle< Transfer_ActorOfFinderProcess >":
        """
        * Returns the Actor for Write attached to the pair (norm,appli) Read from field. Can be redefined
        	:rtype: opencascade::handle<Transfer_ActorOfFinderProcess>
        """
        return _XSControl.XSControl_Controller_ActorWrite(self, *args)


    def AdaptorSession(self, *args) -> "NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const &":
        """:rtype: NCollection_DataMap<TCollection_AsciiString, opencascade::handle<Standard_Transient> >"""
        return _XSControl.XSControl_Controller_AdaptorSession(self, *args)


    def AddSessionItem(self, *args) -> "void":
        """
        * Records a Session Item, to be added for customisation of the Work Session. It must have a specific name. <setapplied> is used if <item> is a GeneralModifier, to decide If set to true, <item> will be applied to the hook list 'send'. Else, it is not applied to any hook list. Remark : this method is to be called at Create time, the recorded items will be used by Customise Warning : if <name> conflicts, the last recorded item is kept
        	:param theItem:
        	:type theItem: Standard_Transient
        	:param theName:
        	:type theName: char *
        	:param toApply: default value is Standard_False
        	:type toApply: bool
        	:rtype: None
        """
        return _XSControl.XSControl_Controller_AddSessionItem(self, *args)


    def AutoRecord(self, *args) -> "void":
        """
        * Records <self> is a general dictionary under Short and Long Names (see method Name)
        	:rtype: None
        """
        return _XSControl.XSControl_Controller_AutoRecord(self, *args)


    def Customise(self, *args) -> "void":
        """
        * Customises a WorkSession, by adding to it the recorded items (by AddSessionItem)
        	:param WS:
        	:type WS: XSControl_WorkSession
        	:rtype: void
        """
        return _XSControl.XSControl_Controller_Customise(self, *args)


    def IsModeWrite(self, *args) -> "Standard_Boolean":
        """
        * Tells if a value of <modetrans> is a good value(within bounds) Actually only for shapes
        	:param modetrans:
        	:type modetrans: int
        	:param shape: default value is Standard_True
        	:type shape: bool
        	:rtype: bool
        """
        return _XSControl.XSControl_Controller_IsModeWrite(self, *args)


    def ModeWriteBounds(self, *args) -> "Standard_Boolean":
        """
        * Returns recorded min and max values for modetrans (write) Actually only for shapes Returns True if bounds are set, False else (then, free value)
        	:param modemin:
        	:type modemin: int
        	:param modemax:
        	:type modemax: int
        	:param shape: default value is Standard_True
        	:type shape: bool
        	:rtype: bool
        """
        return _XSControl.XSControl_Controller_ModeWriteBounds(self, *args)


    def ModeWriteHelp(self, *args) -> "char const *":
        """
        * Returns the help line recorded for a value of modetrans empty if help not defined or not within bounds or if values are free
        	:param modetrans:
        	:type modetrans: int
        	:param shape: default value is Standard_True
        	:type shape: bool
        	:rtype: char *
        """
        return _XSControl.XSControl_Controller_ModeWriteHelp(self, *args)


    def Name(self, *args) -> "char const *":
        """
        * Returns a name, as given when initializing : rsc = False (D) : True Name attached to the Norm (long name) rsc = True : Name of the ressource set (i.e. short name)
        	:param rsc: default value is Standard_False
        	:type rsc: bool
        	:rtype: char *
        """
        return _XSControl.XSControl_Controller_Name(self, *args)


    def NewModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Creates a new empty Model ready to receive data of the Norm Used to write data from Imagine to an interface file
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _XSControl.XSControl_Controller_NewModel(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        * Returns the Protocol attached to the Norm (from field)
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _XSControl.XSControl_Controller_Protocol(self, *args)


    def RecognizeWriteShape(self, *args) -> "Standard_Boolean":
        """
        * Tells if a shape is valid for a transfer to a model Asks the ActorWrite (through a ShapeMapper)
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param modetrans: default value is 0
        	:type modetrans: int
        	:rtype: bool
        """
        return _XSControl.XSControl_Controller_RecognizeWriteShape(self, *args)


    def RecognizeWriteTransient(self, *args) -> "Standard_Boolean":
        """
        * Tells if <obj> (an application object) is a valid candidate for a transfer to a Model. By default, asks the ActorWrite if known (through a TransientMapper). Can be redefined
        	:param obj:
        	:type obj: Standard_Transient
        	:param modetrans: default value is 0
        	:type modetrans: int
        	:rtype: bool
        """
        return _XSControl.XSControl_Controller_RecognizeWriteTransient(self, *args)


    def Record(self, *args) -> "void":
        """
        * Records <self> in a general dictionary under a name Error if <name> already used for another one
        	:param name:
        	:type name: char *
        	:rtype: None
        """
        return _XSControl.XSControl_Controller_Record(self, *args)


    def Recorded(*args) -> "opencascade::handle< XSControl_Controller >":
        """
        * Returns the Controller attached to a given name Returns a Null Handle if <name> is unknown
        	:param name:
        	:type name: char *
        	:rtype: opencascade::handle<XSControl_Controller>
        """
        return _XSControl.XSControl_Controller_Recorded(*args)

    Recorded = staticmethod(Recorded)

    def SessionItem(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns an item given its name to record in a Session If <name> is unknown, returns a Null Handle
        	:param theName:
        	:type theName: char *
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_Controller_SessionItem(self, *args)


    def SetModeWrite(self, *args) -> "void":
        """
        * Sets mininum and maximum values for modetrans (write) Erases formerly recorded bounds and values Actually only for shape Then, for each value a little help can be attached
        	:param modemin:
        	:type modemin: int
        	:param modemax:
        	:type modemax: int
        	:param shape: default value is Standard_True
        	:type shape: bool
        	:rtype: None
        """
        return _XSControl.XSControl_Controller_SetModeWrite(self, *args)


    def SetModeWriteHelp(self, *args) -> "void":
        """
        * Attaches a short line of help to a value of modetrans (write)
        	:param modetrans:
        	:type modetrans: int
        	:param help:
        	:type help: char *
        	:param shape: default value is Standard_True
        	:type shape: bool
        	:rtype: None
        """
        return _XSControl.XSControl_Controller_SetModeWriteHelp(self, *args)


    def SetNames(self, *args) -> "void":
        """
        * Changes names if a name is empty, the formerly set one remains Remark : Does not call Record or AutoRecord
        	:param theLongName:
        	:type theLongName: char *
        	:param theShortName:
        	:type theShortName: char *
        	:rtype: None
        """
        return _XSControl.XSControl_Controller_SetNames(self, *args)


    def TransferWriteShape(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Takes one Shape and transfers it to an InterfaceModel (already created, e.g. by NewModel) Default uses ActorWrite; can be redefined as necessary Returned value is a status, as follows : Done OK , Void : No Result , Fail : Fail (e.g. exception) Error : bad conditions , bad model or null model
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param FP:
        	:type FP: Transfer_FinderProcess
        	:param model:
        	:type model: Interface_InterfaceModel
        	:param modetrans: default value is 0
        	:type modetrans: int
        	:rtype: IFSelect_ReturnStatus
        """
        return _XSControl.XSControl_Controller_TransferWriteShape(self, *args)


    def TransferWriteTransient(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Takes one Transient Object and transfers it to an InterfaceModel (already created, e.g. by NewModel) (result is recorded in the model by AddWithRefs) FP records produced results and checks //! Default uses ActorWrite; can be redefined as necessary Returned value is a status, as follows : 0 OK , 1 No Result , 2 Fail (e.g. exception raised) -1 bad conditions , -2 bad model or null model For type of object not recognized : should return 1
        	:param obj:
        	:type obj: Standard_Transient
        	:param FP:
        	:type FP: Transfer_FinderProcess
        	:param model:
        	:type model: Interface_InterfaceModel
        	:param modetrans: default value is 0
        	:type modetrans: int
        	:rtype: IFSelect_ReturnStatus
        """
        return _XSControl.XSControl_Controller_TransferWriteTransient(self, *args)


    def WorkLibrary(self, *args) -> "opencascade::handle< IFSelect_WorkLibrary > const &":
        """
        * Returns the SignType attached to the norm (from field) Returns the WorkLibrary attached to the Norm. Remark that it has to be in phase with the Protocol (read from field)
        	:rtype: opencascade::handle<IFSelect_WorkLibrary>
        """
        return _XSControl.XSControl_Controller_WorkLibrary(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_XSControl_Controller_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_Controller
XSControl_Controller.ActorRead = new_instancemethod(_XSControl.XSControl_Controller_ActorRead, None, XSControl_Controller)
XSControl_Controller.ActorWrite = new_instancemethod(_XSControl.XSControl_Controller_ActorWrite, None, XSControl_Controller)
XSControl_Controller.AdaptorSession = new_instancemethod(_XSControl.XSControl_Controller_AdaptorSession, None, XSControl_Controller)
XSControl_Controller.AddSessionItem = new_instancemethod(_XSControl.XSControl_Controller_AddSessionItem, None, XSControl_Controller)
XSControl_Controller.AutoRecord = new_instancemethod(_XSControl.XSControl_Controller_AutoRecord, None, XSControl_Controller)
XSControl_Controller.Customise = new_instancemethod(_XSControl.XSControl_Controller_Customise, None, XSControl_Controller)
XSControl_Controller.IsModeWrite = new_instancemethod(_XSControl.XSControl_Controller_IsModeWrite, None, XSControl_Controller)
XSControl_Controller.ModeWriteBounds = new_instancemethod(_XSControl.XSControl_Controller_ModeWriteBounds, None, XSControl_Controller)
XSControl_Controller.ModeWriteHelp = new_instancemethod(_XSControl.XSControl_Controller_ModeWriteHelp, None, XSControl_Controller)
XSControl_Controller.Name = new_instancemethod(_XSControl.XSControl_Controller_Name, None, XSControl_Controller)
XSControl_Controller.NewModel = new_instancemethod(_XSControl.XSControl_Controller_NewModel, None, XSControl_Controller)
XSControl_Controller.Protocol = new_instancemethod(_XSControl.XSControl_Controller_Protocol, None, XSControl_Controller)
XSControl_Controller.RecognizeWriteShape = new_instancemethod(_XSControl.XSControl_Controller_RecognizeWriteShape, None, XSControl_Controller)
XSControl_Controller.RecognizeWriteTransient = new_instancemethod(_XSControl.XSControl_Controller_RecognizeWriteTransient, None, XSControl_Controller)
XSControl_Controller.Record = new_instancemethod(_XSControl.XSControl_Controller_Record, None, XSControl_Controller)
XSControl_Controller.SessionItem = new_instancemethod(_XSControl.XSControl_Controller_SessionItem, None, XSControl_Controller)
XSControl_Controller.SetModeWrite = new_instancemethod(_XSControl.XSControl_Controller_SetModeWrite, None, XSControl_Controller)
XSControl_Controller.SetModeWriteHelp = new_instancemethod(_XSControl.XSControl_Controller_SetModeWriteHelp, None, XSControl_Controller)
XSControl_Controller.SetNames = new_instancemethod(_XSControl.XSControl_Controller_SetNames, None, XSControl_Controller)
XSControl_Controller.TransferWriteShape = new_instancemethod(_XSControl.XSControl_Controller_TransferWriteShape, None, XSControl_Controller)
XSControl_Controller.TransferWriteTransient = new_instancemethod(_XSControl.XSControl_Controller_TransferWriteTransient, None, XSControl_Controller)
XSControl_Controller.WorkLibrary = new_instancemethod(_XSControl.XSControl_Controller_WorkLibrary, None, XSControl_Controller)
XSControl_Controller_swigregister = _XSControl.XSControl_Controller_swigregister
XSControl_Controller_swigregister(XSControl_Controller)

def XSControl_Controller_Recorded(*args) -> "opencascade::handle< XSControl_Controller >":
    """
    * Returns the Controller attached to a given name Returns a Null Handle if <name> is unknown
    	:param name:
    	:type name: char *
    	:rtype: opencascade::handle<XSControl_Controller>
    """
    return _XSControl.XSControl_Controller_Recorded(*args)

class XSControl_FuncShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FileAndVar(*args) -> "Standard_Boolean":
        """
        * Analyses given file name and variable name, with a default name for variables. Returns resulting file name and variable name plus status 'file to read'(True) or 'already read'(False) In the latter case, empty resfile means no file available //! If <file> is null or empty or equates '.', considers Session and returned status is False Else, returns resfile = file and status is True If <var> is neither null nor empty, resvar = var Else, the root part of <resfile> is considered, if defined Else, <def> is taken
        	:param session:
        	:type session: XSControl_WorkSession
        	:param file:
        	:type file: char *
        	:param var:
        	:type var: char *
        	:param def:
        	:type def: char *
        	:param resfile:
        	:type resfile: TCollection_AsciiString
        	:param resvar:
        	:type resvar: TCollection_AsciiString
        	:rtype: bool
        """
        return _XSControl.XSControl_FuncShape_FileAndVar(*args)

    FileAndVar = staticmethod(FileAndVar)

    def Init(*args) -> "void":
        """
        * Defines and loads all functions which work on shapes for XSControl (as ActFunc)
        	:rtype: void
        """
        return _XSControl.XSControl_FuncShape_Init(*args)

    Init = staticmethod(Init)

    def MoreShapes(*args) -> "Standard_Integer":
        """
        * Analyses a name as designating Shapes from a Vars or from XSTEP transfer (last Transfer on Reading). <name> can be : '*' : all the root shapes produced by last Transfer (Read) i.e. considers roots of the TransientProcess a name : a name of a variable DRAW //! Returns the count of designated Shapes. Their list is put in <list>. If <list> is null, it is firstly created. Then it is completed (Append without Clear) by the Shapes found Returns 0 if no Shape could be found
        	:param session:
        	:type session: XSControl_WorkSession
        	:param list:
        	:type list: TopTools_HSequenceOfShape
        	:param name:
        	:type name: char *
        	:rtype: int
        """
        return _XSControl.XSControl_FuncShape_MoreShapes(*args)

    MoreShapes = staticmethod(MoreShapes)

    __repr__ = _dumps_object


    def __init__(self):
        _XSControl.XSControl_FuncShape_swiginit(self, _XSControl.new_XSControl_FuncShape())
    __swig_destroy__ = _XSControl.delete_XSControl_FuncShape
XSControl_FuncShape_swigregister = _XSControl.XSControl_FuncShape_swigregister
XSControl_FuncShape_swigregister(XSControl_FuncShape)

def XSControl_FuncShape_FileAndVar(*args) -> "Standard_Boolean":
    """
    * Analyses given file name and variable name, with a default name for variables. Returns resulting file name and variable name plus status 'file to read'(True) or 'already read'(False) In the latter case, empty resfile means no file available //! If <file> is null or empty or equates '.', considers Session and returned status is False Else, returns resfile = file and status is True If <var> is neither null nor empty, resvar = var Else, the root part of <resfile> is considered, if defined Else, <def> is taken
    	:param session:
    	:type session: XSControl_WorkSession
    	:param file:
    	:type file: char *
    	:param var:
    	:type var: char *
    	:param def:
    	:type def: char *
    	:param resfile:
    	:type resfile: TCollection_AsciiString
    	:param resvar:
    	:type resvar: TCollection_AsciiString
    	:rtype: bool
    """
    return _XSControl.XSControl_FuncShape_FileAndVar(*args)

def XSControl_FuncShape_Init(*args) -> "void":
    """
    * Defines and loads all functions which work on shapes for XSControl (as ActFunc)
    	:rtype: void
    """
    return _XSControl.XSControl_FuncShape_Init(*args)

def XSControl_FuncShape_MoreShapes(*args) -> "Standard_Integer":
    """
    * Analyses a name as designating Shapes from a Vars or from XSTEP transfer (last Transfer on Reading). <name> can be : '*' : all the root shapes produced by last Transfer (Read) i.e. considers roots of the TransientProcess a name : a name of a variable DRAW //! Returns the count of designated Shapes. Their list is put in <list>. If <list> is null, it is firstly created. Then it is completed (Append without Clear) by the Shapes found Returns 0 if no Shape could be found
    	:param session:
    	:type session: XSControl_WorkSession
    	:param list:
    	:type list: TopTools_HSequenceOfShape
    	:param name:
    	:type name: char *
    	:rtype: int
    """
    return _XSControl.XSControl_FuncShape_MoreShapes(*args)

class XSControl_Functions(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(*args) -> "void":
        """
        * Defines and loads all functions for XSControl (as ActFunc)
        	:rtype: void
        """
        return _XSControl.XSControl_Functions_Init(*args)

    Init = staticmethod(Init)

    __repr__ = _dumps_object


    def __init__(self):
        _XSControl.XSControl_Functions_swiginit(self, _XSControl.new_XSControl_Functions())
    __swig_destroy__ = _XSControl.delete_XSControl_Functions
XSControl_Functions_swigregister = _XSControl.XSControl_Functions_swigregister
XSControl_Functions_swigregister(XSControl_Functions)

def XSControl_Functions_Init(*args) -> "void":
    """
    * Defines and loads all functions for XSControl (as ActFunc)
    	:rtype: void
    """
    return _XSControl.XSControl_Functions_Init(*args)

class XSControl_Reader(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ClearShapes(self, *args) -> "void":
        """
        * Clears the list of shapes that may have accumulated in calls to TransferOne or TransferRoot.C
        	:rtype: None
        """
        return _XSControl.XSControl_Reader_ClearShapes(self, *args)


    def GetStatsTransfer(self, *args) -> "void":
        """
        * Gives statistics about Transfer
        	:param list:
        	:type list: TColStd_HSequenceOfTransient
        	:param nbMapped:
        	:type nbMapped: int
        	:param nbWithResult:
        	:type nbWithResult: int
        	:param nbWithFail:
        	:type nbWithFail: int
        	:rtype: None
        """
        return _XSControl.XSControl_Reader_GetStatsTransfer(self, *args)


    def GiveList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns a list of entities from the IGES or STEP file according to the following rules: - if first and second are empty strings, the whole file is selected. - if first is an entity number or label, the entity referred to is selected. - if first is a list of entity numbers/labels separated by commas, the entities referred to are selected, - if first is the name of a selection in the worksession and second is not defined, the list contains the standard output for that selection. - if first is the name of a selection and second is defined, the criterion defined by second is applied to the result of the first selection. A selection is an operator which computes a list of entities from a list given in input according to its type. If no list is specified, the selection computes its list of entities from the whole model. A selection can be: - A predefined selection (xst-transferrable-mode) - A filter based on a signature A Signature is an operator which returns a string from an entity according to its type. For example: - 'xst-type' (CDL) - 'iges-level' - 'step-type'. For example, if you wanted to select only the advanced_faces in a STEP file you would use the following code: Example Reader.GiveList('xst-transferrable-roots','step-type(ADVANCED_FACE)'); Warning If the value given to second is incorrect, it will simply be ignored.
        	:param first: default value is 
        	:type first: char *
        	:param second: default value is 
        	:type second: char *
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        * Computes a List of entities from the model as follows <first> beeing a Selection, <ent> beeing an entity or a list of entities (as a HSequenceOfTransient) : the standard result of this selection applied to this list if <first> is erroneous, a null handle is returned
        	:param first:
        	:type first: char *
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _XSControl.XSControl_Reader_GiveList(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the model. It can then be consulted (header, product)
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _XSControl.XSControl_Reader_Model(self, *args)


    def NbRootsForTransfer(self, *args) -> "Standard_Integer":
        """
        * Determines the list of root entities which are candidate for a transfer to a Shape, and returns the number of entities in the list
        	:rtype: int
        """
        return _XSControl.XSControl_Reader_NbRootsForTransfer(self, *args)


    def NbShapes(self, *args) -> "Standard_Integer":
        """
        * Returns the number of shapes produced by translation.
        	:rtype: int
        """
        return _XSControl.XSControl_Reader_NbShapes(self, *args)


    def OneShape(self, *args) -> "TopoDS_Shape":
        """
        * Returns all of the results in a single shape which is: - a null shape if there are no results, - a shape if there is one result, - a compound containing the resulting shapes if there are more than one.
        	:rtype: TopoDS_Shape
        """
        return _XSControl.XSControl_Reader_OneShape(self, *args)


    def PrintCheckLoad(self, *args) -> "void":
        """
        * Prints the check list attached to loaded data, on the Standard Trace File (starts at std::cout) All messages or fails only, according to <failsonly> mode = 0 : per entity, prints messages mode = 1 : per message, just gives count of entities per check mode = 2 : also gives entity numbers
        	:param failsonly:
        	:type failsonly: bool
        	:param mode:
        	:type mode: IFSelect_PrintCount
        	:rtype: None
        """
        return _XSControl.XSControl_Reader_PrintCheckLoad(self, *args)


    def PrintCheckTransfer(self, *args) -> "void":
        """
        * Displays check results for the last translation of IGES or STEP entities to Open CASCADE entities. Only fail messages are displayed if failsonly is true. All messages are displayed if failsonly is false. mode determines the contents and the order of the messages according to the terms of the IFSelect_PrintCount enumeration.
        	:param failsonly:
        	:type failsonly: bool
        	:param mode:
        	:type mode: IFSelect_PrintCount
        	:rtype: None
        """
        return _XSControl.XSControl_Reader_PrintCheckTransfer(self, *args)


    def PrintStatsTransfer(self, *args) -> "void":
        """
        * Displays the statistics for the last translation. what defines the kind of statistics that are displayed as follows: - 0 gives general statistics (number of translated roots, number of warnings, number of fail messages), - 1 gives root results, - 2 gives statistics for all checked entities, - 3 gives the list of translated entities, - 4 gives warning and fail messages, - 5 gives fail messages only. The use of mode depends on the value of what. If what is 0, mode is ignored. If what is 1, 2 or 3, mode defines the following: - 0 lists the numbers of IGES or STEP entities in the respective model - 1 gives the number, identifier, type and result type for each IGES or STEP entity and/or its status (fail, warning, etc.) - 2 gives maximum information for each IGES or STEP entity (i.e. checks) - 3 gives the number of entities per type of IGES or STEP entity - 4 gives the number of IGES or STEP entities per result type and/or status - 5 gives the number of pairs (IGES or STEP or result type and status) - 6 gives the number of pairs (IGES or STEP or result type and status) AND the list of entity numbers in the IGES or STEP model. If what is 4 or 5, mode defines the warning and fail messages as follows: - if mode is 0 all warnings and checks per entity are returned - if mode is 2 the list of entities per warning is returned. If mode is not set, only the list of all entities per warning is given.
        	:param what:
        	:type what: int
        	:param mode: default value is 0
        	:type mode: int
        	:rtype: None
        """
        return _XSControl.XSControl_Reader_PrintStatsTransfer(self, *args)


    def ReadFile(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Loads a file and returns the read status Zero for a Model which compies with the Controller
        	:param filename:
        	:type filename: char *
        	:rtype: IFSelect_ReturnStatus
        """
        return _XSControl.XSControl_Reader_ReadFile(self, *args)


    def RootForTransfer(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns an IGES or STEP root entity for translation. The entity is identified by its rank in a list.
        	:param num: default value is 1
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_Reader_RootForTransfer(self, *args)


    def SetNorm(self, *args) -> "Standard_Boolean":
        """
        * Sets a specific norm to <self> Returns True if done, False if <norm> is not available
        	:param norm:
        	:type norm: char *
        	:rtype: bool
        """
        return _XSControl.XSControl_Reader_SetNorm(self, *args)


    def SetWS(self, *args) -> "void":
        """
        * Sets a specific session to <self>
        	:param WS:
        	:type WS: XSControl_WorkSession
        	:param scratch: default value is Standard_True
        	:type scratch: bool
        	:rtype: None
        """
        return _XSControl.XSControl_Reader_SetWS(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape":
        """
        * Returns the shape resulting from a translation and identified by the rank num. num equals 1 by default. In other words, the first shape resulting from the translation is returned.
        	:param num: default value is 1
        	:type num: int
        	:rtype: TopoDS_Shape
        """
        return _XSControl.XSControl_Reader_Shape(self, *args)


    def TransferEntity(self, *args) -> "Standard_Boolean":
        """
        * Translates an IGES or STEP entity in the model. true is returned if a shape is produced; otherwise, false is returned.
        	:param start:
        	:type start: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_Reader_TransferEntity(self, *args)


    def TransferList(self, *args) -> "Standard_Integer":
        """
        * Translates a list of entities. Returns the number of IGES or STEP entities that were successfully translated. The list can be produced with GiveList. Warning - This function does not clear the existing output shapes.
        	:param list:
        	:type list: TColStd_HSequenceOfTransient
        	:rtype: int
        """
        return _XSControl.XSControl_Reader_TransferList(self, *args)


    def TransferOne(self, *args) -> "Standard_Boolean":
        """
        * Translates an IGES or STEP entity identified by the rank num in the model. false is returned if no shape is produced.
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _XSControl.XSControl_Reader_TransferOne(self, *args)


    def TransferOneRoot(self, *args) -> "Standard_Boolean":
        """
        * Translates a root identified by the rank num in the model. false is returned if no shape is produced.
        	:param num: default value is 1
        	:type num: int
        	:rtype: bool
        """
        return _XSControl.XSControl_Reader_TransferOneRoot(self, *args)


    def TransferRoots(self, *args) -> "Standard_Integer":
        """
        * Translates all translatable roots and returns the number of successful translations. Warning - This function clears existing output shapes first.
        	:rtype: int
        """
        return _XSControl.XSControl_Reader_TransferRoots(self, *args)


    def WS(self, *args) -> "opencascade::handle< XSControl_WorkSession >":
        """
        * Returns the session used in <self>
        	:rtype: opencascade::handle<XSControl_WorkSession>
        """
        return _XSControl.XSControl_Reader_WS(self, *args)


    def __init__(self, *args):
        """
        * Creates a Reader from scratch (creates an empty WorkSession) A WorkSession or a Controller must be provided before running
        	:rtype: None
        * Creates a Reader from scratch, with a norm name which identifies a Controller
        	:param norm:
        	:type norm: char *
        	:rtype: None
        * Creates a Reader from an already existing Session, with a Controller already set Virtual destructor
        	:param WS:
        	:type WS: XSControl_WorkSession
        	:param scratch: default value is Standard_True
        	:type scratch: bool
        	:rtype: None
        """
        _XSControl.XSControl_Reader_swiginit(self, _XSControl.new_XSControl_Reader(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_Reader
XSControl_Reader.ClearShapes = new_instancemethod(_XSControl.XSControl_Reader_ClearShapes, None, XSControl_Reader)
XSControl_Reader.GetStatsTransfer = new_instancemethod(_XSControl.XSControl_Reader_GetStatsTransfer, None, XSControl_Reader)
XSControl_Reader.GiveList = new_instancemethod(_XSControl.XSControl_Reader_GiveList, None, XSControl_Reader)
XSControl_Reader.Model = new_instancemethod(_XSControl.XSControl_Reader_Model, None, XSControl_Reader)
XSControl_Reader.NbRootsForTransfer = new_instancemethod(_XSControl.XSControl_Reader_NbRootsForTransfer, None, XSControl_Reader)
XSControl_Reader.NbShapes = new_instancemethod(_XSControl.XSControl_Reader_NbShapes, None, XSControl_Reader)
XSControl_Reader.OneShape = new_instancemethod(_XSControl.XSControl_Reader_OneShape, None, XSControl_Reader)
XSControl_Reader.PrintCheckLoad = new_instancemethod(_XSControl.XSControl_Reader_PrintCheckLoad, None, XSControl_Reader)
XSControl_Reader.PrintCheckTransfer = new_instancemethod(_XSControl.XSControl_Reader_PrintCheckTransfer, None, XSControl_Reader)
XSControl_Reader.PrintStatsTransfer = new_instancemethod(_XSControl.XSControl_Reader_PrintStatsTransfer, None, XSControl_Reader)
XSControl_Reader.ReadFile = new_instancemethod(_XSControl.XSControl_Reader_ReadFile, None, XSControl_Reader)
XSControl_Reader.RootForTransfer = new_instancemethod(_XSControl.XSControl_Reader_RootForTransfer, None, XSControl_Reader)
XSControl_Reader.SetNorm = new_instancemethod(_XSControl.XSControl_Reader_SetNorm, None, XSControl_Reader)
XSControl_Reader.SetWS = new_instancemethod(_XSControl.XSControl_Reader_SetWS, None, XSControl_Reader)
XSControl_Reader.Shape = new_instancemethod(_XSControl.XSControl_Reader_Shape, None, XSControl_Reader)
XSControl_Reader.TransferEntity = new_instancemethod(_XSControl.XSControl_Reader_TransferEntity, None, XSControl_Reader)
XSControl_Reader.TransferList = new_instancemethod(_XSControl.XSControl_Reader_TransferList, None, XSControl_Reader)
XSControl_Reader.TransferOne = new_instancemethod(_XSControl.XSControl_Reader_TransferOne, None, XSControl_Reader)
XSControl_Reader.TransferOneRoot = new_instancemethod(_XSControl.XSControl_Reader_TransferOneRoot, None, XSControl_Reader)
XSControl_Reader.TransferRoots = new_instancemethod(_XSControl.XSControl_Reader_TransferRoots, None, XSControl_Reader)
XSControl_Reader.WS = new_instancemethod(_XSControl.XSControl_Reader_WS, None, XSControl_Reader)
XSControl_Reader_swigregister = _XSControl.XSControl_Reader_swigregister
XSControl_Reader_swigregister(XSControl_Reader)

class XSControl_SelectForTransfer(OCC.Core.IFSelect.IFSelect_SelectExtract):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Actor(self, *args) -> "opencascade::handle< Transfer_ActorOfTransientProcess >":
        """
        * Returns the Actor used as precised one. Returns a Null Handle for a creation from a TransferReader without any further setting
        	:rtype: opencascade::handle<Transfer_ActorOfTransientProcess>
        """
        return _XSControl.XSControl_SelectForTransfer_Actor(self, *args)


    def Reader(self, *args) -> "opencascade::handle< XSControl_TransferReader >":
        """
        * Returns the Reader (if created with a Reader) Returns a Null Handle if not created with a Reader
        	:rtype: opencascade::handle<XSControl_TransferReader>
        """
        return _XSControl.XSControl_SelectForTransfer_Reader(self, *args)


    def SetActor(self, *args) -> "void":
        """
        * Sets a precise actor to sort entities This definition oversedes the creation with a TransferReader
        	:param act:
        	:type act: Transfer_ActorOfTransientProcess
        	:rtype: None
        """
        return _XSControl.XSControl_SelectForTransfer_SetActor(self, *args)


    def SetReader(self, *args) -> "void":
        """
        * Sets a TransferReader to sort entities : it brings the Actor, which may change, while the TransferReader does not
        	:param TR:
        	:type TR: XSControl_TransferReader
        	:rtype: None
        """
        return _XSControl.XSControl_SelectForTransfer_SetReader(self, *args)


    def __init__(self, *args):
        """
        * Creates a SelectForTransfer, non initialised it sorts nothing, unless an Actor has been defined
        	:rtype: None
        * Creates a SelectForTransfer, which will work with the currently defined Actor brought by the TransferReader
        	:param TR:
        	:type TR: XSControl_TransferReader
        	:rtype: None
        """
        _XSControl.XSControl_SelectForTransfer_swiginit(self, _XSControl.new_XSControl_SelectForTransfer(*args))


    @staticmethod
    def DownCast(t):
      return Handle_XSControl_SelectForTransfer_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_SelectForTransfer
XSControl_SelectForTransfer.Actor = new_instancemethod(_XSControl.XSControl_SelectForTransfer_Actor, None, XSControl_SelectForTransfer)
XSControl_SelectForTransfer.Reader = new_instancemethod(_XSControl.XSControl_SelectForTransfer_Reader, None, XSControl_SelectForTransfer)
XSControl_SelectForTransfer.SetActor = new_instancemethod(_XSControl.XSControl_SelectForTransfer_SetActor, None, XSControl_SelectForTransfer)
XSControl_SelectForTransfer.SetReader = new_instancemethod(_XSControl.XSControl_SelectForTransfer_SetReader, None, XSControl_SelectForTransfer)
XSControl_SelectForTransfer_swigregister = _XSControl.XSControl_SelectForTransfer_swigregister
XSControl_SelectForTransfer_swigregister(XSControl_SelectForTransfer)

class XSControl_SignTransferStatus(OCC.Core.IFSelect.IFSelect_Signature):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Map(self, *args) -> "opencascade::handle< Transfer_TransientProcess >":
        """
        * Returns the TransientProcess used as precised one Returns a Null Handle for a creation from a TransferReader without any further setting
        	:rtype: opencascade::handle<Transfer_TransientProcess>
        """
        return _XSControl.XSControl_SignTransferStatus_Map(self, *args)


    def Reader(self, *args) -> "opencascade::handle< XSControl_TransferReader >":
        """
        * Returns the Reader (if created with a Reader) Returns a Null Handle if not created with a Reader
        	:rtype: opencascade::handle<XSControl_TransferReader>
        """
        return _XSControl.XSControl_SignTransferStatus_Reader(self, *args)


    def SetMap(self, *args) -> "void":
        """
        * Sets a precise map to sign entities This definition oversedes the creation with a TransferReader
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:rtype: None
        """
        return _XSControl.XSControl_SignTransferStatus_SetMap(self, *args)


    def SetReader(self, *args) -> "void":
        """
        * Sets a TransferReader to work
        	:param TR:
        	:type TR: XSControl_TransferReader
        	:rtype: None
        """
        return _XSControl.XSControl_SignTransferStatus_SetReader(self, *args)


    def __init__(self, *args):
        """
        * Creates a SignTransferStatus, not initialised it gives nothing (empty string)
        	:rtype: None
        * Creates a SignTransferStatus, which will work on the current TransientProcess brought by the TransferReader (its MapReader)
        	:param TR:
        	:type TR: XSControl_TransferReader
        	:rtype: None
        """
        _XSControl.XSControl_SignTransferStatus_swiginit(self, _XSControl.new_XSControl_SignTransferStatus(*args))


    @staticmethod
    def DownCast(t):
      return Handle_XSControl_SignTransferStatus_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_SignTransferStatus
XSControl_SignTransferStatus.Map = new_instancemethod(_XSControl.XSControl_SignTransferStatus_Map, None, XSControl_SignTransferStatus)
XSControl_SignTransferStatus.Reader = new_instancemethod(_XSControl.XSControl_SignTransferStatus_Reader, None, XSControl_SignTransferStatus)
XSControl_SignTransferStatus.SetMap = new_instancemethod(_XSControl.XSControl_SignTransferStatus_SetMap, None, XSControl_SignTransferStatus)
XSControl_SignTransferStatus.SetReader = new_instancemethod(_XSControl.XSControl_SignTransferStatus_SetReader, None, XSControl_SignTransferStatus)
XSControl_SignTransferStatus_swigregister = _XSControl.XSControl_SignTransferStatus_swigregister
XSControl_SignTransferStatus_swigregister(XSControl_SignTransferStatus)

class XSControl_TransferReader(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Actor(self, *args) -> "opencascade::handle< Transfer_ActorOfTransientProcess >":
        """
        * Returns the Actor, determined by the Controller, or if this one is unknown, directly set. Once it has been defined, it can then be edited.
        	:rtype: opencascade::handle<Transfer_ActorOfTransientProcess>
        """
        return _XSControl.XSControl_TransferReader_Actor(self, *args)


    def BeginTransfer(self, *args) -> "Standard_Boolean":
        """
        * Defines a new TransferProcess for reading transfer Returns True if done, False if data are not properly defined (the Model, the Actor for Read)
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_BeginTransfer(self, *args)


    def CheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns the CheckList resulting from transferring <ent>, i.e. stored in its recorded form ResultFromModel (empty if transfer successful or not recorded ...) //! If <ent> is the Model, returns the complete cumulated check-list, <level> is ignored //! If <ent> is an entity of the Model, <level> applies as follows <level> : -1 for <ent> only, LAST transfer (TransientProcess) <level> : 0 for <ent> only (D) 1 for <ent> and its immediate subtransfers, if any 2 for <ent> and subtransferts at all levels
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:param theLevel: default value is 0
        	:type theLevel: int
        	:rtype: Interface_CheckIterator
        """
        return _XSControl.XSControl_TransferReader_CheckList(self, *args)


    def CheckedList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the list of starting entities to which a given check status is attached, IN FINAL RESULTS <ent> can be an entity, or the model to query all entities Below, 'entities' are, either <ent> plus its sub-transferred, or all the entities of the model //! <check> = -2 , all entities whatever the check (see result) <check> = -1 , entities with no fail (warning allowed) <check> = 0 , entities with no check at all <check> = 1 , entities with warning but no fail <check> = 2 , entities with fail <result> : if True, only entities with an attached result Remark : result True and check=0 will give an empty list
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:param WithCheck: default value is Interface_CheckAny
        	:type WithCheck: Interface_CheckStatus
        	:param theResult: default value is Standard_True
        	:type theResult: bool
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _XSControl.XSControl_TransferReader_CheckedList(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears data, according mode : -1 all 0 nothing done +1 final results +2 working data (model, context, transfer process)
        	:param theMode:
        	:type theMode: int
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_Clear(self, *args)


    def ClearResult(self, *args) -> "Standard_Boolean":
        """
        * Clears recorded result for an entity, according mode <mode> = -1 : true, complete, clearing (erasing result) <mode> >= 0 : simple 'stripping', see ResultFromModel, in particular, 0 for simple internal strip, 10 for all but final result, 11 for all : just label, status and filename are kept Returns True when done, False if nothing was to clear
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:param theMode:
        	:type theMode: int
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_ClearResult(self, *args)


    def Context(self, *args) -> "NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &":
        """
        * Returns (modifiable) the whole definition of Context Rather for internal use (ex.: preparing and setting in once)
        	:rtype: NCollection_DataMap<TCollection_AsciiString, opencascade::handle<Standard_Transient> >
        """
        return _XSControl.XSControl_TransferReader_Context(self, *args)


    def EntitiesFromShapeList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the list of entities from which some shapes were produced : it corresponds to a loop on EntityFromShapeResult, but is optimised
        	:param theRes:
        	:type theRes: TopTools_HSequenceOfShape
        	:param theMode: default value is 0
        	:type theMode: int
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _XSControl.XSControl_TransferReader_EntitiesFromShapeList(self, *args)


    def EntityFromResult(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns an entity from which a given result was produced. If <mode> = 0 (D), searches in last root transfers If <mode> = 1, searches in last (root & sub) transfers If <mode> = 2, searches in root recorded results If <mode> = 3, searches in all (root & sub) recordeds <res> can be, either a transient object (result itself) or a binder. For a binder of shape, calls EntityFromShapeResult Returns a Null Handle if <res> not recorded
        	:param theRes:
        	:type theRes: Standard_Transient
        	:param theMode: default value is 0
        	:type theMode: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_TransferReader_EntityFromResult(self, *args)


    def EntityFromShapeResult(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns an entity from which a given shape result was produced Returns a Null Handle if <res> not recorded or not a Shape
        	:param theRes:
        	:type theRes: TopoDS_Shape
        	:param theMode: default value is 0
        	:type theMode: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_TransferReader_EntityFromShapeResult(self, *args)


    def FileName(self, *args) -> "char const *":
        """
        * Returns actual value of file name
        	:rtype: char *
        """
        return _XSControl.XSControl_TransferReader_FileName(self, *args)


    def FinalEntityLabel(self, *args) -> "char const *":
        """
        * Returns the label attached to an entity recorded for final, or an empty string if not recorded
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: char *
        """
        return _XSControl.XSControl_TransferReader_FinalEntityLabel(self, *args)


    def FinalEntityNumber(self, *args) -> "Standard_Integer":
        """
        * Returns the number attached to the entity recorded for final, or zero if not recorded (looks in the ResultFromModel)
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: int
        """
        return _XSControl.XSControl_TransferReader_FinalEntityNumber(self, *args)


    def FinalResult(self, *args) -> "opencascade::handle< Transfer_ResultFromModel >":
        """
        * Returns the final result recorded for an entity, as such
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: opencascade::handle<Transfer_ResultFromModel>
        """
        return _XSControl.XSControl_TransferReader_FinalResult(self, *args)


    def GetContext(self, *args) -> "Standard_Boolean":
        """
        * Returns the Context attached to a name, if set and if it is Kind of the type, else a Null Handle Returns True if OK, False if no Context
        	:param theName:
        	:type theName: char *
        	:param theType:
        	:type theType: Standard_Type
        	:param theCtx:
        	:type theCtx: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_GetContext(self, *args)


    def HasChecks(self, *args) -> "Standard_Boolean":
        """
        * Returns True if an entity (with a final result) has checks : - failsonly = False : any kind of check message - failsonly = True : fails only Returns False if <ent> is not recorded
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:param FailsOnly:
        	:type FailsOnly: bool
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_HasChecks(self, *args)


    def HasResult(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a final result is recorded AND BRINGS AN EFFECTIVE RESULT (else, it brings only fail messages)
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_HasResult(self, *args)


    def IsMarked(self, *args) -> "Standard_Boolean":
        """
        * Returns True if an entity has been asked for transfert, hence it is marked, as : Recorded (a computation has ran, with or without an effective result), or Skipped (case ignored)
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_IsMarked(self, *args)


    def IsRecorded(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a final result is recorded for an entity Remark that it can bring no effective result if transfer has completely failed (FinalResult brings only fail messages ...)
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_IsRecorded(self, *args)


    def IsSkipped(self, *args) -> "Standard_Boolean":
        """
        * Returns True if an entity is noted as skipped
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_IsSkipped(self, *args)


    def LastCheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns the CheckList resulting from last TransferRead i.e. from TransientProcess itself, recorded from last Clear
        	:rtype: Interface_CheckIterator
        """
        return _XSControl.XSControl_TransferReader_LastCheckList(self, *args)


    def LastTransferList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the list of entities recorded as lastly transferred i.e. from TransientProcess itself, recorded from last Clear If <roots> is True , considers only roots of transfer If <roots> is False, considers all entities bound with result
        	:param theRoots:
        	:type theRoots: bool
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _XSControl.XSControl_TransferReader_LastTransferList(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel > const &":
        """
        * Returns the currently set InterfaceModel
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _XSControl.XSControl_TransferReader_Model(self, *args)


    def PrintStats(self, *args) -> "void":
        """
        * Prints statistics on current Trace File, according <what> and <mode>. See PrintStatsProcess for details
        	:param theWhat:
        	:type theWhat: int
        	:param theMode: default value is 0
        	:type theMode: int
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_PrintStats(self, *args)


    def PrintStatsOnList(*args) -> "void":
        """
        * Works as PrintStatsProcess, but displays data only on the entities which are in <list> (filter)
        	:param theTP:
        	:type theTP: Transfer_TransientProcess
        	:param theList:
        	:type theList: TColStd_HSequenceOfTransient
        	:param theWhat:
        	:type theWhat: int
        	:param theMode: default value is 0
        	:type theMode: int
        	:rtype: void
        """
        return _XSControl.XSControl_TransferReader_PrintStatsOnList(*args)

    PrintStatsOnList = staticmethod(PrintStatsOnList)

    def PrintStatsProcess(*args) -> "void":
        """
        * This routines prints statistics about a TransientProcess It can be called, by a TransferReader, or isolately Prints are done on the default trace file <what> defines what kind of statistics are to be printed : 0 : basic figures 1 : root results 2 : all recorded (roots, intermediate, checked entities) 3 : abnormal records 4 : check messages (warnings and fails) 5 : fail messages //! <mode> is used according <what> : <what> = 0 : <mode> is ignored <what> = 1,2,3 : <mode> as follows : 0 (D) : just lists numbers of concerned entities in the model 1 : for each entity, gives number,label, type and result type and/or status (fail/warning...) 2 : for each entity, gives maximal information (i.e. checks) 3 : counts per type of starting entity (class type) 4 : counts per result type and/or status 5 : counts per couple (starting type / result type/status) 6 : idem plus gives for each item, the list of numbers of entities in the starting model //! <what> = 4,5 : modes relays on an enum PrintCount : 0 (D) : ItemsByEntity (sequential list by entity) 1 : CountByItem 2 : ShortByItem (count + 5 first numbers) 3 : ListByItem (count + entity numbers) 4 : EntitiesByItem (count + entity numbers and labels)
        	:param theTP:
        	:type theTP: Transfer_TransientProcess
        	:param theWhat:
        	:type theWhat: int
        	:param theMode: default value is 0
        	:type theMode: int
        	:rtype: void
        """
        return _XSControl.XSControl_TransferReader_PrintStatsProcess(*args)

    PrintStatsProcess = staticmethod(PrintStatsProcess)

    def Recognize(self, *args) -> "Standard_Boolean":
        """
        * Tells if an entity is recognized as a valid candidate for Transfer. Calls method Recognize from the Actor (if known)
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_Recognize(self, *args)


    def RecordResult(self, *args) -> "Standard_Boolean":
        """
        * Records a final result of transferring an entity This result is recorded as a ResultFromModel, taken from the TransientProcess Returns True if a result is available, False else
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_RecordResult(self, *args)


    def RecordedList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the list of entities to which a final result is attached (i.e. processed by RecordResult)
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _XSControl.XSControl_TransferReader_RecordedList(self, *args)


    def ResultFromNumber(self, *args) -> "opencascade::handle< Transfer_ResultFromModel >":
        """
        * Returns the final result recorded for a NUMBER of entity (internal use). Null if out of range
        	:param theNum:
        	:type theNum: int
        	:rtype: opencascade::handle<Transfer_ResultFromModel>
        """
        return _XSControl.XSControl_TransferReader_ResultFromNumber(self, *args)


    def SetActor(self, *args) -> "void":
        """
        * Sets the Actor directly : this value will be used if the Controller is not set
        	:param theActor:
        	:type theActor: Transfer_ActorOfTransientProcess
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_SetActor(self, *args)


    def SetContext(self, *args) -> "void":
        """
        * Sets a Context : according to receiving appli, to be interpreted by the Actor
        	:param theName:
        	:type theName: char *
        	:param theCtx:
        	:type theCtx: Standard_Transient
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_SetContext(self, *args)


    def SetController(self, *args) -> "void":
        """
        * Sets a Controller. It is required to generate the Actor. Elsewhere, the Actor must be provided directly
        	:param theControl:
        	:type theControl: XSControl_Controller
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_SetController(self, *args)


    def SetFileName(self, *args) -> "void":
        """
        * Sets a new value for (loaded) file name
        	:param theName:
        	:type theName: char *
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_SetFileName(self, *args)


    def SetGraph(self, *args) -> "void":
        """
        * Sets a Graph and its InterfaceModel (calls SetModel)
        	:param theGraph:
        	:type theGraph: Interface_HGraph
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_SetGraph(self, *args)


    def SetModel(self, *args) -> "void":
        """
        * Sets an InterfaceModel. This causes former results, computed from another one, to be lost (see also Clear)
        	:param theModel:
        	:type theModel: Interface_InterfaceModel
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_SetModel(self, *args)


    def SetTransientProcess(self, *args) -> "void":
        """
        * Forces the TransientProcess Remark : it also changes the Model and the Actor, from those recorded in the new TransientProcess
        	:param theTP:
        	:type theTP: Transfer_TransientProcess
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_SetTransientProcess(self, *args)


    def ShapeResult(self, *args) -> "TopoDS_Shape":
        """
        * Returns the resulting object as a Shape Null Shape if no result or result not a shape
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: TopoDS_Shape
        """
        return _XSControl.XSControl_TransferReader_ShapeResult(self, *args)


    def ShapeResultList(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape > const &":
        """
        * Returns a list of result Shapes If <rec> is True , sees RecordedList If <rec> is False, sees LastTransferList (last ROOT transfers) For each one, if it is a Shape, it is cumulated to the list If no Shape is found, returns an empty Sequence
        	:param theRec:
        	:type theRec: bool
        	:rtype: opencascade::handle<TopTools_HSequenceOfShape>
        """
        return _XSControl.XSControl_TransferReader_ShapeResultList(self, *args)


    def Skip(self, *args) -> "Standard_Boolean":
        """
        * Note that an entity has been required for transfer but no result at all is available (typically : case not implemented) It is not an error, but it gives a specific status : Skipped Returns True if done, False if <ent> is not in starting model
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferReader_Skip(self, *args)


    def TransferClear(self, *args) -> "void":
        """
        * Clears the results attached to an entity if <ents> equates the starting model, clears all results
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:param theLevel: default value is 0
        	:type theLevel: int
        	:rtype: None
        """
        return _XSControl.XSControl_TransferReader_TransferClear(self, *args)


    def TransferList(self, *args) -> "Standard_Integer":
        """
        * Commands the transfer on reading for a list of entities to data for Imagine, using the selected Actor for Read Returns count of transferred entities, ok or with fails (0/1) If <rec> is True (D), the results are recorded by RecordResult
        	:param theList:
        	:type theList: TColStd_HSequenceOfTransient
        	:param theRec: default value is Standard_True
        	:type theRec: bool
        	:rtype: int
        """
        return _XSControl.XSControl_TransferReader_TransferList(self, *args)


    def TransferOne(self, *args) -> "Standard_Integer":
        """
        * Commands the transfer on reading for an entity to data for Imagine, using the selected Actor for Read Returns count of transferred entities, ok or with fails (0/1) If <rec> is True (D), the result is recorded by RecordResult
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:param theRec: default value is Standard_True
        	:type theRec: bool
        	:rtype: int
        """
        return _XSControl.XSControl_TransferReader_TransferOne(self, *args)


    def TransferRoots(self, *args) -> "Standard_Integer":
        """
        * Transfers the content of the current Interface Model to data handled by Imagine, starting from its Roots (determined by the Graph <G>), using the selected Actor for Read Returns the count of performed root transfers (i.e. 0 if none) or -1 if no actor is defined
        	:param theGraph:
        	:type theGraph: Interface_Graph
        	:rtype: int
        """
        return _XSControl.XSControl_TransferReader_TransferRoots(self, *args)


    def TransientProcess(self, *args) -> "opencascade::handle< Transfer_TransientProcess > const &":
        """
        * Returns the currently used TransientProcess It is computed from the model by TransferReadRoots, or by BeginTransferRead
        	:rtype: opencascade::handle<Transfer_TransientProcess>
        """
        return _XSControl.XSControl_TransferReader_TransientProcess(self, *args)


    def TransientResult(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns the resulting object as a Transient Null Handle if no result or result not transient
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_TransferReader_TransientResult(self, *args)


    def __init__(self, *args):
        """
        * Creates a TransferReader, empty
        	:rtype: None
        """
        _XSControl.XSControl_TransferReader_swiginit(self, _XSControl.new_XSControl_TransferReader(*args))


    @staticmethod
    def DownCast(t):
      return Handle_XSControl_TransferReader_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_TransferReader
XSControl_TransferReader.Actor = new_instancemethod(_XSControl.XSControl_TransferReader_Actor, None, XSControl_TransferReader)
XSControl_TransferReader.BeginTransfer = new_instancemethod(_XSControl.XSControl_TransferReader_BeginTransfer, None, XSControl_TransferReader)
XSControl_TransferReader.CheckList = new_instancemethod(_XSControl.XSControl_TransferReader_CheckList, None, XSControl_TransferReader)
XSControl_TransferReader.CheckedList = new_instancemethod(_XSControl.XSControl_TransferReader_CheckedList, None, XSControl_TransferReader)
XSControl_TransferReader.Clear = new_instancemethod(_XSControl.XSControl_TransferReader_Clear, None, XSControl_TransferReader)
XSControl_TransferReader.ClearResult = new_instancemethod(_XSControl.XSControl_TransferReader_ClearResult, None, XSControl_TransferReader)
XSControl_TransferReader.Context = new_instancemethod(_XSControl.XSControl_TransferReader_Context, None, XSControl_TransferReader)
XSControl_TransferReader.EntitiesFromShapeList = new_instancemethod(_XSControl.XSControl_TransferReader_EntitiesFromShapeList, None, XSControl_TransferReader)
XSControl_TransferReader.EntityFromResult = new_instancemethod(_XSControl.XSControl_TransferReader_EntityFromResult, None, XSControl_TransferReader)
XSControl_TransferReader.EntityFromShapeResult = new_instancemethod(_XSControl.XSControl_TransferReader_EntityFromShapeResult, None, XSControl_TransferReader)
XSControl_TransferReader.FileName = new_instancemethod(_XSControl.XSControl_TransferReader_FileName, None, XSControl_TransferReader)
XSControl_TransferReader.FinalEntityLabel = new_instancemethod(_XSControl.XSControl_TransferReader_FinalEntityLabel, None, XSControl_TransferReader)
XSControl_TransferReader.FinalEntityNumber = new_instancemethod(_XSControl.XSControl_TransferReader_FinalEntityNumber, None, XSControl_TransferReader)
XSControl_TransferReader.FinalResult = new_instancemethod(_XSControl.XSControl_TransferReader_FinalResult, None, XSControl_TransferReader)
XSControl_TransferReader.GetContext = new_instancemethod(_XSControl.XSControl_TransferReader_GetContext, None, XSControl_TransferReader)
XSControl_TransferReader.HasChecks = new_instancemethod(_XSControl.XSControl_TransferReader_HasChecks, None, XSControl_TransferReader)
XSControl_TransferReader.HasResult = new_instancemethod(_XSControl.XSControl_TransferReader_HasResult, None, XSControl_TransferReader)
XSControl_TransferReader.IsMarked = new_instancemethod(_XSControl.XSControl_TransferReader_IsMarked, None, XSControl_TransferReader)
XSControl_TransferReader.IsRecorded = new_instancemethod(_XSControl.XSControl_TransferReader_IsRecorded, None, XSControl_TransferReader)
XSControl_TransferReader.IsSkipped = new_instancemethod(_XSControl.XSControl_TransferReader_IsSkipped, None, XSControl_TransferReader)
XSControl_TransferReader.LastCheckList = new_instancemethod(_XSControl.XSControl_TransferReader_LastCheckList, None, XSControl_TransferReader)
XSControl_TransferReader.LastTransferList = new_instancemethod(_XSControl.XSControl_TransferReader_LastTransferList, None, XSControl_TransferReader)
XSControl_TransferReader.Model = new_instancemethod(_XSControl.XSControl_TransferReader_Model, None, XSControl_TransferReader)
XSControl_TransferReader.PrintStats = new_instancemethod(_XSControl.XSControl_TransferReader_PrintStats, None, XSControl_TransferReader)
XSControl_TransferReader.Recognize = new_instancemethod(_XSControl.XSControl_TransferReader_Recognize, None, XSControl_TransferReader)
XSControl_TransferReader.RecordResult = new_instancemethod(_XSControl.XSControl_TransferReader_RecordResult, None, XSControl_TransferReader)
XSControl_TransferReader.RecordedList = new_instancemethod(_XSControl.XSControl_TransferReader_RecordedList, None, XSControl_TransferReader)
XSControl_TransferReader.ResultFromNumber = new_instancemethod(_XSControl.XSControl_TransferReader_ResultFromNumber, None, XSControl_TransferReader)
XSControl_TransferReader.SetActor = new_instancemethod(_XSControl.XSControl_TransferReader_SetActor, None, XSControl_TransferReader)
XSControl_TransferReader.SetContext = new_instancemethod(_XSControl.XSControl_TransferReader_SetContext, None, XSControl_TransferReader)
XSControl_TransferReader.SetController = new_instancemethod(_XSControl.XSControl_TransferReader_SetController, None, XSControl_TransferReader)
XSControl_TransferReader.SetFileName = new_instancemethod(_XSControl.XSControl_TransferReader_SetFileName, None, XSControl_TransferReader)
XSControl_TransferReader.SetGraph = new_instancemethod(_XSControl.XSControl_TransferReader_SetGraph, None, XSControl_TransferReader)
XSControl_TransferReader.SetModel = new_instancemethod(_XSControl.XSControl_TransferReader_SetModel, None, XSControl_TransferReader)
XSControl_TransferReader.SetTransientProcess = new_instancemethod(_XSControl.XSControl_TransferReader_SetTransientProcess, None, XSControl_TransferReader)
XSControl_TransferReader.ShapeResult = new_instancemethod(_XSControl.XSControl_TransferReader_ShapeResult, None, XSControl_TransferReader)
XSControl_TransferReader.ShapeResultList = new_instancemethod(_XSControl.XSControl_TransferReader_ShapeResultList, None, XSControl_TransferReader)
XSControl_TransferReader.Skip = new_instancemethod(_XSControl.XSControl_TransferReader_Skip, None, XSControl_TransferReader)
XSControl_TransferReader.TransferClear = new_instancemethod(_XSControl.XSControl_TransferReader_TransferClear, None, XSControl_TransferReader)
XSControl_TransferReader.TransferList = new_instancemethod(_XSControl.XSControl_TransferReader_TransferList, None, XSControl_TransferReader)
XSControl_TransferReader.TransferOne = new_instancemethod(_XSControl.XSControl_TransferReader_TransferOne, None, XSControl_TransferReader)
XSControl_TransferReader.TransferRoots = new_instancemethod(_XSControl.XSControl_TransferReader_TransferRoots, None, XSControl_TransferReader)
XSControl_TransferReader.TransientProcess = new_instancemethod(_XSControl.XSControl_TransferReader_TransientProcess, None, XSControl_TransferReader)
XSControl_TransferReader.TransientResult = new_instancemethod(_XSControl.XSControl_TransferReader_TransientResult, None, XSControl_TransferReader)
XSControl_TransferReader_swigregister = _XSControl.XSControl_TransferReader_swigregister
XSControl_TransferReader_swigregister(XSControl_TransferReader)

def XSControl_TransferReader_PrintStatsOnList(*args) -> "void":
    """
    * Works as PrintStatsProcess, but displays data only on the entities which are in <list> (filter)
    	:param theTP:
    	:type theTP: Transfer_TransientProcess
    	:param theList:
    	:type theList: TColStd_HSequenceOfTransient
    	:param theWhat:
    	:type theWhat: int
    	:param theMode: default value is 0
    	:type theMode: int
    	:rtype: void
    """
    return _XSControl.XSControl_TransferReader_PrintStatsOnList(*args)

def XSControl_TransferReader_PrintStatsProcess(*args) -> "void":
    """
    * This routines prints statistics about a TransientProcess It can be called, by a TransferReader, or isolately Prints are done on the default trace file <what> defines what kind of statistics are to be printed : 0 : basic figures 1 : root results 2 : all recorded (roots, intermediate, checked entities) 3 : abnormal records 4 : check messages (warnings and fails) 5 : fail messages //! <mode> is used according <what> : <what> = 0 : <mode> is ignored <what> = 1,2,3 : <mode> as follows : 0 (D) : just lists numbers of concerned entities in the model 1 : for each entity, gives number,label, type and result type and/or status (fail/warning...) 2 : for each entity, gives maximal information (i.e. checks) 3 : counts per type of starting entity (class type) 4 : counts per result type and/or status 5 : counts per couple (starting type / result type/status) 6 : idem plus gives for each item, the list of numbers of entities in the starting model //! <what> = 4,5 : modes relays on an enum PrintCount : 0 (D) : ItemsByEntity (sequential list by entity) 1 : CountByItem 2 : ShortByItem (count + 5 first numbers) 3 : ListByItem (count + entity numbers) 4 : EntitiesByItem (count + entity numbers and labels)
    	:param theTP:
    	:type theTP: Transfer_TransientProcess
    	:param theWhat:
    	:type theWhat: int
    	:param theMode: default value is 0
    	:type theMode: int
    	:rtype: void
    """
    return _XSControl.XSControl_TransferReader_PrintStatsProcess(*args)

class XSControl_TransferWriter(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns the check-list of last transfer (write), i.e. the check-list currently recorded in the FinderProcess
        	:rtype: Interface_CheckIterator
        """
        return _XSControl.XSControl_TransferWriter_CheckList(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears recorded data according a mode 0 clears FinderProcess (results, checks) -1 create a new FinderProcess
        	:param theMode:
        	:type theMode: int
        	:rtype: None
        """
        return _XSControl.XSControl_TransferWriter_Clear(self, *args)


    def Controller(self, *args) -> "opencascade::handle< XSControl_Controller > const &":
        """
        * Returns the currently used Controller
        	:rtype: opencascade::handle<XSControl_Controller>
        """
        return _XSControl.XSControl_TransferWriter_Controller(self, *args)


    def FinderProcess(self, *args) -> "opencascade::handle< Transfer_FinderProcess > const &":
        """
        * Returns the FinderProcess itself
        	:rtype: opencascade::handle<Transfer_FinderProcess>
        """
        return _XSControl.XSControl_TransferWriter_FinderProcess(self, *args)


    def PrintStats(self, *args) -> "void":
        """
        * Prints statistics on current Trace File, according what,mode See PrintStatsProcess for details
        	:param theWhat:
        	:type theWhat: int
        	:param theMode: default value is 0
        	:type theMode: int
        	:rtype: None
        """
        return _XSControl.XSControl_TransferWriter_PrintStats(self, *args)


    def RecognizeShape(self, *args) -> "Standard_Boolean":
        """
        * Tells if a Shape is valid for a transfer to a model Asks the Controller (RecognizeWriteShape)
        	:param theShape:
        	:type theShape: TopoDS_Shape
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferWriter_RecognizeShape(self, *args)


    def RecognizeTransient(self, *args) -> "Standard_Boolean":
        """
        * Tells if a transient object (from an application) is a valid candidate for a transfer to a model Asks the Controller (RecognizeWriteTransient) If <obj> is a HShape, calls RecognizeShape
        	:param theObj:
        	:type theObj: Standard_Transient
        	:rtype: bool
        """
        return _XSControl.XSControl_TransferWriter_RecognizeTransient(self, *args)


    def ResultCheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns the check-list of last transfer (write), but tries to bind to each check, the resulting entity in the model instead of keeping the original Mapper, whenever known
        	:param theModel:
        	:type theModel: Interface_InterfaceModel
        	:rtype: Interface_CheckIterator
        """
        return _XSControl.XSControl_TransferWriter_ResultCheckList(self, *args)


    def SetController(self, *args) -> "void":
        """
        * Sets a new Controller, also sets a new FinderProcess
        	:param theCtl:
        	:type theCtl: XSControl_Controller
        	:rtype: None
        """
        return _XSControl.XSControl_TransferWriter_SetController(self, *args)


    def SetFinderProcess(self, *args) -> "void":
        """
        * Sets a new FinderProcess and forgets the former one
        	:param theFP:
        	:type theFP: Transfer_FinderProcess
        	:rtype: None
        """
        return _XSControl.XSControl_TransferWriter_SetFinderProcess(self, *args)


    def SetTransferMode(self, *args) -> "void":
        """
        * Changes the Transfer Mode
        	:param theMode:
        	:type theMode: int
        	:rtype: None
        """
        return _XSControl.XSControl_TransferWriter_SetTransferMode(self, *args)


    def TransferMode(self, *args) -> "Standard_Integer":
        """
        * Returns the current Transfer Mode (an Integer) It will be interpreted by the Controller to run Transfers This call form could be later replaced by more specific ones (parameters suited for each norm / transfer case)
        	:rtype: int
        """
        return _XSControl.XSControl_TransferWriter_TransferMode(self, *args)


    def TransferWriteShape(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Transfers a Shape from CasCade to a model of current norm, according to the last call to SetTransferMode Works by calling the Controller Returns status : =0 if OK, >0 if error during transfer, <0 if transfer badly initialised
        	:param theModel:
        	:type theModel: Interface_InterfaceModel
        	:param theShape:
        	:type theShape: TopoDS_Shape
        	:rtype: IFSelect_ReturnStatus
        """
        return _XSControl.XSControl_TransferWriter_TransferWriteShape(self, *args)


    def TransferWriteTransient(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Transfers a Transient object (from an application) to a model of current norm, according to the last call to SetTransferMode Works by calling the Controller Returns status : =0 if OK, >0 if error during transfer, <0 if transfer badly initialised
        	:param theModel:
        	:type theModel: Interface_InterfaceModel
        	:param theObj:
        	:type theObj: Standard_Transient
        	:rtype: IFSelect_ReturnStatus
        """
        return _XSControl.XSControl_TransferWriter_TransferWriteTransient(self, *args)


    def __init__(self, *args):
        """
        * Creates a TransferWriter, empty, ready to run with an empty FinderProcess (but no controller, etc)
        	:rtype: None
        """
        _XSControl.XSControl_TransferWriter_swiginit(self, _XSControl.new_XSControl_TransferWriter(*args))


    @staticmethod
    def DownCast(t):
      return Handle_XSControl_TransferWriter_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_TransferWriter
XSControl_TransferWriter.CheckList = new_instancemethod(_XSControl.XSControl_TransferWriter_CheckList, None, XSControl_TransferWriter)
XSControl_TransferWriter.Clear = new_instancemethod(_XSControl.XSControl_TransferWriter_Clear, None, XSControl_TransferWriter)
XSControl_TransferWriter.Controller = new_instancemethod(_XSControl.XSControl_TransferWriter_Controller, None, XSControl_TransferWriter)
XSControl_TransferWriter.FinderProcess = new_instancemethod(_XSControl.XSControl_TransferWriter_FinderProcess, None, XSControl_TransferWriter)
XSControl_TransferWriter.PrintStats = new_instancemethod(_XSControl.XSControl_TransferWriter_PrintStats, None, XSControl_TransferWriter)
XSControl_TransferWriter.RecognizeShape = new_instancemethod(_XSControl.XSControl_TransferWriter_RecognizeShape, None, XSControl_TransferWriter)
XSControl_TransferWriter.RecognizeTransient = new_instancemethod(_XSControl.XSControl_TransferWriter_RecognizeTransient, None, XSControl_TransferWriter)
XSControl_TransferWriter.ResultCheckList = new_instancemethod(_XSControl.XSControl_TransferWriter_ResultCheckList, None, XSControl_TransferWriter)
XSControl_TransferWriter.SetController = new_instancemethod(_XSControl.XSControl_TransferWriter_SetController, None, XSControl_TransferWriter)
XSControl_TransferWriter.SetFinderProcess = new_instancemethod(_XSControl.XSControl_TransferWriter_SetFinderProcess, None, XSControl_TransferWriter)
XSControl_TransferWriter.SetTransferMode = new_instancemethod(_XSControl.XSControl_TransferWriter_SetTransferMode, None, XSControl_TransferWriter)
XSControl_TransferWriter.TransferMode = new_instancemethod(_XSControl.XSControl_TransferWriter_TransferMode, None, XSControl_TransferWriter)
XSControl_TransferWriter.TransferWriteShape = new_instancemethod(_XSControl.XSControl_TransferWriter_TransferWriteShape, None, XSControl_TransferWriter)
XSControl_TransferWriter.TransferWriteTransient = new_instancemethod(_XSControl.XSControl_TransferWriter_TransferWriteTransient, None, XSControl_TransferWriter)
XSControl_TransferWriter_swigregister = _XSControl.XSControl_TransferWriter_swigregister
XSControl_TransferWriter_swigregister(XSControl_TransferWriter)

class XSControl_Utils(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AppendCStr(self, *args) -> "void":
        """
        :param seqval:
        	:type seqval: TColStd_HSequenceOfHAsciiString
        	:param strval:
        	:type strval: char *
        	:rtype: None
        """
        return _XSControl.XSControl_Utils_AppendCStr(self, *args)


    def AppendEStr(self, *args) -> "void":
        """
        :param seqval:
        	:type seqval: TColStd_HSequenceOfHExtendedString
        	:param strval:
        	:type strval: Standard_ExtString
        	:rtype: None
        """
        return _XSControl.XSControl_Utils_AppendEStr(self, *args)


    def AppendShape(self, *args) -> "void":
        """
        :param seqv:
        	:type seqv: TopTools_HSequenceOfShape
        	:param shape:
        	:type shape: TopoDS_Shape
        	:rtype: None
        """
        return _XSControl.XSControl_Utils_AppendShape(self, *args)


    def AppendTra(self, *args) -> "void":
        """
        :param seqval:
        	:type seqval: TColStd_HSequenceOfTransient
        	:param traval:
        	:type traval: Standard_Transient
        	:rtype: None
        """
        return _XSControl.XSControl_Utils_AppendTra(self, *args)


    def ArrToSeq(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        :param arr:
        	:type arr: Standard_Transient
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_Utils_ArrToSeq(self, *args)


    def AsciiToExtended(self, *args) -> "Standard_ExtString":
        """
        :param str:
        	:type str: char *
        	:rtype: Standard_ExtString
        """
        return _XSControl.XSControl_Utils_AsciiToExtended(self, *args)


    def BinderShape(self, *args) -> "TopoDS_Shape":
        """
        * From a Transient, returns a Shape. In fact, recognizes ShapeBinder ShapeMapper and HShape
        	:param tr:
        	:type tr: Standard_Transient
        	:rtype: TopoDS_Shape
        """
        return _XSControl.XSControl_Utils_BinderShape(self, *args)


    def CStrValue(self, *args) -> "char const *":
        """
        :param list:
        	:type list: Standard_Transient
        	:param num:
        	:type num: int
        	:rtype: char *
        """
        return _XSControl.XSControl_Utils_CStrValue(self, *args)


    def CompoundFromSeq(self, *args) -> "TopoDS_Shape":
        """
        * Converts a list of Shapes to a Compound (a kind of Shape)
        	:param seqval:
        	:type seqval: TopTools_HSequenceOfShape
        	:rtype: TopoDS_Shape
        """
        return _XSControl.XSControl_Utils_CompoundFromSeq(self, *args)


    def DateString(self, *args) -> "char const *":
        """
        :param yy:
        	:type yy: int
        	:param mm:
        	:type mm: int
        	:param dd:
        	:type dd: int
        	:param hh:
        	:type hh: int
        	:param mn:
        	:type mn: int
        	:param ss:
        	:type ss: int
        	:rtype: char *
        """
        return _XSControl.XSControl_Utils_DateString(self, *args)


    def DateValues(self, *args) -> "void":
        """
        :param text:
        	:type text: char *
        	:param yy:
        	:type yy: int
        	:param mm:
        	:type mm: int
        	:param dd:
        	:type dd: int
        	:param hh:
        	:type hh: int
        	:param mn:
        	:type mn: int
        	:param ss:
        	:type ss: int
        	:rtype: None
        """
        return _XSControl.XSControl_Utils_DateValues(self, *args)


    def EStrValue(self, *args) -> "Standard_ExtString":
        """
        :param list:
        	:type list: Standard_Transient
        	:param num:
        	:type num: int
        	:rtype: Standard_ExtString
        """
        return _XSControl.XSControl_Utils_EStrValue(self, *args)


    def ExtendedToAscii(self, *args) -> "char const *":
        """
        :param str:
        	:type str: Standard_ExtString
        	:rtype: char *
        """
        return _XSControl.XSControl_Utils_ExtendedToAscii(self, *args)


    def IsAscii(self, *args) -> "Standard_Boolean":
        """
        :param str:
        	:type str: Standard_ExtString
        	:rtype: bool
        """
        return _XSControl.XSControl_Utils_IsAscii(self, *args)


    def IsKind(self, *args) -> "Standard_Boolean":
        """
        :param item:
        	:type item: Standard_Transient
        	:param what:
        	:type what: Standard_Type
        	:rtype: bool
        """
        return _XSControl.XSControl_Utils_IsKind(self, *args)


    def NewSeqCStr(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """:rtype: opencascade::handle<TColStd_HSequenceOfHAsciiString>"""
        return _XSControl.XSControl_Utils_NewSeqCStr(self, *args)


    def NewSeqEStr(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHExtendedString >":
        """:rtype: opencascade::handle<TColStd_HSequenceOfHExtendedString>"""
        return _XSControl.XSControl_Utils_NewSeqEStr(self, *args)


    def NewSeqShape(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """:rtype: opencascade::handle<TopTools_HSequenceOfShape>"""
        return _XSControl.XSControl_Utils_NewSeqShape(self, *args)


    def NewSeqTra(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """:rtype: opencascade::handle<TColStd_HSequenceOfTransient>"""
        return _XSControl.XSControl_Utils_NewSeqTra(self, *args)


    def SeqIntValue(self, *args) -> "Standard_Integer":
        """
        :param list:
        	:type list: TColStd_HSequenceOfInteger
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _XSControl.XSControl_Utils_SeqIntValue(self, *args)


    def SeqLength(self, *args) -> "Standard_Integer":
        """
        :param list:
        	:type list: Standard_Transient
        	:rtype: int
        """
        return _XSControl.XSControl_Utils_SeqLength(self, *args)


    def SeqToArr(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        :param seq:
        	:type seq: Standard_Transient
        	:param first: default value is 1
        	:type first: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_Utils_SeqToArr(self, *args)


    def ShapeBinder(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Creates a Transient Object from a Shape : it is either a Binder (used by functions which require a Transient but can process a Shape, such as viewing functions) or a HShape (according to hs) Default is a HShape
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param hs: default value is Standard_True
        	:type hs: bool
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_Utils_ShapeBinder(self, *args)


    def ShapeType(self, *args) -> "TopAbs_ShapeEnum":
        """
        * Returns the type of a Shape : true type if <compound> is False If <compound> is True and <shape> is a Compound, iterates on its items. If all are of the same type, returns this type. Else, returns COMPOUND. If it is empty, returns SHAPE For a Null Shape, returns SHAPE
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param compound:
        	:type compound: bool
        	:rtype: TopAbs_ShapeEnum
        """
        return _XSControl.XSControl_Utils_ShapeType(self, *args)


    def ShapeValue(self, *args) -> "TopoDS_Shape":
        """
        :param seqv:
        	:type seqv: TopTools_HSequenceOfShape
        	:param num:
        	:type num: int
        	:rtype: TopoDS_Shape
        """
        return _XSControl.XSControl_Utils_ShapeValue(self, *args)


    def SortedCompound(self, *args) -> "TopoDS_Shape":
        """
        * From a Shape, builds a Compound as follows : explores it level by level If <explore> is False, only COMPOUND items. Else, all items Adds to the result, shapes which comply to <type> + if <type> is WIRE, considers free edges (and makes wires) + if <type> is SHELL, considers free faces (and makes shells) If <compound> is True, gathers items in compounds which correspond to starting COMPOUND,SOLID or SHELL containers, or items directly contained in a Compound
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param type:
        	:type type: TopAbs_ShapeEnum
        	:param explore:
        	:type explore: bool
        	:param compound:
        	:type compound: bool
        	:rtype: TopoDS_Shape
        """
        return _XSControl.XSControl_Utils_SortedCompound(self, *args)


    def ToAString(self, *args) -> "TCollection_AsciiString":
        """
        :param strcon:
        	:type strcon: char *
        	:rtype: TCollection_AsciiString
        """
        return _XSControl.XSControl_Utils_ToAString(self, *args)


    def ToCString(self, *args) -> "char const *":
        """
        :param strval:
        	:type strval: TCollection_HAsciiString
        	:rtype: char *
        :param strval:
        	:type strval: TCollection_AsciiString
        	:rtype: char *
        """
        return _XSControl.XSControl_Utils_ToCString(self, *args)


    def ToEString(self, *args) -> "Standard_ExtString":
        """
        :param strval:
        	:type strval: TCollection_HExtendedString
        	:rtype: Standard_ExtString
        :param strval:
        	:type strval: TCollection_ExtendedString
        	:rtype: Standard_ExtString
        """
        return _XSControl.XSControl_Utils_ToEString(self, *args)


    def ToHString(self, *args) -> "opencascade::handle< TCollection_HExtendedString >":
        """
        :param strcon:
        	:type strcon: char *
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        :param strcon:
        	:type strcon: Standard_ExtString
        	:rtype: opencascade::handle<TCollection_HExtendedString>
        """
        return _XSControl.XSControl_Utils_ToHString(self, *args)


    def ToXString(self, *args) -> "TCollection_ExtendedString":
        """
        :param strcon:
        	:type strcon: Standard_ExtString
        	:rtype: TCollection_ExtendedString
        """
        return _XSControl.XSControl_Utils_ToXString(self, *args)


    def TraValue(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        :param list:
        	:type list: Standard_Transient
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_Utils_TraValue(self, *args)


    def TraceLine(self, *args) -> "void":
        """
        * Just prints a line into the current Trace File. This allows to better characterise the various trace outputs, as desired.
        	:param line:
        	:type line: char *
        	:rtype: None
        """
        return _XSControl.XSControl_Utils_TraceLine(self, *args)


    def TraceLines(self, *args) -> "void":
        """
        * Just prints a line or a set of lines into the current Trace File. <lines> can be a HAscii/ExtendedString (produces a print without ending line) or a HSequence or HArray1 Of .. (one new line per item)
        	:param lines:
        	:type lines: Standard_Transient
        	:rtype: None
        """
        return _XSControl.XSControl_Utils_TraceLines(self, *args)


    def TypeName(self, *args) -> "char const *":
        """
        * Returns the name of the dynamic type of an object, i.e. : If it is a Type, its Name If it is a object not a type, the Name of its DynamicType If it is Null, an empty string If <nopk> is False (D), gives complete name If <nopk> is True, returns class name without package
        	:param item:
        	:type item: Standard_Transient
        	:param nopk: default value is Standard_False
        	:type nopk: bool
        	:rtype: char *
        """
        return _XSControl.XSControl_Utils_TypeName(self, *args)


    def __init__(self, *args):
        """
        * the only use of this, is to allow a frontal to get one distinct 'Utils' set per separate engine
        	:rtype: None
        """
        _XSControl.XSControl_Utils_swiginit(self, _XSControl.new_XSControl_Utils(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_Utils
XSControl_Utils.AppendCStr = new_instancemethod(_XSControl.XSControl_Utils_AppendCStr, None, XSControl_Utils)
XSControl_Utils.AppendEStr = new_instancemethod(_XSControl.XSControl_Utils_AppendEStr, None, XSControl_Utils)
XSControl_Utils.AppendShape = new_instancemethod(_XSControl.XSControl_Utils_AppendShape, None, XSControl_Utils)
XSControl_Utils.AppendTra = new_instancemethod(_XSControl.XSControl_Utils_AppendTra, None, XSControl_Utils)
XSControl_Utils.ArrToSeq = new_instancemethod(_XSControl.XSControl_Utils_ArrToSeq, None, XSControl_Utils)
XSControl_Utils.AsciiToExtended = new_instancemethod(_XSControl.XSControl_Utils_AsciiToExtended, None, XSControl_Utils)
XSControl_Utils.BinderShape = new_instancemethod(_XSControl.XSControl_Utils_BinderShape, None, XSControl_Utils)
XSControl_Utils.CStrValue = new_instancemethod(_XSControl.XSControl_Utils_CStrValue, None, XSControl_Utils)
XSControl_Utils.CompoundFromSeq = new_instancemethod(_XSControl.XSControl_Utils_CompoundFromSeq, None, XSControl_Utils)
XSControl_Utils.DateString = new_instancemethod(_XSControl.XSControl_Utils_DateString, None, XSControl_Utils)
XSControl_Utils.DateValues = new_instancemethod(_XSControl.XSControl_Utils_DateValues, None, XSControl_Utils)
XSControl_Utils.EStrValue = new_instancemethod(_XSControl.XSControl_Utils_EStrValue, None, XSControl_Utils)
XSControl_Utils.ExtendedToAscii = new_instancemethod(_XSControl.XSControl_Utils_ExtendedToAscii, None, XSControl_Utils)
XSControl_Utils.IsAscii = new_instancemethod(_XSControl.XSControl_Utils_IsAscii, None, XSControl_Utils)
XSControl_Utils.IsKind = new_instancemethod(_XSControl.XSControl_Utils_IsKind, None, XSControl_Utils)
XSControl_Utils.NewSeqCStr = new_instancemethod(_XSControl.XSControl_Utils_NewSeqCStr, None, XSControl_Utils)
XSControl_Utils.NewSeqEStr = new_instancemethod(_XSControl.XSControl_Utils_NewSeqEStr, None, XSControl_Utils)
XSControl_Utils.NewSeqShape = new_instancemethod(_XSControl.XSControl_Utils_NewSeqShape, None, XSControl_Utils)
XSControl_Utils.NewSeqTra = new_instancemethod(_XSControl.XSControl_Utils_NewSeqTra, None, XSControl_Utils)
XSControl_Utils.SeqIntValue = new_instancemethod(_XSControl.XSControl_Utils_SeqIntValue, None, XSControl_Utils)
XSControl_Utils.SeqLength = new_instancemethod(_XSControl.XSControl_Utils_SeqLength, None, XSControl_Utils)
XSControl_Utils.SeqToArr = new_instancemethod(_XSControl.XSControl_Utils_SeqToArr, None, XSControl_Utils)
XSControl_Utils.ShapeBinder = new_instancemethod(_XSControl.XSControl_Utils_ShapeBinder, None, XSControl_Utils)
XSControl_Utils.ShapeType = new_instancemethod(_XSControl.XSControl_Utils_ShapeType, None, XSControl_Utils)
XSControl_Utils.ShapeValue = new_instancemethod(_XSControl.XSControl_Utils_ShapeValue, None, XSControl_Utils)
XSControl_Utils.SortedCompound = new_instancemethod(_XSControl.XSControl_Utils_SortedCompound, None, XSControl_Utils)
XSControl_Utils.ToAString = new_instancemethod(_XSControl.XSControl_Utils_ToAString, None, XSControl_Utils)
XSControl_Utils.ToCString = new_instancemethod(_XSControl.XSControl_Utils_ToCString, None, XSControl_Utils)
XSControl_Utils.ToEString = new_instancemethod(_XSControl.XSControl_Utils_ToEString, None, XSControl_Utils)
XSControl_Utils.ToHString = new_instancemethod(_XSControl.XSControl_Utils_ToHString, None, XSControl_Utils)
XSControl_Utils.ToXString = new_instancemethod(_XSControl.XSControl_Utils_ToXString, None, XSControl_Utils)
XSControl_Utils.TraValue = new_instancemethod(_XSControl.XSControl_Utils_TraValue, None, XSControl_Utils)
XSControl_Utils.TraceLine = new_instancemethod(_XSControl.XSControl_Utils_TraceLine, None, XSControl_Utils)
XSControl_Utils.TraceLines = new_instancemethod(_XSControl.XSControl_Utils_TraceLines, None, XSControl_Utils)
XSControl_Utils.TypeName = new_instancemethod(_XSControl.XSControl_Utils_TypeName, None, XSControl_Utils)
XSControl_Utils_swigregister = _XSControl.XSControl_Utils_swigregister
XSControl_Utils_swigregister(XSControl_Utils)

class XSControl_Vars(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Get(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        :param name:
        	:type name: char *
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_Vars_Get(self, *args)


    def GetCurve(self, *args) -> "opencascade::handle< Geom_Curve >":
        """
        :param name:
        	:type name: char *
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _XSControl.XSControl_Vars_GetCurve(self, *args)


    def GetCurve2d(self, *args) -> "opencascade::handle< Geom2d_Curve >":
        """
        :param name:
        	:type name: char *
        	:rtype: opencascade::handle<Geom2d_Curve>
        """
        return _XSControl.XSControl_Vars_GetCurve2d(self, *args)


    def GetGeom(self, *args) -> "opencascade::handle< Geom_Geometry >":
        """
        :param name:
        	:type name: char *
        	:rtype: opencascade::handle<Geom_Geometry>
        """
        return _XSControl.XSControl_Vars_GetGeom(self, *args)


    def GetPoint(self, *args) -> "Standard_Boolean":
        """
        :param name:
        	:type name: char *
        	:param pnt:
        	:type pnt: gp_Pnt
        	:rtype: bool
        """
        return _XSControl.XSControl_Vars_GetPoint(self, *args)


    def GetPoint2d(self, *args) -> "Standard_Boolean":
        """
        :param name:
        	:type name: char *
        	:param pnt:
        	:type pnt: gp_Pnt2d
        	:rtype: bool
        """
        return _XSControl.XSControl_Vars_GetPoint2d(self, *args)


    def GetShape(self, *args) -> "TopoDS_Shape":
        """
        :param name:
        	:type name: char *
        	:rtype: TopoDS_Shape
        """
        return _XSControl.XSControl_Vars_GetShape(self, *args)


    def GetSurface(self, *args) -> "opencascade::handle< Geom_Surface >":
        """
        :param name:
        	:type name: char *
        	:rtype: opencascade::handle<Geom_Surface>
        """
        return _XSControl.XSControl_Vars_GetSurface(self, *args)


    def Set(self, *args) -> "void":
        """
        :param name:
        	:type name: char *
        	:param val:
        	:type val: Standard_Transient
        	:rtype: void
        """
        return _XSControl.XSControl_Vars_Set(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        :param name:
        	:type name: char *
        	:param val:
        	:type val: gp_Pnt
        	:rtype: void
        """
        return _XSControl.XSControl_Vars_SetPoint(self, *args)


    def SetPoint2d(self, *args) -> "void":
        """
        :param name:
        	:type name: char *
        	:param val:
        	:type val: gp_Pnt2d
        	:rtype: void
        """
        return _XSControl.XSControl_Vars_SetPoint2d(self, *args)


    def SetShape(self, *args) -> "void":
        """
        :param name:
        	:type name: char *
        	:param val:
        	:type val: TopoDS_Shape
        	:rtype: void
        """
        return _XSControl.XSControl_Vars_SetShape(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _XSControl.XSControl_Vars_swiginit(self, _XSControl.new_XSControl_Vars(*args))


    @staticmethod
    def DownCast(t):
      return Handle_XSControl_Vars_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_Vars
XSControl_Vars.Get = new_instancemethod(_XSControl.XSControl_Vars_Get, None, XSControl_Vars)
XSControl_Vars.GetCurve = new_instancemethod(_XSControl.XSControl_Vars_GetCurve, None, XSControl_Vars)
XSControl_Vars.GetCurve2d = new_instancemethod(_XSControl.XSControl_Vars_GetCurve2d, None, XSControl_Vars)
XSControl_Vars.GetGeom = new_instancemethod(_XSControl.XSControl_Vars_GetGeom, None, XSControl_Vars)
XSControl_Vars.GetPoint = new_instancemethod(_XSControl.XSControl_Vars_GetPoint, None, XSControl_Vars)
XSControl_Vars.GetPoint2d = new_instancemethod(_XSControl.XSControl_Vars_GetPoint2d, None, XSControl_Vars)
XSControl_Vars.GetShape = new_instancemethod(_XSControl.XSControl_Vars_GetShape, None, XSControl_Vars)
XSControl_Vars.GetSurface = new_instancemethod(_XSControl.XSControl_Vars_GetSurface, None, XSControl_Vars)
XSControl_Vars.Set = new_instancemethod(_XSControl.XSControl_Vars_Set, None, XSControl_Vars)
XSControl_Vars.SetPoint = new_instancemethod(_XSControl.XSControl_Vars_SetPoint, None, XSControl_Vars)
XSControl_Vars.SetPoint2d = new_instancemethod(_XSControl.XSControl_Vars_SetPoint2d, None, XSControl_Vars)
XSControl_Vars.SetShape = new_instancemethod(_XSControl.XSControl_Vars_SetShape, None, XSControl_Vars)
XSControl_Vars_swigregister = _XSControl.XSControl_Vars_swigregister
XSControl_Vars_swigregister(XSControl_Vars)

class XSControl_WorkSession(OCC.Core.IFSelect.IFSelect_WorkSession):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ClearContext(self, *args) -> "void":
        """
        * Clears the whole current Context (nullifies it)
        	:rtype: None
        """
        return _XSControl.XSControl_WorkSession_ClearContext(self, *args)


    def Context(self, *args) -> "NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const &":
        """
        * Returns the current Context List, Null if not defined The Context is given to the TransientProcess for TransferRead
        	:rtype: NCollection_DataMap<TCollection_AsciiString, opencascade::handle<Standard_Transient> >
        """
        return _XSControl.XSControl_WorkSession_Context(self, *args)


    def InitTransferReader(self, *args) -> "void":
        """
        * Sets a Transfer Reader, by internal ways, according mode : 0 recreates it clear, 1 clears it (does not recreate) 2 aligns Roots of TransientProcess from final Results 3 aligns final Results from Roots of TransientProcess 4 begins a new transfer (by BeginTransfer) 5 recreates TransferReader then begins a new transfer
        	:param theMode:
        	:type theMode: int
        	:rtype: None
        """
        return _XSControl.XSControl_WorkSession_InitTransferReader(self, *args)


    def MapReader(self, *args) -> "opencascade::handle< Transfer_TransientProcess >":
        """
        * Returns the TransientProcess(internal data for TransferReader)
        	:rtype: opencascade::handle<Transfer_TransientProcess>
        """
        return _XSControl.XSControl_WorkSession_MapReader(self, *args)


    def NewModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * produces and returns a new Model well conditionned It is produced by the Norm Controller It can be Null (if this function is not implemented)
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _XSControl.XSControl_WorkSession_NewModel(self, *args)


    def NormAdaptor(self, *args) -> "opencascade::handle< XSControl_Controller > const &":
        """
        * Returns the norm controller itself
        	:rtype: opencascade::handle<XSControl_Controller>
        """
        return _XSControl.XSControl_WorkSession_NormAdaptor(self, *args)


    def PrintTransferStatus(self, *args) -> "Standard_Boolean":
        """
        * Prints the transfer status of a transferred item, as beeing the Mapped n0 <num>, from MapWriter if <wri> is True, or from MapReader if <wri> is False Returns True when done, False else (i.e. num out of range)
        	:param theNum:
        	:type theNum: int
        	:param theWri:
        	:type theWri: bool
        	:param theS:
        	:type theS: Message_Messenger
        	:rtype: bool
        """
        return _XSControl.XSControl_WorkSession_PrintTransferStatus(self, *args)


    def Result(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns the result attached to a starting entity If <mode> = 0, returns Final Result If <mode> = 1, considers Last Result If <mode> = 2, considers Final, else if absent, Last returns it as Transient, if result is not transient returns the Binder <mode> = 10,11,12 idem but returns the Binder itself (if it is not, e.g. Shape, returns the Binder) <mode> = 20, returns the ResultFromModel
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:param theMode:
        	:type theMode: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _XSControl.XSControl_WorkSession_Result(self, *args)


    def SelectNorm(self, *args) -> "Standard_Boolean":
        """
        * Selects a Norm defined by its name. A Norm is described and handled by a Controller Returns True if done, False if <normname> is unknown //! The current Profile for this Norm is taken.
        	:param theNormName:
        	:type theNormName: char *
        	:rtype: bool
        """
        return _XSControl.XSControl_WorkSession_SelectNorm(self, *args)


    def SelectedNorm(self, *args) -> "char const *":
        """
        * Returns the name of the last Selected Norm. If none is defined, returns an empty string By default, returns the complete name of the norm If <rsc> is True, returns the short name used for resource
        	:param theRsc: default value is Standard_False
        	:type theRsc: bool
        	:rtype: char *
        """
        return _XSControl.XSControl_WorkSession_SelectedNorm(self, *args)


    def SetAllContext(self, *args) -> "void":
        """
        * Sets the current Context List, as a whole Sets it to the TransferReader
        	:param theContext:
        	:type theContext: Standard_Transient
        	:rtype: None
        """
        return _XSControl.XSControl_WorkSession_SetAllContext(self, *args)


    def SetController(self, *args) -> "void":
        """
        * Selects a Norm defined by its Controller itself
        	:param theCtl:
        	:type theCtl: XSControl_Controller
        	:rtype: None
        """
        return _XSControl.XSControl_WorkSession_SetController(self, *args)


    def SetMapReader(self, *args) -> "Standard_Boolean":
        """
        * Changes the Map Reader, i.e. considers that the new one defines the relevant read results (forgets the former ones) Returns True when done, False in case of bad definition, i.e. if Model from TP differs from that of Session
        	:param theTP:
        	:type theTP: Transfer_TransientProcess
        	:rtype: bool
        """
        return _XSControl.XSControl_WorkSession_SetMapReader(self, *args)


    def SetMapWriter(self, *args) -> "Standard_Boolean":
        """
        * Changes the Map Reader, i.e. considers that the new one defines the relevant read results (forgets the former ones) Returns True when done, False if <FP> is Null
        	:param theFP:
        	:type theFP: Transfer_FinderProcess
        	:rtype: bool
        """
        return _XSControl.XSControl_WorkSession_SetMapWriter(self, *args)


    def SetTransferReader(self, *args) -> "void":
        """
        * Sets a Transfer Reader, which manages transfers on reading
        	:param theTR:
        	:type theTR: XSControl_TransferReader
        	:rtype: None
        """
        return _XSControl.XSControl_WorkSession_SetTransferReader(self, *args)


    def SetVars(self, *args) -> "void":
        """
        :param theVars:
        	:type theVars: XSControl_Vars
        	:rtype: None
        """
        return _XSControl.XSControl_WorkSession_SetVars(self, *args)


    def TransferReadOne(self, *args) -> "Standard_Integer":
        """
        * Commands the transfer of, either one entity, or a list I.E. calls the TransferReader after having analysed <ents> It is cumulated from the last BeginTransfer <ents> is processed by GiveList, hence : - <ents> a Selection : its SelectionResult - <ents> a HSequenceOfTransient : this list - <ents> the Model : in this specific case, all the roots, with no cumulation of former transfers (TransferReadRoots)
        	:param theEnts:
        	:type theEnts: Standard_Transient
        	:rtype: int
        """
        return _XSControl.XSControl_WorkSession_TransferReadOne(self, *args)


    def TransferReadRoots(self, *args) -> "Standard_Integer":
        """
        * Commands the transfer of all the root entities of the model i.e. calls TransferRoot from the TransferReader with the Graph No cumulation with former calls to TransferReadOne
        	:rtype: int
        """
        return _XSControl.XSControl_WorkSession_TransferReadRoots(self, *args)


    def TransferReader(self, *args) -> "opencascade::handle< XSControl_TransferReader > const &":
        """
        * Returns the Transfer Reader, Null if not set
        	:rtype: opencascade::handle<XSControl_TransferReader>
        """
        return _XSControl.XSControl_WorkSession_TransferReader(self, *args)


    def TransferWriteCheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns the check-list of last transfer (write) It is recorded in the FinderProcess, but it must be bound with resulting entities (in the resulting file model) rather than with original objects (in fact, their mappers)
        	:rtype: Interface_CheckIterator
        """
        return _XSControl.XSControl_WorkSession_TransferWriteCheckList(self, *args)


    def TransferWriteShape(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Transfers a Shape from CasCade to a model of current norm, according to the last call to SetModeWriteShape Returns status :Done if OK, Fail if error during transfer, Error if transfer badly initialised
        	:param theShape:
        	:type theShape: TopoDS_Shape
        	:param theCompGraph: default value is Standard_True
        	:type theCompGraph: bool
        	:rtype: IFSelect_ReturnStatus
        """
        return _XSControl.XSControl_WorkSession_TransferWriteShape(self, *args)


    def TransferWriter(self, *args) -> "opencascade::handle< XSControl_TransferWriter > const &":
        """
        * Returns the Transfer Reader, Null if not set
        	:rtype: opencascade::handle<XSControl_TransferWriter>
        """
        return _XSControl.XSControl_WorkSession_TransferWriter(self, *args)


    def Vars(self, *args) -> "opencascade::handle< XSControl_Vars > const &":
        """:rtype: opencascade::handle<XSControl_Vars>"""
        return _XSControl.XSControl_WorkSession_Vars(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _XSControl.XSControl_WorkSession_swiginit(self, _XSControl.new_XSControl_WorkSession(*args))


    @staticmethod
    def DownCast(t):
      return Handle_XSControl_WorkSession_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_WorkSession
XSControl_WorkSession.ClearContext = new_instancemethod(_XSControl.XSControl_WorkSession_ClearContext, None, XSControl_WorkSession)
XSControl_WorkSession.Context = new_instancemethod(_XSControl.XSControl_WorkSession_Context, None, XSControl_WorkSession)
XSControl_WorkSession.InitTransferReader = new_instancemethod(_XSControl.XSControl_WorkSession_InitTransferReader, None, XSControl_WorkSession)
XSControl_WorkSession.MapReader = new_instancemethod(_XSControl.XSControl_WorkSession_MapReader, None, XSControl_WorkSession)
XSControl_WorkSession.NewModel = new_instancemethod(_XSControl.XSControl_WorkSession_NewModel, None, XSControl_WorkSession)
XSControl_WorkSession.NormAdaptor = new_instancemethod(_XSControl.XSControl_WorkSession_NormAdaptor, None, XSControl_WorkSession)
XSControl_WorkSession.PrintTransferStatus = new_instancemethod(_XSControl.XSControl_WorkSession_PrintTransferStatus, None, XSControl_WorkSession)
XSControl_WorkSession.Result = new_instancemethod(_XSControl.XSControl_WorkSession_Result, None, XSControl_WorkSession)
XSControl_WorkSession.SelectNorm = new_instancemethod(_XSControl.XSControl_WorkSession_SelectNorm, None, XSControl_WorkSession)
XSControl_WorkSession.SelectedNorm = new_instancemethod(_XSControl.XSControl_WorkSession_SelectedNorm, None, XSControl_WorkSession)
XSControl_WorkSession.SetAllContext = new_instancemethod(_XSControl.XSControl_WorkSession_SetAllContext, None, XSControl_WorkSession)
XSControl_WorkSession.SetController = new_instancemethod(_XSControl.XSControl_WorkSession_SetController, None, XSControl_WorkSession)
XSControl_WorkSession.SetMapReader = new_instancemethod(_XSControl.XSControl_WorkSession_SetMapReader, None, XSControl_WorkSession)
XSControl_WorkSession.SetMapWriter = new_instancemethod(_XSControl.XSControl_WorkSession_SetMapWriter, None, XSControl_WorkSession)
XSControl_WorkSession.SetTransferReader = new_instancemethod(_XSControl.XSControl_WorkSession_SetTransferReader, None, XSControl_WorkSession)
XSControl_WorkSession.SetVars = new_instancemethod(_XSControl.XSControl_WorkSession_SetVars, None, XSControl_WorkSession)
XSControl_WorkSession.TransferReadOne = new_instancemethod(_XSControl.XSControl_WorkSession_TransferReadOne, None, XSControl_WorkSession)
XSControl_WorkSession.TransferReadRoots = new_instancemethod(_XSControl.XSControl_WorkSession_TransferReadRoots, None, XSControl_WorkSession)
XSControl_WorkSession.TransferReader = new_instancemethod(_XSControl.XSControl_WorkSession_TransferReader, None, XSControl_WorkSession)
XSControl_WorkSession.TransferWriteCheckList = new_instancemethod(_XSControl.XSControl_WorkSession_TransferWriteCheckList, None, XSControl_WorkSession)
XSControl_WorkSession.TransferWriteShape = new_instancemethod(_XSControl.XSControl_WorkSession_TransferWriteShape, None, XSControl_WorkSession)
XSControl_WorkSession.TransferWriter = new_instancemethod(_XSControl.XSControl_WorkSession_TransferWriter, None, XSControl_WorkSession)
XSControl_WorkSession.Vars = new_instancemethod(_XSControl.XSControl_WorkSession_Vars, None, XSControl_WorkSession)
XSControl_WorkSession_swigregister = _XSControl.XSControl_WorkSession_swigregister
XSControl_WorkSession_swigregister(XSControl_WorkSession)

class XSControl_Writer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the produced model. Produces a new one if not yet done or if <newone> is True This method allows for instance to edit product or header data before writing
        	:param newone: default value is Standard_False
        	:type newone: bool
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _XSControl.XSControl_Writer_Model(self, *args)


    def PrintStatsTransfer(self, *args) -> "void":
        """
        * Prints Statistics about Transfer
        	:param what:
        	:type what: int
        	:param mode: default value is 0
        	:type mode: int
        	:rtype: None
        """
        return _XSControl.XSControl_Writer_PrintStatsTransfer(self, *args)


    def SetNorm(self, *args) -> "Standard_Boolean":
        """
        * Sets a specific norm to <self> Returns True if done, False if <norm> is not available
        	:param norm:
        	:type norm: char *
        	:rtype: bool
        """
        return _XSControl.XSControl_Writer_SetNorm(self, *args)


    def SetWS(self, *args) -> "void":
        """
        * Sets a specific session to <self>
        	:param WS:
        	:type WS: XSControl_WorkSession
        	:param scratch: default value is Standard_True
        	:type scratch: bool
        	:rtype: None
        """
        return _XSControl.XSControl_Writer_SetWS(self, *args)


    def TransferShape(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Transfers a Shape according to the mode
        	:param sh:
        	:type sh: TopoDS_Shape
        	:param mode: default value is 0
        	:type mode: int
        	:rtype: IFSelect_ReturnStatus
        """
        return _XSControl.XSControl_Writer_TransferShape(self, *args)


    def WS(self, *args) -> "opencascade::handle< XSControl_WorkSession >":
        """
        * Returns the session used in <self>
        	:rtype: opencascade::handle<XSControl_WorkSession>
        """
        return _XSControl.XSControl_Writer_WS(self, *args)


    def WriteFile(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Writes the produced model
        	:param filename:
        	:type filename: char *
        	:rtype: IFSelect_ReturnStatus
        """
        return _XSControl.XSControl_Writer_WriteFile(self, *args)


    def __init__(self, *args):
        """
        * Creates a Writer from scratch
        	:rtype: None
        * Creates a Writer from scratch, with a norm name which identifie a Controller
        	:param norm:
        	:type norm: char *
        	:rtype: None
        * Creates a Writer from an already existing Session If <scratch> is True (D), clears already recorded data
        	:param WS:
        	:type WS: XSControl_WorkSession
        	:param scratch: default value is Standard_True
        	:type scratch: bool
        	:rtype: None
        """
        _XSControl.XSControl_Writer_swiginit(self, _XSControl.new_XSControl_Writer(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _XSControl.delete_XSControl_Writer
XSControl_Writer.Model = new_instancemethod(_XSControl.XSControl_Writer_Model, None, XSControl_Writer)
XSControl_Writer.PrintStatsTransfer = new_instancemethod(_XSControl.XSControl_Writer_PrintStatsTransfer, None, XSControl_Writer)
XSControl_Writer.SetNorm = new_instancemethod(_XSControl.XSControl_Writer_SetNorm, None, XSControl_Writer)
XSControl_Writer.SetWS = new_instancemethod(_XSControl.XSControl_Writer_SetWS, None, XSControl_Writer)
XSControl_Writer.TransferShape = new_instancemethod(_XSControl.XSControl_Writer_TransferShape, None, XSControl_Writer)
XSControl_Writer.WS = new_instancemethod(_XSControl.XSControl_Writer_WS, None, XSControl_Writer)
XSControl_Writer.WriteFile = new_instancemethod(_XSControl.XSControl_Writer_WriteFile, None, XSControl_Writer)
XSControl_Writer_swigregister = _XSControl.XSControl_Writer_swigregister
XSControl_Writer_swigregister(XSControl_Writer)



