# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
gce module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_gce.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _gce.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_gce')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_gce')
    _gce = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gce', [dirname(__file__)])
        except ImportError:
            import _gce
            return _gce
        try:
            _mod = imp.load_module('_gce', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _gce = swig_import_helper()
    del swig_import_helper
else:
    import _gce
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gce.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_gce.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_gce.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_gce.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_gce.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_gce.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_gce.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_gce.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_gce.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_gce.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_gce.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_gce.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_gce.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_gce.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_gce.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_gce.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_gce.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _gce.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _gce.process_exception(error, method_name, class_name)
process_exception = _gce.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
gce_Done = _gce.gce_Done
gce_ConfusedPoints = _gce.gce_ConfusedPoints
gce_NegativeRadius = _gce.gce_NegativeRadius
gce_ColinearPoints = _gce.gce_ColinearPoints
gce_IntersectionError = _gce.gce_IntersectionError
gce_NullAxis = _gce.gce_NullAxis
gce_NullAngle = _gce.gce_NullAngle
gce_NullRadius = _gce.gce_NullRadius
gce_InvertAxis = _gce.gce_InvertAxis
gce_BadAngle = _gce.gce_BadAngle
gce_InvertRadius = _gce.gce_InvertRadius
gce_NullFocusLength = _gce.gce_NullFocusLength
gce_NullVector = _gce.gce_NullVector
gce_BadEquation = _gce.gce_BadEquation
class gce_MakeMirror(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Trsf const":
        """:rtype: gp_Trsf"""
        return _gce.gce_MakeMirror_Operator(self, *args)


    def Value(self, *args) -> "gp_Trsf const":
        """
        * Returns the constructed transformation.
        	:rtype: gp_Trsf
        """
        return _gce.gce_MakeMirror_Value(self, *args)


    def __init__(self, *args):
        """
        :param Point:
        	:type Point: gp_Pnt
        	:rtype: None
        :param Axis:
        	:type Axis: gp_Ax1
        	:rtype: None
        :param Line:
        	:type Line: gp_Lin
        	:rtype: None
        * Makes a symmetry transformation af axis defined by <Point> and <Direc>.
        	:param Point:
        	:type Point: gp_Pnt
        	:param Direc:
        	:type Direc: gp_Dir
        	:rtype: None
        * Makes a symmetry transformation of plane <Plane>.
        	:param Plane:
        	:type Plane: gp_Pln
        	:rtype: None
        * Makes a symmetry transformation of plane <Plane>.
        	:param Plane:
        	:type Plane: gp_Ax2
        	:rtype: None
        """
        _gce.gce_MakeMirror_swiginit(self, _gce.new_gce_MakeMirror(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeMirror
gce_MakeMirror.Operator = new_instancemethod(_gce.gce_MakeMirror_Operator, None, gce_MakeMirror)
gce_MakeMirror.Value = new_instancemethod(_gce.gce_MakeMirror_Value, None, gce_MakeMirror)
gce_MakeMirror_swigregister = _gce.gce_MakeMirror_swigregister
gce_MakeMirror_swigregister(gce_MakeMirror)

class gce_MakeMirror2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Trsf2d const":
        """:rtype: gp_Trsf2d"""
        return _gce.gce_MakeMirror2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Trsf2d const":
        """
        * Returns the constructed transformation.
        	:rtype: gp_Trsf2d
        """
        return _gce.gce_MakeMirror2d_Value(self, *args)


    def __init__(self, *args):
        """
        :param Point:
        	:type Point: gp_Pnt2d
        	:rtype: None
        :param Axis:
        	:type Axis: gp_Ax2d
        	:rtype: None
        :param Line:
        	:type Line: gp_Lin2d
        	:rtype: None
        * Makes a symmetry transformation af axis defined by <Point> and <Direc>.
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Direc:
        	:type Direc: gp_Dir2d
        	:rtype: None
        """
        _gce.gce_MakeMirror2d_swiginit(self, _gce.new_gce_MakeMirror2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeMirror2d
gce_MakeMirror2d.Operator = new_instancemethod(_gce.gce_MakeMirror2d_Operator, None, gce_MakeMirror2d)
gce_MakeMirror2d.Value = new_instancemethod(_gce.gce_MakeMirror2d_Value, None, gce_MakeMirror2d)
gce_MakeMirror2d_swigregister = _gce.gce_MakeMirror2d_swigregister
gce_MakeMirror2d_swigregister(gce_MakeMirror2d)

class gce_MakeRotation(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Trsf const":
        """:rtype: gp_Trsf"""
        return _gce.gce_MakeRotation_Operator(self, *args)


    def Value(self, *args) -> "gp_Trsf const":
        """
        * Returns the constructed transformation.
        	:rtype: gp_Trsf
        """
        return _gce.gce_MakeRotation_Value(self, *args)


    def __init__(self, *args):
        """
        * Constructs a rotation through angle Angle about the axis defined by the line Line.
        	:param Line:
        	:type Line: gp_Lin
        	:param Angle:
        	:type Angle: float
        	:rtype: None
        * Constructs a rotation through angle Angle about the axis defined by the axis Axis.
        	:param Axis:
        	:type Axis: gp_Ax1
        	:param Angle:
        	:type Angle: float
        	:rtype: None
        * Constructs a rotation through angle Angle about the axis defined by: the point Point and the unit vector Direc.
        	:param Point:
        	:type Point: gp_Pnt
        	:param Direc:
        	:type Direc: gp_Dir
        	:param Angle:
        	:type Angle: float
        	:rtype: None
        """
        _gce.gce_MakeRotation_swiginit(self, _gce.new_gce_MakeRotation(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeRotation
gce_MakeRotation.Operator = new_instancemethod(_gce.gce_MakeRotation_Operator, None, gce_MakeRotation)
gce_MakeRotation.Value = new_instancemethod(_gce.gce_MakeRotation_Value, None, gce_MakeRotation)
gce_MakeRotation_swigregister = _gce.gce_MakeRotation_swigregister
gce_MakeRotation_swigregister(gce_MakeRotation)

class gce_MakeRotation2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Trsf2d const":
        """:rtype: gp_Trsf2d"""
        return _gce.gce_MakeRotation2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Trsf2d const":
        """
        * Returns the constructed transformation.
        	:rtype: gp_Trsf2d
        """
        return _gce.gce_MakeRotation2d_Value(self, *args)


    def __init__(self, *args):
        """
        * Constructs a rotation through angle Angle about the center Point.
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Angle:
        	:type Angle: float
        	:rtype: None
        """
        _gce.gce_MakeRotation2d_swiginit(self, _gce.new_gce_MakeRotation2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeRotation2d
gce_MakeRotation2d.Operator = new_instancemethod(_gce.gce_MakeRotation2d_Operator, None, gce_MakeRotation2d)
gce_MakeRotation2d.Value = new_instancemethod(_gce.gce_MakeRotation2d_Value, None, gce_MakeRotation2d)
gce_MakeRotation2d_swigregister = _gce.gce_MakeRotation2d_swigregister
gce_MakeRotation2d_swigregister(gce_MakeRotation2d)

class gce_MakeScale(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Trsf const":
        """:rtype: gp_Trsf"""
        return _gce.gce_MakeScale_Operator(self, *args)


    def Value(self, *args) -> "gp_Trsf const":
        """
        * Returns the constructed transformation.
        	:rtype: gp_Trsf
        """
        return _gce.gce_MakeScale_Value(self, *args)


    def __init__(self, *args):
        """
        * Constructs a scaling transformation with - Point as the center of the transformation, and - Scale as the scale factor.
        	:param Point:
        	:type Point: gp_Pnt
        	:param Scale:
        	:type Scale: float
        	:rtype: None
        """
        _gce.gce_MakeScale_swiginit(self, _gce.new_gce_MakeScale(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeScale
gce_MakeScale.Operator = new_instancemethod(_gce.gce_MakeScale_Operator, None, gce_MakeScale)
gce_MakeScale.Value = new_instancemethod(_gce.gce_MakeScale_Value, None, gce_MakeScale)
gce_MakeScale_swigregister = _gce.gce_MakeScale_swigregister
gce_MakeScale_swigregister(gce_MakeScale)

class gce_MakeScale2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Trsf2d const":
        """:rtype: gp_Trsf2d"""
        return _gce.gce_MakeScale2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Trsf2d const":
        """
        * Returns the constructed transformation.
        	:rtype: gp_Trsf2d
        """
        return _gce.gce_MakeScale2d_Value(self, *args)


    def __init__(self, *args):
        """
        * Constructs a scaling transformation with: - Point as the center of the transformation, and - Scale as the scale factor.
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Scale:
        	:type Scale: float
        	:rtype: None
        """
        _gce.gce_MakeScale2d_swiginit(self, _gce.new_gce_MakeScale2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeScale2d
gce_MakeScale2d.Operator = new_instancemethod(_gce.gce_MakeScale2d_Operator, None, gce_MakeScale2d)
gce_MakeScale2d.Value = new_instancemethod(_gce.gce_MakeScale2d_Value, None, gce_MakeScale2d)
gce_MakeScale2d_swigregister = _gce.gce_MakeScale2d_swigregister
gce_MakeScale2d_swigregister(gce_MakeScale2d)

class gce_MakeTranslation(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Trsf const":
        """:rtype: gp_Trsf"""
        return _gce.gce_MakeTranslation_Operator(self, *args)


    def Value(self, *args) -> "gp_Trsf const":
        """
        * Returns the constructed transformation.
        	:rtype: gp_Trsf
        """
        return _gce.gce_MakeTranslation_Value(self, *args)


    def __init__(self, *args):
        """
        * Constructs a translation along the vector ' Vect'
        	:param Vect:
        	:type Vect: gp_Vec
        	:rtype: None
        * Constructs a translation along the vector (Point1,Point2) defined from the point Point1 to the point Point2.
        	:param Point1:
        	:type Point1: gp_Pnt
        	:param Point2:
        	:type Point2: gp_Pnt
        	:rtype: None
        """
        _gce.gce_MakeTranslation_swiginit(self, _gce.new_gce_MakeTranslation(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeTranslation
gce_MakeTranslation.Operator = new_instancemethod(_gce.gce_MakeTranslation_Operator, None, gce_MakeTranslation)
gce_MakeTranslation.Value = new_instancemethod(_gce.gce_MakeTranslation_Value, None, gce_MakeTranslation)
gce_MakeTranslation_swigregister = _gce.gce_MakeTranslation_swigregister
gce_MakeTranslation_swigregister(gce_MakeTranslation)

class gce_MakeTranslation2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Trsf2d const":
        """:rtype: gp_Trsf2d"""
        return _gce.gce_MakeTranslation2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Trsf2d const":
        """
        * Returns the constructed transformation.
        	:rtype: gp_Trsf2d
        """
        return _gce.gce_MakeTranslation2d_Value(self, *args)


    def __init__(self, *args):
        """
        * Constructs a translation along the vector Vect.
        	:param Vect:
        	:type Vect: gp_Vec2d
        	:rtype: None
        * Constructs a translation along the vector (Point1,Point2) defined from the point Point1 to the point Point2.
        	:param Point1:
        	:type Point1: gp_Pnt2d
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:rtype: None
        """
        _gce.gce_MakeTranslation2d_swiginit(self, _gce.new_gce_MakeTranslation2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeTranslation2d
gce_MakeTranslation2d.Operator = new_instancemethod(_gce.gce_MakeTranslation2d_Operator, None, gce_MakeTranslation2d)
gce_MakeTranslation2d.Value = new_instancemethod(_gce.gce_MakeTranslation2d_Value, None, gce_MakeTranslation2d)
gce_MakeTranslation2d_swigregister = _gce.gce_MakeTranslation2d_swigregister
gce_MakeTranslation2d_swigregister(gce_MakeTranslation2d)

class gce_Root(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the construction is successful.
        	:rtype: bool
        """
        return _gce.gce_Root_IsDone(self, *args)


    def Status(self, *args) -> "gce_ErrorType":
        """
        * Returns the status of the construction: - gce_Done, if the construction is successful, or - another value of the gce_ErrorType enumeration indicating why the construction failed.
        	:rtype: gce_ErrorType
        """
        return _gce.gce_Root_Status(self, *args)


    __repr__ = _dumps_object


    def __init__(self):
        _gce.gce_Root_swiginit(self, _gce.new_gce_Root())
    __swig_destroy__ = _gce.delete_gce_Root
gce_Root.IsDone = new_instancemethod(_gce.gce_Root_IsDone, None, gce_Root)
gce_Root.Status = new_instancemethod(_gce.gce_Root_Status, None, gce_Root)
gce_Root_swigregister = _gce.gce_Root_swigregister
gce_Root_swigregister(gce_Root)

class gce_MakeCirc(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Circ const":
        """:rtype: gp_Circ"""
        return _gce.gce_MakeCirc_Operator(self, *args)


    def Value(self, *args) -> "gp_Circ const":
        """
        * Returns the constructed circle. Exceptions StdFail_NotDone if no circle is constructed.
        	:rtype: gp_Circ
        """
        return _gce.gce_MakeCirc_Value(self, *args)


    def __init__(self, *args):
        """
        * A2 locates the circle and gives its orientation in 3D space. Warnings : It is not forbidden to create a circle with Radius = 0.0 The status is 'NegativeRadius' if Radius < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Makes a Circ from gp <TheCirc> coaxial to another Circ <Circ> at a distance <Dist>. If Dist is greater than zero the result is encloses the circle <Circ>, else the result is enclosed by the circle <Circ>.
        	:param Circ:
        	:type Circ: gp_Circ
        	:param Dist:
        	:type Dist: float
        	:rtype: None
        * Makes a Circ from gp <TheCirc> coaxial to another Circ <Circ> and passing through a Pnt2d <Point>.
        	:param Circ:
        	:type Circ: gp_Circ
        	:param Point:
        	:type Point: gp_Pnt
        	:rtype: None
        * Makes a Circ from gp <TheCirc> passing through 3 Pnt2d <P1>,<P2>,<P3>.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:param P3:
        	:type P3: gp_Pnt
        	:rtype: None
        * Makes a Circ from gp <TheCirc> with its center <Center> and the normal of its plane <Norm> and its radius <Radius>.
        	:param Center:
        	:type Center: gp_Pnt
        	:param Norm:
        	:type Norm: gp_Dir
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Makes a Circ from gp <TheCirc> with its center <Center> and the normal of its plane <Plane> and its radius <Radius>.
        	:param Center:
        	:type Center: gp_Pnt
        	:param Plane:
        	:type Plane: gp_Pln
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Makes a Circ from gp <TheCirc> with its center <Center> and a point <Ptaxis> giving the normal of its plane <Plane> and its radius <Radius>.
        	:param Center:
        	:type Center: gp_Pnt
        	:param Ptaxis:
        	:type Ptaxis: gp_Pnt
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Makes a Circ from gp <TheCirc> with its center <Center> and its radius <Radius>. Warning The MakeCirc class does not prevent the construction of a circle with a null radius. If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_Negative Radius if: - Radius is less than 0.0, or - Dist is less than 0.0 and the absolute value of Dist is greater than the radius of Circ; - gce_IntersectionError if the points P1, P2 and P3 are collinear, and the three are not coincident; - gce_ConfusedPoints if two of the three points P1, P2 and P3 are coincident; or - gce_NullAxis if Center and Ptaxis are coincident.
        	:param Axis:
        	:type Axis: gp_Ax1
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gce.gce_MakeCirc_swiginit(self, _gce.new_gce_MakeCirc(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeCirc
gce_MakeCirc.Operator = new_instancemethod(_gce.gce_MakeCirc_Operator, None, gce_MakeCirc)
gce_MakeCirc.Value = new_instancemethod(_gce.gce_MakeCirc_Value, None, gce_MakeCirc)
gce_MakeCirc_swigregister = _gce.gce_MakeCirc_swigregister
gce_MakeCirc_swigregister(gce_MakeCirc)

class gce_MakeCirc2d(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Circ2d const":
        """:rtype: gp_Circ2d"""
        return _gce.gce_MakeCirc2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Circ2d const":
        """
        * Returns the constructed circle. Exceptions StdFail_NotDone if no circle is constructed.
        	:rtype: gp_Circ2d
        """
        return _gce.gce_MakeCirc2d_Value(self, *args)


    def __init__(self, *args):
        """
        * The location point of XAxis is the center of the circle. Warnings : It is not forbidden to create a circle with Radius = 0.0 If Sense is true the local coordinate system of the solution is direct and non direct in the other case. The status is 'NegativeRadius' if Radius < 0.0.
        	:param XAxis:
        	:type XAxis: gp_Ax2d
        	:param Radius:
        	:type Radius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        * The location point of Axis is the center of the circle. Warnings : It is not forbidden to create a circle with Radius = 0.0
        	:param Axis:
        	:type Axis: gp_Ax22d
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Makes a Circ2d from gp <TheCirc> concentric with another circ2d <Circ> with a distance <Dist>. If Dist is greater than zero the result encloses the circle <Circ>, else the result is enclosed by the circle <Circ>. The local coordinate system of the solution is the same as Circ.
        	:param Circ:
        	:type Circ: gp_Circ2d
        	:param Dist:
        	:type Dist: float
        	:rtype: None
        * Makes a Circ2d from gp <TheCirc> concentric with another circ2d <Circ> and passing through a Pnt2d <Point>. The local coordinate system of the solution is the same as Circ.
        	:param Circ:
        	:type Circ: gp_Circ2d
        	:param Point:
        	:type Point: gp_Pnt2d
        	:rtype: None
        * Makes a Circ2d from gp <TheCirc> passing through 3 Pnt2d <P1>,<P2>,<P3>. The local coordinate system of the solution is given by the three points P1, P2, P3.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:param P3:
        	:type P3: gp_Pnt2d
        	:rtype: None
        * Makes a Circ2d from gp <TheCirc> with its center <Center> and its radius <Radius>. If Sense is true the local coordinate system of the solution is direct and non direct in the other case.
        	:param Center:
        	:type Center: gp_Pnt2d
        	:param Radius:
        	:type Radius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        * Makes a Circ2d from gp <TheCirc> with its center <Center> and a point giving the radius. If Sense is true the local coordinate system of the solution is direct and non direct in the other case.
        	:param Center:
        	:type Center: gp_Pnt2d
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        """
        _gce.gce_MakeCirc2d_swiginit(self, _gce.new_gce_MakeCirc2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeCirc2d
gce_MakeCirc2d.Operator = new_instancemethod(_gce.gce_MakeCirc2d_Operator, None, gce_MakeCirc2d)
gce_MakeCirc2d.Value = new_instancemethod(_gce.gce_MakeCirc2d_Value, None, gce_MakeCirc2d)
gce_MakeCirc2d_swigregister = _gce.gce_MakeCirc2d_swigregister
gce_MakeCirc2d_swigregister(gce_MakeCirc2d)

class gce_MakeCone(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Cone const":
        """:rtype: gp_Cone"""
        return _gce.gce_MakeCone_Operator(self, *args)


    def Value(self, *args) -> "gp_Cone const":
        """
        * Returns the constructed cone. Exceptions StdFail_NotDone if no cone is constructed.
        	:rtype: gp_Cone
        """
        return _gce.gce_MakeCone_Value(self, *args)


    def __init__(self, *args):
        """
        * Creates an infinite conical surface. A2 locates the cone in the space and defines the reference plane of the surface. Ang is the conical surface semi-angle between 0 and PI/2 radians. Radius is the radius of the circle in the reference plane of the cone. If Radius is lower than 0.0 the status is ' If Ang < Resolution from gp or Ang >= (PI/2) - Resolution.
        	:param A2:
        	:type A2: gp_Ax2
        	:param Ang:
        	:type Ang: float
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Makes a Cone from gp <TheCone> coaxial to another Cone <Cone> and passing through a Pnt <Point>.
        	:param Cone:
        	:type Cone: gp_Cone
        	:param Point:
        	:type Point: gp_Pnt
        	:rtype: None
        * Makes a Cone from gp <TheCone> coaxial to another Cone <Cone> at the distance <Dist> which can be greater or lower than zero.
        	:param Cone:
        	:type Cone: gp_Cone
        	:param Dist:
        	:type Dist: float
        	:rtype: None
        * Makes a Cone from gp <TheCone> by four points <P1>, <P2>,<P3> and <P4>. Its axis is <P1P2> and the radius of its base is the distance between <P3> and <P1P2>. The distance between <P4> and <P1P2> is the radius of the section passing through <P4>. If <P1> and <P2> are confused or <P3> and <P4> are confused we have the status 'ConfusedPoints' if <P1>,<P2>,<P3>,<P4> are colinear we have the status 'ColinearPoints' If <P3P4> is perpendicular to <P1P2> we have the status 'NullAngle'. <P3P4> is colinear to <P1P2> we have the status 'NullAngle'.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:param P3:
        	:type P3: gp_Pnt
        	:param P4:
        	:type P4: gp_Pnt
        	:rtype: None
        * Makes a Cone by its axis <Axis> and and two points. The distance between <P1> and the axis is the radius of the section passing through <P1>. The distance between <P2> and the axis is the radius of the section passing through <P2>. If <P1P2> is colinear to <Axis> we have the status 'NullAngle' If <P3P4> is perpendicular to <Axis> we have the status 'NullAngle' If <P1> and <P2> are confused we have the status 'ConfusedPoints'
        	:param Axis:
        	:type Axis: gp_Ax1
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        * Makes a Cone by its axis <Axis> and and two points. The distance between <P1> and the axis is the radius of the section passing through <P1> The distance between <P2> and the axis is the radius of the section passing through <P2> If <P1P2> is colinear to <Axis> we have the status 'NullAngle' If <P3P4> is perpendicular to <Axis> we have the status 'NullAngle' If <P1> and <P2> are confused we have the status 'ConfusedPoints'
        	:param Axis:
        	:type Axis: gp_Lin
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        * Makes a Cone with two points and two radius. The axis of the solution is the line passing through <P1> and <P2>. <R1> is the radius of the section passing through <P1> and <R2> the radius of the section passing through <P2>. If <P1> and <P2> are confused we have the status 'NullAxis'. Warning If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_NegativeRadius if Radius, R1 or R2 is less than 0.0; - gce_BadAngle if Ang is less than gp::Resolution() or greater than Pi/2.- gp::Resolution(); - gce_ConfusedPoints if P1 and P2 or P3 and P4 are coincident; - gce_NullAxis if the points P1 and P2, are coincident (5th syntax only); - gce_NullAngle if: - the vector joining P1 to P2 is parallel to either Axis or the line joining P3 to P4, or - R1 and R2 are equal, (that is, their difference is less than gp::Resolution()); or - gce_NullRadius if: - the vector joining P1 to P2 is perpendicular to the line joining P3 to P4, - the vector joining P1 to P2 is perpendicular to Axis, or - P1, P2, P3, and P4 are collinear.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:rtype: None
        """
        _gce.gce_MakeCone_swiginit(self, _gce.new_gce_MakeCone(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeCone
gce_MakeCone.Operator = new_instancemethod(_gce.gce_MakeCone_Operator, None, gce_MakeCone)
gce_MakeCone.Value = new_instancemethod(_gce.gce_MakeCone_Value, None, gce_MakeCone)
gce_MakeCone_swigregister = _gce.gce_MakeCone_swigregister
gce_MakeCone_swigregister(gce_MakeCone)

class gce_MakeCylinder(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Cylinder const":
        """:rtype: gp_Cylinder"""
        return _gce.gce_MakeCylinder_Operator(self, *args)


    def Value(self, *args) -> "gp_Cylinder const":
        """
        * Returns the constructed cylinder. Exceptions StdFail_NotDone if no cylinder is constructed.
        	:rtype: gp_Cylinder
        """
        return _gce.gce_MakeCylinder_Value(self, *args)


    def __init__(self, *args):
        """
        * <A2> is the local cartesian coordinate system of <self>. The status is 'NegativeRadius' if R < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Makes a Cylinder from gp <TheCylinder> coaxial to another Cylinder <Cylinder> and passing through a Pnt <Point>.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param Point:
        	:type Point: gp_Pnt
        	:rtype: None
        * Makes a Cylinder from gp <TheCylinder> coaxial to another Cylinder <Cylinder> at the distance <Dist> which can be greater or lower than zero. The radius of the result is the absolute value of the radius of <Cyl> plus <Dist>
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param Dist:
        	:type Dist: float
        	:rtype: None
        * Makes a Cylinder from gp <TheCylinder> with 3 points <P1>,<P2>,<P3>. Its axis is <P1P2> and its radius is the distance between <P3> and <P1P2>
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:param P3:
        	:type P3: gp_Pnt
        	:rtype: None
        * Makes a Cylinder by its axis <Axis> and radius <Radius>.
        	:param Axis:
        	:type Axis: gp_Ax1
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        * Makes a Cylinder by its circular base. Warning If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_NegativeRadius if: - Radius is less than 0.0, or - Dist is negative and has an absolute value which is greater than the radius of Cyl; or - gce_ConfusedPoints if points P1 and P2 are coincident.
        	:param Circ:
        	:type Circ: gp_Circ
        	:rtype: None
        """
        _gce.gce_MakeCylinder_swiginit(self, _gce.new_gce_MakeCylinder(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeCylinder
gce_MakeCylinder.Operator = new_instancemethod(_gce.gce_MakeCylinder_Operator, None, gce_MakeCylinder)
gce_MakeCylinder.Value = new_instancemethod(_gce.gce_MakeCylinder_Value, None, gce_MakeCylinder)
gce_MakeCylinder_swigregister = _gce.gce_MakeCylinder_swigregister
gce_MakeCylinder_swigregister(gce_MakeCylinder)

class gce_MakeDir(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Dir const":
        """:rtype: gp_Dir"""
        return _gce.gce_MakeDir_Operator(self, *args)


    def Value(self, *args) -> "gp_Dir const":
        """
        * Returns the constructed unit vector. Exceptions StdFail_NotDone if no unit vector is constructed.
        	:rtype: gp_Dir
        """
        return _gce.gce_MakeDir_Value(self, *args)


    def __init__(self, *args):
        """
        * Normalizes the vector V and creates a direction. Status is 'NullVector' if V.Magnitude() <= Resolution.
        	:param V:
        	:type V: gp_Vec
        	:rtype: None
        * Creates a direction from a triplet of coordinates. Status is 'NullVector' if Coord.Modulus() <= Resolution from gp.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        * Creates a direction with its 3 cartesian coordinates. Status is 'NullVector' if Sqrt(Xv*Xv + Yv*Yv + Zv*Zv) <= Resolution
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:param Zv:
        	:type Zv: float
        	:rtype: None
        * Make a Dir from gp <TheDir> passing through 2 Pnt <P1>,<P2>. Status is 'ConfusedPoints' if <p1> and <P2> are confused. Warning If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_ConfusedPoints if points P1 and P2 are coincident, or - gce_NullVector if one of the following is less than or equal to gp::Resolution(): - the magnitude of vector V, - the modulus of Coord, - Sqrt(Xv*Xv + Yv*Yv + Zv*Zv).
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        _gce.gce_MakeDir_swiginit(self, _gce.new_gce_MakeDir(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeDir
gce_MakeDir.Operator = new_instancemethod(_gce.gce_MakeDir_Operator, None, gce_MakeDir)
gce_MakeDir.Value = new_instancemethod(_gce.gce_MakeDir_Value, None, gce_MakeDir)
gce_MakeDir_swigregister = _gce.gce_MakeDir_swigregister
gce_MakeDir_swigregister(gce_MakeDir)

class gce_MakeDir2d(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Dir2d const":
        """:rtype: gp_Dir2d"""
        return _gce.gce_MakeDir2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Dir2d const":
        """
        * Returns the constructed unit vector. Exceptions StdFail_NotDone if no unit vector is constructed.
        	:rtype: gp_Dir2d
        """
        return _gce.gce_MakeDir2d_Value(self, *args)


    def __init__(self, *args):
        """
        * Normalizes the vector V and creates a direction. Status is 'NullVector' if V.Magnitude() <= Resolution.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None
        * Creates a direction from a triplet of coordinates. Status is 'NullVector' if Coord.Modulus() <= Resolution from gp.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        * Creates a direction with its 3 cartesian coordinates. Status is 'NullVector' if Sqrt(Xv*Xv + Yv*Yv ) <= Resolution
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:rtype: None
        * Make a Dir2d from gp <TheDir> passing through 2 Pnt <P1>,<P2>. Status is 'ConfusedPoints' if <P1> and <P2> are confused. Warning If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_ConfusedPoints if points P1 and P2 are coincident, or - gce_NullVector if one of the following is less than or equal to gp::Resolution(): - the magnitude of vector V, - the modulus of Coord, - Sqrt(Xv*Xv + Yv*Yv).
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        _gce.gce_MakeDir2d_swiginit(self, _gce.new_gce_MakeDir2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeDir2d
gce_MakeDir2d.Operator = new_instancemethod(_gce.gce_MakeDir2d_Operator, None, gce_MakeDir2d)
gce_MakeDir2d.Value = new_instancemethod(_gce.gce_MakeDir2d_Value, None, gce_MakeDir2d)
gce_MakeDir2d_swigregister = _gce.gce_MakeDir2d_swigregister
gce_MakeDir2d_swigregister(gce_MakeDir2d)

class gce_MakeElips(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Elips const":
        """:rtype: gp_Elips"""
        return _gce.gce_MakeElips_Operator(self, *args)


    def Value(self, *args) -> "gp_Elips const":
        """
        * Returns the constructed ellipse. Exceptions StdFail_NotDone if no ellipse is constructed.
        	:rtype: gp_Elips
        """
        return _gce.gce_MakeElips_Value(self, *args)


    def __init__(self, *args):
        """
        * The major radius of the ellipse is on the 'XAxis' and the minor radius is on the 'YAxis' of the ellipse. The 'XAxis' is defined with the 'XDirection' of A2 and the 'YAxis' is defined with the 'YDirection' of A2. Warnings : It is not forbidden to create an ellipse with MajorRadius = MinorRadius.
        	:param A2:
        	:type A2: gp_Ax2
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        * Make an ellipse with its center and two points. Warning The MakeElips class does not prevent the construction of an ellipse where the MajorRadius is equal to the MinorRadius. If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_InvertRadius if MajorRadius is less than MinorRadius; - gce_NegativeRadius if MinorRadius is less than 0.0; - gce_NullAxis if the points S1 and Center are coincident; or - gce_InvertAxis if: - the major radius computed with Center and S1 is less than the minor radius computed with Center, S1 and S2, or - Center, S1 and S2 are collinear.
        	:param S1:
        	:type S1: gp_Pnt
        	:param S2:
        	:type S2: gp_Pnt
        	:param Center:
        	:type Center: gp_Pnt
        	:rtype: None
        """
        _gce.gce_MakeElips_swiginit(self, _gce.new_gce_MakeElips(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeElips
gce_MakeElips.Operator = new_instancemethod(_gce.gce_MakeElips_Operator, None, gce_MakeElips)
gce_MakeElips.Value = new_instancemethod(_gce.gce_MakeElips_Value, None, gce_MakeElips)
gce_MakeElips_swigregister = _gce.gce_MakeElips_swigregister
gce_MakeElips_swigregister(gce_MakeElips)

class gce_MakeElips2d(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Elips2d const":
        """:rtype: gp_Elips2d"""
        return _gce.gce_MakeElips2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Elips2d const":
        """
        * Returns the constructed ellipse. Exceptions StdFail_NotDone if no ellipse is constructed.
        	:rtype: gp_Elips2d
        """
        return _gce.gce_MakeElips2d_Value(self, *args)


    def __init__(self, *args):
        """
        * Creates an ellipse with the major axis, the major and the minor radius. The location of the MajorAxis is the center of the ellipse. The sense of parametrization is given by Sense. It is possible to create an ellipse with MajorRadius = MinorRadius. the status is 'InvertRadius' if MajorRadius < MinorRadius or 'NegativeRadius' if MinorRadius < 0.0
        	:param MajorAxis:
        	:type MajorAxis: gp_Ax2d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        * Axis defines the Xaxis and Yaxis of the ellipse which defines the origin and the sense of parametrization. Creates an ellipse with the AxisPlacement the major and the minor radius. The location of Axis is the center of the ellipse. It is possible to create an ellipse with MajorRadius = MinorRadius. the status is 'InvertRadius' if MajorRadius < MinorRadius or 'NegativeRadius' if MinorRadius < 0.0
        	:param A:
        	:type A: gp_Ax22d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        * Makes an Elips2d with its center and two points. The sense of parametrization is given by S1, S2, and Center. Depending on the constructor, the implicit orientation of the ellipse is: - the sense defined by A, - the sense defined by points Center, S1 and S2, - the trigonometric sense if Sense is not given or is true, or - the opposite if Sense is false. It is possible to construct an ellipse where the major and minor radii are equal. Warning If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_InvertRadius if MajorRadius is less than MinorRadius, - gce_NegativeRadius if MajorRadius or MinorRadius is less than 0.0, - gce_NullAxis if points S1, S2 and Center are collinear, or - gce_InvertAxis if the major radius computed with Center and S1 is less than the minor radius computed with Center, S1 and S2.
        	:param S1:
        	:type S1: gp_Pnt2d
        	:param S2:
        	:type S2: gp_Pnt2d
        	:param Center:
        	:type Center: gp_Pnt2d
        	:rtype: None
        """
        _gce.gce_MakeElips2d_swiginit(self, _gce.new_gce_MakeElips2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeElips2d
gce_MakeElips2d.Operator = new_instancemethod(_gce.gce_MakeElips2d_Operator, None, gce_MakeElips2d)
gce_MakeElips2d.Value = new_instancemethod(_gce.gce_MakeElips2d_Value, None, gce_MakeElips2d)
gce_MakeElips2d_swigregister = _gce.gce_MakeElips2d_swigregister
gce_MakeElips2d_swigregister(gce_MakeElips2d)

class gce_MakeHypr(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Hypr const":
        """:rtype: gp_Hypr"""
        return _gce.gce_MakeHypr_Operator(self, *args)


    def Value(self, *args) -> "gp_Hypr const":
        """
        * Returns the constructed hyperbola. Exceptions StdFail_NotDone if no hyperbola is constructed.
        	:rtype: gp_Hypr
        """
        return _gce.gce_MakeHypr_Value(self, *args)


    def __init__(self, *args):
        """
        * A2 is the local coordinate system of the hyperbola. In the local coordinates system A2 the equation of the hyperbola is : X*X / MajorRadius*MajorRadius - Y*Y / MinorRadius*MinorRadius = 1.0 It is not forbidden to create an Hyperbola with MajorRadius = MinorRadius. For the hyperbola the MajorRadius can be lower than the MinorRadius. The status is 'NegativeRadius' if MajorRadius < 0.0 and 'InvertRadius' if MinorRadius > MajorRadius.
        	:param A2:
        	:type A2: gp_Ax2
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        * Constructs a hyperbola - centered on the point Center, where: - the plane of the hyperbola is defined by Center, S1 and S2, - its major axis is defined by Center and S1, - its major radius is the distance between Center and S1, and - its minor radius is the distance between S2 and the major axis. Warning If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_NegativeRadius if MajorRadius is less than 0.0; - gce_InvertRadius if: - the major radius (computed with Center, S1) is less than the minor radius (computed with Center, S1 and S2), or - MajorRadius is less than MinorRadius; or - gce_ColinearPoints if S1, S2 and Center are collinear.
        	:param S1:
        	:type S1: gp_Pnt
        	:param S2:
        	:type S2: gp_Pnt
        	:param Center:
        	:type Center: gp_Pnt
        	:rtype: None
        """
        _gce.gce_MakeHypr_swiginit(self, _gce.new_gce_MakeHypr(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeHypr
gce_MakeHypr.Operator = new_instancemethod(_gce.gce_MakeHypr_Operator, None, gce_MakeHypr)
gce_MakeHypr.Value = new_instancemethod(_gce.gce_MakeHypr_Value, None, gce_MakeHypr)
gce_MakeHypr_swigregister = _gce.gce_MakeHypr_swigregister
gce_MakeHypr_swigregister(gce_MakeHypr)

class gce_MakeHypr2d(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Hypr2d const":
        """:rtype: gp_Hypr2d"""
        return _gce.gce_MakeHypr2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Hypr2d const":
        """
        * Returns the constructed hyperbola. Exceptions StdFail_NotDone if no hyperbola is constructed.
        	:rtype: gp_Hypr2d
        """
        return _gce.gce_MakeHypr2d_Value(self, *args)


    def __init__(self, *args):
        """
        * Constructs a hyperbola centered on the point Center, where: - the major axis of the hyperbola is defined by Center and point S1, - the major radius is the distance between Center and S1, and - the minor radius is the distance between point S2 and the major axis.
        	:param S1:
        	:type S1: gp_Pnt2d
        	:param S2:
        	:type S2: gp_Pnt2d
        	:param Center:
        	:type Center: gp_Pnt2d
        	:rtype: None
        * Constructs a hyperbola with major and minor radii MajorRadius and MinorRadius, where: - the center of the hyperbola is the origin of the axis MajorAxis, and - the major axis is defined by MajorAxis if Sense is true, or the opposite axis to MajorAxis if Sense is false; or - centered on the origin of the coordinate system A, with major and minor radii MajorRadius and MinorRadius, where its major axis is the 'X Axis' of A (A is the local coordinate system of the hyperbola).
        	:param MajorAxis:
        	:type MajorAxis: gp_Ax2d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:param Sense:
        	:type Sense: bool
        	:rtype: None
        * Creates a Hypr2d centered on the origin of the coordinate system A, with major and minor radii MajorRadius and MinorRadius, where its major axis is the 'X Axis' of A (A is the local coordinate system of the hyperbola).
        	:param A:
        	:type A: gp_Ax22d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gce.gce_MakeHypr2d_swiginit(self, _gce.new_gce_MakeHypr2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeHypr2d
gce_MakeHypr2d.Operator = new_instancemethod(_gce.gce_MakeHypr2d_Operator, None, gce_MakeHypr2d)
gce_MakeHypr2d.Value = new_instancemethod(_gce.gce_MakeHypr2d_Value, None, gce_MakeHypr2d)
gce_MakeHypr2d_swigregister = _gce.gce_MakeHypr2d_swigregister
gce_MakeHypr2d_swigregister(gce_MakeHypr2d)

class gce_MakeLin(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Lin const":
        """:rtype: gp_Lin"""
        return _gce.gce_MakeLin_Operator(self, *args)


    def Value(self, *args) -> "gp_Lin const":
        """
        * Returns the constructed line. Exceptions StdFail_NotDone is raised if no line is constructed.
        	:rtype: gp_Lin
        """
        return _gce.gce_MakeLin_Value(self, *args)


    def __init__(self, *args):
        """
        * Creates a line located along the axis A1.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        * <P> is the location point (origin) of the line and <V> is the direction of the line.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        * Make a Lin from gp <TheLin> parallel to another Lin <Lin> and passing through a Pnt <Point>.
        	:param Lin:
        	:type Lin: gp_Lin
        	:param Point:
        	:type Point: gp_Pnt
        	:rtype: None
        * Make a Lin from gp <TheLin> passing through 2 Pnt <P1>,<P2>. It returns false if <p1> and <P2> are confused.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        _gce.gce_MakeLin_swiginit(self, _gce.new_gce_MakeLin(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeLin
gce_MakeLin.Operator = new_instancemethod(_gce.gce_MakeLin_Operator, None, gce_MakeLin)
gce_MakeLin.Value = new_instancemethod(_gce.gce_MakeLin_Value, None, gce_MakeLin)
gce_MakeLin_swigregister = _gce.gce_MakeLin_swigregister
gce_MakeLin_swigregister(gce_MakeLin)

class gce_MakeLin2d(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Lin2d":
        """:rtype: gp_Lin2d"""
        return _gce.gce_MakeLin2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Lin2d":
        """
        * Returns the constructed line. Exceptions StdFail_NotDone if no line is constructed.
        	:rtype: gp_Lin2d
        """
        return _gce.gce_MakeLin2d_Value(self, *args)


    def __init__(self, *args):
        """
        * Creates a line located with A.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        * <P> is the location point (origin) of the line and <V> is the direction of the line.
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        * Creates the line from the equation A*X + B*Y + C = 0.0 the status is 'NullAxis'if Sqrt(A*A + B*B) <= Resolution from gp.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:rtype: None
        * Make a Lin2d from gp <TheLin> parallel to another Lin2d <Lin> at a distance <Dist>. If Dist is greater than zero the result is on the right of the Line <Lin>, else the result is on the left of the Line <Lin>.
        	:param Lin:
        	:type Lin: gp_Lin2d
        	:param Dist:
        	:type Dist: float
        	:rtype: None
        * Make a Lin2d from gp <TheLin> parallel to another Lin2d <Lin> and passing through a Pnt2d <Point>.
        	:param Lin:
        	:type Lin: gp_Lin2d
        	:param Point:
        	:type Point: gp_Pnt2d
        	:rtype: None
        * Make a Lin2d from gp <TheLin> passing through 2 Pnt2d <P1>,<P2>. It returns false if <P1> and <P2> are confused. Warning If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_NullAxis if Sqrt(A*A + B*B) is less than or equal to gp::Resolution(), or - gce_ConfusedPoints if points P1 and P2 are coincident.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        _gce.gce_MakeLin2d_swiginit(self, _gce.new_gce_MakeLin2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeLin2d
gce_MakeLin2d.Operator = new_instancemethod(_gce.gce_MakeLin2d_Operator, None, gce_MakeLin2d)
gce_MakeLin2d.Value = new_instancemethod(_gce.gce_MakeLin2d_Value, None, gce_MakeLin2d)
gce_MakeLin2d_swigregister = _gce.gce_MakeLin2d_swigregister
gce_MakeLin2d_swigregister(gce_MakeLin2d)

class gce_MakeParab(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Parab const":
        """:rtype: gp_Parab"""
        return _gce.gce_MakeParab_Operator(self, *args)


    def Value(self, *args) -> "gp_Parab const":
        """
        * Returns the constructed parabola. Exceptions StdFail_NotDone if no parabola is constructed.
        	:rtype: gp_Parab
        """
        return _gce.gce_MakeParab_Value(self, *args)


    def __init__(self, *args):
        """
        * --- Purpose ; Creates a parabola with its local coordinate system 'A2' and it's focal length 'Focal'. The XDirection of A2 defines the axis of symmetry of the parabola. The YDirection of A2 is parallel to the directrix of the parabola. The Location point of A2 is the vertex of the parabola The status is 'NullFocusLength' if Focal < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param Focal:
        	:type Focal: float
        	:rtype: None
        * D is the directrix of the parabola and F the focus point. The symmetry axis (XAxis) of the parabola is normal to the directrix and pass through the focus point F, but its location point is the vertex of the parabola. The YAxis of the parabola is parallel to D and its location point is the vertex of the parabola. The normal to the plane of the parabola is the cross product between the XAxis and the YAxis.
        	:param D:
        	:type D: gp_Ax1
        	:param F:
        	:type F: gp_Pnt
        	:rtype: None
        """
        _gce.gce_MakeParab_swiginit(self, _gce.new_gce_MakeParab(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeParab
gce_MakeParab.Operator = new_instancemethod(_gce.gce_MakeParab_Operator, None, gce_MakeParab)
gce_MakeParab.Value = new_instancemethod(_gce.gce_MakeParab_Value, None, gce_MakeParab)
gce_MakeParab_swigregister = _gce.gce_MakeParab_swigregister
gce_MakeParab_swigregister(gce_MakeParab)

class gce_MakeParab2d(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Parab2d const":
        """:rtype: gp_Parab2d"""
        return _gce.gce_MakeParab2d_Operator(self, *args)


    def Value(self, *args) -> "gp_Parab2d const":
        """
        * Returns the constructed parabola. Exceptions StdFail_NotDone if no parabola is constructed.
        	:rtype: gp_Parab2d
        """
        return _gce.gce_MakeParab2d_Value(self, *args)


    def __init__(self, *args):
        """
        * Creates a parabola with its axis of symmetry ('MirrorAxis') and its focal length. Warnings : It is possible to have Focal = 0. The status is 'NullFocalLength' Raised if Focal < 0.0
        	:param MirrorAxis:
        	:type MirrorAxis: gp_Ax2d
        	:param Focal:
        	:type Focal: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        * Creates a parabola with its local coordinate system <A> and its focal length. Warnings : It is possible to have Focal = 0. The status is 'NullFocalLength' Raised if Focal < 0.0
        	:param A:
        	:type A: gp_Ax22d
        	:param Focal:
        	:type Focal: float
        	:rtype: None
        * Creates a parabola with the directrix and the focus point. The sense of parametrization is given by Sense.
        	:param D:
        	:type D: gp_Ax2d
        	:param F:
        	:type F: gp_Pnt2d
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        * Make an Parab2d with S1 as the Focal point and Center as the apex of the parabola Warning The MakeParab2d class does not prevent the construction of a parabola with a null focal distance. If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_NullFocusLength if Focal is less than 0.0, or - gce_NullAxis if S1 and Center are coincident.
        	:param S1:
        	:type S1: gp_Pnt2d
        	:param Center:
        	:type Center: gp_Pnt2d
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        """
        _gce.gce_MakeParab2d_swiginit(self, _gce.new_gce_MakeParab2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakeParab2d
gce_MakeParab2d.Operator = new_instancemethod(_gce.gce_MakeParab2d_Operator, None, gce_MakeParab2d)
gce_MakeParab2d.Value = new_instancemethod(_gce.gce_MakeParab2d_Value, None, gce_MakeParab2d)
gce_MakeParab2d_swigregister = _gce.gce_MakeParab2d_swigregister
gce_MakeParab2d_swigregister(gce_MakeParab2d)

class gce_MakePln(gce_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Operator(self, *args) -> "gp_Pln const":
        """:rtype: gp_Pln"""
        return _gce.gce_MakePln_Operator(self, *args)


    def Value(self, *args) -> "gp_Pln const":
        """
        * Returns the constructed plane. Exceptions StdFail_NotDone if no plane is constructed.
        	:rtype: gp_Pln
        """
        return _gce.gce_MakePln_Value(self, *args)


    def __init__(self, *args):
        """
        * The coordinate system of the plane is defined with the axis placement A2. The 'Direction' of A2 defines the normal to the plane. The 'Location' of A2 defines the location (origin) of the plane. The 'XDirection' and 'YDirection' of A2 define the 'XAxis' and the 'YAxis' of the plane used to parametrize the plane.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        * Creates a plane with the 'Location' point <P> and the normal direction <V>.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        * Creates a plane from its cartesian equation : A * X + B * Y + C * Z + D = 0.0 //! the status is 'BadEquation' if Sqrt (A*A + B*B + C*C) <= Resolution from gp.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:rtype: None
        * Make a Pln from gp <ThePln> parallel to another Pln <Pln> and passing through a Pnt <Point>.
        	:param Pln:
        	:type Pln: gp_Pln
        	:param Point:
        	:type Point: gp_Pnt
        	:rtype: None
        * Make a Pln from gp <ThePln> parallel to another Pln <Pln> at the distance <Dist> which can be greater or less than zero. In the first case the result is at the distance <Dist> to the plane <Pln> in the direction of the normal to <Pln>. Otherwize it is in the opposite direction.
        	:param Pln:
        	:type Pln: gp_Pln
        	:param Dist:
        	:type Dist: float
        	:rtype: None
        * Make a Pln from gp <ThePln> passing through 3 Pnt <P1>,<P2>,<P3>. It returns false if <P1> <P2> <P3> are confused.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:param P3:
        	:type P3: gp_Pnt
        	:rtype: None
        * Make a Pln from gp <ThePln> perpendicular to the line passing through <P1>,<P2>. The status is 'ConfusedPoints' if <P1> <P2> are confused.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        * Make a pln passing through the location of <Axis>and normal to the Direction of <Axis>. Warning - If an error occurs (that is, when IsDone returns false), the Status function returns: - gce_BadEquation if Sqrt(A*A + B*B + C*C) is less than or equal to gp::Resolution(), - gce_ConfusedPoints if P1 and P2 are coincident, or - gce_ColinearPoints if P1, P2 and P3 are collinear.
        	:param Axis:
        	:type Axis: gp_Ax1
        	:rtype: None
        """
        _gce.gce_MakePln_swiginit(self, _gce.new_gce_MakePln(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gce.delete_gce_MakePln
gce_MakePln.Operator = new_instancemethod(_gce.gce_MakePln_Operator, None, gce_MakePln)
gce_MakePln.Value = new_instancemethod(_gce.gce_MakePln_Value, None, gce_MakePln)
gce_MakePln_swigregister = _gce.gce_MakePln_swigregister
gce_MakePln_swigregister(gce_MakePln)



