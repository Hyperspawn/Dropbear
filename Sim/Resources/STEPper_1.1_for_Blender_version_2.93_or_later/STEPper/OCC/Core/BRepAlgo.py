# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BRepAlgo module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_brepalgo.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BRepAlgo.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepAlgo')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepAlgo')
    _BRepAlgo = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepAlgo', [dirname(__file__)])
        except ImportError:
            import _BRepAlgo
            return _BRepAlgo
        try:
            _mod = imp.load_module('_BRepAlgo', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepAlgo = swig_import_helper()
    del swig_import_helper
else:
    import _BRepAlgo
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepAlgo.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BRepAlgo.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BRepAlgo.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BRepAlgo.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BRepAlgo.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BRepAlgo.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BRepAlgo.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BRepAlgo.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BRepAlgo.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BRepAlgo.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BRepAlgo.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BRepAlgo.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BRepAlgo.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BRepAlgo.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BRepAlgo.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BRepAlgo.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BRepAlgo.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BRepAlgo.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _BRepAlgo.process_exception(error, method_name, class_name)
process_exception = _BRepAlgo.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TopTools
import OCC.Core.TCollection
import OCC.Core.BRepBuilderAPI
import OCC.Core.Geom
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.BRepTools
import OCC.Core.Bnd
import OCC.Core.BVH
import OCC.Core.Geom2d
import OCC.Core.BRep
import OCC.Core.Poly
import OCC.Core.TShort
import OCC.Core.TopOpeBRepBuild
import OCC.Core.TopOpeBRepDS
import OCC.Core.TopOpeBRepTool
import OCC.Core.BRepClass3d
import OCC.Core.IntCurveSurface
import OCC.Core.math
import OCC.Core.Adaptor3d
import OCC.Core.Adaptor2d
import OCC.Core.Intf
import OCC.Core.IntSurf
import OCC.Core.IntCurvesFace
import OCC.Core.BRepAdaptor
import OCC.Core.GeomAdaptor
import OCC.Core.Geom2dAdaptor
import OCC.Core.TopExp
import OCC.Core.Extrema
BRepAlgo_OK = _BRepAlgo.BRepAlgo_OK
BRepAlgo_NOK = _BRepAlgo.BRepAlgo_NOK

def Handle_BRepAlgo_AsDes_Create() -> "opencascade::handle< BRepAlgo_AsDes >":
    return _BRepAlgo.Handle_BRepAlgo_AsDes_Create()
Handle_BRepAlgo_AsDes_Create = _BRepAlgo.Handle_BRepAlgo_AsDes_Create

def Handle_BRepAlgo_AsDes_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< BRepAlgo_AsDes >":
    return _BRepAlgo.Handle_BRepAlgo_AsDes_DownCast(t)
Handle_BRepAlgo_AsDes_DownCast = _BRepAlgo.Handle_BRepAlgo_AsDes_DownCast

def Handle_BRepAlgo_AsDes_IsNull(t: 'opencascade::handle< BRepAlgo_AsDes > const &') -> "bool":
    return _BRepAlgo.Handle_BRepAlgo_AsDes_IsNull(t)
Handle_BRepAlgo_AsDes_IsNull = _BRepAlgo.Handle_BRepAlgo_AsDes_IsNull
class brepalgo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ConcatenateWire(*args) -> "TopoDS_Wire":
        """
        * this method makes a wire whose edges are C1 from a Wire whose edges could be G1. It removes a vertex between G1 edges. Option can be G1 or C1.
        	:param Wire:
        	:type Wire: TopoDS_Wire
        	:param Option:
        	:type Option: GeomAbs_Shape
        	:param AngularTolerance: default value is 1.0e-4
        	:type AngularTolerance: float
        	:rtype: TopoDS_Wire
        """
        return _BRepAlgo.brepalgo_ConcatenateWire(*args)

    ConcatenateWire = staticmethod(ConcatenateWire)

    def ConcatenateWireC0(*args) -> "TopoDS_Edge":
        """
        * this method makes an edge from a wire. Junction points between edges of wire may be sharp, resulting curve of the resulting edge may be C0.
        	:param Wire:
        	:type Wire: TopoDS_Wire
        	:rtype: TopoDS_Edge
        """
        return _BRepAlgo.brepalgo_ConcatenateWireC0(*args)

    ConcatenateWireC0 = staticmethod(ConcatenateWireC0)

    def IsTopologicallyValid(*args) -> "Standard_Boolean":
        """
        * Checks if the shape is 'correct'. If not, returns <Standard_False>, else returns <Standard_True>. This method differs from the previous one in the fact that no geometric contols (intersection of wires, pcurve validity) are performed.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: bool
        """
        return _BRepAlgo.brepalgo_IsTopologicallyValid(*args)

    IsTopologicallyValid = staticmethod(IsTopologicallyValid)

    def IsValid(*args) -> "Standard_Boolean":
        """
        * Checks if the shape is 'correct'. If not, returns <Standard_False>, else returns <Standard_True>.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: bool
        * Checks if the Generated and Modified Faces from the shapes <arguments> in the shape <result> are 'correct'. The args may be empty, then all faces will be checked. If <Closed> is True, only closed shape are valid. If <GeomCtrl> is False the geometry of new vertices and edges are not verified and the auto-intersection of new wires are not searched.
        	:param theArgs:
        	:type theArgs: TopTools_ListOfShape
        	:param theResult:
        	:type theResult: TopoDS_Shape
        	:param closedSolid: default value is Standard_False
        	:type closedSolid: bool
        	:param GeomCtrl: default value is Standard_True
        	:type GeomCtrl: bool
        	:rtype: bool
        """
        return _BRepAlgo.brepalgo_IsValid(*args)

    IsValid = staticmethod(IsValid)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepAlgo.brepalgo_swiginit(self, _BRepAlgo.new_brepalgo())
    __swig_destroy__ = _BRepAlgo.delete_brepalgo
brepalgo_swigregister = _BRepAlgo.brepalgo_swigregister
brepalgo_swigregister(brepalgo)

def brepalgo_ConcatenateWire(*args) -> "TopoDS_Wire":
    """
    * this method makes a wire whose edges are C1 from a Wire whose edges could be G1. It removes a vertex between G1 edges. Option can be G1 or C1.
    	:param Wire:
    	:type Wire: TopoDS_Wire
    	:param Option:
    	:type Option: GeomAbs_Shape
    	:param AngularTolerance: default value is 1.0e-4
    	:type AngularTolerance: float
    	:rtype: TopoDS_Wire
    """
    return _BRepAlgo.brepalgo_ConcatenateWire(*args)

def brepalgo_ConcatenateWireC0(*args) -> "TopoDS_Edge":
    """
    * this method makes an edge from a wire. Junction points between edges of wire may be sharp, resulting curve of the resulting edge may be C0.
    	:param Wire:
    	:type Wire: TopoDS_Wire
    	:rtype: TopoDS_Edge
    """
    return _BRepAlgo.brepalgo_ConcatenateWireC0(*args)

def brepalgo_IsTopologicallyValid(*args) -> "Standard_Boolean":
    """
    * Checks if the shape is 'correct'. If not, returns <Standard_False>, else returns <Standard_True>. This method differs from the previous one in the fact that no geometric contols (intersection of wires, pcurve validity) are performed.
    	:param S:
    	:type S: TopoDS_Shape
    	:rtype: bool
    """
    return _BRepAlgo.brepalgo_IsTopologicallyValid(*args)

def brepalgo_IsValid(*args) -> "Standard_Boolean":
    """
    * Checks if the shape is 'correct'. If not, returns <Standard_False>, else returns <Standard_True>.
    	:param S:
    	:type S: TopoDS_Shape
    	:rtype: bool
    * Checks if the Generated and Modified Faces from the shapes <arguments> in the shape <result> are 'correct'. The args may be empty, then all faces will be checked. If <Closed> is True, only closed shape are valid. If <GeomCtrl> is False the geometry of new vertices and edges are not verified and the auto-intersection of new wires are not searched.
    	:param theArgs:
    	:type theArgs: TopTools_ListOfShape
    	:param theResult:
    	:type theResult: TopoDS_Shape
    	:param closedSolid: default value is Standard_False
    	:type closedSolid: bool
    	:param GeomCtrl: default value is Standard_True
    	:type GeomCtrl: bool
    	:rtype: bool
    """
    return _BRepAlgo.brepalgo_IsValid(*args)

class BRepAlgo_AsDes(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Stores <SS> as a futur subshape of <S>.
        	:param S:
        	:type S: TopoDS_Shape
        	:param SS:
        	:type SS: TopoDS_Shape
        	:rtype: None
        * Stores <SS> as futurs SubShapes of <S>.
        	:param S:
        	:type S: TopoDS_Shape
        	:param SS:
        	:type SS: TopTools_ListOfShape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_AsDes_Add(self, *args)


    def Ascendant(self, *args) -> "TopTools_ListOfShape const &":
        """
        * Returns the Shape containing <S>.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopTools_ListOfShape
        """
        return _BRepAlgo.BRepAlgo_AsDes_Ascendant(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty AsDes.
        	:rtype: None
        """
        _BRepAlgo.BRepAlgo_AsDes_swiginit(self, _BRepAlgo.new_BRepAlgo_AsDes(*args))

    def ChangeDescendant(self, *args) -> "TopTools_ListOfShape &":
        """
        * Returns futur subhapes of <S>.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopTools_ListOfShape
        """
        return _BRepAlgo.BRepAlgo_AsDes_ChangeDescendant(self, *args)


    def Clear(self, *args) -> "void":
        """:rtype: None"""
        return _BRepAlgo.BRepAlgo_AsDes_Clear(self, *args)


    def Descendant(self, *args) -> "TopTools_ListOfShape const &":
        """
        * Returns futur subhapes of <S>.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopTools_ListOfShape
        """
        return _BRepAlgo.BRepAlgo_AsDes_Descendant(self, *args)


    def HasAscendant(self, *args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: bool
        """
        return _BRepAlgo.BRepAlgo_AsDes_HasAscendant(self, *args)


    def HasCommonDescendant(self, *args) -> "Standard_Boolean":
        """
        * Returns True if (S1> and <S2> has common Descendants. Stores in <LC> the Commons Descendants.
        	:param S1:
        	:type S1: TopoDS_Shape
        	:param S2:
        	:type S2: TopoDS_Shape
        	:param LC:
        	:type LC: TopTools_ListOfShape
        	:rtype: bool
        """
        return _BRepAlgo.BRepAlgo_AsDes_HasCommonDescendant(self, *args)


    def HasDescendant(self, *args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: bool
        """
        return _BRepAlgo.BRepAlgo_AsDes_HasDescendant(self, *args)


    def Remove(self, *args) -> "void":
        """
        * Remove <S> from me.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_AsDes_Remove(self, *args)


    def Replace(self, *args) -> "void":
        """
        * Replace <OldS> by <NewS>. <OldS> disapear from <self>.
        	:param OldS:
        	:type OldS: TopoDS_Shape
        	:param NewS:
        	:type NewS: TopoDS_Shape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_AsDes_Replace(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_BRepAlgo_AsDes_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_AsDes
BRepAlgo_AsDes.Add = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Add, None, BRepAlgo_AsDes)
BRepAlgo_AsDes.Ascendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Ascendant, None, BRepAlgo_AsDes)
BRepAlgo_AsDes.ChangeDescendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_ChangeDescendant, None, BRepAlgo_AsDes)
BRepAlgo_AsDes.Clear = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Clear, None, BRepAlgo_AsDes)
BRepAlgo_AsDes.Descendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Descendant, None, BRepAlgo_AsDes)
BRepAlgo_AsDes.HasAscendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_HasAscendant, None, BRepAlgo_AsDes)
BRepAlgo_AsDes.HasCommonDescendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_HasCommonDescendant, None, BRepAlgo_AsDes)
BRepAlgo_AsDes.HasDescendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_HasDescendant, None, BRepAlgo_AsDes)
BRepAlgo_AsDes.Remove = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Remove, None, BRepAlgo_AsDes)
BRepAlgo_AsDes.Replace = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Replace, None, BRepAlgo_AsDes)
BRepAlgo_AsDes_swigregister = _BRepAlgo.BRepAlgo_AsDes_swigregister
BRepAlgo_AsDes_swigregister(BRepAlgo_AsDes)

class BRepAlgo_BooleanOperation(OCC.Core.BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Builder(self, *args) -> "opencascade::handle< TopOpeBRepBuild_HBuilder >":
        """:rtype: opencascade::handle<TopOpeBRepBuild_HBuilder>"""
        return _BRepAlgo.BRepAlgo_BooleanOperation_Builder(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param St1:
        	:type St1: TopAbs_State
        	:param St2:
        	:type St2: TopAbs_State
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_Perform(self, *args)


    def PerformDS(self, *args) -> "void":
        """:rtype: None"""
        return _BRepAlgo.BRepAlgo_BooleanOperation_PerformDS(self, *args)


    def Shape1(self, *args) -> "TopoDS_Shape const":
        """
        * Returns the first shape involved in this Boolean operation.
        	:rtype: TopoDS_Shape
        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_Shape1(self, *args)


    def Shape2(self, *args) -> "TopoDS_Shape const":
        """
        * Returns the second shape involved in this Boolean operation.
        	:rtype: TopoDS_Shape
        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_Shape2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_BooleanOperation
BRepAlgo_BooleanOperation.Builder = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_Builder, None, BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation.Perform = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_Perform, None, BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation.PerformDS = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_PerformDS, None, BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation.Shape1 = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_Shape1, None, BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation.Shape2 = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_Shape2, None, BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation_swigregister = _BRepAlgo.BRepAlgo_BooleanOperation_swigregister
BRepAlgo_BooleanOperation_swigregister(BRepAlgo_BooleanOperation)

class BRepAlgo_FaceRestrictor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Add the wire <W> to the set of wires. //! Warning: The Wires must be closed. //! The edges of <W> can be modified if they have not pcurves on the surface <S> of <F>. In this case if <Proj> is false the first pcurve of the edge is positionned on <S>. if <Proj> is True ,the Pcurve On <S> is the projection of the curve 3d on <F>.
        	:param W:
        	:type W: TopoDS_Wire
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Add(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _BRepAlgo.BRepAlgo_FaceRestrictor_swiginit(self, _BRepAlgo.new_BRepAlgo_FaceRestrictor(*args))

    def Clear(self, *args) -> "void":
        """
        * Removes all the Wires
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Clear(self, *args)


    def Current(self, *args) -> "TopoDS_Face":
        """:rtype: TopoDS_Face"""
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Current(self, *args)


    def Init(self, *args) -> "void":
        """
        * the surface of <F> will be the the surface of each new faces built. <Proj> is used to update pcurves on edges if necessary. See Add().
        	:param F:
        	:type F: TopoDS_Face
        	:param Proj: default value is Standard_False
        	:type Proj: bool
        	:param ControlOrientation: default value is Standard_False
        	:type ControlOrientation: bool
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Init(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _BRepAlgo.BRepAlgo_FaceRestrictor_IsDone(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _BRepAlgo.BRepAlgo_FaceRestrictor_More(self, *args)


    def Next(self, *args) -> "void":
        """:rtype: None"""
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Next(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Evaluate all the faces limited by the set of Wires.
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_FaceRestrictor
BRepAlgo_FaceRestrictor.Add = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Add, None, BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Clear = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Clear, None, BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Current = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Current, None, BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Init = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Init, None, BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.IsDone = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_IsDone, None, BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.More = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_More, None, BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Next = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Next, None, BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Perform = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Perform, None, BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor_swigregister = _BRepAlgo.BRepAlgo_FaceRestrictor_swigregister
BRepAlgo_FaceRestrictor_swigregister(BRepAlgo_FaceRestrictor)

class BRepAlgo_Image(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Add <NewS> to the image of <OldS>.
        	:param OldS:
        	:type OldS: TopoDS_Shape
        	:param NewS:
        	:type NewS: TopoDS_Shape
        	:rtype: None
        * Add <NewS> to the image of <OldS>.
        	:param OldS:
        	:type OldS: TopoDS_Shape
        	:param NewS:
        	:type NewS: TopTools_ListOfShape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Image_Add(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _BRepAlgo.BRepAlgo_Image_swiginit(self, _BRepAlgo.new_BRepAlgo_Image(*args))

    def Bind(self, *args) -> "void":
        """
        * Links <NewS> as image of <OldS>.
        	:param OldS:
        	:type OldS: TopoDS_Shape
        	:param NewS:
        	:type NewS: TopoDS_Shape
        	:rtype: None
        * Links <NewS> as image of <OldS>.
        	:param OldS:
        	:type OldS: TopoDS_Shape
        	:param NewS:
        	:type NewS: TopTools_ListOfShape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Image_Bind(self, *args)


    def Clear(self, *args) -> "void":
        """:rtype: None"""
        return _BRepAlgo.BRepAlgo_Image_Clear(self, *args)


    def Compact(self, *args) -> "void":
        """
        * Keeps only the link between roots and lastimage.
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Image_Compact(self, *args)


    def Filter(self, *args) -> "void":
        """
        * Deletes in the images the shape of type <ShapeType> which are not in <S>. Warning: Compact() must be call before.
        	:param S:
        	:type S: TopoDS_Shape
        	:param ShapeType:
        	:type ShapeType: TopAbs_ShapeEnum
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Image_Filter(self, *args)


    def HasImage(self, *args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: bool
        """
        return _BRepAlgo.BRepAlgo_Image_HasImage(self, *args)


    def Image(self, *args) -> "TopTools_ListOfShape const &":
        """
        * Returns the Image of <S>. Returns <S> in the list if HasImage(S) is false.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopTools_ListOfShape
        """
        return _BRepAlgo.BRepAlgo_Image_Image(self, *args)


    def ImageFrom(self, *args) -> "TopoDS_Shape const":
        """
        * Returns the generator of <S>
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _BRepAlgo.BRepAlgo_Image_ImageFrom(self, *args)


    def IsImage(self, *args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: bool
        """
        return _BRepAlgo.BRepAlgo_Image_IsImage(self, *args)


    def LastImage(self, *args) -> "void":
        """
        * Stores in <L> the images of images of...images of <S>. <L> contains only <S> if HasImage(S) is false.
        	:param S:
        	:type S: TopoDS_Shape
        	:param L:
        	:type L: TopTools_ListOfShape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Image_LastImage(self, *args)


    def Remove(self, *args) -> "void":
        """
        * Remove <S> to set of images.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Image_Remove(self, *args)


    def Root(self, *args) -> "TopoDS_Shape const":
        """
        * Returns the upper generator of <S>
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _BRepAlgo.BRepAlgo_Image_Root(self, *args)


    def Roots(self, *args) -> "TopTools_ListOfShape const &":
        """:rtype: TopTools_ListOfShape"""
        return _BRepAlgo.BRepAlgo_Image_Roots(self, *args)


    def SetRoot(self, *args) -> "void":
        """
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Image_SetRoot(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Image
BRepAlgo_Image.Add = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Add, None, BRepAlgo_Image)
BRepAlgo_Image.Bind = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Bind, None, BRepAlgo_Image)
BRepAlgo_Image.Clear = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Clear, None, BRepAlgo_Image)
BRepAlgo_Image.Compact = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Compact, None, BRepAlgo_Image)
BRepAlgo_Image.Filter = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Filter, None, BRepAlgo_Image)
BRepAlgo_Image.HasImage = new_instancemethod(_BRepAlgo.BRepAlgo_Image_HasImage, None, BRepAlgo_Image)
BRepAlgo_Image.Image = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Image, None, BRepAlgo_Image)
BRepAlgo_Image.ImageFrom = new_instancemethod(_BRepAlgo.BRepAlgo_Image_ImageFrom, None, BRepAlgo_Image)
BRepAlgo_Image.IsImage = new_instancemethod(_BRepAlgo.BRepAlgo_Image_IsImage, None, BRepAlgo_Image)
BRepAlgo_Image.LastImage = new_instancemethod(_BRepAlgo.BRepAlgo_Image_LastImage, None, BRepAlgo_Image)
BRepAlgo_Image.Remove = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Remove, None, BRepAlgo_Image)
BRepAlgo_Image.Root = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Root, None, BRepAlgo_Image)
BRepAlgo_Image.Roots = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Roots, None, BRepAlgo_Image)
BRepAlgo_Image.SetRoot = new_instancemethod(_BRepAlgo.BRepAlgo_Image_SetRoot, None, BRepAlgo_Image)
BRepAlgo_Image_swigregister = _BRepAlgo.BRepAlgo_Image_swigregister
BRepAlgo_Image_swigregister(BRepAlgo_Image)

class BRepAlgo_Loop(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddConstEdge(self, *args) -> "void":
        """
        * Add <E> as const edge, E can be in the result.
        	:param E:
        	:type E: TopoDS_Edge
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Loop_AddConstEdge(self, *args)


    def AddConstEdges(self, *args) -> "void":
        """
        * Add <LE> as a set of const edges.
        	:param LE:
        	:type LE: TopTools_ListOfShape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Loop_AddConstEdges(self, *args)


    def AddEdge(self, *args) -> "void":
        """
        * Add E with <LV>. <E> will be copied and trim by vertices in <LV>.
        	:param E:
        	:type E: TopoDS_Edge
        	:param LV:
        	:type LV: TopTools_ListOfShape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Loop_AddEdge(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _BRepAlgo.BRepAlgo_Loop_swiginit(self, _BRepAlgo.new_BRepAlgo_Loop(*args))

    def CutEdge(self, *args) -> "void":
        """
        * Cut the edge <E> in several edges <NE> on the vertices<VonE>.
        	:param E:
        	:type E: TopoDS_Edge
        	:param VonE:
        	:type VonE: TopTools_ListOfShape
        	:param NE:
        	:type NE: TopTools_ListOfShape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Loop_CutEdge(self, *args)


    def GetVerticesForSubstitute(self, *args) -> "void":
        """
        * Returns the datamap of vertices with their substitutes.
        	:param VerVerMap:
        	:type VerVerMap: TopTools_DataMapOfShapeShape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Loop_GetVerticesForSubstitute(self, *args)


    def Init(self, *args) -> "void":
        """
        * Init with <F> the set of edges must have pcurves on <F>.
        	:param F:
        	:type F: TopoDS_Face
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Loop_Init(self, *args)


    def NewEdges(self, *args) -> "TopTools_ListOfShape const &":
        """
        * Returns the list of new edges built from an edge <E> it can be an empty list.
        	:param E:
        	:type E: TopoDS_Edge
        	:rtype: TopTools_ListOfShape
        """
        return _BRepAlgo.BRepAlgo_Loop_NewEdges(self, *args)


    def NewFaces(self, *args) -> "TopTools_ListOfShape const &":
        """
        * Returns the list of faces. Warning: The method <WiresToFaces> as to be called before. can be an empty list.
        	:rtype: TopTools_ListOfShape
        """
        return _BRepAlgo.BRepAlgo_Loop_NewFaces(self, *args)


    def NewWires(self, *args) -> "TopTools_ListOfShape const &":
        """
        * Returns the list of wires performed. can be an empty list.
        	:rtype: TopTools_ListOfShape
        """
        return _BRepAlgo.BRepAlgo_Loop_NewWires(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Make loops.
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Loop_Perform(self, *args)


    def VerticesForSubstitute(self, *args) -> "void":
        """
        :param VerVerMap:
        	:type VerVerMap: TopTools_DataMapOfShapeShape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Loop_VerticesForSubstitute(self, *args)


    def WiresToFaces(self, *args) -> "void":
        """
        * Build faces from the wires result.
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Loop_WiresToFaces(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Loop
BRepAlgo_Loop.AddConstEdge = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_AddConstEdge, None, BRepAlgo_Loop)
BRepAlgo_Loop.AddConstEdges = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_AddConstEdges, None, BRepAlgo_Loop)
BRepAlgo_Loop.AddEdge = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_AddEdge, None, BRepAlgo_Loop)
BRepAlgo_Loop.CutEdge = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_CutEdge, None, BRepAlgo_Loop)
BRepAlgo_Loop.GetVerticesForSubstitute = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_GetVerticesForSubstitute, None, BRepAlgo_Loop)
BRepAlgo_Loop.Init = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_Init, None, BRepAlgo_Loop)
BRepAlgo_Loop.NewEdges = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_NewEdges, None, BRepAlgo_Loop)
BRepAlgo_Loop.NewFaces = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_NewFaces, None, BRepAlgo_Loop)
BRepAlgo_Loop.NewWires = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_NewWires, None, BRepAlgo_Loop)
BRepAlgo_Loop.Perform = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_Perform, None, BRepAlgo_Loop)
BRepAlgo_Loop.VerticesForSubstitute = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_VerticesForSubstitute, None, BRepAlgo_Loop)
BRepAlgo_Loop.WiresToFaces = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_WiresToFaces, None, BRepAlgo_Loop)
BRepAlgo_Loop_swigregister = _BRepAlgo.BRepAlgo_Loop_swigregister
BRepAlgo_Loop_swigregister(BRepAlgo_Loop)

class BRepAlgo_NormalProjection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Add an edge or a wire to the list of shape to project
        	:param ToProj:
        	:type ToProj: TopoDS_Shape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Add(self, *args)


    def Ancestor(self, *args) -> "TopoDS_Shape const":
        """
        * For a resulting edge, returns the corresponding initial edge.
        	:param E:
        	:type E: TopoDS_Edge
        	:rtype: TopoDS_Shape
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Ancestor(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: None
        """
        _BRepAlgo.BRepAlgo_NormalProjection_swiginit(self, _BRepAlgo.new_BRepAlgo_NormalProjection(*args))

    def Build(self, *args) -> "void":
        """
        * Builds the result as a compound.
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Build(self, *args)


    def BuildWire(self, *args) -> "Standard_Boolean":
        """
        * build the result as a list of wire if possible in -- a first returns a wire only if there is only a wire.
        	:param Liste:
        	:type Liste: TopTools_ListOfShape
        	:rtype: bool
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_BuildWire(self, *args)


    def Compute3d(self, *args) -> "void":
        """
        * if With3d = Standard_False the 3dcurve is not computed the initial 3dcurve is kept to build the resulting edges.
        	:param With3d: default value is Standard_True
        	:type With3d: bool
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Compute3d(self, *args)


    def Couple(self, *args) -> "TopoDS_Shape const":
        """
        * For a projected edge, returns the corresponding initial face.
        	:param E:
        	:type E: TopoDS_Edge
        	:rtype: TopoDS_Shape
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Couple(self, *args)


    def Generated(self, *args) -> "TopTools_ListOfShape const &":
        """
        * Returns the list of shapes generated from the shape <S>.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopTools_ListOfShape
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Generated(self, *args)


    def Init(self, *args) -> "void":
        """
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Init(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _BRepAlgo.BRepAlgo_NormalProjection_IsDone(self, *args)


    def IsElementary(self, *args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: Adaptor3d_Curve
        	:rtype: bool
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_IsElementary(self, *args)


    def Projection(self, *args) -> "TopoDS_Shape const":
        """
        * returns the result
        	:rtype: TopoDS_Shape
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Projection(self, *args)


    def SetDefaultParams(self, *args) -> "void":
        """
        * Set the parameters used for computation in their default values
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetDefaultParams(self, *args)


    def SetLimit(self, *args) -> "void":
        """
        * Manage limitation of projected edges.
        	:param FaceBoundaries: default value is Standard_True
        	:type FaceBoundaries: bool
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetLimit(self, *args)


    def SetMaxDistance(self, *args) -> "void":
        """
        * Sets the maximum distance between target shape and shape to project. If this condition is not satisfied then corresponding part of solution is discarded. if MaxDist < 0 then this method does not affect the algorithm
        	:param MaxDist:
        	:type MaxDist: float
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetMaxDistance(self, *args)


    def SetParams(self, *args) -> "void":
        """
        * Set the parameters used for computation Tol3d is the requiered tolerance between the 3d projected curve and its 2d representation InternalContinuity is the order of constraints used for approximation. MaxDeg and MaxSeg are the maximum degree and the maximum number of segment for BSpline resulting of an approximation.
        	:param Tol3D:
        	:type Tol3D: float
        	:param Tol2D:
        	:type Tol2D: float
        	:param InternalContinuity:
        	:type InternalContinuity: GeomAbs_Shape
        	:param MaxDegree:
        	:type MaxDegree: int
        	:param MaxSeg:
        	:type MaxSeg: int
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetParams(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_NormalProjection
BRepAlgo_NormalProjection.Add = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Add, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Ancestor = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Ancestor, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Build = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Build, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.BuildWire = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_BuildWire, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Compute3d = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Compute3d, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Couple = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Couple, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Generated = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Generated, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Init = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Init, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.IsDone = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_IsDone, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.IsElementary = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_IsElementary, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Projection = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Projection, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.SetDefaultParams = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_SetDefaultParams, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.SetLimit = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_SetLimit, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.SetMaxDistance = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_SetMaxDistance, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.SetParams = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_SetParams, None, BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection_swigregister = _BRepAlgo.BRepAlgo_NormalProjection_swigregister
BRepAlgo_NormalProjection_swigregister(BRepAlgo_NormalProjection)

class BRepAlgo_Tool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Deboucle3D(*args) -> "TopoDS_Shape":
        """
        * Remove the non valid part of an offsetshape 1 - Remove all the free boundary and the faces connex to such edges. 2 - Remove all the shapes not valid in the result (according to the side of offseting) in this verion only the first point is implemented.
        	:param S:
        	:type S: TopoDS_Shape
        	:param Boundary:
        	:type Boundary: TopTools_MapOfShape
        	:rtype: TopoDS_Shape
        """
        return _BRepAlgo.BRepAlgo_Tool_Deboucle3D(*args)

    Deboucle3D = staticmethod(Deboucle3D)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepAlgo.BRepAlgo_Tool_swiginit(self, _BRepAlgo.new_BRepAlgo_Tool())
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Tool
BRepAlgo_Tool_swigregister = _BRepAlgo.BRepAlgo_Tool_swigregister
BRepAlgo_Tool_swigregister(BRepAlgo_Tool)

def BRepAlgo_Tool_Deboucle3D(*args) -> "TopoDS_Shape":
    """
    * Remove the non valid part of an offsetshape 1 - Remove all the free boundary and the faces connex to such edges. 2 - Remove all the shapes not valid in the result (according to the side of offseting) in this verion only the first point is implemented.
    	:param S:
    	:type S: TopoDS_Shape
    	:param Boundary:
    	:type Boundary: TopTools_MapOfShape
    	:rtype: TopoDS_Shape
    """
    return _BRepAlgo.BRepAlgo_Tool_Deboucle3D(*args)

class BRepAlgo_Common(BRepAlgo_BooleanOperation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs the common part of shapes S1 and S2.
        	:param S1:
        	:type S1: TopoDS_Shape
        	:param S2:
        	:type S2: TopoDS_Shape
        	:rtype: None
        """
        _BRepAlgo.BRepAlgo_Common_swiginit(self, _BRepAlgo.new_BRepAlgo_Common(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Common
BRepAlgo_Common_swigregister = _BRepAlgo.BRepAlgo_Common_swigregister
BRepAlgo_Common_swigregister(BRepAlgo_Common)

class BRepAlgo_Cut(BRepAlgo_BooleanOperation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Cuts the shape S2 from the shape S1.
        	:param S1:
        	:type S1: TopoDS_Shape
        	:param S2:
        	:type S2: TopoDS_Shape
        	:rtype: None
        """
        _BRepAlgo.BRepAlgo_Cut_swiginit(self, _BRepAlgo.new_BRepAlgo_Cut(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Cut
BRepAlgo_Cut_swigregister = _BRepAlgo.BRepAlgo_Cut_swigregister
BRepAlgo_Cut_swigregister(BRepAlgo_Cut)

class BRepAlgo_Fuse(BRepAlgo_BooleanOperation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Fuse S1 and S2.
        	:param S1:
        	:type S1: TopoDS_Shape
        	:param S2:
        	:type S2: TopoDS_Shape
        	:rtype: None
        """
        _BRepAlgo.BRepAlgo_Fuse_swiginit(self, _BRepAlgo.new_BRepAlgo_Fuse(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Fuse
BRepAlgo_Fuse_swigregister = _BRepAlgo.BRepAlgo_Fuse_swigregister
BRepAlgo_Fuse_swigregister(BRepAlgo_Fuse)

class BRepAlgo_Section(BRepAlgo_BooleanOperation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Approximation(self, *args) -> "void":
        """
        * Defines an option for computation of further intersections. This computation will be performed by the function Build in this framework. By default, the underlying 3D geometry attached to each elementary edge of the result of a computed intersection is: - analytic where possible, provided the corresponding geometry corresponds to a type of analytic curve defined in the Geom package; for example the intersection of a cylindrical shape with a plane gives an ellipse or a circle; - or elsewhere, given as a succession of points grouped together in a BSpline curve of degree 1. If Approx equals true, when further computations are performed in this framework with the function Build, these edges will have an attached 3D geometry which is a BSpline approximation of the computed set of points. Note that as a result, approximations will be computed on edges built only on new intersection lines.
        	:param B:
        	:type B: bool
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Section_Approximation(self, *args)


    def __init__(self, *args):
        """
        :param Sh1:
        	:type Sh1: TopoDS_Shape
        	:param Sh2:
        	:type Sh2: TopoDS_Shape
        	:param PerformNow: default value is Standard_True
        	:type PerformNow: bool
        	:rtype: None
        :param Sh:
        	:type Sh: TopoDS_Shape
        	:param Pl:
        	:type Pl: gp_Pln
        	:param PerformNow: default value is Standard_True
        	:type PerformNow: bool
        	:rtype: None
        :param Sh:
        	:type Sh: TopoDS_Shape
        	:param Sf:
        	:type Sf: Geom_Surface
        	:param PerformNow: default value is Standard_True
        	:type PerformNow: bool
        	:rtype: None
        :param Sf:
        	:type Sf: Geom_Surface
        	:param Sh:
        	:type Sh: TopoDS_Shape
        	:param PerformNow: default value is Standard_True
        	:type PerformNow: bool
        	:rtype: None
        * This and the above algorithms construct a framework for computing the section lines of - the two shapes Sh1 and Sh2, or - the shape Sh and the plane Pl, or - the shape Sh and the surface Sf, or - the surface Sf and the shape Sh, or - the two surfaces Sf1 and Sf2, and builds the result if PerformNow equals true, its default value. If PerformNow equals false, the intersection will be computed later by the function Build. The constructed shape will be returned by the function Shape. This is a compound object composed of edges. These intersection edges may be built: - on new intersection lines, or - on coincident portions of edges in the two intersected shapes. These intersection edges are independent: they are not chained or grouped in wires. If no intersection edge exists, the result is an empty compound object. Note that other objects than TopoDS_Shape shapes involved in these syntaxes are converted into faces or shells before performing the computation of the intersection. A shape resulting from this conversion can be retrieved with the function Shape1 or Shape2. Parametric 2D curves on intersection edges No parametric 2D curve (pcurve) is defined for each elementary edge of the result. To attach such parametric curves to the constructed edges you may use a constructor with the PerformNow flag equal to false; then you use: - the function ComputePCurveOn1 to ask for the additional computation of a pcurve in the parametric space of the first shape, - the function ComputePCurveOn2 to ask for the additional computation of a pcurve in the parametric space of the second shape, - in the end, the function Build to construct the result. Note that as a result, pcurves will only be added on edges built on new intersection lines. Approximation of intersection edges The underlying 3D geometry attached to each elementary edge of the result is: - analytic where possible, provided the corresponding geometry corresponds to a type of analytic curve defined in the Geom package; for example, the intersection of a cylindrical shape with a plane gives an ellipse or a circle; - or elsewhere, given as a succession of points grouped together in a BSpline curve of degree 1. If you prefer to have an attached 3D geometry which is a BSpline approximation of the computed set of points on computed elementary intersection edges whose underlying geometry is not analytic, you may use a constructor with the PerformNow flag equal to false. Then you use: - the function Approximation to ask for this computation option, and - the function Build to construct the result. Note that as a result, approximations will only be computed on edges built on new intersection lines. Example You may also combine these computation options. In the following example: - each elementary edge of the computed intersection, built on a new intersection line, which does not correspond to an analytic Geom curve, will be approximated by a BSpline curve whose degree is not greater than 8. - each elementary edge built on a new intersection line, will have: - a pcurve in the parametric space of the shape S1, - no pcurve in the parametric space of the shape S2. // TopoDS_Shape S1 = ... , S2 = ... ; Standard_Boolean PerformNow = Standard_False; BRepAlgo_Section S ( S1, S2, PerformNow ); S.ComputePCurveOn1 (Standard_True); S.Approximation (Standard_True); S.Build(); TopoDS_Shape R = S.Shape();
        	:param Sf1:
        	:type Sf1: Geom_Surface
        	:param Sf2:
        	:type Sf2: Geom_Surface
        	:param PerformNow: default value is Standard_True
        	:type PerformNow: bool
        	:rtype: None
        """
        _BRepAlgo.BRepAlgo_Section_swiginit(self, _BRepAlgo.new_BRepAlgo_Section(*args))

    def ComputePCurveOn1(self, *args) -> "void":
        """
        * Indicates if the Pcurve must be (or not) performed on first part.
        	:param B:
        	:type B: bool
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Section_ComputePCurveOn1(self, *args)


    def ComputePCurveOn2(self, *args) -> "void":
        """
        * Define options for the computation of further intersections which will be performed by the function Build in this framework. By default, no parametric 2D curve (pcurve) is defined for the elementary edges of the result. If ComputePCurve1 equals true, further computations performed in this framework with the function Build will attach an additional pcurve in the parametric space of the first shape to the constructed edges. If ComputePCurve2 equals true, the additional pcurve will be attached to the constructed edges in the parametric space of the second shape. These two functions may be used together. Note that as a result, pcurves will only be added onto edges built on new intersection lines.
        	:param B:
        	:type B: bool
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Section_ComputePCurveOn2(self, *args)


    def HasAncestorFaceOn1(self, *args) -> "Standard_Boolean":
        """
        * Identifies the ancestor faces of the new intersection edge E resulting from the last computation performed in this framework, that is, the faces of the two original shapes on which the edge E lies: - HasAncestorFaceOn1 gives the ancestor face in the first shape, and These functions return: - true if an ancestor face F is found, or - false if not. An ancestor face is identifiable for the edge E if the three following conditions are satisfied: - the first part on which this algorithm performed its last computation is a shape, that is, it was not given as a surface or a plane at the time of construction of this algorithm or at a later time by the Init1 function, - E is one of the elementary edges built by the last computation of this section algorithm, - the edge E is built on an intersection curve. In other words, E is a new edge built on the intersection curve, not on edges belonging to the intersecting shapes. To use these functions properly, you have to test the returned Boolean value before using the ancestor face: F is significant only if the returned Boolean value equals true.
        	:param E:
        	:type E: TopoDS_Shape
        	:param F:
        	:type F: TopoDS_Shape
        	:rtype: bool
        """
        return _BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn1(self, *args)


    def HasAncestorFaceOn2(self, *args) -> "Standard_Boolean":
        """
        * Identifies the ancestor faces of the new intersection edge E resulting from the last computation performed in this framework, that is, the faces of the two original shapes on which the edge E lies: - HasAncestorFaceOn2 gives the ancestor face in the second shape. These functions return: - true if an ancestor face F is found, or - false if not. An ancestor face is identifiable for the edge E if the three following conditions are satisfied: - the first part on which this algorithm performed its last computation is a shape, that is, it was not given as a surface or a plane at the time of construction of this algorithm or at a later time by the Init1 function, - E is one of the elementary edges built by the last computation of this section algorithm, - the edge E is built on an intersection curve. In other words, E is a new edge built on the intersection curve, not on edges belonging to the intersecting shapes. To use these functions properly, you have to test the returned Boolean value before using the ancestor face: F is significant only if the returned Boolean value equals true.
        	:param E:
        	:type E: TopoDS_Shape
        	:param F:
        	:type F: TopoDS_Shape
        	:rtype: bool
        """
        return _BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn2(self, *args)


    def Init1(self, *args) -> "void":
        """
        * Initializes the first part
        	:param S1:
        	:type S1: TopoDS_Shape
        	:rtype: None
        * Initializes the first part
        	:param Pl:
        	:type Pl: gp_Pln
        	:rtype: None
        * Initializes the first part
        	:param Sf:
        	:type Sf: Geom_Surface
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Section_Init1(self, *args)


    def Init2(self, *args) -> "void":
        """
        * initialize second part
        	:param S2:
        	:type S2: TopoDS_Shape
        	:rtype: None
        * Initializes the second part
        	:param Pl:
        	:type Pl: gp_Pln
        	:rtype: None
        * This and the above algorithms reinitialize the first and the second parts on which this algorithm is going to perform the intersection computation. This is done with either: the surface Sf, the plane Pl or the shape Sh. You use the function Build to construct the result.
        	:param Sf:
        	:type Sf: Geom_Surface
        	:rtype: None
        """
        return _BRepAlgo.BRepAlgo_Section_Init2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Section
BRepAlgo_Section.Approximation = new_instancemethod(_BRepAlgo.BRepAlgo_Section_Approximation, None, BRepAlgo_Section)
BRepAlgo_Section.ComputePCurveOn1 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_ComputePCurveOn1, None, BRepAlgo_Section)
BRepAlgo_Section.ComputePCurveOn2 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_ComputePCurveOn2, None, BRepAlgo_Section)
BRepAlgo_Section.HasAncestorFaceOn1 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn1, None, BRepAlgo_Section)
BRepAlgo_Section.HasAncestorFaceOn2 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn2, None, BRepAlgo_Section)
BRepAlgo_Section.Init1 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_Init1, None, BRepAlgo_Section)
BRepAlgo_Section.Init2 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_Init2, None, BRepAlgo_Section)
BRepAlgo_Section_swigregister = _BRepAlgo.BRepAlgo_Section_swigregister
BRepAlgo_Section_swigregister(BRepAlgo_Section)



