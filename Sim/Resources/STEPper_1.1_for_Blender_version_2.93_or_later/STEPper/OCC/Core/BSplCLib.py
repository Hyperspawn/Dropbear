# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BSplCLib module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_bsplclib.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BSplCLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BSplCLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BSplCLib')
    _BSplCLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BSplCLib', [dirname(__file__)])
        except ImportError:
            import _BSplCLib
            return _BSplCLib
        try:
            _mod = imp.load_module('_BSplCLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BSplCLib = swig_import_helper()
    del swig_import_helper
else:
    import _BSplCLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BSplCLib.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BSplCLib.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BSplCLib.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BSplCLib.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BSplCLib.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BSplCLib.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BSplCLib.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BSplCLib.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BSplCLib.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BSplCLib.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BSplCLib.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BSplCLib.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BSplCLib.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BSplCLib.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BSplCLib.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BSplCLib.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BSplCLib.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BSplCLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _BSplCLib.process_exception(error, method_name, class_name)
process_exception = _BSplCLib.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.gp
import OCC.Core.TColgp
import OCC.Core.GeomAbs
BSplCLib_NonConstant = _BSplCLib.BSplCLib_NonConstant
BSplCLib_Constant = _BSplCLib.BSplCLib_Constant
BSplCLib_QuasiConstant = _BSplCLib.BSplCLib_QuasiConstant
BSplCLib_NonUniform = _BSplCLib.BSplCLib_NonUniform
BSplCLib_Uniform = _BSplCLib.BSplCLib_Uniform

def Handle_BSplCLib_Cache_Create() -> "opencascade::handle< BSplCLib_Cache >":
    return _BSplCLib.Handle_BSplCLib_Cache_Create()
Handle_BSplCLib_Cache_Create = _BSplCLib.Handle_BSplCLib_Cache_Create

def Handle_BSplCLib_Cache_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< BSplCLib_Cache >":
    return _BSplCLib.Handle_BSplCLib_Cache_DownCast(t)
Handle_BSplCLib_Cache_DownCast = _BSplCLib.Handle_BSplCLib_Cache_DownCast

def Handle_BSplCLib_Cache_IsNull(t: 'opencascade::handle< BSplCLib_Cache > const &') -> "bool":
    return _BSplCLib.Handle_BSplCLib_Cache_IsNull(t)
Handle_BSplCLib_Cache_IsNull = _BSplCLib.Handle_BSplCLib_Cache_IsNull
class bsplclib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AntiBoorScheme(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Compute the content of Pole before the BoorScheme. This method is used to remove poles. //! U is the poles to remove, Knots should contains the knots of the curve after knot removal. //! The first and last poles do not change, the other poles are computed by averaging two possible values. The distance between the two possible poles is computed, if it is higher than <Tolerance> False is returned.
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param Knots:
        	:type Knots: float
        	:param Dimension:
        	:type Dimension: int
        	:param Poles:
        	:type Poles: float
        	:param Depth:
        	:type Depth: int
        	:param Length:
        	:type Length: int
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: bool
        """
        return _BSplCLib.bsplclib_AntiBoorScheme(*args)

    AntiBoorScheme = staticmethod(AntiBoorScheme)

    def Bohm(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Performs the Bohm Algorithm at parameter <U>. This algorithm computes the value and all the derivatives up to order N (N <= Degree). //! <Poles> is the original array of poles. //! The result in <Poles> is the value and the derivatives. Poles[0] is the value, Poles[Degree] is the last derivative.
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param N:
        	:type N: int
        	:param Knots:
        	:type Knots: float
        	:param Dimension:
        	:type Dimension: int
        	:param Poles:
        	:type Poles: float
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Bohm(*args)

    Bohm = staticmethod(Bohm)

    def BoorIndex(*args) -> "Standard_Integer":
        """
        * Returns the index in the Boor result array of the poles <Index>. If the Boor algorithm was perform with <Length> and <Depth>.
        	:param Index:
        	:type Index: int
        	:param Length:
        	:type Length: int
        	:param Depth:
        	:type Depth: int
        	:rtype: int
        """
        return _BSplCLib.bsplclib_BoorIndex(*args)

    BoorIndex = staticmethod(BoorIndex)

    def BoorScheme(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Performs the Boor Algorithm at parameter <U> with the given <Degree> and the array of <Knots> on the poles <Poles> of dimension <Dimension>. The schema is computed until level <Depth> on a basis of <Length+1> poles. //! * Knots is an array of reals of length : //! <Length> + <Degree> //! * Poles is an array of reals of length : //! (2 * <Length> + 1) * <Dimension> //! The poles values must be set in the array at the positions. //! 0..Dimension, //! 2 * Dimension .. 3 * Dimension //! 4 * Dimension .. 5 * Dimension //! ... //! The results are found in the array poles depending on the Depth. (See the method GetPole).
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param Knots:
        	:type Knots: float
        	:param Dimension:
        	:type Dimension: int
        	:param Poles:
        	:type Poles: float
        	:param Depth:
        	:type Depth: int
        	:param Length:
        	:type Length: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_BoorScheme(*args)

    BoorScheme = staticmethod(BoorScheme)

    def BuildBSpMatrix(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * This Builds a fully blown Matrix of (ni) Bi (tj) //! with i and j within 1..Order + NumPoles The integer ni is the ith slot of the array OrderArray, tj is the jth slot of the array Parameters
        	:param Parameters:
        	:type Parameters: TColStd_Array1OfReal
        	:param OrderArray:
        	:type OrderArray: TColStd_Array1OfInteger
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Degree:
        	:type Degree: int
        	:param Matrix:
        	:type Matrix: math_Matrix
        	:param UpperBandWidth:
        	:type UpperBandWidth: int
        	:param LowerBandWidth:
        	:type LowerBandWidth: int
        	:rtype: int
        """
        return _BSplCLib.bsplclib_BuildBSpMatrix(*args)

    BuildBSpMatrix = staticmethod(BuildBSpMatrix)

    def BuildBoor(*args) -> "Standard_Real &":
        """
        * Copy in <LP> poles for <Dimension> Boor scheme. Starting from <Index> * <Dimension>, copy <Length+1> poles.
        	:param Index:
        	:type Index: int
        	:param Length:
        	:type Length: int
        	:param Dimension:
        	:type Dimension: int
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param LP:
        	:type LP: float
        	:rtype: void
        """
        return _BSplCLib.bsplclib_BuildBoor(*args)

    BuildBoor = staticmethod(BuildBoor)

    def BuildCache(*args) -> "void":
        """
        * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles
        	:param U:
        	:type U: float
        	:param InverseOfSpanDomain:
        	:type InverseOfSpanDomain: float
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param CachePoles:
        	:type CachePoles: TColgp_Array1OfPnt
        	:param CacheWeights:
        	:type CacheWeights: TColStd_Array1OfReal *
        	:rtype: void
        * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles
        	:param U:
        	:type U: float
        	:param InverseOfSpanDomain:
        	:type InverseOfSpanDomain: float
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param CachePoles:
        	:type CachePoles: TColgp_Array1OfPnt2d
        	:param CacheWeights:
        	:type CacheWeights: TColStd_Array1OfReal *
        	:rtype: void
        * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. Structure of result optimized for BSplCLib_Cache.
        	:param theParameter:
        	:type theParameter: float
        	:param theSpanDomain:
        	:type theSpanDomain: float
        	:param thePeriodicFlag:
        	:type thePeriodicFlag: bool
        	:param theDegree:
        	:type theDegree: int
        	:param theSpanIndex:
        	:type theSpanIndex: int
        	:param theFlatKnots:
        	:type theFlatKnots: TColStd_Array1OfReal
        	:param thePoles:
        	:type thePoles: TColgp_Array1OfPnt
        	:param theWeights:
        	:type theWeights: TColStd_Array1OfReal *
        	:param theCacheArray:
        	:type theCacheArray: TColStd_Array2OfReal
        	:rtype: void
        * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. Structure of result optimized for BSplCLib_Cache.
        	:param theParameter:
        	:type theParameter: float
        	:param theSpanDomain:
        	:type theSpanDomain: float
        	:param thePeriodicFlag:
        	:type thePeriodicFlag: bool
        	:param theDegree:
        	:type theDegree: int
        	:param theSpanIndex:
        	:type theSpanIndex: int
        	:param theFlatKnots:
        	:type theFlatKnots: TColStd_Array1OfReal
        	:param thePoles:
        	:type thePoles: TColgp_Array1OfPnt2d
        	:param theWeights:
        	:type theWeights: TColStd_Array1OfReal *
        	:param theCacheArray:
        	:type theCacheArray: TColStd_Array2OfReal
        	:rtype: void
        """
        return _BSplCLib.bsplclib_BuildCache(*args)

    BuildCache = staticmethod(BuildCache)

    def BuildEval(*args) -> "Standard_Real &":
        """
        :param Degree:
        	:type Degree: int
        	:param Index:
        	:type Index: int
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param LP:
        	:type LP: float
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param Index:
        	:type Index: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param LP:
        	:type LP: float
        	:rtype: void
        * Copy in <LP> the poles and weights for the Eval scheme. starting from Poles(Poles.Lower()+Index)
        	:param Degree:
        	:type Degree: int
        	:param Index:
        	:type Index: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param LP:
        	:type LP: float
        	:rtype: void
        """
        return _BSplCLib.bsplclib_BuildEval(*args)

    BuildEval = staticmethod(BuildEval)

    def BuildKnots(*args) -> "Standard_Real &":
        """
        * Stores in LK the usefull knots for the BoorSchem on the span Knots(Index) - Knots(Index+1)
        	:param Degree:
        	:type Degree: int
        	:param Index:
        	:type Index: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param LK:
        	:type LK: float
        	:rtype: void
        """
        return _BSplCLib.bsplclib_BuildKnots(*args)

    BuildKnots = staticmethod(BuildKnots)

    def BuildSchoenbergPoints(*args) -> "void":
        """
        * builds the Schoenberg points from the flat knot used to interpolate a BSpline since the BSpline matrix is invertible.
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Parameters:
        	:type Parameters: TColStd_Array1OfReal
        	:rtype: void
        """
        return _BSplCLib.bsplclib_BuildSchoenbergPoints(*args)

    BuildSchoenbergPoints = staticmethod(BuildSchoenbergPoints)

    def CacheD0(*args) -> "void":
        """
        * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param CacheParameter:
        	:type CacheParameter: float
        	:param SpanLenght:
        	:type SpanLenght: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt
        	:rtype: void
        * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param CacheParameter:
        	:type CacheParameter: float
        	:param SpanLenght:
        	:type SpanLenght: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt2d
        	:rtype: void
        """
        return _BSplCLib.bsplclib_CacheD0(*args)

    CacheD0 = staticmethod(CacheD0)

    def CacheD1(*args) -> "void":
        """
        * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param CacheParameter:
        	:type CacheParameter: float
        	:param SpanLenght:
        	:type SpanLenght: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt
        	:param Vec:
        	:type Vec: gp_Vec
        	:rtype: void
        * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param CacheParameter:
        	:type CacheParameter: float
        	:param SpanLenght:
        	:type SpanLenght: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Vec:
        	:type Vec: gp_Vec2d
        	:rtype: void
        """
        return _BSplCLib.bsplclib_CacheD1(*args)

    CacheD1 = staticmethod(CacheD1)

    def CacheD2(*args) -> "void":
        """
        * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param CacheParameter:
        	:type CacheParameter: float
        	:param SpanLenght:
        	:type SpanLenght: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt
        	:param Vec1:
        	:type Vec1: gp_Vec
        	:param Vec2:
        	:type Vec2: gp_Vec
        	:rtype: void
        * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param CacheParameter:
        	:type CacheParameter: float
        	:param SpanLenght:
        	:type SpanLenght: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Vec1:
        	:type Vec1: gp_Vec2d
        	:param Vec2:
        	:type Vec2: gp_Vec2d
        	:rtype: void
        """
        return _BSplCLib.bsplclib_CacheD2(*args)

    CacheD2 = staticmethod(CacheD2)

    def CacheD3(*args) -> "void":
        """
        * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param CacheParameter:
        	:type CacheParameter: float
        	:param SpanLenght:
        	:type SpanLenght: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt
        	:param Vec1:
        	:type Vec1: gp_Vec
        	:param Vec2:
        	:type Vec2: gp_Vec
        	:param Vec3:
        	:type Vec3: gp_Vec
        	:rtype: void
        * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param CacheParameter:
        	:type CacheParameter: float
        	:param SpanLenght:
        	:type SpanLenght: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Vec1:
        	:type Vec1: gp_Vec2d
        	:param Vec2:
        	:type Vec2: gp_Vec2d
        	:param Vec3:
        	:type Vec3: gp_Vec2d
        	:rtype: void
        """
        return _BSplCLib.bsplclib_CacheD3(*args)

    CacheD3 = staticmethod(CacheD3)

    def CoefsD0(*args) -> "void":
        """
        * Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
        	:param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt
        	:rtype: None
        * Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
        	:param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt2d
        	:rtype: None
        """
        return _BSplCLib.bsplclib_CoefsD0(*args)

    CoefsD0 = staticmethod(CoefsD0)

    def CoefsD1(*args) -> "void":
        """
        * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
        	:param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt
        	:param Vec:
        	:type Vec: gp_Vec
        	:rtype: None
        * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
        	:param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Vec:
        	:type Vec: gp_Vec2d
        	:rtype: None
        """
        return _BSplCLib.bsplclib_CoefsD1(*args)

    CoefsD1 = staticmethod(CoefsD1)

    def CoefsD2(*args) -> "void":
        """
        * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
        	:param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt
        	:param Vec1:
        	:type Vec1: gp_Vec
        	:param Vec2:
        	:type Vec2: gp_Vec
        	:rtype: None
        * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
        	:param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Vec1:
        	:type Vec1: gp_Vec2d
        	:param Vec2:
        	:type Vec2: gp_Vec2d
        	:rtype: None
        """
        return _BSplCLib.bsplclib_CoefsD2(*args)

    CoefsD2 = staticmethod(CoefsD2)

    def CoefsD3(*args) -> "void":
        """
        * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
        	:param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt
        	:param Vec1:
        	:type Vec1: gp_Vec
        	:param Vec2:
        	:type Vec2: gp_Vec
        	:param Vec3:
        	:type Vec3: gp_Vec
        	:rtype: None
        * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
        	:param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Vec1:
        	:type Vec1: gp_Vec2d
        	:param Vec2:
        	:type Vec2: gp_Vec2d
        	:param Vec3:
        	:type Vec3: gp_Vec2d
        	:rtype: None
        """
        return _BSplCLib.bsplclib_CoefsD3(*args)

    CoefsD3 = staticmethod(CoefsD3)

    def D0(*args) -> "void":
        """
        :param U:
        	:type U: float
        	:param Index:
        	:type Index: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: float
        	:rtype: void
        :param U:
        	:type U: float
        	:param Index:
        	:type Index: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: gp_Pnt
        	:rtype: void
        :param U:
        	:type U: float
        	:param UIndex:
        	:type UIndex: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: void
        :param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param P:
        	:type P: gp_Pnt
        	:rtype: void
        :param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: void
        """
        return _BSplCLib.bsplclib_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args) -> "void":
        """
        :param U:
        	:type U: float
        	:param Index:
        	:type Index: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: float
        	:param V:
        	:type V: float
        	:rtype: void
        :param U:
        	:type U: float
        	:param Index:
        	:type Index: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Vec
        	:rtype: void
        :param U:
        	:type U: float
        	:param UIndex:
        	:type UIndex: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: void
        :param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Vec
        	:rtype: void
        :param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: void
        """
        return _BSplCLib.bsplclib_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        :param U:
        	:type U: float
        	:param Index:
        	:type Index: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: float
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:rtype: void
        :param U:
        	:type U: float
        	:param Index:
        	:type Index: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: void
        :param U:
        	:type U: float
        	:param UIndex:
        	:type UIndex: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:rtype: void
        :param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: void
        :param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:rtype: void
        """
        return _BSplCLib.bsplclib_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        :param U:
        	:type U: float
        	:param Index:
        	:type Index: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: float
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:param V3:
        	:type V3: float
        	:rtype: void
        :param U:
        	:type U: float
        	:param Index:
        	:type Index: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:param V3:
        	:type V3: gp_Vec
        	:rtype: void
        :param U:
        	:type U: float
        	:param UIndex:
        	:type UIndex: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:param V3:
        	:type V3: gp_Vec2d
        	:rtype: void
        :param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:param V3:
        	:type V3: gp_Vec
        	:rtype: void
        :param U:
        	:type U: float
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:param V3:
        	:type V3: gp_Vec2d
        	:rtype: void
        """
        return _BSplCLib.bsplclib_D3(*args)

    D3 = staticmethod(D3)

    def Derivative(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Computes the poles of the BSpline giving the derivatives of order <Order>. //! The formula for the first order is //! Pole(i) = Degree * (Pole(i+1) - Pole(i)) / (Knots(i+Degree+1) - Knots(i+1)) //! This formula is repeated (Degree is decremented at each step).
        	:param Degree:
        	:type Degree: int
        	:param Knots:
        	:type Knots: float
        	:param Dimension:
        	:type Dimension: int
        	:param Length:
        	:type Length: int
        	:param Order:
        	:type Order: int
        	:param Poles:
        	:type Poles: float
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Derivative(*args)

    Derivative = staticmethod(Derivative)

    def Eval(*args) -> "Standard_Integer &, Standard_Real &":
        """
        * Perform the Boor algorithm to evaluate a point at parameter <U>, with <Degree> and <Dimension>. //! Poles is an array of Reals of size //! <Dimension> * <Degree>+1 //! Containing the poles. At the end <Poles> contains the current point.
        	:param U:
        	:type U: float
        	:param Degree:
        	:type Degree: int
        	:param Knots:
        	:type Knots: float
        	:param Dimension:
        	:type Dimension: int
        	:param Poles:
        	:type Poles: float
        	:rtype: void
        * Perform the De Boor algorithm to evaluate a point at parameter <U>, with <Degree> and <Dimension>. //! Poles is an array of Reals of size //! <Dimension> * <Degree>+1 //! Containing the poles. At the end <Poles> contains the current point. Poles Contain all the poles of the BsplineCurve, Knots also Contains all the knots of the BsplineCurve. ExtrapMode has two slots [0] = Degree used to extrapolate before the first knot [1] = Degre used to extrapolate after the last knot has to be between 1 and Degree
        	:param U:
        	:type U: float
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param DerivativeRequest:
        	:type DerivativeRequest: int
        	:param ExtrapMode:
        	:type ExtrapMode: int
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param ArrayDimension:
        	:type ArrayDimension: int
        	:param Poles:
        	:type Poles: float
        	:param Result:
        	:type Result: float
        	:rtype: void
        * Perform the De Boor algorithm to evaluate a point at parameter <U>, with <Degree> and <Dimension>. Evaluates by multiplying the Poles by the Weights and gives the homogeneous result in PolesResult that is the results of the evaluation of the numerator once it has been multiplied by the weights and in WeightsResult one has the result of the evaluation of the denominator //! Warning: <PolesResult> and <WeightsResult> must be dimensionned properly.
        	:param U:
        	:type U: float
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param DerivativeRequest:
        	:type DerivativeRequest: int
        	:param ExtrapMode:
        	:type ExtrapMode: int
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param ArrayDimension:
        	:type ArrayDimension: int
        	:param Poles:
        	:type Poles: float
        	:param Weights:
        	:type Weights: float
        	:param PolesResult:
        	:type PolesResult: float
        	:param WeightsResult:
        	:type WeightsResult: float
        	:rtype: void
        * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point
        	:param U:
        	:type U: float
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param HomogeneousFlag:
        	:type HomogeneousFlag: bool
        	:param ExtrapMode:
        	:type ExtrapMode: int
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param Point:
        	:type Point: gp_Pnt
        	:param Weight:
        	:type Weight: float
        	:rtype: void
        * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point
        	:param U:
        	:type U: float
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param HomogeneousFlag:
        	:type HomogeneousFlag: bool
        	:param ExtrapMode:
        	:type ExtrapMode: int
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param Point:
        	:type Point: gp_Pnt2d
        	:param Weight:
        	:type Weight: float
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Eval(*args)

    Eval = staticmethod(Eval)

    def EvalBsplineBasis(*args) -> "Standard_Integer &":
        """
        * This evaluates the Bspline Basis at a given parameter Parameter up to the requested DerivativeOrder and store the result in the array BsplineBasis in the following fashion BSplineBasis(1,1) = value of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BsplineBasis(1,2) = value of second non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + 1 BsplineBasis(1,n) = value of second non vanishing non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + n (n <= Order) BSplineBasis(2,1) = value of derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BSplineBasis(N,1) = value of Nth derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex if N <= DerivativeOrder + 1
        	:param DerivativeOrder:
        	:type DerivativeOrder: int
        	:param Order:
        	:type Order: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Parameter:
        	:type Parameter: float
        	:param FirstNonZeroBsplineIndex:
        	:type FirstNonZeroBsplineIndex: int
        	:param BsplineBasis:
        	:type BsplineBasis: math_Matrix
        	:param isPeriodic: default value is Standard_False
        	:type isPeriodic: bool
        	:rtype: int
        """
        return _BSplCLib.bsplclib_EvalBsplineBasis(*args)

    EvalBsplineBasis = staticmethod(EvalBsplineBasis)

    def FactorBandedMatrix(*args) -> "Standard_Integer &":
        """
        * this factors the Banded Matrix in the LU form with a Banded storage of components of the L matrix WARNING : do not use if the Matrix is totally positive (It is the case for Bspline matrices build as above with parameters being the Schoenberg points
        	:param Matrix:
        	:type Matrix: math_Matrix
        	:param UpperBandWidth:
        	:type UpperBandWidth: int
        	:param LowerBandWidth:
        	:type LowerBandWidth: int
        	:param PivotIndexProblem:
        	:type PivotIndexProblem: int
        	:rtype: int
        """
        return _BSplCLib.bsplclib_FactorBandedMatrix(*args)

    FactorBandedMatrix = staticmethod(FactorBandedMatrix)

    def FirstUKnotIndex(*args) -> "Standard_Integer":
        """
        * Computes the index of the knots value which gives the start point of the curve.
        	:param Degree:
        	:type Degree: int
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: int
        """
        return _BSplCLib.bsplclib_FirstUKnotIndex(*args)

    FirstUKnotIndex = staticmethod(FirstUKnotIndex)

    def FlatBezierKnots(*args) -> "Standard_Real const &":
        """
        * Returns pointer to statically allocated array representing flat knots for bezier curve of the specified degree. Raises OutOfRange if Degree > MaxDegree()
        	:param Degree:
        	:type Degree: int
        	:rtype: float
        """
        return _BSplCLib.bsplclib_FlatBezierKnots(*args)

    FlatBezierKnots = staticmethod(FlatBezierKnots)

    def FlatIndex(*args) -> "Standard_Integer":
        """
        * Computes the index of the flats knots sequence corresponding to <Index> in the knots sequence which multiplicities are <Mults>.
        	:param Degree:
        	:type Degree: int
        	:param Index:
        	:type Index: int
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Periodic:
        	:type Periodic: bool
        	:rtype: int
        """
        return _BSplCLib.bsplclib_FlatIndex(*args)

    FlatIndex = staticmethod(FlatIndex)

    def FunctionMultiply(*args) -> "Standard_Integer &":
        """
        * this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)
        	:param Function:
        	:type Function: BSplCLib_EvaluatorFunction
        	:param BSplineDegree:
        	:type BSplineDegree: int
        	:param BSplineFlatKnots:
        	:type BSplineFlatKnots: TColStd_Array1OfReal
        	:param PolesDimension:
        	:type PolesDimension: int
        	:param Poles:
        	:type Poles: float
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewDegree:
        	:type NewDegree: int
        	:param NewPoles:
        	:type NewPoles: float
        	:param theStatus:
        	:type theStatus: int
        	:rtype: void
        * this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)
        	:param Function:
        	:type Function: BSplCLib_EvaluatorFunction
        	:param BSplineDegree:
        	:type BSplineDegree: int
        	:param BSplineFlatKnots:
        	:type BSplineFlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewDegree:
        	:type NewDegree: int
        	:param NewPoles:
        	:type NewPoles: TColStd_Array1OfReal
        	:param theStatus:
        	:type theStatus: int
        	:rtype: void
        * this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)
        	:param Function:
        	:type Function: BSplCLib_EvaluatorFunction
        	:param BSplineDegree:
        	:type BSplineDegree: int
        	:param BSplineFlatKnots:
        	:type BSplineFlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewDegree:
        	:type NewDegree: int
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param theStatus:
        	:type theStatus: int
        	:rtype: void
        * this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)
        	:param Function:
        	:type Function: BSplCLib_EvaluatorFunction
        	:param BSplineDegree:
        	:type BSplineDegree: int
        	:param BSplineFlatKnots:
        	:type BSplineFlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewDegree:
        	:type NewDegree: int
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param theStatus:
        	:type theStatus: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_FunctionMultiply(*args)

    FunctionMultiply = staticmethod(FunctionMultiply)

    def FunctionReparameterise(*args) -> "Standard_Integer &":
        """
        * This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following: //! 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots //! 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) //! Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method //! theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))
        	:param Function:
        	:type Function: BSplCLib_EvaluatorFunction
        	:param BSplineDegree:
        	:type BSplineDegree: int
        	:param BSplineFlatKnots:
        	:type BSplineFlatKnots: TColStd_Array1OfReal
        	:param PolesDimension:
        	:type PolesDimension: int
        	:param Poles:
        	:type Poles: float
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewDegree:
        	:type NewDegree: int
        	:param NewPoles:
        	:type NewPoles: float
        	:param theStatus:
        	:type theStatus: int
        	:rtype: void
        * This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following: //! 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots //! 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) //! Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method //! theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))
        	:param Function:
        	:type Function: BSplCLib_EvaluatorFunction
        	:param BSplineDegree:
        	:type BSplineDegree: int
        	:param BSplineFlatKnots:
        	:type BSplineFlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewDegree:
        	:type NewDegree: int
        	:param NewPoles:
        	:type NewPoles: TColStd_Array1OfReal
        	:param theStatus:
        	:type theStatus: int
        	:rtype: void
        * this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))
        	:param Function:
        	:type Function: BSplCLib_EvaluatorFunction
        	:param BSplineDegree:
        	:type BSplineDegree: int
        	:param BSplineFlatKnots:
        	:type BSplineFlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewDegree:
        	:type NewDegree: int
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param theStatus:
        	:type theStatus: int
        	:rtype: void
        * this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))
        	:param Function:
        	:type Function: BSplCLib_EvaluatorFunction
        	:param BSplineDegree:
        	:type BSplineDegree: int
        	:param BSplineFlatKnots:
        	:type BSplineFlatKnots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewDegree:
        	:type NewDegree: int
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param theStatus:
        	:type theStatus: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_FunctionReparameterise(*args)

    FunctionReparameterise = staticmethod(FunctionReparameterise)

    def GetPole(*args) -> "Standard_Real &, Standard_Integer &":
        """
        * Copy the pole at position <Index> in the Boor scheme of dimension <Dimension> to <Position> in the array <Pole>. <Position> is updated.
        	:param Index:
        	:type Index: int
        	:param Length:
        	:type Length: int
        	:param Depth:
        	:type Depth: int
        	:param Dimension:
        	:type Dimension: int
        	:param LocPoles:
        	:type LocPoles: float
        	:param Position:
        	:type Position: int
        	:param Pole:
        	:type Pole: TColStd_Array1OfReal
        	:rtype: void
        """
        return _BSplCLib.bsplclib_GetPole(*args)

    GetPole = staticmethod(GetPole)

    def Hunt(*args) -> "Standard_Integer &":
        """
        * This routine searches the position of the real value theX in the monotonically increasing set of real values theArray using bisection algorithm. //! If the given value is out of range or array values, algorithm returns either theArray.Lower()-1 or theArray.Upper()+1 depending on theX position in the ordered set. //! This routine is used to locate a knot value in a set of knots.
        	:param theArray:
        	:type theArray: TColStd_Array1OfReal
        	:param theX:
        	:type theX: float
        	:param theXPos:
        	:type theXPos: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Hunt(*args)

    Hunt = staticmethod(Hunt)

    def IncreaseDegree(*args) -> "void":
        """
        :param Degree:
        	:type Degree: int
        	:param NewDegree:
        	:type NewDegree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Dimension:
        	:type Dimension: int
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColStd_Array1OfReal
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param NewDegree:
        	:type NewDegree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param NewDegree:
        	:type NewDegree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:rtype: void
        :param NewDegree:
        	:type NewDegree: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        * Increase the degree of a bspline (or bezier) curve of dimension <Dimension> form <Degree> to <NewDegree>. //! The number of poles in the new curve is : //! Poles.Length() + (NewDegree - Degree) * Number of spans //! Where the number of spans is : //! LastUKnotIndex(Mults) - FirstUKnotIndex(Mults) + 1 //! for a non-periodic curve //! And Knots.Length() - 1 for a periodic curve. //! The multiplicities of all knots are increased by the degree elevation. //! The new knots are usually the same knots with the exception of a non-periodic curve with the first and last multiplicity not equal to Degree+1 where knots are removed form the start and the bottom untils the sum of the multiplicities is equal to NewDegree+1 at the knots corresponding to the first and last parameters of the curve. //! Example : Suppose a curve of degree 3 starting with following knots and multiplicities : //! knot : 0. 1. 2. mult : 1 2 1 //! The FirstUKnot is 2. because the sum of multiplicities is Degree+1 : 1 + 2 + 1 = 4 = 3 + 1 //! i.e. the first parameter of the curve is 2. and will still be 2. after degree elevation. Let raises this curve to degree 4. The multiplicities are increased by 2. //! They become 2 3 2. But we need a sum of multiplicities of 5 at knot 2. So the first knot is removed and the new knots are : //! knot : 1. 2. mult : 3 2 //! The multipicity of the first knot may also be reduced if the sum is still to big. //! In the most common situations (periodic curve or curve with first and last multiplicities equals to Degree+1) the knots are knot changes. //! The method IncreaseDegreeCountKnots can be used to compute the new number of knots.
        	:param NewDegree:
        	:type NewDegree: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        """
        return _BSplCLib.bsplclib_IncreaseDegree(*args)

    IncreaseDegree = staticmethod(IncreaseDegree)

    def IncreaseDegreeCountKnots(*args) -> "Standard_Integer":
        """
        * Returns the number of knots of a curve with multiplicities <Mults> after elevating the degree from <Degree> to <NewDegree>. See the IncreaseDegree method for more comments.
        	:param Degree:
        	:type Degree: int
        	:param NewDegree:
        	:type NewDegree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: int
        """
        return _BSplCLib.bsplclib_IncreaseDegreeCountKnots(*args)

    IncreaseDegreeCountKnots = staticmethod(IncreaseDegreeCountKnots)

    def InsertKnot(*args) -> "void":
        """
        :param UIndex:
        	:type UIndex: int
        	:param U:
        	:type U: float
        	:param UMult:
        	:type UMult: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        * Insert a new knot U of multiplicity UMult in the knot sequence. //! The location of the new Knot should be given as an input data. UIndex locates the new knot U in the knot sequence and Knots (UIndex) < U < Knots (UIndex + 1). //! The new control points corresponding to this insertion are returned. Knots and Mults are not updated.
        	:param UIndex:
        	:type UIndex: int
        	:param U:
        	:type U: float
        	:param UMult:
        	:type UMult: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        """
        return _BSplCLib.bsplclib_InsertKnot(*args)

    InsertKnot = staticmethod(InsertKnot)

    def InsertKnots(*args) -> "void":
        """
        :param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Dimension:
        	:type Dimension: int
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param AddKnots:
        	:type AddKnots: TColStd_Array1OfReal
        	:param AddMults:
        	:type AddMults: TColStd_Array1OfInteger *
        	:param NewPoles:
        	:type NewPoles: TColStd_Array1OfReal
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param Epsilon:
        	:type Epsilon: float
        	:param Add: default value is Standard_True
        	:type Add: bool
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param AddKnots:
        	:type AddKnots: TColStd_Array1OfReal
        	:param AddMults:
        	:type AddMults: TColStd_Array1OfInteger *
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param Epsilon:
        	:type Epsilon: float
        	:param Add: default value is Standard_True
        	:type Add: bool
        	:rtype: void
        * Insert a sequence of knots <AddKnots> with multiplicities <AddMults>. <AddKnots> must be a non decreasing sequence and verifies : //! Knots(Knots.Lower()) <= AddKnots(AddKnots.Lower()) Knots(Knots.Upper()) >= AddKnots(AddKnots.Upper()) //! The NewPoles and NewWeights arrays must have a length : Poles.Length() + Sum(AddMults()) //! When a knot to insert is identic to an existing knot the multiplicities are added. //! Epsilon is used to test knots for equality. //! When AddMult is negative or null the knot is not inserted. No multiplicity will becomes higher than the degree. //! The new Knots and Multiplicities are copied in <NewKnots> and <NewMults>. //! All the New arrays should be correctly dimensioned. //! When all the new knots are existing knots, i.e. only the multiplicities will change it is safe to use the same arrays as input and output.
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param AddKnots:
        	:type AddKnots: TColStd_Array1OfReal
        	:param AddMults:
        	:type AddMults: TColStd_Array1OfInteger *
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param Epsilon:
        	:type Epsilon: float
        	:param Add: default value is Standard_True
        	:type Add: bool
        	:rtype: void
        """
        return _BSplCLib.bsplclib_InsertKnots(*args)

    InsertKnots = staticmethod(InsertKnots)

    def Interpolate(*args) -> "Standard_Real &, Standard_Real &, Standard_Integer &":
        """
        * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Parameters:
        	:type Parameters: TColStd_Array1OfReal
        	:param ContactOrderArray:
        	:type ContactOrderArray: TColStd_Array1OfInteger
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param InversionProblem:
        	:type InversionProblem: int
        	:rtype: void
        * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the index of the faulty pivot
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Parameters:
        	:type Parameters: TColStd_Array1OfReal
        	:param ContactOrderArray:
        	:type ContactOrderArray: TColStd_Array1OfInteger
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param InversionProblem:
        	:type InversionProblem: int
        	:rtype: void
        * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Parameters:
        	:type Parameters: TColStd_Array1OfReal
        	:param ContactOrderArray:
        	:type ContactOrderArray: TColStd_Array1OfInteger
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param InversionProblem:
        	:type InversionProblem: int
        	:rtype: void
        * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the i
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Parameters:
        	:type Parameters: TColStd_Array1OfReal
        	:param ContactOrderArray:
        	:type ContactOrderArray: TColStd_Array1OfInteger
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param InversionProblem:
        	:type InversionProblem: int
        	:rtype: void
        * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray The length of FlatKnots is Degree + L + 1 The PolesArray is an seen as an Array[1..N][1..ArrayDimension] with N = tge length of the parameters array Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot
        	:param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Parameters:
        	:type Parameters: TColStd_Array1OfReal
        	:param ContactOrderArray:
        	:type ContactOrderArray: TColStd_Array1OfInteger
        	:param ArrayDimension:
        	:type ArrayDimension: int
        	:param Poles:
        	:type Poles: float
        	:param InversionProblem:
        	:type InversionProblem: int
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Parameters:
        	:type Parameters: TColStd_Array1OfReal
        	:param ContactOrderArray:
        	:type ContactOrderArray: TColStd_Array1OfInteger
        	:param ArrayDimension:
        	:type ArrayDimension: int
        	:param Poles:
        	:type Poles: float
        	:param Weights:
        	:type Weights: float
        	:param InversionProblem:
        	:type InversionProblem: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Interpolate(*args)

    Interpolate = staticmethod(Interpolate)

    def IsRational(*args) -> "Standard_Boolean":
        """
        * Returns False if all the weights of the array <Weights> between I1 an I2 are identic. Epsilon is used for comparing weights. If Epsilon is 0. the Epsilon of the first weight is used.
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:param Epsilon: default value is 0.0
        	:type Epsilon: float
        	:rtype: bool
        """
        return _BSplCLib.bsplclib_IsRational(*args)

    IsRational = staticmethod(IsRational)

    def KnotAnalysis(*args) -> "Standard_Integer &":
        """
        * Analyzes the array of knots. Returns the form and the maximum knot multiplicity.
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param CKnots:
        	:type CKnots: TColStd_Array1OfReal
        	:param CMults:
        	:type CMults: TColStd_Array1OfInteger
        	:param KnotForm:
        	:type KnotForm: GeomAbs_BSplKnotDistribution
        	:param MaxKnotMult:
        	:type MaxKnotMult: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_KnotAnalysis(*args)

    KnotAnalysis = staticmethod(KnotAnalysis)

    def KnotForm(*args) -> "BSplCLib_KnotDistribution":
        """
        * Analyses if the knots distribution is 'Uniform' or 'NonUniform' between the knot FromK1 and the knot ToK2. There is no repetition of knot in the knots'sequence <Knots>.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param FromK1:
        	:type FromK1: int
        	:param ToK2:
        	:type ToK2: int
        	:rtype: BSplCLib_KnotDistribution
        """
        return _BSplCLib.bsplclib_KnotForm(*args)

    KnotForm = staticmethod(KnotForm)

    def KnotSequence(*args) -> "void":
        """
        :param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param KnotSeq:
        	:type KnotSeq: TColStd_Array1OfReal
        	:param Periodic: default value is Standard_False
        	:type Periodic: bool
        	:rtype: void
        * Computes the sequence of knots KnotSeq with repetition of the knots of multiplicity greater than 1. //! Length of KnotSeq must be KnotSequenceLength(Mults,Degree,Periodic)
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param KnotSeq:
        	:type KnotSeq: TColStd_Array1OfReal
        	:rtype: void
        """
        return _BSplCLib.bsplclib_KnotSequence(*args)

    KnotSequence = staticmethod(KnotSequence)

    def KnotSequenceLength(*args) -> "Standard_Integer":
        """
        * Returns the length of the sequence of knots with repetition. //! Periodic : //! Sum(Mults(i), i = Mults.Lower(); i <= Mults.Upper()); //! Non Periodic : //! Sum(Mults(i); i = Mults.Lower(); i < Mults.Upper()) + 2 * Degree
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:rtype: int
        """
        return _BSplCLib.bsplclib_KnotSequenceLength(*args)

    KnotSequenceLength = staticmethod(KnotSequenceLength)

    def Knots(*args) -> "void":
        """
        * Computes the sequence of knots Knots without repetition of the knots of multiplicity greater than 1. //! Length of <Knots> and <Mults> must be KnotsLength(KnotSequence,Periodic)
        	:param KnotSeq:
        	:type KnotSeq: TColStd_Array1OfReal
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Periodic: default value is Standard_False
        	:type Periodic: bool
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Knots(*args)

    Knots = staticmethod(Knots)

    def KnotsLength(*args) -> "Standard_Integer":
        """
        * Returns the length of the sequence of knots (and Mults) without repetition.
        	:param KnotSeq:
        	:type KnotSeq: TColStd_Array1OfReal
        	:param Periodic: default value is Standard_False
        	:type Periodic: bool
        	:rtype: int
        """
        return _BSplCLib.bsplclib_KnotsLength(*args)

    KnotsLength = staticmethod(KnotsLength)

    def LastUKnotIndex(*args) -> "Standard_Integer":
        """
        * Computes the index of the knots value which gives the end point of the curve.
        	:param Degree:
        	:type Degree: int
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: int
        """
        return _BSplCLib.bsplclib_LastUKnotIndex(*args)

    LastUKnotIndex = staticmethod(LastUKnotIndex)

    def LocateParameter(*args) -> "Standard_Integer &, Standard_Real &":
        """
        * Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies. //! Knots(Index) <= U < Knots(Index + 1) if U <= Knots (K1) then Index = K1 if U >= Knots (K2) then Index = K2 - 1 //! If Periodic is True U may be modified to fit in the range Knots(K1), Knots(K2). In any case the correct value is returned in NewU. //! Warnings :Index is used as input data to initialize the searching function. Warning: Knots have to be 'withe repetitions'
        	:param Degree:
        	:type Degree: int
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param U:
        	:type U: float
        	:param IsPeriodic:
        	:type IsPeriodic: bool
        	:param FromK1:
        	:type FromK1: int
        	:param ToK2:
        	:type ToK2: int
        	:param KnotIndex:
        	:type KnotIndex: int
        	:param NewU:
        	:type NewU: float
        	:rtype: void
        * Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies. //! Knots(Index) <= U < Knots(Index + 1) if U <= Knots (K1) then Index = K1 if U >= Knots (K2) then Index = K2 - 1 //! If Periodic is True U may be modified to fit in the range Knots(K1), Knots(K2). In any case the correct value is returned in NewU. //! Warnings :Index is used as input data to initialize the searching function. Warning: Knots have to be 'flat'
        	:param Degree:
        	:type Degree: int
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param U:
        	:type U: float
        	:param IsPeriodic:
        	:type IsPeriodic: bool
        	:param FromK1:
        	:type FromK1: int
        	:param ToK2:
        	:type ToK2: int
        	:param KnotIndex:
        	:type KnotIndex: int
        	:param NewU:
        	:type NewU: float
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger *
        	:param U:
        	:type U: float
        	:param Periodic:
        	:type Periodic: bool
        	:param Index:
        	:type Index: int
        	:param NewU:
        	:type NewU: float
        	:rtype: void
        """
        return _BSplCLib.bsplclib_LocateParameter(*args)

    LocateParameter = staticmethod(LocateParameter)

    def MaxDegree(*args) -> "Standard_Integer":
        """
        * returns the degree maxima for a BSplineCurve.
        	:rtype: int
        """
        return _BSplCLib.bsplclib_MaxDegree(*args)

    MaxDegree = staticmethod(MaxDegree)

    def MaxKnotMult(*args) -> "Standard_Integer":
        """
        * Finds the greatest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param K1:
        	:type K1: int
        	:param K2:
        	:type K2: int
        	:rtype: int
        """
        return _BSplCLib.bsplclib_MaxKnotMult(*args)

    MaxKnotMult = staticmethod(MaxKnotMult)

    def MergeBSplineKnots(*args) -> "Standard_Integer &":
        """
        * Merges two knot vector by setting the starting and ending values to StartValue and EndValue
        	:param Tolerance:
        	:type Tolerance: float
        	:param StartValue:
        	:type StartValue: float
        	:param EndValue:
        	:type EndValue: float
        	:param Degree1:
        	:type Degree1: int
        	:param Knots1:
        	:type Knots1: TColStd_Array1OfReal
        	:param Mults1:
        	:type Mults1: TColStd_Array1OfInteger
        	:param Degree2:
        	:type Degree2: int
        	:param Knots2:
        	:type Knots2: TColStd_Array1OfReal
        	:param Mults2:
        	:type Mults2: TColStd_Array1OfInteger
        	:param NumPoles:
        	:type NumPoles: int
        	:param NewKnots:
        	:type NewKnots: TColStd_HArray1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_HArray1OfInteger
        	:rtype: void
        """
        return _BSplCLib.bsplclib_MergeBSplineKnots(*args)

    MergeBSplineKnots = staticmethod(MergeBSplineKnots)

    def MinKnotMult(*args) -> "Standard_Integer":
        """
        * Finds the lowest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param K1:
        	:type K1: int
        	:param K2:
        	:type K2: int
        	:rtype: int
        """
        return _BSplCLib.bsplclib_MinKnotMult(*args)

    MinKnotMult = staticmethod(MinKnotMult)

    def MovePoint(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -> no constraint for one side don't enter (1,NbPoles) -> error: rigid move (2, NbPoles-1) -> the ends are enforced (3, NbPoles-2) -> the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0
        	:param U:
        	:type U: float
        	:param Displ:
        	:type Displ: gp_Vec2d
        	:param Index1:
        	:type Index1: int
        	:param Index2:
        	:type Index2: int
        	:param Degree:
        	:type Degree: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param FirstIndex:
        	:type FirstIndex: int
        	:param LastIndex:
        	:type LastIndex: int
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:rtype: void
        * Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -> no constraint for one side don't enter (1,NbPoles) -> error: rigid move (2, NbPoles-1) -> the ends are enforced (3, NbPoles-2) -> the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0
        	:param U:
        	:type U: float
        	:param Displ:
        	:type Displ: gp_Vec
        	:param Index1:
        	:type Index1: int
        	:param Index2:
        	:type Index2: int
        	:param Degree:
        	:type Degree: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param FirstIndex:
        	:type FirstIndex: int
        	:param LastIndex:
        	:type LastIndex: int
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:rtype: void
        """
        return _BSplCLib.bsplclib_MovePoint(*args)

    MovePoint = staticmethod(MovePoint)

    def MovePointAndTangent(*args) -> "Standard_Integer &":
        """
        * This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = ... Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if not NULL NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.
        	:param U:
        	:type U: float
        	:param ArrayDimension:
        	:type ArrayDimension: int
        	:param Delta:
        	:type Delta: float
        	:param DeltaDerivative:
        	:type DeltaDerivative: float
        	:param Tolerance:
        	:type Tolerance: float
        	:param Degree:
        	:type Degree: int
        	:param StartingCondition:
        	:type StartingCondition: int
        	:param EndingCondition:
        	:type EndingCondition: int
        	:param Poles:
        	:type Poles: float
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewPoles:
        	:type NewPoles: float
        	:param ErrorStatus:
        	:type ErrorStatus: int
        	:rtype: void
        * This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = ... Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if not NULL NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.
        	:param U:
        	:type U: float
        	:param Delta:
        	:type Delta: gp_Vec
        	:param DeltaDerivative:
        	:type DeltaDerivative: gp_Vec
        	:param Tolerance:
        	:type Tolerance: float
        	:param Degree:
        	:type Degree: int
        	:param StartingCondition:
        	:type StartingCondition: int
        	:param EndingCondition:
        	:type EndingCondition: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param ErrorStatus:
        	:type ErrorStatus: int
        	:rtype: void
        * This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = ... Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if not NULL NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.
        	:param U:
        	:type U: float
        	:param Delta:
        	:type Delta: gp_Vec2d
        	:param DeltaDerivative:
        	:type DeltaDerivative: gp_Vec2d
        	:param Tolerance:
        	:type Tolerance: float
        	:param Degree:
        	:type Degree: int
        	:param StartingCondition:
        	:type StartingCondition: int
        	:param EndingCondition:
        	:type EndingCondition: int
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param ErrorStatus:
        	:type ErrorStatus: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_MovePointAndTangent(*args)

    MovePointAndTangent = staticmethod(MovePointAndTangent)

    def MultForm(*args) -> "BSplCLib_MultDistribution":
        """
        * Analyses the distribution of multiplicities between the knot FromK1 and the Knot ToK2.
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FromK1:
        	:type FromK1: int
        	:param ToK2:
        	:type ToK2: int
        	:rtype: BSplCLib_MultDistribution
        """
        return _BSplCLib.bsplclib_MultForm(*args)

    MultForm = staticmethod(MultForm)

    def NbPoles(*args) -> "Standard_Integer":
        """
        * Returns the number of poles of the curve. Returns 0 if one of the multiplicities is incorrect. //! * Non positive. //! * Greater than Degree, or Degree+1 at the first and last knot of a non periodic curve. //! * The last periodicity on a periodic curve is not equal to the first.
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: int
        """
        return _BSplCLib.bsplclib_NbPoles(*args)

    NbPoles = staticmethod(NbPoles)

    def NoMults(*args) -> "TColStd_Array1OfInteger *":
        """
        * Used as argument for a flatknots evaluation.
        	:rtype: TColStd_Array1OfInteger *
        """
        return _BSplCLib.bsplclib_NoMults(*args)

    NoMults = staticmethod(NoMults)

    def NoWeights(*args) -> "TColStd_Array1OfReal *":
        """
        * Used as argument for a non rational curve.
        	:rtype: TColStd_Array1OfReal *
        """
        return _BSplCLib.bsplclib_NoWeights(*args)

    NoWeights = staticmethod(NoWeights)

    def PoleIndex(*args) -> "Standard_Integer":
        """
        * Return the index of the first Pole to use on the span Mults(Index) - Mults(Index+1). This index must be added to Poles.Lower().
        	:param Degree:
        	:type Degree: int
        	:param Index:
        	:type Index: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: int
        """
        return _BSplCLib.bsplclib_PoleIndex(*args)

    PoleIndex = staticmethod(PoleIndex)

    def PolesCoefficients(*args) -> "void":
        """
        :param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param CachePoles:
        	:type CachePoles: TColgp_Array1OfPnt2d
        	:rtype: None
        :param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param CachePoles:
        	:type CachePoles: TColgp_Array1OfPnt2d
        	:param CacheWeights:
        	:type CacheWeights: TColStd_Array1OfReal *
        	:rtype: void
        :param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param CachePoles:
        	:type CachePoles: TColgp_Array1OfPnt
        	:rtype: None
        * Encapsulation of BuildCache to perform the evaluation of the Taylor expansion for beziercurves at parameter 0. Warning: To be used for Beziercurves ONLY!!!
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param CachePoles:
        	:type CachePoles: TColgp_Array1OfPnt
        	:param CacheWeights:
        	:type CacheWeights: TColStd_Array1OfReal *
        	:rtype: void
        """
        return _BSplCLib.bsplclib_PolesCoefficients(*args)

    PolesCoefficients = staticmethod(PolesCoefficients)

    def PrepareInsertKnots(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * Returns in <NbPoles, NbKnots> the new number of poles and knots if the sequence of knots <AddKnots, AddMults> is inserted in the sequence <Knots, Mults>. //! Epsilon is used to compare knots for equality. //! If Add is True the multiplicities on equal knots are added. //! If Add is False the max value of the multiplicities is kept. //! Return False if : The knew knots are knot increasing. The new knots are not in the range.
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param AddKnots:
        	:type AddKnots: TColStd_Array1OfReal
        	:param AddMults:
        	:type AddMults: TColStd_Array1OfInteger *
        	:param NbPoles:
        	:type NbPoles: int
        	:param NbKnots:
        	:type NbKnots: int
        	:param Epsilon:
        	:type Epsilon: float
        	:param Add: default value is Standard_True
        	:type Add: bool
        	:rtype: bool
        """
        return _BSplCLib.bsplclib_PrepareInsertKnots(*args)

    PrepareInsertKnots = staticmethod(PrepareInsertKnots)

    def PrepareTrimming(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * Set in <NbKnots> and <NbPoles> the number of Knots and Poles of the curve resulting of the trimming of the BSplinecurve definded with <degree>, <knots>, <mults>
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param NbKnots:
        	:type NbKnots: int
        	:param NbPoles:
        	:type NbPoles: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_PrepareTrimming(*args)

    PrepareTrimming = staticmethod(PrepareTrimming)

    def PrepareUnperiodize(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * Set in <NbKnots> and <NbPolesToAdd> the number of Knots and Poles of the NotPeriodic Curve identical at the periodic curve with a degree <Degree> , a knots-distribution with Multiplicities <Mults>.
        	:param Degree:
        	:type Degree: int
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NbKnots:
        	:type NbKnots: int
        	:param NbPoles:
        	:type NbPoles: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_PrepareUnperiodize(*args)

    PrepareUnperiodize = staticmethod(PrepareUnperiodize)

    def RaiseMultiplicity(*args) -> "void":
        """
        :param KnotIndex:
        	:type KnotIndex: int
        	:param Mult:
        	:type Mult: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        * Raise the multiplicity of knot to <UMult>. //! The new control points are returned. Knots and Mults are not updated.
        	:param KnotIndex:
        	:type KnotIndex: int
        	:param Mult:
        	:type Mult: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        """
        return _BSplCLib.bsplclib_RaiseMultiplicity(*args)

    RaiseMultiplicity = staticmethod(RaiseMultiplicity)

    def RemoveKnot(*args) -> "Standard_Boolean":
        """
        :param Index:
        	:type Index: int
        	:param Mult:
        	:type Mult: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Dimension:
        	:type Dimension: int
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColStd_Array1OfReal
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: bool
        :param Index:
        	:type Index: int
        	:param Mult:
        	:type Mult: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: bool
        * Decrement the multiplicity of <Knots(Index)> to <Mult>. If <Mult> is null the knot is removed. //! As there are two ways to compute the new poles the midlle will be used as long as the distance is lower than Tolerance. //! If a distance is bigger than tolerance the methods returns False and the new arrays are not modified. //! A low tolerance can be used to test if the knot can be removed without modifying the curve. //! A high tolerance can be used to 'smooth' the curve.
        	:param Index:
        	:type Index: int
        	:param Mult:
        	:type Mult: int
        	:param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: bool
        """
        return _BSplCLib.bsplclib_RemoveKnot(*args)

    RemoveKnot = staticmethod(RemoveKnot)

    def Reparametrize(*args) -> "void":
        """
        * Reparametrizes a B-spline curve to [U1, U2]. The knot values are recomputed such that Knots (Lower) = U1 and Knots (Upper) = U2 but the knot form is not modified. Warnings : In the array Knots the values must be in ascending order. U1 must not be equal to U2 to avoid division by zero.
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Reparametrize(*args)

    Reparametrize = staticmethod(Reparametrize)

    def Resolution(*args) -> "Standard_Real &":
        """
        * given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | < UTolerance and we have |f (u1) - f (u0)| < Tolerance3D
        	:param PolesArray:
        	:type PolesArray: float
        	:param ArrayDimension:
        	:type ArrayDimension: int
        	:param NumPoles:
        	:type NumPoles: int
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Degree:
        	:type Degree: int
        	:param Tolerance3D:
        	:type Tolerance3D: float
        	:param UTolerance:
        	:type UTolerance: float
        	:rtype: void
        * given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | < UTolerance and we have |f (u1) - f (u0)| < Tolerance3D
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param NumPoles:
        	:type NumPoles: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Degree:
        	:type Degree: int
        	:param Tolerance3D:
        	:type Tolerance3D: float
        	:param UTolerance:
        	:type UTolerance: float
        	:rtype: void
        * given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | < UTolerance and we have |f (u1) - f (u0)| < Tolerance3D
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param NumPoles:
        	:type NumPoles: int
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param Degree:
        	:type Degree: int
        	:param Tolerance3D:
        	:type Tolerance3D: float
        	:param UTolerance:
        	:type UTolerance: float
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def Reverse(*args) -> "void":
        """
        * Reverses the array knots to become the knots sequence of the reversed curve.
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:rtype: void
        * Reverses the array of multiplicities.
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:rtype: void
        * Reverses the array of poles. Last is the index of the new first pole. On a non periodic curve last is Poles.Upper(). On a periodic curve last is //! (number of flat knots - degree - 1) //! or //! (sum of multiplicities(but for the last) + degree - 1)
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Last:
        	:type Last: int
        	:rtype: void
        * Reverses the array of poles.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Last:
        	:type Last: int
        	:rtype: void
        * Reverses the array of poles.
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param Last:
        	:type Last: int
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Reverse(*args)

    Reverse = staticmethod(Reverse)

    def SolveBandedSystem(*args) -> "Standard_Integer":
        """
        * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension
        	:param Matrix:
        	:type Matrix: math_Matrix
        	:param UpperBandWidth:
        	:type UpperBandWidth: int
        	:param LowerBandWidth:
        	:type LowerBandWidth: int
        	:param ArrayDimension:
        	:type ArrayDimension: int
        	:param Array:
        	:type Array: float
        	:rtype: int
        * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension
        	:param Matrix:
        	:type Matrix: math_Matrix
        	:param UpperBandWidth:
        	:type UpperBandWidth: int
        	:param LowerBandWidth:
        	:type LowerBandWidth: int
        	:param Array:
        	:type Array: TColgp_Array1OfPnt2d
        	:rtype: int
        * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension
        	:param Matrix:
        	:type Matrix: math_Matrix
        	:param UpperBandWidth:
        	:type UpperBandWidth: int
        	:param LowerBandWidth:
        	:type LowerBandWidth: int
        	:param Array:
        	:type Array: TColgp_Array1OfPnt
        	:rtype: int
        :param Matrix:
        	:type Matrix: math_Matrix
        	:param UpperBandWidth:
        	:type UpperBandWidth: int
        	:param LowerBandWidth:
        	:type LowerBandWidth: int
        	:param HomogenousFlag:
        	:type HomogenousFlag: bool
        	:param ArrayDimension:
        	:type ArrayDimension: int
        	:param Array:
        	:type Array: float
        	:param Weights:
        	:type Weights: float
        	:rtype: int
        * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension. If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.
        	:param Matrix:
        	:type Matrix: math_Matrix
        	:param UpperBandWidth:
        	:type UpperBandWidth: int
        	:param LowerBandWidth:
        	:type LowerBandWidth: int
        	:param HomogenousFlag:
        	:type HomogenousFlag: bool
        	:param Array:
        	:type Array: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:rtype: int
        * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.
        	:param Matrix:
        	:type Matrix: math_Matrix
        	:param UpperBandWidth:
        	:type UpperBandWidth: int
        	:param LowerBandWidth:
        	:type LowerBandWidth: int
        	:param HomogeneousFlag:
        	:type HomogeneousFlag: bool
        	:param Array:
        	:type Array: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:rtype: int
        """
        return _BSplCLib.bsplclib_SolveBandedSystem(*args)

    SolveBandedSystem = staticmethod(SolveBandedSystem)

    def TangExtendToConstraint(*args) -> "Standard_Real &, Standard_Integer &, Standard_Integer &, Standard_Real &, Standard_Real &":
        """
        * Extend a BSpline nD using the tangency map <C1Coefficient> is the coefficient of reparametrisation <Continuity> must be equal to 1, 2 or 3. <Degree> must be greater or equal than <Continuity> + 1. //! Warning: <KnotsResult> and <PolesResult> must be dimensionned properly.
        	:param FlatKnots:
        	:type FlatKnots: TColStd_Array1OfReal
        	:param C1Coefficient:
        	:type C1Coefficient: float
        	:param NumPoles:
        	:type NumPoles: int
        	:param Poles:
        	:type Poles: float
        	:param Dimension:
        	:type Dimension: int
        	:param Degree:
        	:type Degree: int
        	:param ConstraintPoint:
        	:type ConstraintPoint: TColStd_Array1OfReal
        	:param Continuity:
        	:type Continuity: int
        	:param After:
        	:type After: bool
        	:param NbPolesResult:
        	:type NbPolesResult: int
        	:param NbKnotsRsult:
        	:type NbKnotsRsult: int
        	:param KnotsResult:
        	:type KnotsResult: float
        	:param PolesResult:
        	:type PolesResult: float
        	:rtype: void
        """
        return _BSplCLib.bsplclib_TangExtendToConstraint(*args)

    TangExtendToConstraint = staticmethod(TangExtendToConstraint)

    def Trimming(*args) -> "void":
        """
        :param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Dimension:
        	:type Dimension: int
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColStd_Array1OfReal
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param Periodic:
        	:type Periodic: bool
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Trimming(*args)

    Trimming = staticmethod(Trimming)

    def Unperiodize(*args) -> "void":
        """
        :param Degree:
        	:type Degree: int
        	:param Dimension:
        	:type Dimension: int
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewPoles:
        	:type NewPoles: TColStd_Array1OfReal
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        :param Degree:
        	:type Degree: int
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal *
        	:param NewMults:
        	:type NewMults: TColStd_Array1OfInteger
        	:param NewKnots:
        	:type NewKnots: TColStd_Array1OfReal
        	:param NewPoles:
        	:type NewPoles: TColgp_Array1OfPnt2d
        	:param NewWeights:
        	:type NewWeights: TColStd_Array1OfReal *
        	:rtype: void
        """
        return _BSplCLib.bsplclib_Unperiodize(*args)

    Unperiodize = staticmethod(Unperiodize)

    __repr__ = _dumps_object


    def __init__(self):
        _BSplCLib.bsplclib_swiginit(self, _BSplCLib.new_bsplclib())
    __swig_destroy__ = _BSplCLib.delete_bsplclib
bsplclib_swigregister = _BSplCLib.bsplclib_swigregister
bsplclib_swigregister(bsplclib)

def bsplclib_AntiBoorScheme(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Compute the content of Pole before the BoorScheme. This method is used to remove poles. //! U is the poles to remove, Knots should contains the knots of the curve after knot removal. //! The first and last poles do not change, the other poles are computed by averaging two possible values. The distance between the two possible poles is computed, if it is higher than <Tolerance> False is returned.
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param Knots:
    	:type Knots: float
    	:param Dimension:
    	:type Dimension: int
    	:param Poles:
    	:type Poles: float
    	:param Depth:
    	:type Depth: int
    	:param Length:
    	:type Length: int
    	:param Tolerance:
    	:type Tolerance: float
    	:rtype: bool
    """
    return _BSplCLib.bsplclib_AntiBoorScheme(*args)

def bsplclib_Bohm(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Performs the Bohm Algorithm at parameter <U>. This algorithm computes the value and all the derivatives up to order N (N <= Degree). //! <Poles> is the original array of poles. //! The result in <Poles> is the value and the derivatives. Poles[0] is the value, Poles[Degree] is the last derivative.
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param N:
    	:type N: int
    	:param Knots:
    	:type Knots: float
    	:param Dimension:
    	:type Dimension: int
    	:param Poles:
    	:type Poles: float
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Bohm(*args)

def bsplclib_BoorIndex(*args) -> "Standard_Integer":
    """
    * Returns the index in the Boor result array of the poles <Index>. If the Boor algorithm was perform with <Length> and <Depth>.
    	:param Index:
    	:type Index: int
    	:param Length:
    	:type Length: int
    	:param Depth:
    	:type Depth: int
    	:rtype: int
    """
    return _BSplCLib.bsplclib_BoorIndex(*args)

def bsplclib_BoorScheme(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Performs the Boor Algorithm at parameter <U> with the given <Degree> and the array of <Knots> on the poles <Poles> of dimension <Dimension>. The schema is computed until level <Depth> on a basis of <Length+1> poles. //! * Knots is an array of reals of length : //! <Length> + <Degree> //! * Poles is an array of reals of length : //! (2 * <Length> + 1) * <Dimension> //! The poles values must be set in the array at the positions. //! 0..Dimension, //! 2 * Dimension .. 3 * Dimension //! 4 * Dimension .. 5 * Dimension //! ... //! The results are found in the array poles depending on the Depth. (See the method GetPole).
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param Knots:
    	:type Knots: float
    	:param Dimension:
    	:type Dimension: int
    	:param Poles:
    	:type Poles: float
    	:param Depth:
    	:type Depth: int
    	:param Length:
    	:type Length: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_BoorScheme(*args)

def bsplclib_BuildBSpMatrix(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * This Builds a fully blown Matrix of (ni) Bi (tj) //! with i and j within 1..Order + NumPoles The integer ni is the ith slot of the array OrderArray, tj is the jth slot of the array Parameters
    	:param Parameters:
    	:type Parameters: TColStd_Array1OfReal
    	:param OrderArray:
    	:type OrderArray: TColStd_Array1OfInteger
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Degree:
    	:type Degree: int
    	:param Matrix:
    	:type Matrix: math_Matrix
    	:param UpperBandWidth:
    	:type UpperBandWidth: int
    	:param LowerBandWidth:
    	:type LowerBandWidth: int
    	:rtype: int
    """
    return _BSplCLib.bsplclib_BuildBSpMatrix(*args)

def bsplclib_BuildBoor(*args) -> "Standard_Real &":
    """
    * Copy in <LP> poles for <Dimension> Boor scheme. Starting from <Index> * <Dimension>, copy <Length+1> poles.
    	:param Index:
    	:type Index: int
    	:param Length:
    	:type Length: int
    	:param Dimension:
    	:type Dimension: int
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param LP:
    	:type LP: float
    	:rtype: void
    """
    return _BSplCLib.bsplclib_BuildBoor(*args)

def bsplclib_BuildCache(*args) -> "void":
    """
    * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles
    	:param U:
    	:type U: float
    	:param InverseOfSpanDomain:
    	:type InverseOfSpanDomain: float
    	:param PeriodicFlag:
    	:type PeriodicFlag: bool
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param CachePoles:
    	:type CachePoles: TColgp_Array1OfPnt
    	:param CacheWeights:
    	:type CacheWeights: TColStd_Array1OfReal *
    	:rtype: void
    * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles
    	:param U:
    	:type U: float
    	:param InverseOfSpanDomain:
    	:type InverseOfSpanDomain: float
    	:param PeriodicFlag:
    	:type PeriodicFlag: bool
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param CachePoles:
    	:type CachePoles: TColgp_Array1OfPnt2d
    	:param CacheWeights:
    	:type CacheWeights: TColStd_Array1OfReal *
    	:rtype: void
    * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. Structure of result optimized for BSplCLib_Cache.
    	:param theParameter:
    	:type theParameter: float
    	:param theSpanDomain:
    	:type theSpanDomain: float
    	:param thePeriodicFlag:
    	:type thePeriodicFlag: bool
    	:param theDegree:
    	:type theDegree: int
    	:param theSpanIndex:
    	:type theSpanIndex: int
    	:param theFlatKnots:
    	:type theFlatKnots: TColStd_Array1OfReal
    	:param thePoles:
    	:type thePoles: TColgp_Array1OfPnt
    	:param theWeights:
    	:type theWeights: TColStd_Array1OfReal *
    	:param theCacheArray:
    	:type theCacheArray: TColStd_Array2OfReal
    	:rtype: void
    * Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. Structure of result optimized for BSplCLib_Cache.
    	:param theParameter:
    	:type theParameter: float
    	:param theSpanDomain:
    	:type theSpanDomain: float
    	:param thePeriodicFlag:
    	:type thePeriodicFlag: bool
    	:param theDegree:
    	:type theDegree: int
    	:param theSpanIndex:
    	:type theSpanIndex: int
    	:param theFlatKnots:
    	:type theFlatKnots: TColStd_Array1OfReal
    	:param thePoles:
    	:type thePoles: TColgp_Array1OfPnt2d
    	:param theWeights:
    	:type theWeights: TColStd_Array1OfReal *
    	:param theCacheArray:
    	:type theCacheArray: TColStd_Array2OfReal
    	:rtype: void
    """
    return _BSplCLib.bsplclib_BuildCache(*args)

def bsplclib_BuildEval(*args) -> "Standard_Real &":
    """
    :param Degree:
    	:type Degree: int
    	:param Index:
    	:type Index: int
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param LP:
    	:type LP: float
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param Index:
    	:type Index: int
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param LP:
    	:type LP: float
    	:rtype: void
    * Copy in <LP> the poles and weights for the Eval scheme. starting from Poles(Poles.Lower()+Index)
    	:param Degree:
    	:type Degree: int
    	:param Index:
    	:type Index: int
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param LP:
    	:type LP: float
    	:rtype: void
    """
    return _BSplCLib.bsplclib_BuildEval(*args)

def bsplclib_BuildKnots(*args) -> "Standard_Real &":
    """
    * Stores in LK the usefull knots for the BoorSchem on the span Knots(Index) - Knots(Index+1)
    	:param Degree:
    	:type Degree: int
    	:param Index:
    	:type Index: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param LK:
    	:type LK: float
    	:rtype: void
    """
    return _BSplCLib.bsplclib_BuildKnots(*args)

def bsplclib_BuildSchoenbergPoints(*args) -> "void":
    """
    * builds the Schoenberg points from the flat knot used to interpolate a BSpline since the BSpline matrix is invertible.
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Parameters:
    	:type Parameters: TColStd_Array1OfReal
    	:rtype: void
    """
    return _BSplCLib.bsplclib_BuildSchoenbergPoints(*args)

def bsplclib_CacheD0(*args) -> "void":
    """
    * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param CacheParameter:
    	:type CacheParameter: float
    	:param SpanLenght:
    	:type SpanLenght: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt
    	:rtype: void
    * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param CacheParameter:
    	:type CacheParameter: float
    	:param SpanLenght:
    	:type SpanLenght: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt2d
    	:rtype: void
    """
    return _BSplCLib.bsplclib_CacheD0(*args)

def bsplclib_CacheD1(*args) -> "void":
    """
    * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param CacheParameter:
    	:type CacheParameter: float
    	:param SpanLenght:
    	:type SpanLenght: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt
    	:param Vec:
    	:type Vec: gp_Vec
    	:rtype: void
    * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param CacheParameter:
    	:type CacheParameter: float
    	:param SpanLenght:
    	:type SpanLenght: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt2d
    	:param Vec:
    	:type Vec: gp_Vec2d
    	:rtype: void
    """
    return _BSplCLib.bsplclib_CacheD1(*args)

def bsplclib_CacheD2(*args) -> "void":
    """
    * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param CacheParameter:
    	:type CacheParameter: float
    	:param SpanLenght:
    	:type SpanLenght: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt
    	:param Vec1:
    	:type Vec1: gp_Vec
    	:param Vec2:
    	:type Vec2: gp_Vec
    	:rtype: void
    * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param CacheParameter:
    	:type CacheParameter: float
    	:param SpanLenght:
    	:type SpanLenght: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt2d
    	:param Vec1:
    	:type Vec1: gp_Vec2d
    	:param Vec2:
    	:type Vec2: gp_Vec2d
    	:rtype: void
    """
    return _BSplCLib.bsplclib_CacheD2(*args)

def bsplclib_CacheD3(*args) -> "void":
    """
    * Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param CacheParameter:
    	:type CacheParameter: float
    	:param SpanLenght:
    	:type SpanLenght: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt
    	:param Vec1:
    	:type Vec1: gp_Vec
    	:param Vec2:
    	:type Vec2: gp_Vec
    	:param Vec3:
    	:type Vec3: gp_Vec
    	:rtype: void
    * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param CacheParameter:
    	:type CacheParameter: float
    	:param SpanLenght:
    	:type SpanLenght: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt2d
    	:param Vec1:
    	:type Vec1: gp_Vec2d
    	:param Vec2:
    	:type Vec2: gp_Vec2d
    	:param Vec3:
    	:type Vec3: gp_Vec2d
    	:rtype: void
    """
    return _BSplCLib.bsplclib_CacheD3(*args)

def bsplclib_CoefsD0(*args) -> "void":
    """
    * Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
    	:param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt
    	:rtype: None
    * Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
    	:param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt2d
    	:rtype: None
    """
    return _BSplCLib.bsplclib_CoefsD0(*args)

def bsplclib_CoefsD1(*args) -> "void":
    """
    * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
    	:param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt
    	:param Vec:
    	:type Vec: gp_Vec
    	:rtype: None
    * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
    	:param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt2d
    	:param Vec:
    	:type Vec: gp_Vec2d
    	:rtype: None
    """
    return _BSplCLib.bsplclib_CoefsD1(*args)

def bsplclib_CoefsD2(*args) -> "void":
    """
    * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
    	:param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt
    	:param Vec1:
    	:type Vec1: gp_Vec
    	:param Vec2:
    	:type Vec2: gp_Vec
    	:rtype: None
    * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
    	:param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt2d
    	:param Vec1:
    	:type Vec1: gp_Vec2d
    	:param Vec2:
    	:type Vec2: gp_Vec2d
    	:rtype: None
    """
    return _BSplCLib.bsplclib_CoefsD2(*args)

def bsplclib_CoefsD3(*args) -> "void":
    """
    * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
    	:param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt
    	:param Vec1:
    	:type Vec1: gp_Vec
    	:param Vec2:
    	:type Vec2: gp_Vec
    	:param Vec3:
    	:type Vec3: gp_Vec
    	:rtype: None
    * Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!
    	:param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Point:
    	:type Point: gp_Pnt2d
    	:param Vec1:
    	:type Vec1: gp_Vec2d
    	:param Vec2:
    	:type Vec2: gp_Vec2d
    	:param Vec3:
    	:type Vec3: gp_Vec2d
    	:rtype: None
    """
    return _BSplCLib.bsplclib_CoefsD3(*args)

def bsplclib_D0(*args) -> "void":
    """
    :param U:
    	:type U: float
    	:param Index:
    	:type Index: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: float
    	:rtype: void
    :param U:
    	:type U: float
    	:param Index:
    	:type Index: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: gp_Pnt
    	:rtype: void
    :param U:
    	:type U: float
    	:param UIndex:
    	:type UIndex: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: gp_Pnt2d
    	:rtype: void
    :param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param P:
    	:type P: gp_Pnt
    	:rtype: void
    :param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param P:
    	:type P: gp_Pnt2d
    	:rtype: void
    """
    return _BSplCLib.bsplclib_D0(*args)

def bsplclib_D1(*args) -> "void":
    """
    :param U:
    	:type U: float
    	:param Index:
    	:type Index: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: float
    	:param V:
    	:type V: float
    	:rtype: void
    :param U:
    	:type U: float
    	:param Index:
    	:type Index: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: gp_Pnt
    	:param V:
    	:type V: gp_Vec
    	:rtype: void
    :param U:
    	:type U: float
    	:param UIndex:
    	:type UIndex: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: gp_Pnt2d
    	:param V:
    	:type V: gp_Vec2d
    	:rtype: void
    :param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param P:
    	:type P: gp_Pnt
    	:param V:
    	:type V: gp_Vec
    	:rtype: void
    :param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param P:
    	:type P: gp_Pnt2d
    	:param V:
    	:type V: gp_Vec2d
    	:rtype: void
    """
    return _BSplCLib.bsplclib_D1(*args)

def bsplclib_D2(*args) -> "void":
    """
    :param U:
    	:type U: float
    	:param Index:
    	:type Index: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: float
    	:param V1:
    	:type V1: float
    	:param V2:
    	:type V2: float
    	:rtype: void
    :param U:
    	:type U: float
    	:param Index:
    	:type Index: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:rtype: void
    :param U:
    	:type U: float
    	:param UIndex:
    	:type UIndex: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:rtype: void
    :param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:rtype: void
    :param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:rtype: void
    """
    return _BSplCLib.bsplclib_D2(*args)

def bsplclib_D3(*args) -> "void":
    """
    :param U:
    	:type U: float
    	:param Index:
    	:type Index: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: float
    	:param V1:
    	:type V1: float
    	:param V2:
    	:type V2: float
    	:param V3:
    	:type V3: float
    	:rtype: void
    :param U:
    	:type U: float
    	:param Index:
    	:type Index: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:param V3:
    	:type V3: gp_Vec
    	:rtype: void
    :param U:
    	:type U: float
    	:param UIndex:
    	:type UIndex: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:param V3:
    	:type V3: gp_Vec2d
    	:rtype: void
    :param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:param V3:
    	:type V3: gp_Vec
    	:rtype: void
    :param U:
    	:type U: float
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:param V3:
    	:type V3: gp_Vec2d
    	:rtype: void
    """
    return _BSplCLib.bsplclib_D3(*args)

def bsplclib_Derivative(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Computes the poles of the BSpline giving the derivatives of order <Order>. //! The formula for the first order is //! Pole(i) = Degree * (Pole(i+1) - Pole(i)) / (Knots(i+Degree+1) - Knots(i+1)) //! This formula is repeated (Degree is decremented at each step).
    	:param Degree:
    	:type Degree: int
    	:param Knots:
    	:type Knots: float
    	:param Dimension:
    	:type Dimension: int
    	:param Length:
    	:type Length: int
    	:param Order:
    	:type Order: int
    	:param Poles:
    	:type Poles: float
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Derivative(*args)

def bsplclib_Eval(*args) -> "Standard_Integer &, Standard_Real &":
    """
    * Perform the Boor algorithm to evaluate a point at parameter <U>, with <Degree> and <Dimension>. //! Poles is an array of Reals of size //! <Dimension> * <Degree>+1 //! Containing the poles. At the end <Poles> contains the current point.
    	:param U:
    	:type U: float
    	:param Degree:
    	:type Degree: int
    	:param Knots:
    	:type Knots: float
    	:param Dimension:
    	:type Dimension: int
    	:param Poles:
    	:type Poles: float
    	:rtype: void
    * Perform the De Boor algorithm to evaluate a point at parameter <U>, with <Degree> and <Dimension>. //! Poles is an array of Reals of size //! <Dimension> * <Degree>+1 //! Containing the poles. At the end <Poles> contains the current point. Poles Contain all the poles of the BsplineCurve, Knots also Contains all the knots of the BsplineCurve. ExtrapMode has two slots [0] = Degree used to extrapolate before the first knot [1] = Degre used to extrapolate after the last knot has to be between 1 and Degree
    	:param U:
    	:type U: float
    	:param PeriodicFlag:
    	:type PeriodicFlag: bool
    	:param DerivativeRequest:
    	:type DerivativeRequest: int
    	:param ExtrapMode:
    	:type ExtrapMode: int
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param ArrayDimension:
    	:type ArrayDimension: int
    	:param Poles:
    	:type Poles: float
    	:param Result:
    	:type Result: float
    	:rtype: void
    * Perform the De Boor algorithm to evaluate a point at parameter <U>, with <Degree> and <Dimension>. Evaluates by multiplying the Poles by the Weights and gives the homogeneous result in PolesResult that is the results of the evaluation of the numerator once it has been multiplied by the weights and in WeightsResult one has the result of the evaluation of the denominator //! Warning: <PolesResult> and <WeightsResult> must be dimensionned properly.
    	:param U:
    	:type U: float
    	:param PeriodicFlag:
    	:type PeriodicFlag: bool
    	:param DerivativeRequest:
    	:type DerivativeRequest: int
    	:param ExtrapMode:
    	:type ExtrapMode: int
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param ArrayDimension:
    	:type ArrayDimension: int
    	:param Poles:
    	:type Poles: float
    	:param Weights:
    	:type Weights: float
    	:param PolesResult:
    	:type PolesResult: float
    	:param WeightsResult:
    	:type WeightsResult: float
    	:rtype: void
    * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point
    	:param U:
    	:type U: float
    	:param PeriodicFlag:
    	:type PeriodicFlag: bool
    	:param HomogeneousFlag:
    	:type HomogeneousFlag: bool
    	:param ExtrapMode:
    	:type ExtrapMode: int
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:param Point:
    	:type Point: gp_Pnt
    	:param Weight:
    	:type Weight: float
    	:rtype: void
    * Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point
    	:param U:
    	:type U: float
    	:param PeriodicFlag:
    	:type PeriodicFlag: bool
    	:param HomogeneousFlag:
    	:type HomogeneousFlag: bool
    	:param ExtrapMode:
    	:type ExtrapMode: int
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:param Point:
    	:type Point: gp_Pnt2d
    	:param Weight:
    	:type Weight: float
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Eval(*args)

def bsplclib_EvalBsplineBasis(*args) -> "Standard_Integer &":
    """
    * This evaluates the Bspline Basis at a given parameter Parameter up to the requested DerivativeOrder and store the result in the array BsplineBasis in the following fashion BSplineBasis(1,1) = value of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BsplineBasis(1,2) = value of second non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + 1 BsplineBasis(1,n) = value of second non vanishing non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + n (n <= Order) BSplineBasis(2,1) = value of derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BSplineBasis(N,1) = value of Nth derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex if N <= DerivativeOrder + 1
    	:param DerivativeOrder:
    	:type DerivativeOrder: int
    	:param Order:
    	:type Order: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Parameter:
    	:type Parameter: float
    	:param FirstNonZeroBsplineIndex:
    	:type FirstNonZeroBsplineIndex: int
    	:param BsplineBasis:
    	:type BsplineBasis: math_Matrix
    	:param isPeriodic: default value is Standard_False
    	:type isPeriodic: bool
    	:rtype: int
    """
    return _BSplCLib.bsplclib_EvalBsplineBasis(*args)

def bsplclib_FactorBandedMatrix(*args) -> "Standard_Integer &":
    """
    * this factors the Banded Matrix in the LU form with a Banded storage of components of the L matrix WARNING : do not use if the Matrix is totally positive (It is the case for Bspline matrices build as above with parameters being the Schoenberg points
    	:param Matrix:
    	:type Matrix: math_Matrix
    	:param UpperBandWidth:
    	:type UpperBandWidth: int
    	:param LowerBandWidth:
    	:type LowerBandWidth: int
    	:param PivotIndexProblem:
    	:type PivotIndexProblem: int
    	:rtype: int
    """
    return _BSplCLib.bsplclib_FactorBandedMatrix(*args)

def bsplclib_FirstUKnotIndex(*args) -> "Standard_Integer":
    """
    * Computes the index of the knots value which gives the start point of the curve.
    	:param Degree:
    	:type Degree: int
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:rtype: int
    """
    return _BSplCLib.bsplclib_FirstUKnotIndex(*args)

def bsplclib_FlatBezierKnots(*args) -> "Standard_Real const &":
    """
    * Returns pointer to statically allocated array representing flat knots for bezier curve of the specified degree. Raises OutOfRange if Degree > MaxDegree()
    	:param Degree:
    	:type Degree: int
    	:rtype: float
    """
    return _BSplCLib.bsplclib_FlatBezierKnots(*args)

def bsplclib_FlatIndex(*args) -> "Standard_Integer":
    """
    * Computes the index of the flats knots sequence corresponding to <Index> in the knots sequence which multiplicities are <Mults>.
    	:param Degree:
    	:type Degree: int
    	:param Index:
    	:type Index: int
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Periodic:
    	:type Periodic: bool
    	:rtype: int
    """
    return _BSplCLib.bsplclib_FlatIndex(*args)

def bsplclib_FunctionMultiply(*args) -> "Standard_Integer &":
    """
    * this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)
    	:param Function:
    	:type Function: BSplCLib_EvaluatorFunction
    	:param BSplineDegree:
    	:type BSplineDegree: int
    	:param BSplineFlatKnots:
    	:type BSplineFlatKnots: TColStd_Array1OfReal
    	:param PolesDimension:
    	:type PolesDimension: int
    	:param Poles:
    	:type Poles: float
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewDegree:
    	:type NewDegree: int
    	:param NewPoles:
    	:type NewPoles: float
    	:param theStatus:
    	:type theStatus: int
    	:rtype: void
    * this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)
    	:param Function:
    	:type Function: BSplCLib_EvaluatorFunction
    	:param BSplineDegree:
    	:type BSplineDegree: int
    	:param BSplineFlatKnots:
    	:type BSplineFlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewDegree:
    	:type NewDegree: int
    	:param NewPoles:
    	:type NewPoles: TColStd_Array1OfReal
    	:param theStatus:
    	:type theStatus: int
    	:rtype: void
    * this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)
    	:param Function:
    	:type Function: BSplCLib_EvaluatorFunction
    	:param BSplineDegree:
    	:type BSplineDegree: int
    	:param BSplineFlatKnots:
    	:type BSplineFlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewDegree:
    	:type NewDegree: int
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param theStatus:
    	:type theStatus: int
    	:rtype: void
    * this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)
    	:param Function:
    	:type Function: BSplCLib_EvaluatorFunction
    	:param BSplineDegree:
    	:type BSplineDegree: int
    	:param BSplineFlatKnots:
    	:type BSplineFlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewDegree:
    	:type NewDegree: int
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param theStatus:
    	:type theStatus: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_FunctionMultiply(*args)

def bsplclib_FunctionReparameterise(*args) -> "Standard_Integer &":
    """
    * This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following: //! 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots //! 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) //! Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method //! theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))
    	:param Function:
    	:type Function: BSplCLib_EvaluatorFunction
    	:param BSplineDegree:
    	:type BSplineDegree: int
    	:param BSplineFlatKnots:
    	:type BSplineFlatKnots: TColStd_Array1OfReal
    	:param PolesDimension:
    	:type PolesDimension: int
    	:param Poles:
    	:type Poles: float
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewDegree:
    	:type NewDegree: int
    	:param NewPoles:
    	:type NewPoles: float
    	:param theStatus:
    	:type theStatus: int
    	:rtype: void
    * This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following: //! 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots //! 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) //! Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method //! theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))
    	:param Function:
    	:type Function: BSplCLib_EvaluatorFunction
    	:param BSplineDegree:
    	:type BSplineDegree: int
    	:param BSplineFlatKnots:
    	:type BSplineFlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewDegree:
    	:type NewDegree: int
    	:param NewPoles:
    	:type NewPoles: TColStd_Array1OfReal
    	:param theStatus:
    	:type theStatus: int
    	:rtype: void
    * this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))
    	:param Function:
    	:type Function: BSplCLib_EvaluatorFunction
    	:param BSplineDegree:
    	:type BSplineDegree: int
    	:param BSplineFlatKnots:
    	:type BSplineFlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewDegree:
    	:type NewDegree: int
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param theStatus:
    	:type theStatus: int
    	:rtype: void
    * this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))
    	:param Function:
    	:type Function: BSplCLib_EvaluatorFunction
    	:param BSplineDegree:
    	:type BSplineDegree: int
    	:param BSplineFlatKnots:
    	:type BSplineFlatKnots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewDegree:
    	:type NewDegree: int
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param theStatus:
    	:type theStatus: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_FunctionReparameterise(*args)

def bsplclib_GetPole(*args) -> "Standard_Real &, Standard_Integer &":
    """
    * Copy the pole at position <Index> in the Boor scheme of dimension <Dimension> to <Position> in the array <Pole>. <Position> is updated.
    	:param Index:
    	:type Index: int
    	:param Length:
    	:type Length: int
    	:param Depth:
    	:type Depth: int
    	:param Dimension:
    	:type Dimension: int
    	:param LocPoles:
    	:type LocPoles: float
    	:param Position:
    	:type Position: int
    	:param Pole:
    	:type Pole: TColStd_Array1OfReal
    	:rtype: void
    """
    return _BSplCLib.bsplclib_GetPole(*args)

def bsplclib_Hunt(*args) -> "Standard_Integer &":
    """
    * This routine searches the position of the real value theX in the monotonically increasing set of real values theArray using bisection algorithm. //! If the given value is out of range or array values, algorithm returns either theArray.Lower()-1 or theArray.Upper()+1 depending on theX position in the ordered set. //! This routine is used to locate a knot value in a set of knots.
    	:param theArray:
    	:type theArray: TColStd_Array1OfReal
    	:param theX:
    	:type theX: float
    	:param theXPos:
    	:type theXPos: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Hunt(*args)

def bsplclib_IncreaseDegree(*args) -> "void":
    """
    :param Degree:
    	:type Degree: int
    	:param NewDegree:
    	:type NewDegree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Dimension:
    	:type Dimension: int
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColStd_Array1OfReal
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param NewDegree:
    	:type NewDegree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param NewDegree:
    	:type NewDegree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:rtype: void
    :param NewDegree:
    	:type NewDegree: int
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    * Increase the degree of a bspline (or bezier) curve of dimension <Dimension> form <Degree> to <NewDegree>. //! The number of poles in the new curve is : //! Poles.Length() + (NewDegree - Degree) * Number of spans //! Where the number of spans is : //! LastUKnotIndex(Mults) - FirstUKnotIndex(Mults) + 1 //! for a non-periodic curve //! And Knots.Length() - 1 for a periodic curve. //! The multiplicities of all knots are increased by the degree elevation. //! The new knots are usually the same knots with the exception of a non-periodic curve with the first and last multiplicity not equal to Degree+1 where knots are removed form the start and the bottom untils the sum of the multiplicities is equal to NewDegree+1 at the knots corresponding to the first and last parameters of the curve. //! Example : Suppose a curve of degree 3 starting with following knots and multiplicities : //! knot : 0. 1. 2. mult : 1 2 1 //! The FirstUKnot is 2. because the sum of multiplicities is Degree+1 : 1 + 2 + 1 = 4 = 3 + 1 //! i.e. the first parameter of the curve is 2. and will still be 2. after degree elevation. Let raises this curve to degree 4. The multiplicities are increased by 2. //! They become 2 3 2. But we need a sum of multiplicities of 5 at knot 2. So the first knot is removed and the new knots are : //! knot : 1. 2. mult : 3 2 //! The multipicity of the first knot may also be reduced if the sum is still to big. //! In the most common situations (periodic curve or curve with first and last multiplicities equals to Degree+1) the knots are knot changes. //! The method IncreaseDegreeCountKnots can be used to compute the new number of knots.
    	:param NewDegree:
    	:type NewDegree: int
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    """
    return _BSplCLib.bsplclib_IncreaseDegree(*args)

def bsplclib_IncreaseDegreeCountKnots(*args) -> "Standard_Integer":
    """
    * Returns the number of knots of a curve with multiplicities <Mults> after elevating the degree from <Degree> to <NewDegree>. See the IncreaseDegree method for more comments.
    	:param Degree:
    	:type Degree: int
    	:param NewDegree:
    	:type NewDegree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:rtype: int
    """
    return _BSplCLib.bsplclib_IncreaseDegreeCountKnots(*args)

def bsplclib_InsertKnot(*args) -> "void":
    """
    :param UIndex:
    	:type UIndex: int
    	:param U:
    	:type U: float
    	:param UMult:
    	:type UMult: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    * Insert a new knot U of multiplicity UMult in the knot sequence. //! The location of the new Knot should be given as an input data. UIndex locates the new knot U in the knot sequence and Knots (UIndex) < U < Knots (UIndex + 1). //! The new control points corresponding to this insertion are returned. Knots and Mults are not updated.
    	:param UIndex:
    	:type UIndex: int
    	:param U:
    	:type U: float
    	:param UMult:
    	:type UMult: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    """
    return _BSplCLib.bsplclib_InsertKnot(*args)

def bsplclib_InsertKnots(*args) -> "void":
    """
    :param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Dimension:
    	:type Dimension: int
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param AddKnots:
    	:type AddKnots: TColStd_Array1OfReal
    	:param AddMults:
    	:type AddMults: TColStd_Array1OfInteger *
    	:param NewPoles:
    	:type NewPoles: TColStd_Array1OfReal
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param Epsilon:
    	:type Epsilon: float
    	:param Add: default value is Standard_True
    	:type Add: bool
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param AddKnots:
    	:type AddKnots: TColStd_Array1OfReal
    	:param AddMults:
    	:type AddMults: TColStd_Array1OfInteger *
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param Epsilon:
    	:type Epsilon: float
    	:param Add: default value is Standard_True
    	:type Add: bool
    	:rtype: void
    * Insert a sequence of knots <AddKnots> with multiplicities <AddMults>. <AddKnots> must be a non decreasing sequence and verifies : //! Knots(Knots.Lower()) <= AddKnots(AddKnots.Lower()) Knots(Knots.Upper()) >= AddKnots(AddKnots.Upper()) //! The NewPoles and NewWeights arrays must have a length : Poles.Length() + Sum(AddMults()) //! When a knot to insert is identic to an existing knot the multiplicities are added. //! Epsilon is used to test knots for equality. //! When AddMult is negative or null the knot is not inserted. No multiplicity will becomes higher than the degree. //! The new Knots and Multiplicities are copied in <NewKnots> and <NewMults>. //! All the New arrays should be correctly dimensioned. //! When all the new knots are existing knots, i.e. only the multiplicities will change it is safe to use the same arrays as input and output.
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param AddKnots:
    	:type AddKnots: TColStd_Array1OfReal
    	:param AddMults:
    	:type AddMults: TColStd_Array1OfInteger *
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param Epsilon:
    	:type Epsilon: float
    	:param Add: default value is Standard_True
    	:type Add: bool
    	:rtype: void
    """
    return _BSplCLib.bsplclib_InsertKnots(*args)

def bsplclib_Interpolate(*args) -> "Standard_Real &, Standard_Real &, Standard_Integer &":
    """
    * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Parameters:
    	:type Parameters: TColStd_Array1OfReal
    	:param ContactOrderArray:
    	:type ContactOrderArray: TColStd_Array1OfInteger
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param InversionProblem:
    	:type InversionProblem: int
    	:rtype: void
    * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the index of the faulty pivot
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Parameters:
    	:type Parameters: TColStd_Array1OfReal
    	:param ContactOrderArray:
    	:type ContactOrderArray: TColStd_Array1OfInteger
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param InversionProblem:
    	:type InversionProblem: int
    	:rtype: void
    * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Parameters:
    	:type Parameters: TColStd_Array1OfReal
    	:param ContactOrderArray:
    	:type ContactOrderArray: TColStd_Array1OfInteger
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:param InversionProblem:
    	:type InversionProblem: int
    	:rtype: void
    * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the i
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Parameters:
    	:type Parameters: TColStd_Array1OfReal
    	:param ContactOrderArray:
    	:type ContactOrderArray: TColStd_Array1OfInteger
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:param InversionProblem:
    	:type InversionProblem: int
    	:rtype: void
    * Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is :  if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray The length of FlatKnots is Degree + L + 1 The PolesArray is an seen as an Array[1..N][1..ArrayDimension] with N = tge length of the parameters array Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot
    	:param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Parameters:
    	:type Parameters: TColStd_Array1OfReal
    	:param ContactOrderArray:
    	:type ContactOrderArray: TColStd_Array1OfInteger
    	:param ArrayDimension:
    	:type ArrayDimension: int
    	:param Poles:
    	:type Poles: float
    	:param InversionProblem:
    	:type InversionProblem: int
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Parameters:
    	:type Parameters: TColStd_Array1OfReal
    	:param ContactOrderArray:
    	:type ContactOrderArray: TColStd_Array1OfInteger
    	:param ArrayDimension:
    	:type ArrayDimension: int
    	:param Poles:
    	:type Poles: float
    	:param Weights:
    	:type Weights: float
    	:param InversionProblem:
    	:type InversionProblem: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Interpolate(*args)

def bsplclib_IsRational(*args) -> "Standard_Boolean":
    """
    * Returns False if all the weights of the array <Weights> between I1 an I2 are identic. Epsilon is used for comparing weights. If Epsilon is 0. the Epsilon of the first weight is used.
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:param I1:
    	:type I1: int
    	:param I2:
    	:type I2: int
    	:param Epsilon: default value is 0.0
    	:type Epsilon: float
    	:rtype: bool
    """
    return _BSplCLib.bsplclib_IsRational(*args)

def bsplclib_KnotAnalysis(*args) -> "Standard_Integer &":
    """
    * Analyzes the array of knots. Returns the form and the maximum knot multiplicity.
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param CKnots:
    	:type CKnots: TColStd_Array1OfReal
    	:param CMults:
    	:type CMults: TColStd_Array1OfInteger
    	:param KnotForm:
    	:type KnotForm: GeomAbs_BSplKnotDistribution
    	:param MaxKnotMult:
    	:type MaxKnotMult: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_KnotAnalysis(*args)

def bsplclib_KnotForm(*args) -> "BSplCLib_KnotDistribution":
    """
    * Analyses if the knots distribution is 'Uniform' or 'NonUniform' between the knot FromK1 and the knot ToK2. There is no repetition of knot in the knots'sequence <Knots>.
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param FromK1:
    	:type FromK1: int
    	:param ToK2:
    	:type ToK2: int
    	:rtype: BSplCLib_KnotDistribution
    """
    return _BSplCLib.bsplclib_KnotForm(*args)

def bsplclib_KnotSequence(*args) -> "void":
    """
    :param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param KnotSeq:
    	:type KnotSeq: TColStd_Array1OfReal
    	:param Periodic: default value is Standard_False
    	:type Periodic: bool
    	:rtype: void
    * Computes the sequence of knots KnotSeq with repetition of the knots of multiplicity greater than 1. //! Length of KnotSeq must be KnotSequenceLength(Mults,Degree,Periodic)
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param KnotSeq:
    	:type KnotSeq: TColStd_Array1OfReal
    	:rtype: void
    """
    return _BSplCLib.bsplclib_KnotSequence(*args)

def bsplclib_KnotSequenceLength(*args) -> "Standard_Integer":
    """
    * Returns the length of the sequence of knots with repetition. //! Periodic : //! Sum(Mults(i), i = Mults.Lower(); i <= Mults.Upper()); //! Non Periodic : //! Sum(Mults(i); i = Mults.Lower(); i < Mults.Upper()) + 2 * Degree
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:rtype: int
    """
    return _BSplCLib.bsplclib_KnotSequenceLength(*args)

def bsplclib_Knots(*args) -> "void":
    """
    * Computes the sequence of knots Knots without repetition of the knots of multiplicity greater than 1. //! Length of <Knots> and <Mults> must be KnotsLength(KnotSequence,Periodic)
    	:param KnotSeq:
    	:type KnotSeq: TColStd_Array1OfReal
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Periodic: default value is Standard_False
    	:type Periodic: bool
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Knots(*args)

def bsplclib_KnotsLength(*args) -> "Standard_Integer":
    """
    * Returns the length of the sequence of knots (and Mults) without repetition.
    	:param KnotSeq:
    	:type KnotSeq: TColStd_Array1OfReal
    	:param Periodic: default value is Standard_False
    	:type Periodic: bool
    	:rtype: int
    """
    return _BSplCLib.bsplclib_KnotsLength(*args)

def bsplclib_LastUKnotIndex(*args) -> "Standard_Integer":
    """
    * Computes the index of the knots value which gives the end point of the curve.
    	:param Degree:
    	:type Degree: int
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:rtype: int
    """
    return _BSplCLib.bsplclib_LastUKnotIndex(*args)

def bsplclib_LocateParameter(*args) -> "Standard_Integer &, Standard_Real &":
    """
    * Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies. //! Knots(Index) <= U < Knots(Index + 1) if U <= Knots (K1) then Index = K1 if U >= Knots (K2) then Index = K2 - 1 //! If Periodic is True U may be modified to fit in the range Knots(K1), Knots(K2). In any case the correct value is returned in NewU. //! Warnings :Index is used as input data to initialize the searching function. Warning: Knots have to be 'withe repetitions'
    	:param Degree:
    	:type Degree: int
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param U:
    	:type U: float
    	:param IsPeriodic:
    	:type IsPeriodic: bool
    	:param FromK1:
    	:type FromK1: int
    	:param ToK2:
    	:type ToK2: int
    	:param KnotIndex:
    	:type KnotIndex: int
    	:param NewU:
    	:type NewU: float
    	:rtype: void
    * Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies. //! Knots(Index) <= U < Knots(Index + 1) if U <= Knots (K1) then Index = K1 if U >= Knots (K2) then Index = K2 - 1 //! If Periodic is True U may be modified to fit in the range Knots(K1), Knots(K2). In any case the correct value is returned in NewU. //! Warnings :Index is used as input data to initialize the searching function. Warning: Knots have to be 'flat'
    	:param Degree:
    	:type Degree: int
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param U:
    	:type U: float
    	:param IsPeriodic:
    	:type IsPeriodic: bool
    	:param FromK1:
    	:type FromK1: int
    	:param ToK2:
    	:type ToK2: int
    	:param KnotIndex:
    	:type KnotIndex: int
    	:param NewU:
    	:type NewU: float
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger *
    	:param U:
    	:type U: float
    	:param Periodic:
    	:type Periodic: bool
    	:param Index:
    	:type Index: int
    	:param NewU:
    	:type NewU: float
    	:rtype: void
    """
    return _BSplCLib.bsplclib_LocateParameter(*args)

def bsplclib_MaxDegree(*args) -> "Standard_Integer":
    """
    * returns the degree maxima for a BSplineCurve.
    	:rtype: int
    """
    return _BSplCLib.bsplclib_MaxDegree(*args)

def bsplclib_MaxKnotMult(*args) -> "Standard_Integer":
    """
    * Finds the greatest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param K1:
    	:type K1: int
    	:param K2:
    	:type K2: int
    	:rtype: int
    """
    return _BSplCLib.bsplclib_MaxKnotMult(*args)

def bsplclib_MergeBSplineKnots(*args) -> "Standard_Integer &":
    """
    * Merges two knot vector by setting the starting and ending values to StartValue and EndValue
    	:param Tolerance:
    	:type Tolerance: float
    	:param StartValue:
    	:type StartValue: float
    	:param EndValue:
    	:type EndValue: float
    	:param Degree1:
    	:type Degree1: int
    	:param Knots1:
    	:type Knots1: TColStd_Array1OfReal
    	:param Mults1:
    	:type Mults1: TColStd_Array1OfInteger
    	:param Degree2:
    	:type Degree2: int
    	:param Knots2:
    	:type Knots2: TColStd_Array1OfReal
    	:param Mults2:
    	:type Mults2: TColStd_Array1OfInteger
    	:param NumPoles:
    	:type NumPoles: int
    	:param NewKnots:
    	:type NewKnots: TColStd_HArray1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_HArray1OfInteger
    	:rtype: void
    """
    return _BSplCLib.bsplclib_MergeBSplineKnots(*args)

def bsplclib_MinKnotMult(*args) -> "Standard_Integer":
    """
    * Finds the lowest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param K1:
    	:type K1: int
    	:param K2:
    	:type K2: int
    	:rtype: int
    """
    return _BSplCLib.bsplclib_MinKnotMult(*args)

def bsplclib_MovePoint(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -> no constraint for one side don't enter (1,NbPoles) -> error: rigid move (2, NbPoles-1) -> the ends are enforced (3, NbPoles-2) -> the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0
    	:param U:
    	:type U: float
    	:param Displ:
    	:type Displ: gp_Vec2d
    	:param Index1:
    	:type Index1: int
    	:param Index2:
    	:type Index2: int
    	:param Degree:
    	:type Degree: int
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param FirstIndex:
    	:type FirstIndex: int
    	:param LastIndex:
    	:type LastIndex: int
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:rtype: void
    * Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -> no constraint for one side don't enter (1,NbPoles) -> error: rigid move (2, NbPoles-1) -> the ends are enforced (3, NbPoles-2) -> the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0
    	:param U:
    	:type U: float
    	:param Displ:
    	:type Displ: gp_Vec
    	:param Index1:
    	:type Index1: int
    	:param Index2:
    	:type Index2: int
    	:param Degree:
    	:type Degree: int
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param FirstIndex:
    	:type FirstIndex: int
    	:param LastIndex:
    	:type LastIndex: int
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:rtype: void
    """
    return _BSplCLib.bsplclib_MovePoint(*args)

def bsplclib_MovePointAndTangent(*args) -> "Standard_Integer &":
    """
    * This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = ... Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if not NULL NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.
    	:param U:
    	:type U: float
    	:param ArrayDimension:
    	:type ArrayDimension: int
    	:param Delta:
    	:type Delta: float
    	:param DeltaDerivative:
    	:type DeltaDerivative: float
    	:param Tolerance:
    	:type Tolerance: float
    	:param Degree:
    	:type Degree: int
    	:param StartingCondition:
    	:type StartingCondition: int
    	:param EndingCondition:
    	:type EndingCondition: int
    	:param Poles:
    	:type Poles: float
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewPoles:
    	:type NewPoles: float
    	:param ErrorStatus:
    	:type ErrorStatus: int
    	:rtype: void
    * This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = ... Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if not NULL NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.
    	:param U:
    	:type U: float
    	:param Delta:
    	:type Delta: gp_Vec
    	:param DeltaDerivative:
    	:type DeltaDerivative: gp_Vec
    	:param Tolerance:
    	:type Tolerance: float
    	:param Degree:
    	:type Degree: int
    	:param StartingCondition:
    	:type StartingCondition: int
    	:param EndingCondition:
    	:type EndingCondition: int
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param ErrorStatus:
    	:type ErrorStatus: int
    	:rtype: void
    * This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = ... Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if not NULL NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.
    	:param U:
    	:type U: float
    	:param Delta:
    	:type Delta: gp_Vec2d
    	:param DeltaDerivative:
    	:type DeltaDerivative: gp_Vec2d
    	:param Tolerance:
    	:type Tolerance: float
    	:param Degree:
    	:type Degree: int
    	:param StartingCondition:
    	:type StartingCondition: int
    	:param EndingCondition:
    	:type EndingCondition: int
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param ErrorStatus:
    	:type ErrorStatus: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_MovePointAndTangent(*args)

def bsplclib_MultForm(*args) -> "BSplCLib_MultDistribution":
    """
    * Analyses the distribution of multiplicities between the knot FromK1 and the Knot ToK2.
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param FromK1:
    	:type FromK1: int
    	:param ToK2:
    	:type ToK2: int
    	:rtype: BSplCLib_MultDistribution
    """
    return _BSplCLib.bsplclib_MultForm(*args)

def bsplclib_NbPoles(*args) -> "Standard_Integer":
    """
    * Returns the number of poles of the curve. Returns 0 if one of the multiplicities is incorrect. //! * Non positive. //! * Greater than Degree, or Degree+1 at the first and last knot of a non periodic curve. //! * The last periodicity on a periodic curve is not equal to the first.
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:rtype: int
    """
    return _BSplCLib.bsplclib_NbPoles(*args)

def bsplclib_NoMults(*args) -> "TColStd_Array1OfInteger *":
    """
    * Used as argument for a flatknots evaluation.
    	:rtype: TColStd_Array1OfInteger *
    """
    return _BSplCLib.bsplclib_NoMults(*args)

def bsplclib_NoWeights(*args) -> "TColStd_Array1OfReal *":
    """
    * Used as argument for a non rational curve.
    	:rtype: TColStd_Array1OfReal *
    """
    return _BSplCLib.bsplclib_NoWeights(*args)

def bsplclib_PoleIndex(*args) -> "Standard_Integer":
    """
    * Return the index of the first Pole to use on the span Mults(Index) - Mults(Index+1). This index must be added to Poles.Lower().
    	:param Degree:
    	:type Degree: int
    	:param Index:
    	:type Index: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:rtype: int
    """
    return _BSplCLib.bsplclib_PoleIndex(*args)

def bsplclib_PolesCoefficients(*args) -> "void":
    """
    :param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param CachePoles:
    	:type CachePoles: TColgp_Array1OfPnt2d
    	:rtype: None
    :param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param CachePoles:
    	:type CachePoles: TColgp_Array1OfPnt2d
    	:param CacheWeights:
    	:type CacheWeights: TColStd_Array1OfReal *
    	:rtype: void
    :param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param CachePoles:
    	:type CachePoles: TColgp_Array1OfPnt
    	:rtype: None
    * Encapsulation of BuildCache to perform the evaluation of the Taylor expansion for beziercurves at parameter 0. Warning: To be used for Beziercurves ONLY!!!
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param CachePoles:
    	:type CachePoles: TColgp_Array1OfPnt
    	:param CacheWeights:
    	:type CacheWeights: TColStd_Array1OfReal *
    	:rtype: void
    """
    return _BSplCLib.bsplclib_PolesCoefficients(*args)

def bsplclib_PrepareInsertKnots(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * Returns in <NbPoles, NbKnots> the new number of poles and knots if the sequence of knots <AddKnots, AddMults> is inserted in the sequence <Knots, Mults>. //! Epsilon is used to compare knots for equality. //! If Add is True the multiplicities on equal knots are added. //! If Add is False the max value of the multiplicities is kept. //! Return False if : The knew knots are knot increasing. The new knots are not in the range.
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param AddKnots:
    	:type AddKnots: TColStd_Array1OfReal
    	:param AddMults:
    	:type AddMults: TColStd_Array1OfInteger *
    	:param NbPoles:
    	:type NbPoles: int
    	:param NbKnots:
    	:type NbKnots: int
    	:param Epsilon:
    	:type Epsilon: float
    	:param Add: default value is Standard_True
    	:type Add: bool
    	:rtype: bool
    """
    return _BSplCLib.bsplclib_PrepareInsertKnots(*args)

def bsplclib_PrepareTrimming(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * Set in <NbKnots> and <NbPoles> the number of Knots and Poles of the curve resulting of the trimming of the BSplinecurve definded with <degree>, <knots>, <mults>
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param NbKnots:
    	:type NbKnots: int
    	:param NbPoles:
    	:type NbPoles: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_PrepareTrimming(*args)

def bsplclib_PrepareUnperiodize(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * Set in <NbKnots> and <NbPolesToAdd> the number of Knots and Poles of the NotPeriodic Curve identical at the periodic curve with a degree <Degree> , a knots-distribution with Multiplicities <Mults>.
    	:param Degree:
    	:type Degree: int
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NbKnots:
    	:type NbKnots: int
    	:param NbPoles:
    	:type NbPoles: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_PrepareUnperiodize(*args)

def bsplclib_RaiseMultiplicity(*args) -> "void":
    """
    :param KnotIndex:
    	:type KnotIndex: int
    	:param Mult:
    	:type Mult: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    * Raise the multiplicity of knot to <UMult>. //! The new control points are returned. Knots and Mults are not updated.
    	:param KnotIndex:
    	:type KnotIndex: int
    	:param Mult:
    	:type Mult: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    """
    return _BSplCLib.bsplclib_RaiseMultiplicity(*args)

def bsplclib_RemoveKnot(*args) -> "Standard_Boolean":
    """
    :param Index:
    	:type Index: int
    	:param Mult:
    	:type Mult: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Dimension:
    	:type Dimension: int
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColStd_Array1OfReal
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param Tolerance:
    	:type Tolerance: float
    	:rtype: bool
    :param Index:
    	:type Index: int
    	:param Mult:
    	:type Mult: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param Tolerance:
    	:type Tolerance: float
    	:rtype: bool
    * Decrement the multiplicity of <Knots(Index)> to <Mult>. If <Mult> is null the knot is removed. //! As there are two ways to compute the new poles the midlle will be used as long as the distance is lower than Tolerance. //! If a distance is bigger than tolerance the methods returns False and the new arrays are not modified. //! A low tolerance can be used to test if the knot can be removed without modifying the curve. //! A high tolerance can be used to 'smooth' the curve.
    	:param Index:
    	:type Index: int
    	:param Mult:
    	:type Mult: int
    	:param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param Tolerance:
    	:type Tolerance: float
    	:rtype: bool
    """
    return _BSplCLib.bsplclib_RemoveKnot(*args)

def bsplclib_Reparametrize(*args) -> "void":
    """
    * Reparametrizes a B-spline curve to [U1, U2]. The knot values are recomputed such that Knots (Lower) = U1 and Knots (Upper) = U2 but the knot form is not modified. Warnings : In the array Knots the values must be in ascending order. U1 must not be equal to U2 to avoid division by zero.
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Reparametrize(*args)

def bsplclib_Resolution(*args) -> "Standard_Real &":
    """
    * given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | < UTolerance and we have |f (u1) - f (u0)| < Tolerance3D
    	:param PolesArray:
    	:type PolesArray: float
    	:param ArrayDimension:
    	:type ArrayDimension: int
    	:param NumPoles:
    	:type NumPoles: int
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Degree:
    	:type Degree: int
    	:param Tolerance3D:
    	:type Tolerance3D: float
    	:param UTolerance:
    	:type UTolerance: float
    	:rtype: void
    * given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | < UTolerance and we have |f (u1) - f (u0)| < Tolerance3D
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param NumPoles:
    	:type NumPoles: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Degree:
    	:type Degree: int
    	:param Tolerance3D:
    	:type Tolerance3D: float
    	:param UTolerance:
    	:type UTolerance: float
    	:rtype: void
    * given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | < UTolerance and we have |f (u1) - f (u0)| < Tolerance3D
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param NumPoles:
    	:type NumPoles: int
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param Degree:
    	:type Degree: int
    	:param Tolerance3D:
    	:type Tolerance3D: float
    	:param UTolerance:
    	:type UTolerance: float
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Resolution(*args)

def bsplclib_Reverse(*args) -> "void":
    """
    * Reverses the array knots to become the knots sequence of the reversed curve.
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:rtype: void
    * Reverses the array of multiplicities.
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:rtype: void
    * Reverses the array of poles. Last is the index of the new first pole. On a non periodic curve last is Poles.Upper(). On a periodic curve last is //! (number of flat knots - degree - 1) //! or //! (sum of multiplicities(but for the last) + degree - 1)
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Last:
    	:type Last: int
    	:rtype: void
    * Reverses the array of poles.
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Last:
    	:type Last: int
    	:rtype: void
    * Reverses the array of poles.
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:param Last:
    	:type Last: int
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Reverse(*args)

def bsplclib_SolveBandedSystem(*args) -> "Standard_Integer":
    """
    * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension
    	:param Matrix:
    	:type Matrix: math_Matrix
    	:param UpperBandWidth:
    	:type UpperBandWidth: int
    	:param LowerBandWidth:
    	:type LowerBandWidth: int
    	:param ArrayDimension:
    	:type ArrayDimension: int
    	:param Array:
    	:type Array: float
    	:rtype: int
    * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension
    	:param Matrix:
    	:type Matrix: math_Matrix
    	:param UpperBandWidth:
    	:type UpperBandWidth: int
    	:param LowerBandWidth:
    	:type LowerBandWidth: int
    	:param Array:
    	:type Array: TColgp_Array1OfPnt2d
    	:rtype: int
    * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension
    	:param Matrix:
    	:type Matrix: math_Matrix
    	:param UpperBandWidth:
    	:type UpperBandWidth: int
    	:param LowerBandWidth:
    	:type LowerBandWidth: int
    	:param Array:
    	:type Array: TColgp_Array1OfPnt
    	:rtype: int
    :param Matrix:
    	:type Matrix: math_Matrix
    	:param UpperBandWidth:
    	:type UpperBandWidth: int
    	:param LowerBandWidth:
    	:type LowerBandWidth: int
    	:param HomogenousFlag:
    	:type HomogenousFlag: bool
    	:param ArrayDimension:
    	:type ArrayDimension: int
    	:param Array:
    	:type Array: float
    	:param Weights:
    	:type Weights: float
    	:rtype: int
    * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension. If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.
    	:param Matrix:
    	:type Matrix: math_Matrix
    	:param UpperBandWidth:
    	:type UpperBandWidth: int
    	:param LowerBandWidth:
    	:type LowerBandWidth: int
    	:param HomogenousFlag:
    	:type HomogenousFlag: bool
    	:param Array:
    	:type Array: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:rtype: int
    * This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.
    	:param Matrix:
    	:type Matrix: math_Matrix
    	:param UpperBandWidth:
    	:type UpperBandWidth: int
    	:param LowerBandWidth:
    	:type LowerBandWidth: int
    	:param HomogeneousFlag:
    	:type HomogeneousFlag: bool
    	:param Array:
    	:type Array: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal
    	:rtype: int
    """
    return _BSplCLib.bsplclib_SolveBandedSystem(*args)

def bsplclib_TangExtendToConstraint(*args) -> "Standard_Real &, Standard_Integer &, Standard_Integer &, Standard_Real &, Standard_Real &":
    """
    * Extend a BSpline nD using the tangency map <C1Coefficient> is the coefficient of reparametrisation <Continuity> must be equal to 1, 2 or 3. <Degree> must be greater or equal than <Continuity> + 1. //! Warning: <KnotsResult> and <PolesResult> must be dimensionned properly.
    	:param FlatKnots:
    	:type FlatKnots: TColStd_Array1OfReal
    	:param C1Coefficient:
    	:type C1Coefficient: float
    	:param NumPoles:
    	:type NumPoles: int
    	:param Poles:
    	:type Poles: float
    	:param Dimension:
    	:type Dimension: int
    	:param Degree:
    	:type Degree: int
    	:param ConstraintPoint:
    	:type ConstraintPoint: TColStd_Array1OfReal
    	:param Continuity:
    	:type Continuity: int
    	:param After:
    	:type After: bool
    	:param NbPolesResult:
    	:type NbPolesResult: int
    	:param NbKnotsRsult:
    	:type NbKnotsRsult: int
    	:param KnotsResult:
    	:type KnotsResult: float
    	:param PolesResult:
    	:type PolesResult: float
    	:rtype: void
    """
    return _BSplCLib.bsplclib_TangExtendToConstraint(*args)

def bsplclib_Trimming(*args) -> "void":
    """
    :param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Dimension:
    	:type Dimension: int
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColStd_Array1OfReal
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param Periodic:
    	:type Periodic: bool
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Trimming(*args)

def bsplclib_Unperiodize(*args) -> "void":
    """
    :param Degree:
    	:type Degree: int
    	:param Dimension:
    	:type Dimension: int
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColStd_Array1OfReal
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewPoles:
    	:type NewPoles: TColStd_Array1OfReal
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    :param Degree:
    	:type Degree: int
    	:param Mults:
    	:type Mults: TColStd_Array1OfInteger
    	:param Knots:
    	:type Knots: TColStd_Array1OfReal
    	:param Poles:
    	:type Poles: TColgp_Array1OfPnt2d
    	:param Weights:
    	:type Weights: TColStd_Array1OfReal *
    	:param NewMults:
    	:type NewMults: TColStd_Array1OfInteger
    	:param NewKnots:
    	:type NewKnots: TColStd_Array1OfReal
    	:param NewPoles:
    	:type NewPoles: TColgp_Array1OfPnt2d
    	:param NewWeights:
    	:type NewWeights: TColStd_Array1OfReal *
    	:rtype: void
    """
    return _BSplCLib.bsplclib_Unperiodize(*args)

class BSplCLib_Cache(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor, prepares data structures for caching values on a 2d curve. \param theDegree degree of the curve \param thePeriodic identify whether the curve is periodic \param theFlatKnots knots of Bezier/B-spline curve (with repetitions) \param thePoles2d array of poles of 2D curve \param theWeights array of weights of corresponding poles
        	:param theDegree:
        	:type theDegree: int
        	:param thePeriodic:
        	:type thePeriodic: bool
        	:param theFlatKnots:
        	:type theFlatKnots: TColStd_Array1OfReal
        	:param thePoles2d:
        	:type thePoles2d: TColgp_Array1OfPnt2d
        	:param theWeights: default value is NULL
        	:type theWeights: TColStd_Array1OfReal *
        	:rtype: None
        * Constructor, prepares data structures for caching values on a 3d curve. \param theDegree degree of the curve \param thePeriodic identify whether the curve is periodic \param theFlatKnots knots of Bezier/B-spline curve (with repetitions) \param thePoles array of poles of 3D curve \param theWeights array of weights of corresponding poles
        	:param theDegree:
        	:type theDegree: int
        	:param thePeriodic:
        	:type thePeriodic: bool
        	:param theFlatKnots:
        	:type theFlatKnots: TColStd_Array1OfReal
        	:param thePoles:
        	:type thePoles: TColgp_Array1OfPnt
        	:param theWeights: default value is NULL
        	:type theWeights: TColStd_Array1OfReal *
        	:rtype: None
        """
        _BSplCLib.BSplCLib_Cache_swiginit(self, _BSplCLib.new_BSplCLib_Cache(*args))

    def BuildCache(self, *args) -> "void":
        """
        * Recomputes the cache data for 2D curves. Does not verify validity of the cache \param theParameter the value on the knot's axis to identify the span \param theFlatKnots knots of Bezier/B-spline curve (with repetitions) \param thePoles2d array of poles of 2D curve \param theWeights array of weights of corresponding poles
        	:param theParameter:
        	:type theParameter: float
        	:param theFlatKnots:
        	:type theFlatKnots: TColStd_Array1OfReal
        	:param thePoles2d:
        	:type thePoles2d: TColgp_Array1OfPnt2d
        	:param theWeights:
        	:type theWeights: TColStd_Array1OfReal *
        	:rtype: None
        * Recomputes the cache data for 3D curves. Does not verify validity of the cache \param theParameter the value on the knot's axis to identify the span \param theFlatKnots knots of Bezier/B-spline curve (with repetitions) \param thePoles array of poles of 3D curve \param theWeights array of weights of corresponding poles
        	:param theParameter:
        	:type theParameter: float
        	:param theFlatKnots:
        	:type theFlatKnots: TColStd_Array1OfReal
        	:param thePoles:
        	:type thePoles: TColgp_Array1OfPnt
        	:param theWeights: default value is NULL
        	:type theWeights: TColStd_Array1OfReal *
        	:rtype: None
        """
        return _BSplCLib.BSplCLib_Cache_BuildCache(self, *args)


    def D0(self, *args) -> "void":
        """
        * Calculates the point on the curve in the specified parameter \param[in] theParameter parameter of calculation of the value \param[out] thePoint the result of calculation (the point on the curve)
        	:param theParameter:
        	:type theParameter: float
        	:param thePoint:
        	:type thePoint: gp_Pnt2d
        	:rtype: None
        :param theParameter:
        	:type theParameter: float
        	:param thePoint:
        	:type thePoint: gp_Pnt
        	:rtype: None
        """
        return _BSplCLib.BSplCLib_Cache_D0(self, *args)


    def D1(self, *args) -> "void":
        """
        * Calculates the point on the curve and its first derivative in the specified parameter \param[in] theParameter parameter of calculation of the value \param[out] thePoint the result of calculation (the point on the curve) \param[out] theTangent tangent vector (first derivatives) for the curve in the calculated point
        	:param theParameter:
        	:type theParameter: float
        	:param thePoint:
        	:type thePoint: gp_Pnt2d
        	:param theTangent:
        	:type theTangent: gp_Vec2d
        	:rtype: None
        :param theParameter:
        	:type theParameter: float
        	:param thePoint:
        	:type thePoint: gp_Pnt
        	:param theTangent:
        	:type theTangent: gp_Vec
        	:rtype: None
        """
        return _BSplCLib.BSplCLib_Cache_D1(self, *args)


    def D2(self, *args) -> "void":
        """
        * Calculates the point on the curve and two derivatives in the specified parameter \param[in] theParameter parameter of calculation of the value \param[out] thePoint the result of calculation (the point on the curve) \param[out] theTangent tangent vector (1st derivatives) for the curve in the calculated point \param[out] theCurvature curvature vector (2nd derivatives) for the curve in the calculated point
        	:param theParameter:
        	:type theParameter: float
        	:param thePoint:
        	:type thePoint: gp_Pnt2d
        	:param theTangent:
        	:type theTangent: gp_Vec2d
        	:param theCurvature:
        	:type theCurvature: gp_Vec2d
        	:rtype: None
        :param theParameter:
        	:type theParameter: float
        	:param thePoint:
        	:type thePoint: gp_Pnt
        	:param theTangent:
        	:type theTangent: gp_Vec
        	:param theCurvature:
        	:type theCurvature: gp_Vec
        	:rtype: None
        """
        return _BSplCLib.BSplCLib_Cache_D2(self, *args)


    def D3(self, *args) -> "void":
        """
        * Calculates the point on the curve and three derivatives in the specified parameter \param[in] theParameter parameter of calculation of the value \param[out] thePoint the result of calculation (the point on the curve) \param[out] theTangent tangent vector (1st derivatives) for the curve in the calculated point \param[out] theCurvature curvature vector (2nd derivatives) for the curve in the calculated point \param[out] theTorsion second curvature vector (3rd derivatives) for the curve in the calculated point
        	:param theParameter:
        	:type theParameter: float
        	:param thePoint:
        	:type thePoint: gp_Pnt2d
        	:param theTangent:
        	:type theTangent: gp_Vec2d
        	:param theCurvature:
        	:type theCurvature: gp_Vec2d
        	:param theTorsion:
        	:type theTorsion: gp_Vec2d
        	:rtype: None
        :param theParameter:
        	:type theParameter: float
        	:param thePoint:
        	:type thePoint: gp_Pnt
        	:param theTangent:
        	:type theTangent: gp_Vec
        	:param theCurvature:
        	:type theCurvature: gp_Vec
        	:param theTorsion:
        	:type theTorsion: gp_Vec
        	:rtype: None
        """
        return _BSplCLib.BSplCLib_Cache_D3(self, *args)


    def IsCacheValid(self, *args) -> "Standard_Boolean":
        """
        * Verifies validity of the cache using flat parameter of the point \param theParameter parameter of the point placed in the span
        	:param theParameter:
        	:type theParameter: float
        	:rtype: bool
        """
        return _BSplCLib.BSplCLib_Cache_IsCacheValid(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_BSplCLib_Cache_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _BSplCLib.delete_BSplCLib_Cache
BSplCLib_Cache.BuildCache = new_instancemethod(_BSplCLib.BSplCLib_Cache_BuildCache, None, BSplCLib_Cache)
BSplCLib_Cache.D0 = new_instancemethod(_BSplCLib.BSplCLib_Cache_D0, None, BSplCLib_Cache)
BSplCLib_Cache.D1 = new_instancemethod(_BSplCLib.BSplCLib_Cache_D1, None, BSplCLib_Cache)
BSplCLib_Cache.D2 = new_instancemethod(_BSplCLib.BSplCLib_Cache_D2, None, BSplCLib_Cache)
BSplCLib_Cache.D3 = new_instancemethod(_BSplCLib.BSplCLib_Cache_D3, None, BSplCLib_Cache)
BSplCLib_Cache.IsCacheValid = new_instancemethod(_BSplCLib.BSplCLib_Cache_IsCacheValid, None, BSplCLib_Cache)
BSplCLib_Cache_swigregister = _BSplCLib.BSplCLib_Cache_swigregister
BSplCLib_Cache_swigregister(BSplCLib_Cache)

class BSplCLib_CacheParams(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SpanStart = _swig_property(_BSplCLib.BSplCLib_CacheParams_SpanStart_get, _BSplCLib.BSplCLib_CacheParams_SpanStart_set)
    SpanLength = _swig_property(_BSplCLib.BSplCLib_CacheParams_SpanLength_get, _BSplCLib.BSplCLib_CacheParams_SpanLength_set)
    SpanIndex = _swig_property(_BSplCLib.BSplCLib_CacheParams_SpanIndex_get, _BSplCLib.BSplCLib_CacheParams_SpanIndex_set)

    def __init__(self, *args):
        """
        * ///< index of the span Constructor, prepares data structures for caching. \param theDegree degree of the B-spline (or Bezier) \param thePeriodic identify whether the B-spline is periodic \param theFlatKnots knots of Bezier / B-spline parameterization
        	:param theDegree:
        	:type theDegree: int
        	:param thePeriodic:
        	:type thePeriodic: bool
        	:param theFlatKnots:
        	:type theFlatKnots: TColStd_Array1OfReal
        	:rtype: None
        """
        _BSplCLib.BSplCLib_CacheParams_swiginit(self, _BSplCLib.new_BSplCLib_CacheParams(*args))

    def IsCacheValid(self, *args) -> "Standard_Boolean":
        """
        * Verifies validity of the cache using flat parameter of the point \param theParameter parameter of the point placed in the span
        	:param theParameter:
        	:type theParameter: float
        	:rtype: bool
        """
        return _BSplCLib.BSplCLib_CacheParams_IsCacheValid(self, *args)


    def LocateParameter(self, *args) -> "void":
        """
        * Computes span for the specified parameter \param theParameter parameter of the point placed in the span \param theFlatKnots knots of Bezier / B-spline parameterization
        	:param theParameter:
        	:type theParameter: float
        	:param theFlatKnots:
        	:type theFlatKnots: TColStd_Array1OfReal
        	:rtype: None
        """
        return _BSplCLib.BSplCLib_CacheParams_LocateParameter(self, *args)


    def PeriodicNormalization(self, *args) -> "Standard_Real":
        """
        * Normalizes the parameter for periodic B-splines \param theParameter the value to be normalized into the knots array
        	:param theParameter:
        	:type theParameter: float
        	:rtype: float
        """
        return _BSplCLib.BSplCLib_CacheParams_PeriodicNormalization(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BSplCLib.delete_BSplCLib_CacheParams
BSplCLib_CacheParams.IsCacheValid = new_instancemethod(_BSplCLib.BSplCLib_CacheParams_IsCacheValid, None, BSplCLib_CacheParams)
BSplCLib_CacheParams.LocateParameter = new_instancemethod(_BSplCLib.BSplCLib_CacheParams_LocateParameter, None, BSplCLib_CacheParams)
BSplCLib_CacheParams.PeriodicNormalization = new_instancemethod(_BSplCLib.BSplCLib_CacheParams_PeriodicNormalization, None, BSplCLib_CacheParams)
BSplCLib_CacheParams_swigregister = _BSplCLib.BSplCLib_CacheParams_swigregister
BSplCLib_CacheParams_swigregister(BSplCLib_CacheParams)



