# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Blend module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_blend.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Blend.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Blend')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Blend')
    _Blend = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Blend', [dirname(__file__)])
        except ImportError:
            import _Blend
            return _Blend
        try:
            _mod = imp.load_module('_Blend', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Blend = swig_import_helper()
    del swig_import_helper
else:
    import _Blend
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Blend.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Blend.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Blend.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Blend.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Blend.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Blend.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Blend.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Blend.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Blend.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Blend.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Blend.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Blend.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Blend.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Blend.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Blend.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Blend.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Blend.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Blend.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _Blend.process_exception(error, method_name, class_name)
process_exception = _Blend.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.math
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
Blend_StepTooLarge = _Blend.Blend_StepTooLarge
Blend_StepTooSmall = _Blend.Blend_StepTooSmall
Blend_Backward = _Blend.Blend_Backward
Blend_SamePoints = _Blend.Blend_SamePoints
Blend_OnRst1 = _Blend.Blend_OnRst1
Blend_OnRst2 = _Blend.Blend_OnRst2
Blend_OnRst12 = _Blend.Blend_OnRst12
Blend_OK = _Blend.Blend_OK
Blend_NoDecroch = _Blend.Blend_NoDecroch
Blend_DecrochRst1 = _Blend.Blend_DecrochRst1
Blend_DecrochRst2 = _Blend.Blend_DecrochRst2
Blend_DecrochBoth = _Blend.Blend_DecrochBoth
class Blend_SequenceOfPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Blend.Blend_SequenceOfPoint_swiginit(self, _Blend.new_Blend_SequenceOfPoint(*args))
    delNode = staticmethod(_Blend.Blend_SequenceOfPoint_delNode)
    __swig_destroy__ = _Blend.delete_Blend_SequenceOfPoint
Blend_SequenceOfPoint.begin = new_instancemethod(_Blend.Blend_SequenceOfPoint_begin, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.end = new_instancemethod(_Blend.Blend_SequenceOfPoint_end, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.cbegin = new_instancemethod(_Blend.Blend_SequenceOfPoint_cbegin, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.cend = new_instancemethod(_Blend.Blend_SequenceOfPoint_cend, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Size = new_instancemethod(_Blend.Blend_SequenceOfPoint_Size, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Length = new_instancemethod(_Blend.Blend_SequenceOfPoint_Length, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Lower = new_instancemethod(_Blend.Blend_SequenceOfPoint_Lower, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Upper = new_instancemethod(_Blend.Blend_SequenceOfPoint_Upper, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.IsEmpty = new_instancemethod(_Blend.Blend_SequenceOfPoint_IsEmpty, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Reverse = new_instancemethod(_Blend.Blend_SequenceOfPoint_Reverse, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Exchange = new_instancemethod(_Blend.Blend_SequenceOfPoint_Exchange, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Clear = new_instancemethod(_Blend.Blend_SequenceOfPoint_Clear, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Assign = new_instancemethod(_Blend.Blend_SequenceOfPoint_Assign, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Set = new_instancemethod(_Blend.Blend_SequenceOfPoint_Set, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Remove = new_instancemethod(_Blend.Blend_SequenceOfPoint_Remove, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Append = new_instancemethod(_Blend.Blend_SequenceOfPoint_Append, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Prepend = new_instancemethod(_Blend.Blend_SequenceOfPoint_Prepend, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.InsertBefore = new_instancemethod(_Blend.Blend_SequenceOfPoint_InsertBefore, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.InsertAfter = new_instancemethod(_Blend.Blend_SequenceOfPoint_InsertAfter, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Split = new_instancemethod(_Blend.Blend_SequenceOfPoint_Split, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.First = new_instancemethod(_Blend.Blend_SequenceOfPoint_First, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.ChangeFirst = new_instancemethod(_Blend.Blend_SequenceOfPoint_ChangeFirst, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Last = new_instancemethod(_Blend.Blend_SequenceOfPoint_Last, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.ChangeLast = new_instancemethod(_Blend.Blend_SequenceOfPoint_ChangeLast, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Value = new_instancemethod(_Blend.Blend_SequenceOfPoint_Value, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.ChangeValue = new_instancemethod(_Blend.Blend_SequenceOfPoint_ChangeValue, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.__call__ = new_instancemethod(_Blend.Blend_SequenceOfPoint___call__, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint.SetValue = new_instancemethod(_Blend.Blend_SequenceOfPoint_SetValue, None, Blend_SequenceOfPoint)
Blend_SequenceOfPoint_swigregister = _Blend.Blend_SequenceOfPoint_swigregister
Blend_SequenceOfPoint_swigregister(Blend_SequenceOfPoint)

def Blend_SequenceOfPoint_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _Blend.Blend_SequenceOfPoint_delNode(theNode, theAl)
Blend_SequenceOfPoint_delNode = _Blend.Blend_SequenceOfPoint_delNode

class Blend_AppFunction(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetBounds(self, *args) -> "void":
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 4 variables. Returns in the vector SupBound the greatest values allowed for each of the 4 variables.
        	:param InfBound:
        	:type InfBound: math_Vector
        	:param SupBound:
        	:type SupBound: math_Vector
        	:rtype: void
        """
        return _Blend.Blend_AppFunction_GetBounds(self, *args)


    def GetMinimalDistance(self, *args) -> "Standard_Real":
        """
        * Returns the minimal Distance beetween two extremitys of calculed sections.
        	:rtype: float
        """
        return _Blend.Blend_AppFunction_GetMinimalDistance(self, *args)


    def GetMinimalWeight(self, *args) -> "void":
        """
        * Compute the minimal value of weight for each poles of all sections.
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        """
        return _Blend.Blend_AppFunction_GetMinimalWeight(self, *args)


    def GetSectionSize(self, *args) -> "Standard_Real":
        """
        * Returns the length of the maximum section
        	:rtype: float
        """
        return _Blend.Blend_AppFunction_GetSectionSize(self, *args)


    def GetShape(self, *args) -> "void":
        """
        :param NbPoles:
        	:type NbPoles: int
        	:param NbKnots:
        	:type NbKnots: int
        	:param Degree:
        	:type Degree: int
        	:param NbPoles2d:
        	:type NbPoles2d: int
        	:rtype: void
        """
        return _Blend.Blend_AppFunction_GetShape(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 4 variables; Tol is the tolerance used in 3d space.
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: void
        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.
        	:param BoundTol:
        	:type BoundTol: float
        	:param SurfTol:
        	:type SurfTol: float
        	:param AngleTol:
        	:type AngleTol: float
        	:param Tol3d:
        	:type Tol3d: math_Vector
        	:param Tol1D:
        	:type Tol1D: math_Vector
        	:rtype: void
        """
        return _Blend.Blend_AppFunction_GetTolerance(self, *args)


    def Intervals(self, *args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals() raises OutOfRange from Standard
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: void
        """
        return _Blend.Blend_AppFunction_Intervals(self, *args)


    def IsRational(self, *args) -> "Standard_Boolean":
        """
        * Returns if the section is rationnal
        	:rtype: bool
        """
        return _Blend.Blend_AppFunction_IsRational(self, *args)


    def IsSolution(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space. The computation is made at the current value of the parameter on the guide line.
        	:param Sol:
        	:type Sol: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: bool
        """
        return _Blend.Blend_AppFunction_IsSolution(self, *args)


    def Knots(self, *args) -> "void":
        """
        :param TKnots:
        	:type TKnots: TColStd_Array1OfReal
        	:rtype: void
        """
        return _Blend.Blend_AppFunction_Knots(self, *args)


    def Mults(self, *args) -> "void":
        """
        :param TMults:
        	:type TMults: TColStd_Array1OfInteger
        	:rtype: void
        """
        return _Blend.Blend_AppFunction_Mults(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _Blend.Blend_AppFunction_NbIntervals(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        * Returns the parameter of the point P. Used to impose the parameters in the approximation.
        	:param P:
        	:type P: Blend_Point
        	:rtype: float
        """
        return _Blend.Blend_AppFunction_Parameter(self, *args)


    def Pnt1(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the first support.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_AppFunction_Pnt1(self, *args)


    def Pnt2(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the first support.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_AppFunction_Pnt2(self, *args)


    def Resolution(self, *args) -> "void":
        """
        :param IC2d:
        	:type IC2d: int
        	:param Tol:
        	:type Tol: float
        	:param TolU:
        	:type TolU: float
        	:param TolV:
        	:type TolV: float
        	:rtype: void
        """
        return _Blend.Blend_AppFunction_Resolution(self, *args)


    def Section(self, *args) -> "Standard_Boolean":
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.
        	:param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:rtype: bool
        :param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.
        	:param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param D2Poles2d:
        	:type D2Poles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:param D2Weigths:
        	:type D2Weigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Blend.Blend_AppFunction_Section(self, *args)


    def Set(self, *args) -> "void":
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.
        	:param Param:
        	:type Param: float
        	:rtype: void
        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _Blend.Blend_AppFunction_Set(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_AppFunction
Blend_AppFunction.GetBounds = new_instancemethod(_Blend.Blend_AppFunction_GetBounds, None, Blend_AppFunction)
Blend_AppFunction.GetMinimalDistance = new_instancemethod(_Blend.Blend_AppFunction_GetMinimalDistance, None, Blend_AppFunction)
Blend_AppFunction.GetMinimalWeight = new_instancemethod(_Blend.Blend_AppFunction_GetMinimalWeight, None, Blend_AppFunction)
Blend_AppFunction.GetSectionSize = new_instancemethod(_Blend.Blend_AppFunction_GetSectionSize, None, Blend_AppFunction)
Blend_AppFunction.GetShape = new_instancemethod(_Blend.Blend_AppFunction_GetShape, None, Blend_AppFunction)
Blend_AppFunction.GetTolerance = new_instancemethod(_Blend.Blend_AppFunction_GetTolerance, None, Blend_AppFunction)
Blend_AppFunction.Intervals = new_instancemethod(_Blend.Blend_AppFunction_Intervals, None, Blend_AppFunction)
Blend_AppFunction.IsRational = new_instancemethod(_Blend.Blend_AppFunction_IsRational, None, Blend_AppFunction)
Blend_AppFunction.IsSolution = new_instancemethod(_Blend.Blend_AppFunction_IsSolution, None, Blend_AppFunction)
Blend_AppFunction.Knots = new_instancemethod(_Blend.Blend_AppFunction_Knots, None, Blend_AppFunction)
Blend_AppFunction.Mults = new_instancemethod(_Blend.Blend_AppFunction_Mults, None, Blend_AppFunction)
Blend_AppFunction.NbIntervals = new_instancemethod(_Blend.Blend_AppFunction_NbIntervals, None, Blend_AppFunction)
Blend_AppFunction.Parameter = new_instancemethod(_Blend.Blend_AppFunction_Parameter, None, Blend_AppFunction)
Blend_AppFunction.Pnt1 = new_instancemethod(_Blend.Blend_AppFunction_Pnt1, None, Blend_AppFunction)
Blend_AppFunction.Pnt2 = new_instancemethod(_Blend.Blend_AppFunction_Pnt2, None, Blend_AppFunction)
Blend_AppFunction.Resolution = new_instancemethod(_Blend.Blend_AppFunction_Resolution, None, Blend_AppFunction)
Blend_AppFunction.Section = new_instancemethod(_Blend.Blend_AppFunction_Section, None, Blend_AppFunction)
Blend_AppFunction.Set = new_instancemethod(_Blend.Blend_AppFunction_Set, None, Blend_AppFunction)
Blend_AppFunction_swigregister = _Blend.Blend_AppFunction_swigregister
Blend_AppFunction_swigregister(Blend_AppFunction)

class Blend_CurvPointFuncInv(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetBounds(self, *args) -> "void":
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 3 variables. Returns in the vector SupBound the greatest values allowed for each of the 3 variables.
        	:param InfBound:
        	:type InfBound: math_Vector
        	:param SupBound:
        	:type SupBound: math_Vector
        	:rtype: void
        """
        return _Blend.Blend_CurvPointFuncInv_GetBounds(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: void
        """
        return _Blend.Blend_CurvPointFuncInv_GetTolerance(self, *args)


    def IsSolution(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.
        	:param Sol:
        	:type Sol: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: bool
        """
        return _Blend.Blend_CurvPointFuncInv_IsSolution(self, *args)


    def Set(self, *args) -> "void":
        """
        * Set the Point on which a solution has to be found.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: void
        """
        return _Blend.Blend_CurvPointFuncInv_Set(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_CurvPointFuncInv
Blend_CurvPointFuncInv.GetBounds = new_instancemethod(_Blend.Blend_CurvPointFuncInv_GetBounds, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.GetTolerance = new_instancemethod(_Blend.Blend_CurvPointFuncInv_GetTolerance, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.IsSolution = new_instancemethod(_Blend.Blend_CurvPointFuncInv_IsSolution, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.Set = new_instancemethod(_Blend.Blend_CurvPointFuncInv_Set, None, Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv_swigregister = _Blend.Blend_CurvPointFuncInv_swigregister
Blend_CurvPointFuncInv_swigregister(Blend_CurvPointFuncInv)

class Blend_FuncInv(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetBounds(self, *args) -> "void":
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 4 variables. Returns in the vector SupBound the greatest values allowed for each of the 4 variables.
        	:param InfBound:
        	:type InfBound: math_Vector
        	:param SupBound:
        	:type SupBound: math_Vector
        	:rtype: void
        """
        return _Blend.Blend_FuncInv_GetBounds(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 4 variables; Tol is the tolerance used in 3d space.
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: void
        """
        return _Blend.Blend_FuncInv_GetTolerance(self, *args)


    def IsSolution(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.
        	:param Sol:
        	:type Sol: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: bool
        """
        return _Blend.Blend_FuncInv_IsSolution(self, *args)


    def Set(self, *args) -> "void":
        """
        * Sets the CurveOnSurface on which a solution has to be found. If <OnFirst> is set to Standard_True, the curve will be on the first surface, otherwise the curve is on the second one.
        	:param OnFirst:
        	:type OnFirst: bool
        	:param COnSurf:
        	:type COnSurf: Adaptor2d_HCurve2d
        	:rtype: void
        """
        return _Blend.Blend_FuncInv_Set(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_FuncInv
Blend_FuncInv.GetBounds = new_instancemethod(_Blend.Blend_FuncInv_GetBounds, None, Blend_FuncInv)
Blend_FuncInv.GetTolerance = new_instancemethod(_Blend.Blend_FuncInv_GetTolerance, None, Blend_FuncInv)
Blend_FuncInv.IsSolution = new_instancemethod(_Blend.Blend_FuncInv_IsSolution, None, Blend_FuncInv)
Blend_FuncInv.Set = new_instancemethod(_Blend.Blend_FuncInv_Set, None, Blend_FuncInv)
Blend_FuncInv_swigregister = _Blend.Blend_FuncInv_swigregister
Blend_FuncInv_swigregister(Blend_FuncInv)

class Blend_Point(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        * Creates a point on 2 surfaces, with tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param Tg1:
        	:type Tg1: gp_Vec
        	:param Tg2:
        	:type Tg2: gp_Vec
        	:param Tg12d:
        	:type Tg12d: gp_Vec2d
        	:param Tg22d:
        	:type Tg22d: gp_Vec2d
        	:rtype: None
        * Creates a point on 2 surfaces, without tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        * Creates a point on a surface and a curve, with tangents.
        	:param Pts:
        	:type Pts: gp_Pnt
        	:param Ptc:
        	:type Ptc: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:param Tgs:
        	:type Tgs: gp_Vec
        	:param Tgc:
        	:type Tgc: gp_Vec
        	:param Tg2d:
        	:type Tg2d: gp_Vec2d
        	:rtype: None
        * Creates a point on a surface and a curve, without tangents.
        	:param Pts:
        	:type Pts: gp_Pnt
        	:param Ptc:
        	:type Ptc: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:rtype: None
        * Creates a point on a surface and a curve on surface, with tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param PC:
        	:type PC: float
        	:param Tg1:
        	:type Tg1: gp_Vec
        	:param Tg2:
        	:type Tg2: gp_Vec
        	:param Tg12d:
        	:type Tg12d: gp_Vec2d
        	:param Tg22d:
        	:type Tg22d: gp_Vec2d
        	:rtype: None
        * Creates a point on a surface and a curve on surface, without tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param PC:
        	:type PC: float
        	:rtype: None
        * Creates a point on two curves on surfaces, with tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param PC1:
        	:type PC1: float
        	:param PC2:
        	:type PC2: float
        	:param Tg1:
        	:type Tg1: gp_Vec
        	:param Tg2:
        	:type Tg2: gp_Vec
        	:param Tg12d:
        	:type Tg12d: gp_Vec2d
        	:param Tg22d:
        	:type Tg22d: gp_Vec2d
        	:rtype: None
        * Creates a point on two curves on surfaces, with tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param PC1:
        	:type PC1: float
        	:param PC2:
        	:type PC2: float
        	:rtype: None
        """
        _Blend.Blend_Point_swiginit(self, _Blend.new_Blend_Point(*args))

    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if it was not possible to compute the tangent vectors at PointOnS1 and/or PointOnS2.
        	:rtype: bool
        """
        return _Blend.Blend_Point_IsTangencyPoint(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Blend.Blend_Point_Parameter(self, *args)


    def ParameterOnC(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Blend.Blend_Point_ParameterOnC(self, *args)


    def ParameterOnC1(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Blend.Blend_Point_ParameterOnC1(self, *args)


    def ParameterOnC2(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _Blend.Blend_Point_ParameterOnC2(self, *args)


    def ParametersOnS(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _Blend.Blend_Point_ParametersOnS(self, *args)


    def ParametersOnS1(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _Blend.Blend_Point_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _Blend.Blend_Point_ParametersOnS2(self, *args)


    def PointOnC(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _Blend.Blend_Point_PointOnC(self, *args)


    def PointOnC1(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _Blend.Blend_Point_PointOnC1(self, *args)


    def PointOnC2(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _Blend.Blend_Point_PointOnC2(self, *args)


    def PointOnS(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _Blend.Blend_Point_PointOnS(self, *args)


    def PointOnS1(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _Blend.Blend_Point_PointOnS1(self, *args)


    def PointOnS2(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _Blend.Blend_Point_PointOnS2(self, *args)


    def SetParameter(self, *args) -> "void":
        """
        * Changes parameter on existing point
        	:param Param:
        	:type Param: float
        	:rtype: None
        """
        return _Blend.Blend_Point_SetParameter(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Set the values for a point on 2 surfaces, with tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param Tg1:
        	:type Tg1: gp_Vec
        	:param Tg2:
        	:type Tg2: gp_Vec
        	:param Tg12d:
        	:type Tg12d: gp_Vec2d
        	:param Tg22d:
        	:type Tg22d: gp_Vec2d
        	:rtype: None
        * Set the values for a point on 2 surfaces, without tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        * Set the values for a point on a surface and a curve, with tangents.
        	:param Pts:
        	:type Pts: gp_Pnt
        	:param Ptc:
        	:type Ptc: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:param Tgs:
        	:type Tgs: gp_Vec
        	:param Tgc:
        	:type Tgc: gp_Vec
        	:param Tg2d:
        	:type Tg2d: gp_Vec2d
        	:rtype: None
        * Set the values for a point on a surface and a curve, without tangents.
        	:param Pts:
        	:type Pts: gp_Pnt
        	:param Ptc:
        	:type Ptc: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:rtype: None
        * Creates a point on a surface and a curve on surface, with tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param PC:
        	:type PC: float
        	:param Tg1:
        	:type Tg1: gp_Vec
        	:param Tg2:
        	:type Tg2: gp_Vec
        	:param Tg12d:
        	:type Tg12d: gp_Vec2d
        	:param Tg22d:
        	:type Tg22d: gp_Vec2d
        	:rtype: None
        * Creates a point on a surface and a curve on surface, without tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param PC:
        	:type PC: float
        	:rtype: None
        * Creates a point on two curves on surfaces, with tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param PC1:
        	:type PC1: float
        	:param PC2:
        	:type PC2: float
        	:param Tg1:
        	:type Tg1: gp_Vec
        	:param Tg2:
        	:type Tg2: gp_Vec
        	:param Tg12d:
        	:type Tg12d: gp_Vec2d
        	:param Tg22d:
        	:type Tg22d: gp_Vec2d
        	:rtype: None
        * Creates a point on two curves on surfaces, without tangents.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param PC1:
        	:type PC1: float
        	:param PC2:
        	:type PC2: float
        	:rtype: None
        * Creates a point on two curves.
        	:param Pt1:
        	:type Pt1: gp_Pnt
        	:param Pt2:
        	:type Pt2: gp_Pnt
        	:param Param:
        	:type Param: float
        	:param PC1:
        	:type PC1: float
        	:param PC2:
        	:type PC2: float
        	:rtype: None
        """
        return _Blend.Blend_Point_SetValue(self, *args)


    def Tangent2d(self, *args) -> "gp_Vec2d":
        """:rtype: gp_Vec2d"""
        return _Blend.Blend_Point_Tangent2d(self, *args)


    def Tangent2dOnS1(self, *args) -> "gp_Vec2d":
        """:rtype: gp_Vec2d"""
        return _Blend.Blend_Point_Tangent2dOnS1(self, *args)


    def Tangent2dOnS2(self, *args) -> "gp_Vec2d":
        """:rtype: gp_Vec2d"""
        return _Blend.Blend_Point_Tangent2dOnS2(self, *args)


    def TangentOnC(self, *args) -> "gp_Vec const":
        """:rtype: gp_Vec"""
        return _Blend.Blend_Point_TangentOnC(self, *args)


    def TangentOnC1(self, *args) -> "gp_Vec const":
        """:rtype: gp_Vec"""
        return _Blend.Blend_Point_TangentOnC1(self, *args)


    def TangentOnC2(self, *args) -> "gp_Vec const":
        """:rtype: gp_Vec"""
        return _Blend.Blend_Point_TangentOnC2(self, *args)


    def TangentOnS(self, *args) -> "gp_Vec const":
        """:rtype: gp_Vec"""
        return _Blend.Blend_Point_TangentOnS(self, *args)


    def TangentOnS1(self, *args) -> "gp_Vec const":
        """:rtype: gp_Vec"""
        return _Blend.Blend_Point_TangentOnS1(self, *args)


    def TangentOnS2(self, *args) -> "gp_Vec const":
        """:rtype: gp_Vec"""
        return _Blend.Blend_Point_TangentOnS2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_Point
Blend_Point.IsTangencyPoint = new_instancemethod(_Blend.Blend_Point_IsTangencyPoint, None, Blend_Point)
Blend_Point.Parameter = new_instancemethod(_Blend.Blend_Point_Parameter, None, Blend_Point)
Blend_Point.ParameterOnC = new_instancemethod(_Blend.Blend_Point_ParameterOnC, None, Blend_Point)
Blend_Point.ParameterOnC1 = new_instancemethod(_Blend.Blend_Point_ParameterOnC1, None, Blend_Point)
Blend_Point.ParameterOnC2 = new_instancemethod(_Blend.Blend_Point_ParameterOnC2, None, Blend_Point)
Blend_Point.ParametersOnS = new_instancemethod(_Blend.Blend_Point_ParametersOnS, None, Blend_Point)
Blend_Point.ParametersOnS1 = new_instancemethod(_Blend.Blend_Point_ParametersOnS1, None, Blend_Point)
Blend_Point.ParametersOnS2 = new_instancemethod(_Blend.Blend_Point_ParametersOnS2, None, Blend_Point)
Blend_Point.PointOnC = new_instancemethod(_Blend.Blend_Point_PointOnC, None, Blend_Point)
Blend_Point.PointOnC1 = new_instancemethod(_Blend.Blend_Point_PointOnC1, None, Blend_Point)
Blend_Point.PointOnC2 = new_instancemethod(_Blend.Blend_Point_PointOnC2, None, Blend_Point)
Blend_Point.PointOnS = new_instancemethod(_Blend.Blend_Point_PointOnS, None, Blend_Point)
Blend_Point.PointOnS1 = new_instancemethod(_Blend.Blend_Point_PointOnS1, None, Blend_Point)
Blend_Point.PointOnS2 = new_instancemethod(_Blend.Blend_Point_PointOnS2, None, Blend_Point)
Blend_Point.SetParameter = new_instancemethod(_Blend.Blend_Point_SetParameter, None, Blend_Point)
Blend_Point.SetValue = new_instancemethod(_Blend.Blend_Point_SetValue, None, Blend_Point)
Blend_Point.Tangent2d = new_instancemethod(_Blend.Blend_Point_Tangent2d, None, Blend_Point)
Blend_Point.Tangent2dOnS1 = new_instancemethod(_Blend.Blend_Point_Tangent2dOnS1, None, Blend_Point)
Blend_Point.Tangent2dOnS2 = new_instancemethod(_Blend.Blend_Point_Tangent2dOnS2, None, Blend_Point)
Blend_Point.TangentOnC = new_instancemethod(_Blend.Blend_Point_TangentOnC, None, Blend_Point)
Blend_Point.TangentOnC1 = new_instancemethod(_Blend.Blend_Point_TangentOnC1, None, Blend_Point)
Blend_Point.TangentOnC2 = new_instancemethod(_Blend.Blend_Point_TangentOnC2, None, Blend_Point)
Blend_Point.TangentOnS = new_instancemethod(_Blend.Blend_Point_TangentOnS, None, Blend_Point)
Blend_Point.TangentOnS1 = new_instancemethod(_Blend.Blend_Point_TangentOnS1, None, Blend_Point)
Blend_Point.TangentOnS2 = new_instancemethod(_Blend.Blend_Point_TangentOnS2, None, Blend_Point)
Blend_Point_swigregister = _Blend.Blend_Point_swigregister
Blend_Point_swigregister(Blend_Point)

class Blend_SurfCurvFuncInv(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetBounds(self, *args) -> "void":
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 3 variables. Returns in the vector SupBound the greatest values allowed for each of the 3 variables.
        	:param InfBound:
        	:type InfBound: math_Vector
        	:param SupBound:
        	:type SupBound: math_Vector
        	:rtype: void
        """
        return _Blend.Blend_SurfCurvFuncInv_GetBounds(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: void
        """
        return _Blend.Blend_SurfCurvFuncInv_GetTolerance(self, *args)


    def IsSolution(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.
        	:param Sol:
        	:type Sol: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: bool
        """
        return _Blend.Blend_SurfCurvFuncInv_IsSolution(self, *args)


    def Set(self, *args) -> "void":
        """
        * Set the Point on which a solution has to be found.
        	:param Rst:
        	:type Rst: Adaptor2d_HCurve2d
        	:rtype: void
        """
        return _Blend.Blend_SurfCurvFuncInv_Set(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_SurfCurvFuncInv
Blend_SurfCurvFuncInv.GetBounds = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_GetBounds, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.GetTolerance = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_GetTolerance, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.IsSolution = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_IsSolution, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.Set = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_Set, None, Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv_swigregister = _Blend.Blend_SurfCurvFuncInv_swigregister
Blend_SurfCurvFuncInv_swigregister(Blend_SurfCurvFuncInv)

class Blend_SurfPointFuncInv(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetBounds(self, *args) -> "void":
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 3 variables. Returns in the vector SupBound the greatest values allowed for each of the 3 variables.
        	:param InfBound:
        	:type InfBound: math_Vector
        	:param SupBound:
        	:type SupBound: math_Vector
        	:rtype: void
        """
        return _Blend.Blend_SurfPointFuncInv_GetBounds(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: void
        """
        return _Blend.Blend_SurfPointFuncInv_GetTolerance(self, *args)


    def IsSolution(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.
        	:param Sol:
        	:type Sol: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: bool
        """
        return _Blend.Blend_SurfPointFuncInv_IsSolution(self, *args)


    def Set(self, *args) -> "void":
        """
        * Set the Point on which a solution has to be found.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: void
        """
        return _Blend.Blend_SurfPointFuncInv_Set(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_SurfPointFuncInv
Blend_SurfPointFuncInv.GetBounds = new_instancemethod(_Blend.Blend_SurfPointFuncInv_GetBounds, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.GetTolerance = new_instancemethod(_Blend.Blend_SurfPointFuncInv_GetTolerance, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.IsSolution = new_instancemethod(_Blend.Blend_SurfPointFuncInv_IsSolution, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.Set = new_instancemethod(_Blend.Blend_SurfPointFuncInv_Set, None, Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv_swigregister = _Blend.Blend_SurfPointFuncInv_swigregister
Blend_SurfPointFuncInv_swigregister(Blend_SurfPointFuncInv)

class Blend_CSFunction(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetTolerance(self, *args) -> "void":
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: void
        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.
        	:param BoundTol:
        	:type BoundTol: float
        	:param SurfTol:
        	:type SurfTol: float
        	:param AngleTol:
        	:type AngleTol: float
        	:param Tol3d:
        	:type Tol3d: math_Vector
        	:param Tol1D:
        	:type Tol1D: math_Vector
        	:rtype: void
        """
        return _Blend.Blend_CSFunction_GetTolerance(self, *args)


    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS and/or PointOnC.
        	:rtype: bool
        """
        return _Blend.Blend_CSFunction_IsTangencyPoint(self, *args)


    def ParameterOnC(self, *args) -> "Standard_Real":
        """
        * Returns parameter of the point on the curve.
        	:rtype: float
        """
        return _Blend.Blend_CSFunction_ParameterOnC(self, *args)


    def Pnt2d(self, *args) -> "gp_Pnt2d const":
        """
        * Returns U,V coordinates of the point on the surface.
        	:rtype: gp_Pnt2d
        """
        return _Blend.Blend_CSFunction_Pnt2d(self, *args)


    def PointOnC(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the curve.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_CSFunction_PointOnC(self, *args)


    def PointOnS(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the surface.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_CSFunction_PointOnS(self, *args)


    def Section(self, *args) -> "Standard_Boolean":
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.
        	:param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:rtype: bool
        :param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.
        	:param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param D2Poles2d:
        	:type D2Poles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:param D2Weigths:
        	:type D2Weigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Blend.Blend_CSFunction_Section(self, *args)


    def Set(self, *args) -> "void":
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.
        	:param Param:
        	:type Param: float
        	:rtype: void
        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _Blend.Blend_CSFunction_Set(self, *args)


    def Tangent(self, *args) -> "void":
        """
        * Returns the tangent vector at the section, at the beginning and the end of the section, and returns the normal (of the surfaces) at these points.
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param TgS:
        	:type TgS: gp_Vec
        	:param NormS:
        	:type NormS: gp_Vec
        	:rtype: void
        """
        return _Blend.Blend_CSFunction_Tangent(self, *args)


    def Tangent2d(self, *args) -> "gp_Vec2d const":
        """
        * Returns the tangent vector at PointOnS, in the parametric space of the first surface.
        	:rtype: gp_Vec2d
        """
        return _Blend.Blend_CSFunction_Tangent2d(self, *args)


    def TangentOnC(self, *args) -> "gp_Vec const":
        """
        * Returns the tangent vector at PointOnC, in 3d space.
        	:rtype: gp_Vec
        """
        return _Blend.Blend_CSFunction_TangentOnC(self, *args)


    def TangentOnS(self, *args) -> "gp_Vec const":
        """
        * Returns the tangent vector at PointOnS, in 3d space.
        	:rtype: gp_Vec
        """
        return _Blend.Blend_CSFunction_TangentOnS(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_CSFunction
Blend_CSFunction.GetTolerance = new_instancemethod(_Blend.Blend_CSFunction_GetTolerance, None, Blend_CSFunction)
Blend_CSFunction.IsTangencyPoint = new_instancemethod(_Blend.Blend_CSFunction_IsTangencyPoint, None, Blend_CSFunction)
Blend_CSFunction.ParameterOnC = new_instancemethod(_Blend.Blend_CSFunction_ParameterOnC, None, Blend_CSFunction)
Blend_CSFunction.Pnt2d = new_instancemethod(_Blend.Blend_CSFunction_Pnt2d, None, Blend_CSFunction)
Blend_CSFunction.PointOnC = new_instancemethod(_Blend.Blend_CSFunction_PointOnC, None, Blend_CSFunction)
Blend_CSFunction.PointOnS = new_instancemethod(_Blend.Blend_CSFunction_PointOnS, None, Blend_CSFunction)
Blend_CSFunction.Section = new_instancemethod(_Blend.Blend_CSFunction_Section, None, Blend_CSFunction)
Blend_CSFunction.Set = new_instancemethod(_Blend.Blend_CSFunction_Set, None, Blend_CSFunction)
Blend_CSFunction.Tangent = new_instancemethod(_Blend.Blend_CSFunction_Tangent, None, Blend_CSFunction)
Blend_CSFunction.Tangent2d = new_instancemethod(_Blend.Blend_CSFunction_Tangent2d, None, Blend_CSFunction)
Blend_CSFunction.TangentOnC = new_instancemethod(_Blend.Blend_CSFunction_TangentOnC, None, Blend_CSFunction)
Blend_CSFunction.TangentOnS = new_instancemethod(_Blend.Blend_CSFunction_TangentOnS, None, Blend_CSFunction)
Blend_CSFunction_swigregister = _Blend.Blend_CSFunction_swigregister
Blend_CSFunction_swigregister(Blend_CSFunction)

class Blend_Function(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS1 and/or PointOnS2.
        	:rtype: bool
        """
        return _Blend.Blend_Function_IsTangencyPoint(self, *args)


    def PointOnS1(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the first surface, at parameter Sol(1),Sol(2) (Sol is the vector used in the call of IsSolution.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_Function_PointOnS1(self, *args)


    def PointOnS2(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the second surface, at parameter Sol(3),Sol(4) (Sol is the vector used in the call of IsSolution.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_Function_PointOnS2(self, *args)


    def Section(self, *args) -> "Standard_Boolean":
        """
        :param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False
        	:param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param D2Poles2d:
        	:type D2Poles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:param D2Weigths:
        	:type D2Weigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Blend.Blend_Function_Section(self, *args)


    def Tangent(self, *args) -> "void":
        """
        * Returns the tangent vector at the section, at the beginning and the end of the section, and returns the normal (of the surfaces) at these points.
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param TgFirst:
        	:type TgFirst: gp_Vec
        	:param TgLast:
        	:type TgLast: gp_Vec
        	:param NormFirst:
        	:type NormFirst: gp_Vec
        	:param NormLast:
        	:type NormLast: gp_Vec
        	:rtype: void
        """
        return _Blend.Blend_Function_Tangent(self, *args)


    def Tangent2dOnS1(self, *args) -> "gp_Vec2d const":
        """
        * Returns the tangent vector at PointOnS1, in the parametric space of the first surface.
        	:rtype: gp_Vec2d
        """
        return _Blend.Blend_Function_Tangent2dOnS1(self, *args)


    def Tangent2dOnS2(self, *args) -> "gp_Vec2d const":
        """
        * Returns the tangent vector at PointOnS2, in the parametric space of the second surface.
        	:rtype: gp_Vec2d
        """
        return _Blend.Blend_Function_Tangent2dOnS2(self, *args)


    def TangentOnS1(self, *args) -> "gp_Vec const":
        """
        * Returns the tangent vector at PointOnS1, in 3d space.
        	:rtype: gp_Vec
        """
        return _Blend.Blend_Function_TangentOnS1(self, *args)


    def TangentOnS2(self, *args) -> "gp_Vec const":
        """
        * Returns the tangent vector at PointOnS2, in 3d space.
        	:rtype: gp_Vec
        """
        return _Blend.Blend_Function_TangentOnS2(self, *args)


    def TwistOnS1(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Blend.Blend_Function_TwistOnS1(self, *args)


    def TwistOnS2(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _Blend.Blend_Function_TwistOnS2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_Function
Blend_Function.IsTangencyPoint = new_instancemethod(_Blend.Blend_Function_IsTangencyPoint, None, Blend_Function)
Blend_Function.PointOnS1 = new_instancemethod(_Blend.Blend_Function_PointOnS1, None, Blend_Function)
Blend_Function.PointOnS2 = new_instancemethod(_Blend.Blend_Function_PointOnS2, None, Blend_Function)
Blend_Function.Section = new_instancemethod(_Blend.Blend_Function_Section, None, Blend_Function)
Blend_Function.Tangent = new_instancemethod(_Blend.Blend_Function_Tangent, None, Blend_Function)
Blend_Function.Tangent2dOnS1 = new_instancemethod(_Blend.Blend_Function_Tangent2dOnS1, None, Blend_Function)
Blend_Function.Tangent2dOnS2 = new_instancemethod(_Blend.Blend_Function_Tangent2dOnS2, None, Blend_Function)
Blend_Function.TangentOnS1 = new_instancemethod(_Blend.Blend_Function_TangentOnS1, None, Blend_Function)
Blend_Function.TangentOnS2 = new_instancemethod(_Blend.Blend_Function_TangentOnS2, None, Blend_Function)
Blend_Function.TwistOnS1 = new_instancemethod(_Blend.Blend_Function_TwistOnS1, None, Blend_Function)
Blend_Function.TwistOnS2 = new_instancemethod(_Blend.Blend_Function_TwistOnS2, None, Blend_Function)
Blend_Function_swigregister = _Blend.Blend_Function_swigregister
Blend_Function_swigregister(Blend_Function)

class Blend_RstRstFunction(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Decroch(self, *args) -> "Blend_DecrochStatus":
        """
        * Enables to implement a criterion of decrochage specific to the function. Warning: Can be called without previous call of issolution but the values calculated can be senseless.
        	:param Sol:
        	:type Sol: math_Vector
        	:param NRst1:
        	:type NRst1: gp_Vec
        	:param TgRst1:
        	:type TgRst1: gp_Vec
        	:param NRst2:
        	:type NRst2: gp_Vec
        	:param TgRst2:
        	:type TgRst2: gp_Vec
        	:rtype: Blend_DecrochStatus
        """
        return _Blend.Blend_RstRstFunction_Decroch(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        * Returns in the vector Tolerance the parametric tolerance for each variable; Tol is the tolerance used in 3d space.
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: void
        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.
        	:param BoundTol:
        	:type BoundTol: float
        	:param SurfTol:
        	:type SurfTol: float
        	:param AngleTol:
        	:type AngleTol: float
        	:param Tol3d:
        	:type Tol3d: math_Vector
        	:param Tol1D:
        	:type Tol1D: math_Vector
        	:rtype: void
        """
        return _Blend.Blend_RstRstFunction_GetTolerance(self, *args)


    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS and/or PointOnRst.
        	:rtype: bool
        """
        return _Blend.Blend_RstRstFunction_IsTangencyPoint(self, *args)


    def ParameterOnRst1(self, *args) -> "Standard_Real":
        """
        * Returns parameter of the point on the curve.
        	:rtype: float
        """
        return _Blend.Blend_RstRstFunction_ParameterOnRst1(self, *args)


    def ParameterOnRst2(self, *args) -> "Standard_Real":
        """
        * Returns parameter of the point on the curve.
        	:rtype: float
        """
        return _Blend.Blend_RstRstFunction_ParameterOnRst2(self, *args)


    def Pnt2dOnRst1(self, *args) -> "gp_Pnt2d const":
        """
        * Returns U,V coordinates of the point on the surface.
        	:rtype: gp_Pnt2d
        """
        return _Blend.Blend_RstRstFunction_Pnt2dOnRst1(self, *args)


    def Pnt2dOnRst2(self, *args) -> "gp_Pnt2d const":
        """
        * Returns U,V coordinates of the point on the curve on surface.
        	:rtype: gp_Pnt2d
        """
        return _Blend.Blend_RstRstFunction_Pnt2dOnRst2(self, *args)


    def PointOnRst1(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the surface.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_RstRstFunction_PointOnRst1(self, *args)


    def PointOnRst2(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the curve.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_RstRstFunction_PointOnRst2(self, *args)


    def Section(self, *args) -> "Standard_Boolean":
        """
        :param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.
        	:param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:rtype: bool
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.
        	:param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param D2Poles2d:
        	:type D2Poles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:param D2Weigths:
        	:type D2Weigths: TColStd_Array1OfReal
        	:rtype: bool
        """
        return _Blend.Blend_RstRstFunction_Section(self, *args)


    def Set(self, *args) -> "void":
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.
        	:param Param:
        	:type Param: float
        	:rtype: void
        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _Blend.Blend_RstRstFunction_Set(self, *args)


    def Tangent2dOnRst1(self, *args) -> "gp_Vec2d const":
        """
        * Returns the tangent vector at PointOnS, in the parametric space of the first surface.
        	:rtype: gp_Vec2d
        """
        return _Blend.Blend_RstRstFunction_Tangent2dOnRst1(self, *args)


    def Tangent2dOnRst2(self, *args) -> "gp_Vec2d const":
        """
        * Returns the tangent vector at PointOnRst, in the parametric space of the second surface.
        	:rtype: gp_Vec2d
        """
        return _Blend.Blend_RstRstFunction_Tangent2dOnRst2(self, *args)


    def TangentOnRst1(self, *args) -> "gp_Vec const":
        """
        * Returns the tangent vector at PointOnS, in 3d space.
        	:rtype: gp_Vec
        """
        return _Blend.Blend_RstRstFunction_TangentOnRst1(self, *args)


    def TangentOnRst2(self, *args) -> "gp_Vec const":
        """
        * Returns the tangent vector at PointOnC, in 3d space.
        	:rtype: gp_Vec
        """
        return _Blend.Blend_RstRstFunction_TangentOnRst2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_RstRstFunction
Blend_RstRstFunction.Decroch = new_instancemethod(_Blend.Blend_RstRstFunction_Decroch, None, Blend_RstRstFunction)
Blend_RstRstFunction.GetTolerance = new_instancemethod(_Blend.Blend_RstRstFunction_GetTolerance, None, Blend_RstRstFunction)
Blend_RstRstFunction.IsTangencyPoint = new_instancemethod(_Blend.Blend_RstRstFunction_IsTangencyPoint, None, Blend_RstRstFunction)
Blend_RstRstFunction.ParameterOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_ParameterOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.ParameterOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_ParameterOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction.Pnt2dOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_Pnt2dOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.Pnt2dOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_Pnt2dOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction.PointOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_PointOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.PointOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_PointOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction.Section = new_instancemethod(_Blend.Blend_RstRstFunction_Section, None, Blend_RstRstFunction)
Blend_RstRstFunction.Set = new_instancemethod(_Blend.Blend_RstRstFunction_Set, None, Blend_RstRstFunction)
Blend_RstRstFunction.Tangent2dOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_Tangent2dOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.Tangent2dOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_Tangent2dOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction.TangentOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_TangentOnRst1, None, Blend_RstRstFunction)
Blend_RstRstFunction.TangentOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_TangentOnRst2, None, Blend_RstRstFunction)
Blend_RstRstFunction_swigregister = _Blend.Blend_RstRstFunction_swigregister
Blend_RstRstFunction_swigregister(Blend_RstRstFunction)

class Blend_SurfRstFunction(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Decroch(self, *args) -> "Standard_Boolean":
        """
        * Enables implementation of a criterion of decrochage specific to the function.
        	:param Sol:
        	:type Sol: math_Vector
        	:param NS:
        	:type NS: gp_Vec
        	:param TgS:
        	:type TgS: gp_Vec
        	:rtype: bool
        """
        return _Blend.Blend_SurfRstFunction_Decroch(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        * Returns in the vector Tolerance the parametric tolerance for each variable; Tol is the tolerance used in 3d space.
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param Tol:
        	:type Tol: float
        	:rtype: void
        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.
        	:param BoundTol:
        	:type BoundTol: float
        	:param SurfTol:
        	:type SurfTol: float
        	:param AngleTol:
        	:type AngleTol: float
        	:param Tol3d:
        	:type Tol3d: math_Vector
        	:param Tol1D:
        	:type Tol1D: math_Vector
        	:rtype: void
        """
        return _Blend.Blend_SurfRstFunction_GetTolerance(self, *args)


    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS and/or PointOnRst.
        	:rtype: bool
        """
        return _Blend.Blend_SurfRstFunction_IsTangencyPoint(self, *args)


    def ParameterOnRst(self, *args) -> "Standard_Real":
        """
        * Returns parameter of the point on the curve.
        	:rtype: float
        """
        return _Blend.Blend_SurfRstFunction_ParameterOnRst(self, *args)


    def Pnt2dOnRst(self, *args) -> "gp_Pnt2d const":
        """
        * Returns U,V coordinates of the point on the curve on surface.
        	:rtype: gp_Pnt2d
        """
        return _Blend.Blend_SurfRstFunction_Pnt2dOnRst(self, *args)


    def Pnt2dOnS(self, *args) -> "gp_Pnt2d const":
        """
        * Returns U,V coordinates of the point on the surface.
        	:rtype: gp_Pnt2d
        """
        return _Blend.Blend_SurfRstFunction_Pnt2dOnS(self, *args)


    def PointOnRst(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the curve.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_SurfRstFunction_PointOnRst(self, *args)


    def PointOnS(self, *args) -> "gp_Pnt const":
        """
        * Returns the point on the surface.
        	:rtype: gp_Pnt
        """
        return _Blend.Blend_SurfRstFunction_PointOnS(self, *args)


    def Section(self, *args) -> "void":
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.
        	:param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:rtype: bool
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.
        	:param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param DPoles:
        	:type DPoles: TColgp_Array1OfVec
        	:param D2Poles:
        	:type D2Poles: TColgp_Array1OfVec
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param DPoles2d:
        	:type DPoles2d: TColgp_Array1OfVec2d
        	:param D2Poles2d:
        	:type D2Poles2d: TColgp_Array1OfVec2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:param DWeigths:
        	:type DWeigths: TColStd_Array1OfReal
        	:param D2Weigths:
        	:type D2Weigths: TColStd_Array1OfReal
        	:rtype: bool
        :param P:
        	:type P: Blend_Point
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Poles2d:
        	:type Poles2d: TColgp_Array1OfPnt2d
        	:param Weigths:
        	:type Weigths: TColStd_Array1OfReal
        	:rtype: void
        """
        return _Blend.Blend_SurfRstFunction_Section(self, *args)


    def Set(self, *args) -> "void":
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.
        	:param Param:
        	:type Param: float
        	:rtype: void
        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: void
        """
        return _Blend.Blend_SurfRstFunction_Set(self, *args)


    def Tangent2dOnRst(self, *args) -> "gp_Vec2d const":
        """
        * Returns the tangent vector at PointOnRst, in the parametric space of the second surface.
        	:rtype: gp_Vec2d
        """
        return _Blend.Blend_SurfRstFunction_Tangent2dOnRst(self, *args)


    def Tangent2dOnS(self, *args) -> "gp_Vec2d const":
        """
        * Returns the tangent vector at PointOnS, in the parametric space of the first surface.
        	:rtype: gp_Vec2d
        """
        return _Blend.Blend_SurfRstFunction_Tangent2dOnS(self, *args)


    def TangentOnRst(self, *args) -> "gp_Vec const":
        """
        * Returns the tangent vector at PointOnC, in 3d space.
        	:rtype: gp_Vec
        """
        return _Blend.Blend_SurfRstFunction_TangentOnRst(self, *args)


    def TangentOnS(self, *args) -> "gp_Vec const":
        """
        * Returns the tangent vector at PointOnS, in 3d space.
        	:rtype: gp_Vec
        """
        return _Blend.Blend_SurfRstFunction_TangentOnS(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Blend.delete_Blend_SurfRstFunction
Blend_SurfRstFunction.Decroch = new_instancemethod(_Blend.Blend_SurfRstFunction_Decroch, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.GetTolerance = new_instancemethod(_Blend.Blend_SurfRstFunction_GetTolerance, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.IsTangencyPoint = new_instancemethod(_Blend.Blend_SurfRstFunction_IsTangencyPoint, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.ParameterOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_ParameterOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Pnt2dOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_Pnt2dOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Pnt2dOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_Pnt2dOnS, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.PointOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_PointOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.PointOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_PointOnS, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Section = new_instancemethod(_Blend.Blend_SurfRstFunction_Section, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Set = new_instancemethod(_Blend.Blend_SurfRstFunction_Set, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Tangent2dOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_Tangent2dOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.Tangent2dOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_Tangent2dOnS, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.TangentOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_TangentOnRst, None, Blend_SurfRstFunction)
Blend_SurfRstFunction.TangentOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_TangentOnS, None, Blend_SurfRstFunction)
Blend_SurfRstFunction_swigregister = _Blend.Blend_SurfRstFunction_swigregister
Blend_SurfRstFunction_swigregister(Blend_SurfRstFunction)



