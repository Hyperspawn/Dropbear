# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BndLib module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_bndlib.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _BndLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BndLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BndLib')
    _BndLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BndLib', [dirname(__file__)])
        except ImportError:
            import _BndLib
            return _BndLib
        try:
            _mod = imp.load_module('_BndLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BndLib = swig_import_helper()
    del swig_import_helper
else:
    import _BndLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BndLib.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_BndLib.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BndLib.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BndLib.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BndLib.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BndLib.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BndLib.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BndLib.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BndLib.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BndLib.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BndLib.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BndLib.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BndLib.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BndLib.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BndLib.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BndLib.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BndLib.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _BndLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _BndLib.process_exception(error, method_name, class_name)
process_exception = _BndLib.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
import OCC.Core.Bnd
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.TColgp
import OCC.Core.BVH
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.GeomAbs
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.TopAbs
import OCC.Core.math
import OCC.Core.Message
class bndlib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Bounding box for a surface trimmed or not Adds the segment of the line L limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. Tol is the tolerance value to enlarge the minimun and maximum dimension P1 and P2 may represent infinite values. Exceptions Standard_Failure if P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
        	:param L:
        	:type L: gp_Lin
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        :param L:
        	:type L: gp_Lin2d
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        :param C:
        	:type C: gp_Circ
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * P2-P1 can be in [0,2*pi]
        	:param C:
        	:type C: gp_Circ
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        :param C:
        	:type C: gp_Circ2d
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        * Adds the circle C, or the arc of the circle C limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. P2-P1 can be in [0,2*pi]
        	:param C:
        	:type C: gp_Circ2d
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        :param C:
        	:type C: gp_Elips
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * P2-P1 can be in [0,2*pi]
        	:param C:
        	:type C: gp_Elips
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        :param C:
        	:type C: gp_Elips2d
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        * Adds the ellipse E, or the arc of the ellipse E limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. P2-P1 can be in [0,2*pi]
        	:param C:
        	:type C: gp_Elips2d
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        :param P:
        	:type P: gp_Parab
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * Adds the arc of the parabola P limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. P1 and P2 may represent infinite values. Exceptions Standard_Failure if P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
        	:param P:
        	:type P: gp_Parab2d
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        :param H:
        	:type H: gp_Hypr
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * Adds the arc of the branch of hyperbola H limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. P1 and P2 may represent infinite values. Exceptions Standard_Failure if P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
        	:param H:
        	:type H: gp_Hypr2d
        	:param P1:
        	:type P1: float
        	:param P2:
        	:type P2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        * UMax -UMin can be in [0,2*pi]
        	:param S:
        	:type S: gp_Cylinder
        	:param UMin:
        	:type UMin: float
        	:param UMax:
        	:type UMax: float
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * Adds to the bounding box B, the patch of the cylinder S limited - in the v parametric direction, by the two parameter values VMin and VMax - and optionally in the u parametric direction, by the two parameter values UMin and UMax. B is then enlarged by the tolerance value Tol. VMin and VMax may represent infinite values. Exceptions Standard_Failure if VMin and VMax are either two negative infinite real numbers, or two positive infinite real numbers.
        	:param S:
        	:type S: gp_Cylinder
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * UMax-UMin can be in [0,2*pi]
        	:param S:
        	:type S: gp_Cone
        	:param UMin:
        	:type UMin: float
        	:param UMax:
        	:type UMax: float
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * Adds to the bounding box B, the patch of the cone S limited - in the v parametric direction, by the two parameter values VMin and VMax - and optionally in the u parametric direction, by the two parameter values UMin and UMax, B is then enlarged by the tolerance value Tol. VMin and VMax may represent infinite values. Exceptions Standard_Failure if VMin and VMax are either two negative infinite real numbers, or two positive infinite real numbers.
        	:param S:
        	:type S: gp_Cone
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        :param S:
        	:type S: gp_Sphere
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * Adds to the bounding box B the sphere S, or - the patch of the sphere S, limited in the u parametric direction, by the two parameter values UMin and UMax, and in the v parametric direction, by the two parameter values VMin and VMax. B is then enlarged by the tolerance value Tol. UMax-UMin can be in [0,2*pi] VMin,VMax can be [-pi/2,pi/2]
        	:param S:
        	:type S: gp_Sphere
        	:param UMin:
        	:type UMin: float
        	:param UMax:
        	:type UMax: float
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        :param P:
        	:type P: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * Adds to the bounding box B - the torus S, or - the patch of the torus S, limited in the u parametric direction, by the two parameter values UMin and UMax, and in the v parametric direction, by the two parameter values VMin and VMax. B is then enlarged by the tolerance value Tol. UMax-UMin can be in [0,2*pi], VMin,VMax can be [-pi/2,pi/2]
        	:param P:
        	:type P: gp_Torus
        	:param UMin:
        	:type UMin: float
        	:param UMax:
        	:type UMax: float
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        """
        return _BndLib.bndlib_Add(*args)

    Add = staticmethod(Add)

    __repr__ = _dumps_object


    def __init__(self):
        _BndLib.bndlib_swiginit(self, _BndLib.new_bndlib())
    __swig_destroy__ = _BndLib.delete_bndlib
bndlib_swigregister = _BndLib.bndlib_swigregister
bndlib_swigregister(bndlib)

def bndlib_Add(*args) -> "void":
    """
    * Bounding box for a surface trimmed or not Adds the segment of the line L limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. Tol is the tolerance value to enlarge the minimun and maximum dimension P1 and P2 may represent infinite values. Exceptions Standard_Failure if P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
    	:param L:
    	:type L: gp_Lin
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    :param L:
    	:type L: gp_Lin2d
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    :param C:
    	:type C: gp_Circ
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * P2-P1 can be in [0,2*pi]
    	:param C:
    	:type C: gp_Circ
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    :param C:
    	:type C: gp_Circ2d
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    * Adds the circle C, or the arc of the circle C limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. P2-P1 can be in [0,2*pi]
    	:param C:
    	:type C: gp_Circ2d
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    :param C:
    	:type C: gp_Elips
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * P2-P1 can be in [0,2*pi]
    	:param C:
    	:type C: gp_Elips
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    :param C:
    	:type C: gp_Elips2d
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    * Adds the ellipse E, or the arc of the ellipse E limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. P2-P1 can be in [0,2*pi]
    	:param C:
    	:type C: gp_Elips2d
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    :param P:
    	:type P: gp_Parab
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * Adds the arc of the parabola P limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. P1 and P2 may represent infinite values. Exceptions Standard_Failure if P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
    	:param P:
    	:type P: gp_Parab2d
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    :param H:
    	:type H: gp_Hypr
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * Adds the arc of the branch of hyperbola H limited by the two parameter values P1 and P2, to the bounding box B, and then enlarges B by the tolerance value Tol. P1 and P2 may represent infinite values. Exceptions Standard_Failure if P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
    	:param H:
    	:type H: gp_Hypr2d
    	:param P1:
    	:type P1: float
    	:param P2:
    	:type P2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    * UMax -UMin can be in [0,2*pi]
    	:param S:
    	:type S: gp_Cylinder
    	:param UMin:
    	:type UMin: float
    	:param UMax:
    	:type UMax: float
    	:param VMin:
    	:type VMin: float
    	:param VMax:
    	:type VMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * Adds to the bounding box B, the patch of the cylinder S limited - in the v parametric direction, by the two parameter values VMin and VMax - and optionally in the u parametric direction, by the two parameter values UMin and UMax. B is then enlarged by the tolerance value Tol. VMin and VMax may represent infinite values. Exceptions Standard_Failure if VMin and VMax are either two negative infinite real numbers, or two positive infinite real numbers.
    	:param S:
    	:type S: gp_Cylinder
    	:param VMin:
    	:type VMin: float
    	:param VMax:
    	:type VMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * UMax-UMin can be in [0,2*pi]
    	:param S:
    	:type S: gp_Cone
    	:param UMin:
    	:type UMin: float
    	:param UMax:
    	:type UMax: float
    	:param VMin:
    	:type VMin: float
    	:param VMax:
    	:type VMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * Adds to the bounding box B, the patch of the cone S limited - in the v parametric direction, by the two parameter values VMin and VMax - and optionally in the u parametric direction, by the two parameter values UMin and UMax, B is then enlarged by the tolerance value Tol. VMin and VMax may represent infinite values. Exceptions Standard_Failure if VMin and VMax are either two negative infinite real numbers, or two positive infinite real numbers.
    	:param S:
    	:type S: gp_Cone
    	:param VMin:
    	:type VMin: float
    	:param VMax:
    	:type VMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    :param S:
    	:type S: gp_Sphere
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * Adds to the bounding box B the sphere S, or - the patch of the sphere S, limited in the u parametric direction, by the two parameter values UMin and UMax, and in the v parametric direction, by the two parameter values VMin and VMax. B is then enlarged by the tolerance value Tol. UMax-UMin can be in [0,2*pi] VMin,VMax can be [-pi/2,pi/2]
    	:param S:
    	:type S: gp_Sphere
    	:param UMin:
    	:type UMin: float
    	:param UMax:
    	:type UMax: float
    	:param VMin:
    	:type VMin: float
    	:param VMax:
    	:type VMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    :param P:
    	:type P: gp_Torus
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * Adds to the bounding box B - the torus S, or - the patch of the torus S, limited in the u parametric direction, by the two parameter values UMin and UMax, and in the v parametric direction, by the two parameter values VMin and VMax. B is then enlarged by the tolerance value Tol. UMax-UMin can be in [0,2*pi], VMin,VMax can be [-pi/2,pi/2]
    	:param P:
    	:type P: gp_Torus
    	:param UMin:
    	:type UMin: float
    	:param UMax:
    	:type UMax: float
    	:param VMin:
    	:type VMin: float
    	:param VMax:
    	:type VMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    """
    return _BndLib.bndlib_Add(*args)

class BndLib_Add2dCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Adds to the bounding box B the curve C B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, - if not, the points of an approximation of the curve C. Warning C is an adapted curve, that is, an object which is an interface between: - the services provided by a 2D curve from the package Geom2d - and those required of the curve by the computation algorithm. The adapted curve is created in the following way: opencascade::handle<Geom2d_Curve> mycurve = ... ; Geom2dAdaptor_Curve C(mycurve); The bounding box B is then enlarged by adding it: Bnd_Box2d B; // ... Standard_Real Tol = ... ; Add2dCurve::Add ( C, Tol, B ); Exceptions Standard_Failure if the curve is built from: - a Geom_Line, or - a Geom_Parabola, or - a Geom_Hyperbola, and P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
        	:param C:
        	:type C: Adaptor2d_Curve2d
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        * Adds to the bounding box Bthe arc of the curve C limited by the two parameter values P1 and P2. B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, - if not, the points of an approximation of the curve C. Warning C is an adapted curve, that is, an object which is an interface between: - the services provided by a 2D curve from the package Geom2d - and those required of the curve by the computation algorithm. The adapted curve is created in the following way: opencascade::handle<Geom2d_Curve> mycurve = ... ; Geom2dAdaptor_Curve C(mycurve); The bounding box B is then enlarged by adding it: Bnd_Box2d B; // ... Standard_Real Tol = ... ; Add2dCurve::Add ( C, Tol, B ); Exceptions Standard_Failure if the curve is built from: - a Geom_Line, or - a Geom_Parabola, or - a Geom_Hyperbola, and P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
        	:param C:
        	:type C: Adaptor2d_Curve2d
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        * Adds to the bounding box B the curve C B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, - if not, the points of an approximation of the curve C.
        	:param C:
        	:type C: Geom2d_Curve
        	:param Tol:
        	:type Tol: float
        	:param Box:
        	:type Box: Bnd_Box2d
        	:rtype: void
        * Adds to the bounding box B the part of curve C B is then enlarged by the tolerance value Tol. U1, U2 - the parametric range to comute the bounding box; Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, - if not, the points of an approximation of the curve C.
        	:param C:
        	:type C: Geom2d_Curve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        """
        return _BndLib.BndLib_Add2dCurve_Add(*args)

    Add = staticmethod(Add)

    def AddOptimal(*args) -> "void":
        """
        * Adds to the bounding box B the part of curve C B is then enlarged by the tolerance value Tol. U1, U2 - the parametric range to comute the bounding box; Note: depending on the type of curve, one of the following algorithms is used to include it in the bounding box B: - an exact analytical if C is built from a line, a circle or a conic curve, - numerical calculation of bounding box sizes, based on minimization algorithm, for other types of curve If Tol = < Precision::PConfusion(), Precision::PConfusion is used as tolerance for calculation
        	:param C:
        	:type C: Geom2d_Curve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box2d
        	:rtype: void
        """
        return _BndLib.BndLib_Add2dCurve_AddOptimal(*args)

    AddOptimal = staticmethod(AddOptimal)

    __repr__ = _dumps_object


    def __init__(self):
        _BndLib.BndLib_Add2dCurve_swiginit(self, _BndLib.new_BndLib_Add2dCurve())
    __swig_destroy__ = _BndLib.delete_BndLib_Add2dCurve
BndLib_Add2dCurve_swigregister = _BndLib.BndLib_Add2dCurve_swigregister
BndLib_Add2dCurve_swigregister(BndLib_Add2dCurve)

def BndLib_Add2dCurve_Add(*args) -> "void":
    """
    * Adds to the bounding box B the curve C B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, - if not, the points of an approximation of the curve C. Warning C is an adapted curve, that is, an object which is an interface between: - the services provided by a 2D curve from the package Geom2d - and those required of the curve by the computation algorithm. The adapted curve is created in the following way: opencascade::handle<Geom2d_Curve> mycurve = ... ; Geom2dAdaptor_Curve C(mycurve); The bounding box B is then enlarged by adding it: Bnd_Box2d B; // ... Standard_Real Tol = ... ; Add2dCurve::Add ( C, Tol, B ); Exceptions Standard_Failure if the curve is built from: - a Geom_Line, or - a Geom_Parabola, or - a Geom_Hyperbola, and P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
    	:param C:
    	:type C: Adaptor2d_Curve2d
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    * Adds to the bounding box Bthe arc of the curve C limited by the two parameter values P1 and P2. B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, - if not, the points of an approximation of the curve C. Warning C is an adapted curve, that is, an object which is an interface between: - the services provided by a 2D curve from the package Geom2d - and those required of the curve by the computation algorithm. The adapted curve is created in the following way: opencascade::handle<Geom2d_Curve> mycurve = ... ; Geom2dAdaptor_Curve C(mycurve); The bounding box B is then enlarged by adding it: Bnd_Box2d B; // ... Standard_Real Tol = ... ; Add2dCurve::Add ( C, Tol, B ); Exceptions Standard_Failure if the curve is built from: - a Geom_Line, or - a Geom_Parabola, or - a Geom_Hyperbola, and P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
    	:param C:
    	:type C: Adaptor2d_Curve2d
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    * Adds to the bounding box B the curve C B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, - if not, the points of an approximation of the curve C.
    	:param C:
    	:type C: Geom2d_Curve
    	:param Tol:
    	:type Tol: float
    	:param Box:
    	:type Box: Bnd_Box2d
    	:rtype: void
    * Adds to the bounding box B the part of curve C B is then enlarged by the tolerance value Tol. U1, U2 - the parametric range to comute the bounding box; Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, - if not, the points of an approximation of the curve C.
    	:param C:
    	:type C: Geom2d_Curve
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    """
    return _BndLib.BndLib_Add2dCurve_Add(*args)

def BndLib_Add2dCurve_AddOptimal(*args) -> "void":
    """
    * Adds to the bounding box B the part of curve C B is then enlarged by the tolerance value Tol. U1, U2 - the parametric range to comute the bounding box; Note: depending on the type of curve, one of the following algorithms is used to include it in the bounding box B: - an exact analytical if C is built from a line, a circle or a conic curve, - numerical calculation of bounding box sizes, based on minimization algorithm, for other types of curve If Tol = < Precision::PConfusion(), Precision::PConfusion is used as tolerance for calculation
    	:param C:
    	:type C: Geom2d_Curve
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box2d
    	:rtype: void
    """
    return _BndLib.BndLib_Add2dCurve_AddOptimal(*args)

class BndLib_Add3dCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Adds to the bounding box B the curve C B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, if not, the points of an approximation of the curve C. Warning C is an adapted curve, that is, an object which is an interface between: - the services provided by a 3D curve from the package Geom - and those required of the curve by the computation algorithm. The adapted curve is created in the following way: opencascade::handle<Geom_Curve> mycurve = ... ; GeomAdaptor_Curve C(mycurve); The bounding box B is then enlarged by adding it: Bnd_Box B; // ... Standard_Real Tol = ... ; Add3dCurve::Add ( C, Tol, B ); Exceptions Standard_Failure if the curve is built from: - a Geom_Line, or - a Geom_Parabola, or - a Geom_Hyperbola, and P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
        	:param C:
        	:type C: Adaptor3d_Curve
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * Adds to the bounding box B the curve C the arc of the curve C limited by the two parameter values P1 and P2. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, if not, the points of an approximation of the curve C. Warning C is an adapted curve, that is, an object which is an interface between: - the services provided by a 3D curve from the package Geom - and those required of the curve by the computation algorithm. The adapted curve is created in the following way: opencascade::handle<Geom_Curve> mycurve = ... ; GeomAdaptor_Curve C(mycurve); The bounding box B is then enlarged by adding it: Bnd_Box B; // ... Standard_Real Tol = ... ; Add3dCurve::Add ( C, Tol, B ); Exceptions Standard_Failure if the curve is built from: - a Geom_Line, or - a Geom_Parabola, or - a Geom_Hyperbola, and P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
        	:param C:
        	:type C: Adaptor3d_Curve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        """
        return _BndLib.BndLib_Add3dCurve_Add(*args)

    Add = staticmethod(Add)

    def AddGenCurv(*args) -> "void":
        """
        * Adds to the bounding box B the curve C using numerical minimization algorithms This method is used in AddOptimal for not analytical curves. if Tol < Precision::Confusion(), Precision:;Confusion is used as computation tolerance
        	:param C:
        	:type C: Adaptor3d_Curve
        	:param UMin:
        	:type UMin: float
        	:param UMax:
        	:type UMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        """
        return _BndLib.BndLib_Add3dCurve_AddGenCurv(*args)

    AddGenCurv = staticmethod(AddGenCurv)

    def AddOptimal(*args) -> "void":
        """
        * Adds to the bounding box B the curve C These methods use more precise algorithms for building bnd box then methods Add(...)
        	:param C:
        	:type C: Adaptor3d_Curve
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        :param C:
        	:type C: Adaptor3d_Curve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        """
        return _BndLib.BndLib_Add3dCurve_AddOptimal(*args)

    AddOptimal = staticmethod(AddOptimal)

    __repr__ = _dumps_object


    def __init__(self):
        _BndLib.BndLib_Add3dCurve_swiginit(self, _BndLib.new_BndLib_Add3dCurve())
    __swig_destroy__ = _BndLib.delete_BndLib_Add3dCurve
BndLib_Add3dCurve_swigregister = _BndLib.BndLib_Add3dCurve_swigregister
BndLib_Add3dCurve_swigregister(BndLib_Add3dCurve)

def BndLib_Add3dCurve_Add(*args) -> "void":
    """
    * Adds to the bounding box B the curve C B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, if not, the points of an approximation of the curve C. Warning C is an adapted curve, that is, an object which is an interface between: - the services provided by a 3D curve from the package Geom - and those required of the curve by the computation algorithm. The adapted curve is created in the following way: opencascade::handle<Geom_Curve> mycurve = ... ; GeomAdaptor_Curve C(mycurve); The bounding box B is then enlarged by adding it: Bnd_Box B; // ... Standard_Real Tol = ... ; Add3dCurve::Add ( C, Tol, B ); Exceptions Standard_Failure if the curve is built from: - a Geom_Line, or - a Geom_Parabola, or - a Geom_Hyperbola, and P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
    	:param C:
    	:type C: Adaptor3d_Curve
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * Adds to the bounding box B the curve C the arc of the curve C limited by the two parameter values P1 and P2. Note: depending on the type of curve, one of the following representations of the curve C is used to include it in the bounding box B: - an exact representation if C is built from a line, a circle or a conic curve, - the poles of the curve if C is built from a Bezier curve or a BSpline curve, if not, the points of an approximation of the curve C. Warning C is an adapted curve, that is, an object which is an interface between: - the services provided by a 3D curve from the package Geom - and those required of the curve by the computation algorithm. The adapted curve is created in the following way: opencascade::handle<Geom_Curve> mycurve = ... ; GeomAdaptor_Curve C(mycurve); The bounding box B is then enlarged by adding it: Bnd_Box B; // ... Standard_Real Tol = ... ; Add3dCurve::Add ( C, Tol, B ); Exceptions Standard_Failure if the curve is built from: - a Geom_Line, or - a Geom_Parabola, or - a Geom_Hyperbola, and P1 and P2 are either two negative infinite real numbers, or two positive infinite real numbers.
    	:param C:
    	:type C: Adaptor3d_Curve
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    """
    return _BndLib.BndLib_Add3dCurve_Add(*args)

def BndLib_Add3dCurve_AddGenCurv(*args) -> "void":
    """
    * Adds to the bounding box B the curve C using numerical minimization algorithms This method is used in AddOptimal for not analytical curves. if Tol < Precision::Confusion(), Precision:;Confusion is used as computation tolerance
    	:param C:
    	:type C: Adaptor3d_Curve
    	:param UMin:
    	:type UMin: float
    	:param UMax:
    	:type UMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    """
    return _BndLib.BndLib_Add3dCurve_AddGenCurv(*args)

def BndLib_Add3dCurve_AddOptimal(*args) -> "void":
    """
    * Adds to the bounding box B the curve C These methods use more precise algorithms for building bnd box then methods Add(...)
    	:param C:
    	:type C: Adaptor3d_Curve
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    :param C:
    	:type C: Adaptor3d_Curve
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    """
    return _BndLib.BndLib_Add3dCurve_AddOptimal(*args)

class BndLib_AddSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        * Adds to the bounding box B the surface S B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the surface S is used to include it in the bounding box B: - an exact representation if S is built from a plane, a cylinder, a cone, a sphere or a torus, - the poles of the surface if S is built from a Bezier surface or a BSpline surface, - the points of an approximation of the surface S in cases other than offset surfaces; - in the case of an offset surface, the basis surface is first included according to the previous rules; then the bounding box is enlarged by the offset value. Warning Do not use these functions to add a non-finite surface to the bounding box B. If UMin, UMax, VMin or VMax is an infinite value B will become WholeSpace. S is an adapted surface, that is, an object which is an interface between: - the services provided by a surface from the package Geom - and those required of the surface by the computation algorithm. The adapted surface is created in the following way: opencascade::handle<Geom_Surface> mysurface = ... ; GeomAdaptor_Surface S(mysurface); The bounding box B is then enlarged by adding this surface: Bnd_Box B; // ... Standard_Real Tol = ... ; AddSurface::Add ( S, Tol, B );
        	:param S:
        	:type S: Adaptor3d_Surface
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        * Adds to the bounding box B the surface S the patch of the surface S limited in the u parametric direction by the two parameter values UMin, UMax, and in the v parametric direction by the two parameter values VMin, VMax. Note: depending on the type of curve, one of the following representations of the surface S is used to include it in the bounding box B: - an exact representation if S is built from a plane, a cylinder, a cone, a sphere or a torus, - the poles of the surface if S is built from a Bezier surface or a BSpline surface, - the points of an approximation of the surface S in cases other than offset surfaces; - in the case of an offset surface, the basis surface is first included according to the previous rules; then the bounding box is enlarged by the offset value. Warning Do not use these functions to add a non-finite surface to the bounding box B. If UMin, UMax, VMin or VMax is an infinite value B will become WholeSpace. S is an adapted surface, that is, an object which is an interface between: - the services provided by a surface from the package Geom - and those required of the surface by the computation algorithm. The adapted surface is created in the following way: opencascade::handle<Geom_Surface> mysurface = ... ; GeomAdaptor_Surface S(mysurface); The bounding box B is then enlarged by adding this surface: Bnd_Box B; // ... Standard_Real Tol = ... ; AddSurface::Add ( S, Tol, B );
        	:param S:
        	:type S: Adaptor3d_Surface
        	:param UMin:
        	:type UMin: float
        	:param UMax:
        	:type UMax: float
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        """
        return _BndLib.BndLib_AddSurface_Add(*args)

    Add = staticmethod(Add)

    def AddGenSurf(*args) -> "void":
        """
        * Adds to the bounding box B the surface S using numerical minimization algorithms This method is used in AddOptimal for not analytical surfaces and torus. if Tol < Precision::Confusion(), Precision::Confusion is used as computation tolerance
        	:param S:
        	:type S: Adaptor3d_Surface
        	:param UMin:
        	:type UMin: float
        	:param UMax:
        	:type UMax: float
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        """
        return _BndLib.BndLib_AddSurface_AddGenSurf(*args)

    AddGenSurf = staticmethod(AddGenSurf)

    def AddOptimal(*args) -> "void":
        """
        * Adds the surface S to the bounding box B. This algorith builds precise bounding box
        	:param S:
        	:type S: Adaptor3d_Surface
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        :param S:
        	:type S: Adaptor3d_Surface
        	:param UMin:
        	:type UMin: float
        	:param UMax:
        	:type UMax: float
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param Tol:
        	:type Tol: float
        	:param B:
        	:type B: Bnd_Box
        	:rtype: void
        """
        return _BndLib.BndLib_AddSurface_AddOptimal(*args)

    AddOptimal = staticmethod(AddOptimal)

    __repr__ = _dumps_object


    def __init__(self):
        _BndLib.BndLib_AddSurface_swiginit(self, _BndLib.new_BndLib_AddSurface())
    __swig_destroy__ = _BndLib.delete_BndLib_AddSurface
BndLib_AddSurface_swigregister = _BndLib.BndLib_AddSurface_swigregister
BndLib_AddSurface_swigregister(BndLib_AddSurface)

def BndLib_AddSurface_Add(*args) -> "void":
    """
    * Adds to the bounding box B the surface S B is then enlarged by the tolerance value Tol. Note: depending on the type of curve, one of the following representations of the surface S is used to include it in the bounding box B: - an exact representation if S is built from a plane, a cylinder, a cone, a sphere or a torus, - the poles of the surface if S is built from a Bezier surface or a BSpline surface, - the points of an approximation of the surface S in cases other than offset surfaces; - in the case of an offset surface, the basis surface is first included according to the previous rules; then the bounding box is enlarged by the offset value. Warning Do not use these functions to add a non-finite surface to the bounding box B. If UMin, UMax, VMin or VMax is an infinite value B will become WholeSpace. S is an adapted surface, that is, an object which is an interface between: - the services provided by a surface from the package Geom - and those required of the surface by the computation algorithm. The adapted surface is created in the following way: opencascade::handle<Geom_Surface> mysurface = ... ; GeomAdaptor_Surface S(mysurface); The bounding box B is then enlarged by adding this surface: Bnd_Box B; // ... Standard_Real Tol = ... ; AddSurface::Add ( S, Tol, B );
    	:param S:
    	:type S: Adaptor3d_Surface
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    * Adds to the bounding box B the surface S the patch of the surface S limited in the u parametric direction by the two parameter values UMin, UMax, and in the v parametric direction by the two parameter values VMin, VMax. Note: depending on the type of curve, one of the following representations of the surface S is used to include it in the bounding box B: - an exact representation if S is built from a plane, a cylinder, a cone, a sphere or a torus, - the poles of the surface if S is built from a Bezier surface or a BSpline surface, - the points of an approximation of the surface S in cases other than offset surfaces; - in the case of an offset surface, the basis surface is first included according to the previous rules; then the bounding box is enlarged by the offset value. Warning Do not use these functions to add a non-finite surface to the bounding box B. If UMin, UMax, VMin or VMax is an infinite value B will become WholeSpace. S is an adapted surface, that is, an object which is an interface between: - the services provided by a surface from the package Geom - and those required of the surface by the computation algorithm. The adapted surface is created in the following way: opencascade::handle<Geom_Surface> mysurface = ... ; GeomAdaptor_Surface S(mysurface); The bounding box B is then enlarged by adding this surface: Bnd_Box B; // ... Standard_Real Tol = ... ; AddSurface::Add ( S, Tol, B );
    	:param S:
    	:type S: Adaptor3d_Surface
    	:param UMin:
    	:type UMin: float
    	:param UMax:
    	:type UMax: float
    	:param VMin:
    	:type VMin: float
    	:param VMax:
    	:type VMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    """
    return _BndLib.BndLib_AddSurface_Add(*args)

def BndLib_AddSurface_AddGenSurf(*args) -> "void":
    """
    * Adds to the bounding box B the surface S using numerical minimization algorithms This method is used in AddOptimal for not analytical surfaces and torus. if Tol < Precision::Confusion(), Precision::Confusion is used as computation tolerance
    	:param S:
    	:type S: Adaptor3d_Surface
    	:param UMin:
    	:type UMin: float
    	:param UMax:
    	:type UMax: float
    	:param VMin:
    	:type VMin: float
    	:param VMax:
    	:type VMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    """
    return _BndLib.BndLib_AddSurface_AddGenSurf(*args)

def BndLib_AddSurface_AddOptimal(*args) -> "void":
    """
    * Adds the surface S to the bounding box B. This algorith builds precise bounding box
    	:param S:
    	:type S: Adaptor3d_Surface
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    :param S:
    	:type S: Adaptor3d_Surface
    	:param UMin:
    	:type UMin: float
    	:param UMax:
    	:type UMax: float
    	:param VMin:
    	:type VMin: float
    	:param VMax:
    	:type VMax: float
    	:param Tol:
    	:type Tol: float
    	:param B:
    	:type B: Bnd_Box
    	:rtype: void
    """
    return _BndLib.BndLib_AddSurface_AddOptimal(*args)



