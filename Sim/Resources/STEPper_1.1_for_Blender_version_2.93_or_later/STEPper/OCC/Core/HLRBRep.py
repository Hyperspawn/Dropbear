# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
HLRBRep module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_hlrbrep.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _HLRBRep.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_HLRBRep')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_HLRBRep')
    _HLRBRep = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_HLRBRep', [dirname(__file__)])
        except ImportError:
            import _HLRBRep
            return _HLRBRep
        try:
            _mod = imp.load_module('_HLRBRep', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _HLRBRep = swig_import_helper()
    del swig_import_helper
else:
    import _HLRBRep
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _HLRBRep.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_HLRBRep.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_HLRBRep.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_HLRBRep.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_HLRBRep.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_HLRBRep.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_HLRBRep.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_HLRBRep.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_HLRBRep.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_HLRBRep.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_HLRBRep.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_HLRBRep.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_HLRBRep.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_HLRBRep.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_HLRBRep.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_HLRBRep.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_HLRBRep.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _HLRBRep.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _HLRBRep.process_exception(error, method_name, class_name)
process_exception = _HLRBRep.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.HLRAlgo
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.TColgp
import OCC.Core.BRepAdaptor
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.GeomAdaptor
import OCC.Core.Geom2dAdaptor
import OCC.Core.IntRes2d
import OCC.Core.TopTools
import OCC.Core.BRepTopAdaptor
import OCC.Core.IntCurveSurface
import OCC.Core.Intf
import OCC.Core.Bnd
import OCC.Core.BVH
import OCC.Core.IntSurf
import OCC.Core.HLRTopoBRep
import OCC.Core.Contap
import OCC.Core.IntCurve
import OCC.Core.Extrema
HLRBRep_Undefined = _HLRBRep.HLRBRep_Undefined
HLRBRep_IsoLine = _HLRBRep.HLRBRep_IsoLine
HLRBRep_OutLine = _HLRBRep.HLRBRep_OutLine
HLRBRep_Rg1Line = _HLRBRep.HLRBRep_Rg1Line
HLRBRep_RgNLine = _HLRBRep.HLRBRep_RgNLine
HLRBRep_Sharp = _HLRBRep.HLRBRep_Sharp

def Handle_HLRBRep_AreaLimit_Create() -> "opencascade::handle< HLRBRep_AreaLimit >":
    return _HLRBRep.Handle_HLRBRep_AreaLimit_Create()
Handle_HLRBRep_AreaLimit_Create = _HLRBRep.Handle_HLRBRep_AreaLimit_Create

def Handle_HLRBRep_AreaLimit_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< HLRBRep_AreaLimit >":
    return _HLRBRep.Handle_HLRBRep_AreaLimit_DownCast(t)
Handle_HLRBRep_AreaLimit_DownCast = _HLRBRep.Handle_HLRBRep_AreaLimit_DownCast

def Handle_HLRBRep_AreaLimit_IsNull(t: 'opencascade::handle< HLRBRep_AreaLimit > const &') -> "bool":
    return _HLRBRep.Handle_HLRBRep_AreaLimit_IsNull(t)
Handle_HLRBRep_AreaLimit_IsNull = _HLRBRep.Handle_HLRBRep_AreaLimit_IsNull

def Handle_HLRBRep_Data_Create() -> "opencascade::handle< HLRBRep_Data >":
    return _HLRBRep.Handle_HLRBRep_Data_Create()
Handle_HLRBRep_Data_Create = _HLRBRep.Handle_HLRBRep_Data_Create

def Handle_HLRBRep_Data_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< HLRBRep_Data >":
    return _HLRBRep.Handle_HLRBRep_Data_DownCast(t)
Handle_HLRBRep_Data_DownCast = _HLRBRep.Handle_HLRBRep_Data_DownCast

def Handle_HLRBRep_Data_IsNull(t: 'opencascade::handle< HLRBRep_Data > const &') -> "bool":
    return _HLRBRep.Handle_HLRBRep_Data_IsNull(t)
Handle_HLRBRep_Data_IsNull = _HLRBRep.Handle_HLRBRep_Data_IsNull

def Handle_HLRBRep_InternalAlgo_Create() -> "opencascade::handle< HLRBRep_InternalAlgo >":
    return _HLRBRep.Handle_HLRBRep_InternalAlgo_Create()
Handle_HLRBRep_InternalAlgo_Create = _HLRBRep.Handle_HLRBRep_InternalAlgo_Create

def Handle_HLRBRep_InternalAlgo_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< HLRBRep_InternalAlgo >":
    return _HLRBRep.Handle_HLRBRep_InternalAlgo_DownCast(t)
Handle_HLRBRep_InternalAlgo_DownCast = _HLRBRep.Handle_HLRBRep_InternalAlgo_DownCast

def Handle_HLRBRep_InternalAlgo_IsNull(t: 'opencascade::handle< HLRBRep_InternalAlgo > const &') -> "bool":
    return _HLRBRep.Handle_HLRBRep_InternalAlgo_IsNull(t)
Handle_HLRBRep_InternalAlgo_IsNull = _HLRBRep.Handle_HLRBRep_InternalAlgo_IsNull

def Handle_HLRBRep_PolyAlgo_Create() -> "opencascade::handle< HLRBRep_PolyAlgo >":
    return _HLRBRep.Handle_HLRBRep_PolyAlgo_Create()
Handle_HLRBRep_PolyAlgo_Create = _HLRBRep.Handle_HLRBRep_PolyAlgo_Create

def Handle_HLRBRep_PolyAlgo_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< HLRBRep_PolyAlgo >":
    return _HLRBRep.Handle_HLRBRep_PolyAlgo_DownCast(t)
Handle_HLRBRep_PolyAlgo_DownCast = _HLRBRep.Handle_HLRBRep_PolyAlgo_DownCast

def Handle_HLRBRep_PolyAlgo_IsNull(t: 'opencascade::handle< HLRBRep_PolyAlgo > const &') -> "bool":
    return _HLRBRep.Handle_HLRBRep_PolyAlgo_IsNull(t)
Handle_HLRBRep_PolyAlgo_IsNull = _HLRBRep.Handle_HLRBRep_PolyAlgo_IsNull

def Handle_HLRBRep_Algo_Create() -> "opencascade::handle< HLRBRep_Algo >":
    return _HLRBRep.Handle_HLRBRep_Algo_Create()
Handle_HLRBRep_Algo_Create = _HLRBRep.Handle_HLRBRep_Algo_Create

def Handle_HLRBRep_Algo_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< HLRBRep_Algo >":
    return _HLRBRep.Handle_HLRBRep_Algo_DownCast(t)
Handle_HLRBRep_Algo_DownCast = _HLRBRep.Handle_HLRBRep_Algo_DownCast

def Handle_HLRBRep_Algo_IsNull(t: 'opencascade::handle< HLRBRep_Algo > const &') -> "bool":
    return _HLRBRep.Handle_HLRBRep_Algo_IsNull(t)
Handle_HLRBRep_Algo_IsNull = _HLRBRep.Handle_HLRBRep_Algo_IsNull
class HLRBRep_ListOfBPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _HLRBRep.HLRBRep_ListOfBPoint_swiginit(self, _HLRBRep.new_HLRBRep_ListOfBPoint(*args))
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ListOfBPoint
HLRBRep_ListOfBPoint.begin = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_begin, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.end = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_end, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.cbegin = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_cbegin, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.cend = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_cend, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.Size = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_Size, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.Assign = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_Assign, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.Set = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_Set, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.Clear = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_Clear, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.First = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_First, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.Last = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_Last, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.Append = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_Append, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.Prepend = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_Prepend, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.RemoveFirst = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_RemoveFirst, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.Remove = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_Remove, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.InsertBefore = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_InsertBefore, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.InsertAfter = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_InsertAfter, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint.Reverse = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPoint_Reverse, None, HLRBRep_ListOfBPoint)
HLRBRep_ListOfBPoint_swigregister = _HLRBRep.HLRBRep_ListOfBPoint_swigregister
HLRBRep_ListOfBPoint_swigregister(HLRBRep_ListOfBPoint)

class HLRBRep_ListIteratorOfListOfBPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _HLRBRep.HLRBRep_ListIteratorOfListOfBPoint_swiginit(self, _HLRBRep.new_HLRBRep_ListIteratorOfListOfBPoint(*args))
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ListIteratorOfListOfBPoint
HLRBRep_ListIteratorOfListOfBPoint.More = new_instancemethod(_HLRBRep.HLRBRep_ListIteratorOfListOfBPoint_More, None, HLRBRep_ListIteratorOfListOfBPoint)
HLRBRep_ListIteratorOfListOfBPoint.Next = new_instancemethod(_HLRBRep.HLRBRep_ListIteratorOfListOfBPoint_Next, None, HLRBRep_ListIteratorOfListOfBPoint)
HLRBRep_ListIteratorOfListOfBPoint.Value = new_instancemethod(_HLRBRep.HLRBRep_ListIteratorOfListOfBPoint_Value, None, HLRBRep_ListIteratorOfListOfBPoint)
HLRBRep_ListIteratorOfListOfBPoint.ChangeValue = new_instancemethod(_HLRBRep.HLRBRep_ListIteratorOfListOfBPoint_ChangeValue, None, HLRBRep_ListIteratorOfListOfBPoint)
HLRBRep_ListIteratorOfListOfBPoint_swigregister = _HLRBRep.HLRBRep_ListIteratorOfListOfBPoint_swigregister
HLRBRep_ListIteratorOfListOfBPoint_swigregister(HLRBRep_ListIteratorOfListOfBPoint)

class HLRBRep_SeqOfShapeBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _HLRBRep.HLRBRep_SeqOfShapeBounds_swiginit(self, _HLRBRep.new_HLRBRep_SeqOfShapeBounds(*args))
    delNode = staticmethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_delNode)
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_SeqOfShapeBounds
HLRBRep_SeqOfShapeBounds.begin = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_begin, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.end = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_end, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.cbegin = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_cbegin, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.cend = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_cend, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Size = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Size, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Length = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Length, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Lower = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Lower, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Upper = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Upper, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.IsEmpty = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_IsEmpty, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Reverse = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Reverse, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Exchange = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Exchange, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Clear = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Clear, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Assign = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Assign, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Set = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Set, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Remove = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Remove, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Append = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Append, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Prepend = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Prepend, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.InsertBefore = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_InsertBefore, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.InsertAfter = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_InsertAfter, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Split = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Split, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.First = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_First, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.ChangeFirst = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_ChangeFirst, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Last = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Last, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.ChangeLast = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_ChangeLast, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.Value = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_Value, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.ChangeValue = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_ChangeValue, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.__call__ = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds___call__, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds.SetValue = new_instancemethod(_HLRBRep.HLRBRep_SeqOfShapeBounds_SetValue, None, HLRBRep_SeqOfShapeBounds)
HLRBRep_SeqOfShapeBounds_swigregister = _HLRBRep.HLRBRep_SeqOfShapeBounds_swigregister
HLRBRep_SeqOfShapeBounds_swigregister(HLRBRep_SeqOfShapeBounds)

def HLRBRep_SeqOfShapeBounds_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _HLRBRep.HLRBRep_SeqOfShapeBounds_delNode(theNode, theAl)
HLRBRep_SeqOfShapeBounds_delNode = _HLRBRep.HLRBRep_SeqOfShapeBounds_delNode

class HLRBRep_Array1OfEData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _HLRBRep.HLRBRep_Array1OfEData_swiginit(self, _HLRBRep.new_HLRBRep_Array1OfEData(*args))
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Array1OfEData

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

HLRBRep_Array1OfEData.begin = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_begin, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.end = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_end, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.cbegin = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_cbegin, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.cend = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_cend, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Init = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Init, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Size = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Size, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Length = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Length, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.IsEmpty = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_IsEmpty, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Lower = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Lower, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Upper = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Upper, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.IsDeletable = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_IsDeletable, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.IsAllocated = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_IsAllocated, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Assign = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Assign, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Move = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Move, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Set = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Set, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.First = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_First, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.ChangeFirst = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_ChangeFirst, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Last = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Last, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.ChangeLast = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_ChangeLast, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Value = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Value, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.ChangeValue = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_ChangeValue, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.__call__ = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData___call__, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.SetValue = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_SetValue, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData.Resize = new_instancemethod(_HLRBRep.HLRBRep_Array1OfEData_Resize, None, HLRBRep_Array1OfEData)
HLRBRep_Array1OfEData_swigregister = _HLRBRep.HLRBRep_Array1OfEData_swigregister
HLRBRep_Array1OfEData_swigregister(HLRBRep_Array1OfEData)

class HLRBRep_Array1OfFData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _HLRBRep.HLRBRep_Array1OfFData_swiginit(self, _HLRBRep.new_HLRBRep_Array1OfFData(*args))
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Array1OfFData

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

HLRBRep_Array1OfFData.begin = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_begin, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.end = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_end, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.cbegin = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_cbegin, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.cend = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_cend, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Init = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Init, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Size = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Size, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Length = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Length, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.IsEmpty = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_IsEmpty, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Lower = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Lower, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Upper = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Upper, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.IsDeletable = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_IsDeletable, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.IsAllocated = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_IsAllocated, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Assign = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Assign, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Move = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Move, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Set = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Set, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.First = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_First, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.ChangeFirst = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_ChangeFirst, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Last = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Last, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.ChangeLast = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_ChangeLast, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Value = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Value, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.ChangeValue = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_ChangeValue, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.__call__ = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData___call__, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.SetValue = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_SetValue, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData.Resize = new_instancemethod(_HLRBRep.HLRBRep_Array1OfFData_Resize, None, HLRBRep_Array1OfFData)
HLRBRep_Array1OfFData_swigregister = _HLRBRep.HLRBRep_Array1OfFData_swigregister
HLRBRep_Array1OfFData_swigregister(HLRBRep_Array1OfFData)

class HLRBRep_ListOfBPnt2D(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _HLRBRep.HLRBRep_ListOfBPnt2D_swiginit(self, _HLRBRep.new_HLRBRep_ListOfBPnt2D(*args))
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ListOfBPnt2D
HLRBRep_ListOfBPnt2D.begin = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_begin, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.end = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_end, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.cbegin = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_cbegin, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.cend = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_cend, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.Size = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_Size, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.Assign = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_Assign, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.Set = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_Set, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.Clear = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_Clear, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.First = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_First, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.Last = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_Last, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.Append = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_Append, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.Prepend = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_Prepend, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.RemoveFirst = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_RemoveFirst, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.Remove = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_Remove, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.InsertBefore = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_InsertBefore, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.InsertAfter = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_InsertAfter, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D.Reverse = new_instancemethod(_HLRBRep.HLRBRep_ListOfBPnt2D_Reverse, None, HLRBRep_ListOfBPnt2D)
HLRBRep_ListOfBPnt2D_swigregister = _HLRBRep.HLRBRep_ListOfBPnt2D_swigregister
HLRBRep_ListOfBPnt2D_swigregister(HLRBRep_ListOfBPnt2D)

class HLRBRep_ListIteratorOfListOfBPnt2D(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _HLRBRep.HLRBRep_ListIteratorOfListOfBPnt2D_swiginit(self, _HLRBRep.new_HLRBRep_ListIteratorOfListOfBPnt2D(*args))
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ListIteratorOfListOfBPnt2D
HLRBRep_ListIteratorOfListOfBPnt2D.More = new_instancemethod(_HLRBRep.HLRBRep_ListIteratorOfListOfBPnt2D_More, None, HLRBRep_ListIteratorOfListOfBPnt2D)
HLRBRep_ListIteratorOfListOfBPnt2D.Next = new_instancemethod(_HLRBRep.HLRBRep_ListIteratorOfListOfBPnt2D_Next, None, HLRBRep_ListIteratorOfListOfBPnt2D)
HLRBRep_ListIteratorOfListOfBPnt2D.Value = new_instancemethod(_HLRBRep.HLRBRep_ListIteratorOfListOfBPnt2D_Value, None, HLRBRep_ListIteratorOfListOfBPnt2D)
HLRBRep_ListIteratorOfListOfBPnt2D.ChangeValue = new_instancemethod(_HLRBRep.HLRBRep_ListIteratorOfListOfBPnt2D_ChangeValue, None, HLRBRep_ListIteratorOfListOfBPnt2D)
HLRBRep_ListIteratorOfListOfBPnt2D_swigregister = _HLRBRep.HLRBRep_ListIteratorOfListOfBPnt2D_swigregister
HLRBRep_ListIteratorOfListOfBPnt2D_swigregister(HLRBRep_ListIteratorOfListOfBPnt2D)

class hlrbrep(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MakeEdge(*args) -> "TopoDS_Edge":
        """
        :param ec:
        	:type ec: HLRBRep_Curve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:rtype: TopoDS_Edge
        """
        return _HLRBRep.hlrbrep_MakeEdge(*args)

    MakeEdge = staticmethod(MakeEdge)

    def MakeEdge3d(*args) -> "TopoDS_Edge":
        """
        :param ec:
        	:type ec: HLRBRep_Curve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:rtype: TopoDS_Edge
        """
        return _HLRBRep.hlrbrep_MakeEdge3d(*args)

    MakeEdge3d = staticmethod(MakeEdge3d)

    def PolyHLRAngleAndDeflection(*args) -> "Standard_Real &, Standard_Real &":
        """
        :param InAngl:
        	:type InAngl: float
        	:param OutAngl:
        	:type OutAngl: float
        	:param OutDefl:
        	:type OutDefl: float
        	:rtype: void
        """
        return _HLRBRep.hlrbrep_PolyHLRAngleAndDeflection(*args)

    PolyHLRAngleAndDeflection = staticmethod(PolyHLRAngleAndDeflection)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.hlrbrep_swiginit(self, _HLRBRep.new_hlrbrep())
    __swig_destroy__ = _HLRBRep.delete_hlrbrep
hlrbrep_swigregister = _HLRBRep.hlrbrep_swigregister
hlrbrep_swigregister(hlrbrep)

def hlrbrep_MakeEdge(*args) -> "TopoDS_Edge":
    """
    :param ec:
    	:type ec: HLRBRep_Curve
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:rtype: TopoDS_Edge
    """
    return _HLRBRep.hlrbrep_MakeEdge(*args)

def hlrbrep_MakeEdge3d(*args) -> "TopoDS_Edge":
    """
    :param ec:
    	:type ec: HLRBRep_Curve
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:rtype: TopoDS_Edge
    """
    return _HLRBRep.hlrbrep_MakeEdge3d(*args)

def hlrbrep_PolyHLRAngleAndDeflection(*args) -> "Standard_Real &, Standard_Real &":
    """
    :param InAngl:
    	:type InAngl: float
    	:param OutAngl:
    	:type OutAngl: float
    	:param OutDefl:
    	:type OutDefl: float
    	:rtype: void
    """
    return _HLRBRep.hlrbrep_PolyHLRAngleAndDeflection(*args)

class HLRBRep_AreaLimit(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Clear(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_AreaLimit_Clear(self, *args)


    def EdgeAfter(self, *args) -> "TopAbs_State":
        """
        :param St:
        	:type St: TopAbs_State
        	:rtype: None
        :rtype: TopAbs_State
        """
        return _HLRBRep.HLRBRep_AreaLimit_EdgeAfter(self, *args)


    def EdgeBefore(self, *args) -> "TopAbs_State":
        """
        :param St:
        	:type St: TopAbs_State
        	:rtype: None
        :rtype: TopAbs_State
        """
        return _HLRBRep.HLRBRep_AreaLimit_EdgeBefore(self, *args)


    def __init__(self, *args):
        """
        * The previous and next field are set to NULL.
        	:param V:
        	:type V: HLRAlgo_Intersection
        	:param Boundary:
        	:type Boundary: bool
        	:param Interference:
        	:type Interference: bool
        	:param StateBefore:
        	:type StateBefore: TopAbs_State
        	:param StateAfter:
        	:type StateAfter: TopAbs_State
        	:param EdgeBefore:
        	:type EdgeBefore: TopAbs_State
        	:param EdgeAfter:
        	:type EdgeAfter: TopAbs_State
        	:rtype: None
        """
        _HLRBRep.HLRBRep_AreaLimit_swiginit(self, _HLRBRep.new_HLRBRep_AreaLimit(*args))

    def IsBoundary(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_AreaLimit_IsBoundary(self, *args)


    def IsInterference(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_AreaLimit_IsInterference(self, *args)


    def Next(self, *args) -> "opencascade::handle< HLRBRep_AreaLimit >":
        """
        :param N:
        	:type N: HLRBRep_AreaLimit
        	:rtype: None
        :rtype: opencascade::handle<HLRBRep_AreaLimit>
        """
        return _HLRBRep.HLRBRep_AreaLimit_Next(self, *args)


    def Previous(self, *args) -> "opencascade::handle< HLRBRep_AreaLimit >":
        """
        :param P:
        	:type P: HLRBRep_AreaLimit
        	:rtype: None
        :rtype: opencascade::handle<HLRBRep_AreaLimit>
        """
        return _HLRBRep.HLRBRep_AreaLimit_Previous(self, *args)


    def StateAfter(self, *args) -> "TopAbs_State":
        """
        :param St:
        	:type St: TopAbs_State
        	:rtype: None
        :rtype: TopAbs_State
        """
        return _HLRBRep.HLRBRep_AreaLimit_StateAfter(self, *args)


    def StateBefore(self, *args) -> "TopAbs_State":
        """
        :param St:
        	:type St: TopAbs_State
        	:rtype: None
        :rtype: TopAbs_State
        """
        return _HLRBRep.HLRBRep_AreaLimit_StateBefore(self, *args)


    def Vertex(self, *args) -> "HLRAlgo_Intersection const &":
        """:rtype: HLRAlgo_Intersection"""
        return _HLRBRep.HLRBRep_AreaLimit_Vertex(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_HLRBRep_AreaLimit_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_AreaLimit
HLRBRep_AreaLimit.Clear = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_Clear, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit.EdgeAfter = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_EdgeAfter, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit.EdgeBefore = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_EdgeBefore, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit.IsBoundary = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_IsBoundary, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit.IsInterference = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_IsInterference, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit.Next = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_Next, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit.Previous = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_Previous, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit.StateAfter = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_StateAfter, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit.StateBefore = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_StateBefore, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit.Vertex = new_instancemethod(_HLRBRep.HLRBRep_AreaLimit_Vertex, None, HLRBRep_AreaLimit)
HLRBRep_AreaLimit_swigregister = _HLRBRep.HLRBRep_AreaLimit_swigregister
HLRBRep_AreaLimit_swigregister(HLRBRep_AreaLimit)

class HLRBRep_BCurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSpline(*args) -> "opencascade::handle< Geom_BSplineCurve >":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: opencascade::handle<Geom_BSplineCurve>
        """
        return _HLRBRep.HLRBRep_BCurveTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def Bezier(*args) -> "opencascade::handle< Geom_BezierCurve >":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: opencascade::handle<Geom_BezierCurve>
        """
        return _HLRBRep.HLRBRep_BCurveTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def Circle(*args) -> "gp_Circ":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: gp_Circ
        """
        return _HLRBRep.HLRBRep_BCurveTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Continuity(*args) -> "GeomAbs_Shape":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: GeomAbs_Shape
        """
        return _HLRBRep.HLRBRep_BCurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D0(*args) -> "void":
        """
        * Computes the point of parameter U on the curve.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BCurveTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args) -> "void":
        """
        * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BCurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BCurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:param V3:
        	:type V3: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BCurveTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args) -> "gp_Vec":
        """
        * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:param N:
        	:type N: int
        	:rtype: gp_Vec
        """
        return _HLRBRep.HLRBRep_BCurveTool_DN(*args)

    DN = staticmethod(DN)

    def Degree(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_BCurveTool_Degree(*args)

    Degree = staticmethod(Degree)

    def Ellipse(*args) -> "gp_Elips":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: gp_Elips
        """
        return _HLRBRep.HLRBRep_BCurveTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def FirstParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_BCurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def GetType(*args) -> "GeomAbs_CurveType":
        """
        * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: GeomAbs_CurveType
        """
        return _HLRBRep.HLRBRep_BCurveTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Hyperbola(*args) -> "gp_Hypr":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: gp_Hypr
        """
        return _HLRBRep.HLRBRep_BCurveTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Intervals(*args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BCurveTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_BCurveTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_BCurveTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def IsRational(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_BCurveTool_IsRational(*args)

    IsRational = staticmethod(IsRational)

    def LastParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_BCurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Line(*args) -> "gp_Lin":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: gp_Lin
        """
        return _HLRBRep.HLRBRep_BCurveTool_Line(*args)

    Line = staticmethod(Line)

    def NbIntervals(*args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_BCurveTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def NbKnots(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_BCurveTool_NbKnots(*args)

    NbKnots = staticmethod(NbKnots)

    def NbPoles(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_BCurveTool_NbPoles(*args)

    NbPoles = staticmethod(NbPoles)

    def NbSamples(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:param U0:
        	:type U0: float
        	:param U1:
        	:type U1: float
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_BCurveTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Parabola(*args) -> "gp_Parab":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: gp_Parab
        """
        return _HLRBRep.HLRBRep_BCurveTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Period(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_BCurveTool_Period(*args)

    Period = staticmethod(Period)

    def Poles(*args) -> "void":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:param T:
        	:type T: TColgp_Array1OfPnt
        	:rtype: void
        """
        return _HLRBRep.HLRBRep_BCurveTool_Poles(*args)

    Poles = staticmethod(Poles)

    def PolesAndWeights(*args) -> "void":
        """
        :param C:
        	:type C: BRepAdaptor_Curve
        	:param T:
        	:type T: TColgp_Array1OfPnt
        	:param W:
        	:type W: TColStd_Array1OfReal
        	:rtype: void
        """
        return _HLRBRep.HLRBRep_BCurveTool_PolesAndWeights(*args)

    PolesAndWeights = staticmethod(PolesAndWeights)

    def Resolution(*args) -> "Standard_Real":
        """
        * Returns the parametric resolution corresponding to the real space resolution <R3d>.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param R3d:
        	:type R3d: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_BCurveTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def Value(*args) -> "gp_Pnt":
        """
        * Computes the point of parameter U on the curve.
        	:param C:
        	:type C: BRepAdaptor_Curve
        	:param U:
        	:type U: float
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_BCurveTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_BCurveTool_swiginit(self, _HLRBRep.new_HLRBRep_BCurveTool())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_BCurveTool
HLRBRep_BCurveTool_swigregister = _HLRBRep.HLRBRep_BCurveTool_swigregister
HLRBRep_BCurveTool_swigregister(HLRBRep_BCurveTool)

def HLRBRep_BCurveTool_BSpline(*args) -> "opencascade::handle< Geom_BSplineCurve >":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: opencascade::handle<Geom_BSplineCurve>
    """
    return _HLRBRep.HLRBRep_BCurveTool_BSpline(*args)

def HLRBRep_BCurveTool_Bezier(*args) -> "opencascade::handle< Geom_BezierCurve >":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: opencascade::handle<Geom_BezierCurve>
    """
    return _HLRBRep.HLRBRep_BCurveTool_Bezier(*args)

def HLRBRep_BCurveTool_Circle(*args) -> "gp_Circ":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: gp_Circ
    """
    return _HLRBRep.HLRBRep_BCurveTool_Circle(*args)

def HLRBRep_BCurveTool_Continuity(*args) -> "GeomAbs_Shape":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: GeomAbs_Shape
    """
    return _HLRBRep.HLRBRep_BCurveTool_Continuity(*args)

def HLRBRep_BCurveTool_D0(*args) -> "void":
    """
    * Computes the point of parameter U on the curve.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_BCurveTool_D0(*args)

def HLRBRep_BCurveTool_D1(*args) -> "void":
    """
    * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V:
    	:type V: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_BCurveTool_D1(*args)

def HLRBRep_BCurveTool_D2(*args) -> "void":
    """
    * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_BCurveTool_D2(*args)

def HLRBRep_BCurveTool_D3(*args) -> "void":
    """
    * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:param V3:
    	:type V3: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_BCurveTool_D3(*args)

def HLRBRep_BCurveTool_DN(*args) -> "gp_Vec":
    """
    * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:param N:
    	:type N: int
    	:rtype: gp_Vec
    """
    return _HLRBRep.HLRBRep_BCurveTool_DN(*args)

def HLRBRep_BCurveTool_Degree(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_BCurveTool_Degree(*args)

def HLRBRep_BCurveTool_Ellipse(*args) -> "gp_Elips":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: gp_Elips
    """
    return _HLRBRep.HLRBRep_BCurveTool_Ellipse(*args)

def HLRBRep_BCurveTool_FirstParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_BCurveTool_FirstParameter(*args)

def HLRBRep_BCurveTool_GetType(*args) -> "GeomAbs_CurveType":
    """
    * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: GeomAbs_CurveType
    """
    return _HLRBRep.HLRBRep_BCurveTool_GetType(*args)

def HLRBRep_BCurveTool_Hyperbola(*args) -> "gp_Hypr":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: gp_Hypr
    """
    return _HLRBRep.HLRBRep_BCurveTool_Hyperbola(*args)

def HLRBRep_BCurveTool_Intervals(*args) -> "void":
    """
    * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param T:
    	:type T: TColStd_Array1OfReal
    	:param S:
    	:type S: GeomAbs_Shape
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_BCurveTool_Intervals(*args)

def HLRBRep_BCurveTool_IsClosed(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_BCurveTool_IsClosed(*args)

def HLRBRep_BCurveTool_IsPeriodic(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_BCurveTool_IsPeriodic(*args)

def HLRBRep_BCurveTool_IsRational(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_BCurveTool_IsRational(*args)

def HLRBRep_BCurveTool_LastParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_BCurveTool_LastParameter(*args)

def HLRBRep_BCurveTool_Line(*args) -> "gp_Lin":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: gp_Lin
    """
    return _HLRBRep.HLRBRep_BCurveTool_Line(*args)

def HLRBRep_BCurveTool_NbIntervals(*args) -> "Standard_Integer":
    """
    * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param S:
    	:type S: GeomAbs_Shape
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_BCurveTool_NbIntervals(*args)

def HLRBRep_BCurveTool_NbKnots(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_BCurveTool_NbKnots(*args)

def HLRBRep_BCurveTool_NbPoles(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_BCurveTool_NbPoles(*args)

def HLRBRep_BCurveTool_NbSamples(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:param U0:
    	:type U0: float
    	:param U1:
    	:type U1: float
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_BCurveTool_NbSamples(*args)

def HLRBRep_BCurveTool_Parabola(*args) -> "gp_Parab":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: gp_Parab
    """
    return _HLRBRep.HLRBRep_BCurveTool_Parabola(*args)

def HLRBRep_BCurveTool_Period(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_BCurveTool_Period(*args)

def HLRBRep_BCurveTool_Poles(*args) -> "void":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:param T:
    	:type T: TColgp_Array1OfPnt
    	:rtype: void
    """
    return _HLRBRep.HLRBRep_BCurveTool_Poles(*args)

def HLRBRep_BCurveTool_PolesAndWeights(*args) -> "void":
    """
    :param C:
    	:type C: BRepAdaptor_Curve
    	:param T:
    	:type T: TColgp_Array1OfPnt
    	:param W:
    	:type W: TColStd_Array1OfReal
    	:rtype: void
    """
    return _HLRBRep.HLRBRep_BCurveTool_PolesAndWeights(*args)

def HLRBRep_BCurveTool_Resolution(*args) -> "Standard_Real":
    """
    * Returns the parametric resolution corresponding to the real space resolution <R3d>.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param R3d:
    	:type R3d: float
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_BCurveTool_Resolution(*args)

def HLRBRep_BCurveTool_Value(*args) -> "gp_Pnt":
    """
    * Computes the point of parameter U on the curve.
    	:param C:
    	:type C: BRepAdaptor_Curve
    	:param U:
    	:type U: float
    	:rtype: gp_Pnt
    """
    return _HLRBRep.HLRBRep_BCurveTool_Value(*args)

class HLRBRep_BiPnt2D(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param x1:
        	:type x1: float
        	:param y1:
        	:type y1: float
        	:param x2:
        	:type x2: float
        	:param y2:
        	:type y2: float
        	:param S:
        	:type S: TopoDS_Shape
        	:param reg1:
        	:type reg1: bool
        	:param regn:
        	:type regn: bool
        	:param outl:
        	:type outl: bool
        	:param intl:
        	:type intl: bool
        	:rtype: None
        :param thePoint1:
        	:type thePoint1: gp_XY
        	:param thePoint2:
        	:type thePoint2: gp_XY
        	:param S:
        	:type S: TopoDS_Shape
        	:param reg1:
        	:type reg1: bool
        	:param regn:
        	:type regn: bool
        	:param outl:
        	:type outl: bool
        	:param intl:
        	:type intl: bool
        	:rtype: None
        """
        _HLRBRep.HLRBRep_BiPnt2D_swiginit(self, _HLRBRep.new_HLRBRep_BiPnt2D(*args))

    def IntLine(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPnt2D_IntLine(self, *args)


    def OutLine(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPnt2D_OutLine(self, *args)


    def P1(self, *args) -> "gp_Pnt2d const":
        """:rtype: gp_Pnt2d"""
        return _HLRBRep.HLRBRep_BiPnt2D_P1(self, *args)


    def P2(self, *args) -> "gp_Pnt2d const":
        """:rtype: gp_Pnt2d"""
        return _HLRBRep.HLRBRep_BiPnt2D_P2(self, *args)


    def Rg1Line(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPnt2D_Rg1Line(self, *args)


    def RgNLine(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPnt2D_RgNLine(self, *args)


    def Shape(self, *args) -> "void":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPnt2D_Shape(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_BiPnt2D
HLRBRep_BiPnt2D.IntLine = new_instancemethod(_HLRBRep.HLRBRep_BiPnt2D_IntLine, None, HLRBRep_BiPnt2D)
HLRBRep_BiPnt2D.OutLine = new_instancemethod(_HLRBRep.HLRBRep_BiPnt2D_OutLine, None, HLRBRep_BiPnt2D)
HLRBRep_BiPnt2D.P1 = new_instancemethod(_HLRBRep.HLRBRep_BiPnt2D_P1, None, HLRBRep_BiPnt2D)
HLRBRep_BiPnt2D.P2 = new_instancemethod(_HLRBRep.HLRBRep_BiPnt2D_P2, None, HLRBRep_BiPnt2D)
HLRBRep_BiPnt2D.Rg1Line = new_instancemethod(_HLRBRep.HLRBRep_BiPnt2D_Rg1Line, None, HLRBRep_BiPnt2D)
HLRBRep_BiPnt2D.RgNLine = new_instancemethod(_HLRBRep.HLRBRep_BiPnt2D_RgNLine, None, HLRBRep_BiPnt2D)
HLRBRep_BiPnt2D.Shape = new_instancemethod(_HLRBRep.HLRBRep_BiPnt2D_Shape, None, HLRBRep_BiPnt2D)
HLRBRep_BiPnt2D_swigregister = _HLRBRep.HLRBRep_BiPnt2D_swigregister
HLRBRep_BiPnt2D_swigregister(HLRBRep_BiPnt2D)

class HLRBRep_BiPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param x1:
        	:type x1: float
        	:param y1:
        	:type y1: float
        	:param z1:
        	:type z1: float
        	:param x2:
        	:type x2: float
        	:param y2:
        	:type y2: float
        	:param z2:
        	:type z2: float
        	:param S:
        	:type S: TopoDS_Shape
        	:param reg1:
        	:type reg1: bool
        	:param regn:
        	:type regn: bool
        	:param outl:
        	:type outl: bool
        	:param intl:
        	:type intl: bool
        	:rtype: None
        """
        _HLRBRep.HLRBRep_BiPoint_swiginit(self, _HLRBRep.new_HLRBRep_BiPoint(*args))

    def IntLine(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPoint_IntLine(self, *args)


    def OutLine(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPoint_OutLine(self, *args)


    def P1(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _HLRBRep.HLRBRep_BiPoint_P1(self, *args)


    def P2(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _HLRBRep.HLRBRep_BiPoint_P2(self, *args)


    def Rg1Line(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPoint_Rg1Line(self, *args)


    def RgNLine(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPoint_RgNLine(self, *args)


    def Shape(self, *args) -> "void":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_BiPoint_Shape(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_BiPoint
HLRBRep_BiPoint.IntLine = new_instancemethod(_HLRBRep.HLRBRep_BiPoint_IntLine, None, HLRBRep_BiPoint)
HLRBRep_BiPoint.OutLine = new_instancemethod(_HLRBRep.HLRBRep_BiPoint_OutLine, None, HLRBRep_BiPoint)
HLRBRep_BiPoint.P1 = new_instancemethod(_HLRBRep.HLRBRep_BiPoint_P1, None, HLRBRep_BiPoint)
HLRBRep_BiPoint.P2 = new_instancemethod(_HLRBRep.HLRBRep_BiPoint_P2, None, HLRBRep_BiPoint)
HLRBRep_BiPoint.Rg1Line = new_instancemethod(_HLRBRep.HLRBRep_BiPoint_Rg1Line, None, HLRBRep_BiPoint)
HLRBRep_BiPoint.RgNLine = new_instancemethod(_HLRBRep.HLRBRep_BiPoint_RgNLine, None, HLRBRep_BiPoint)
HLRBRep_BiPoint.Shape = new_instancemethod(_HLRBRep.HLRBRep_BiPoint_Shape, None, HLRBRep_BiPoint)
HLRBRep_BiPoint_swigregister = _HLRBRep.HLRBRep_BiPoint_swigregister
HLRBRep_BiPoint_swigregister(HLRBRep_BiPoint)

class HLRBRep_CInter(OCC.Core.IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ComputeDomain(self, *args) -> "IntRes2d_Domain":
        """
        * Create a domain from a curve
        	:param C1:
        	:type C1: Standard_Address
        	:param TolDomain:
        	:type TolDomain: float
        	:rtype: IntRes2d_Domain
        """
        return _HLRBRep.HLRBRep_CInter_ComputeDomain(self, *args)


    def GetMinNbSamples(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_CInter_GetMinNbSamples(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Self Intersection of a curve
        	:param C:
        	:type C: Standard_Address
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Self Intersection of a curve with a domain.
        	:param C:
        	:type C: Standard_Address
        	:param D:
        	:type D: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param C2:
        	:type C2: Standard_Address
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param C2:
        	:type C2: Standard_Address
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param C2:
        	:type C2: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param C2:
        	:type C2: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_CInter_swiginit(self, _HLRBRep.new_HLRBRep_CInter(*args))

    def Perform(self, *args) -> "void":
        """
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param C2:
        	:type C2: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param C2:
        	:type C2: Standard_Address
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param C2:
        	:type C2: Standard_Address
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between 2 curves.
        	:param C1:
        	:type C1: Standard_Address
        	:param C2:
        	:type C2: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CInter_Perform(self, *args)


    def SetMinNbSamples(self, *args) -> "void":
        """
        * Set / get minimum number of points in polygon intersection.
        	:param theMinNbSamples:
        	:type theMinNbSamples: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CInter_SetMinNbSamples(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_CInter
HLRBRep_CInter.ComputeDomain = new_instancemethod(_HLRBRep.HLRBRep_CInter_ComputeDomain, None, HLRBRep_CInter)
HLRBRep_CInter.GetMinNbSamples = new_instancemethod(_HLRBRep.HLRBRep_CInter_GetMinNbSamples, None, HLRBRep_CInter)
HLRBRep_CInter.Perform = new_instancemethod(_HLRBRep.HLRBRep_CInter_Perform, None, HLRBRep_CInter)
HLRBRep_CInter.SetMinNbSamples = new_instancemethod(_HLRBRep.HLRBRep_CInter_SetMinNbSamples, None, HLRBRep_CInter)
HLRBRep_CInter_swigregister = _HLRBRep.HLRBRep_CInter_swigregister
HLRBRep_CInter_swigregister(HLRBRep_CInter)

class HLRBRep_CLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CentreOfCurvature(self, *args) -> "void":
        """
        * Returns the centre of curvature <P>.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CLProps_CentreOfCurvature(self, *args)


    def Curvature(self, *args) -> "Standard_Real":
        """
        * Returns the curvature.
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_CLProps_Curvature(self, *args)


    def D1(self, *args) -> "gp_Vec2d const":
        """
        * Returns the first derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec2d
        """
        return _HLRBRep.HLRBRep_CLProps_D1(self, *args)


    def D2(self, *args) -> "gp_Vec2d const":
        """
        * Returns the second derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec2d
        """
        return _HLRBRep.HLRBRep_CLProps_D2(self, *args)


    def D3(self, *args) -> "gp_Vec2d const":
        """
        * Returns the third derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec2d
        """
        return _HLRBRep.HLRBRep_CLProps_D3(self, *args)


    def __init__(self, *args):
        """
        * Initializes the local properties of the curve <C> The current point and the derivatives are computed at the same time, which allows an optimization of the computation time. <N> indicates the maximum number of derivations to be done (0, 1, 2 or 3). For example, to compute only the tangent, N should be equal to 1. <Resolution> is the linear tolerance (it is used to test if a vector is null).
        	:param C:
        	:type C: HLRBRep_Curve *
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        * Same as previous constructor but here the parameter is set to the value <U>. All the computations done will be related to <C> and <U>.
        	:param C:
        	:type C: HLRBRep_Curve *
        	:param U:
        	:type U: float
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        * Same as previous constructor but here the parameter is set to the value <U> and the curve is set with SetCurve. the curve can have a empty constructor All the computations done will be related to <C> and <U> when the functions 'set' will be done.
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_CLProps_swiginit(self, _HLRBRep.new_HLRBRep_CLProps(*args))

    def IsTangentDefined(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the tangent is defined. For example, the tangent is not defined if the three first derivatives are all null.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_CLProps_IsTangentDefined(self, *args)


    def Normal(self, *args) -> "void":
        """
        * Returns the normal direction <N>.
        	:param N:
        	:type N: gp_Dir2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CLProps_Normal(self, *args)


    def SetCurve(self, *args) -> "void":
        """
        * Initializes the local properties of the curve for the new curve.
        	:param C:
        	:type C: HLRBRep_Curve *
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CLProps_SetCurve(self, *args)


    def SetParameter(self, *args) -> "void":
        """
        * Initializes the local properties of the curve for the parameter value <U>.
        	:param U:
        	:type U: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CLProps_SetParameter(self, *args)


    def Tangent(self, *args) -> "void":
        """
        * output the tangent direction <D>
        	:param D:
        	:type D: gp_Dir2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CLProps_Tangent(self, *args)


    def Value(self, *args) -> "gp_Pnt2d const":
        """
        * Returns the Point.
        	:rtype: gp_Pnt2d
        """
        return _HLRBRep.HLRBRep_CLProps_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_CLProps
HLRBRep_CLProps.CentreOfCurvature = new_instancemethod(_HLRBRep.HLRBRep_CLProps_CentreOfCurvature, None, HLRBRep_CLProps)
HLRBRep_CLProps.Curvature = new_instancemethod(_HLRBRep.HLRBRep_CLProps_Curvature, None, HLRBRep_CLProps)
HLRBRep_CLProps.D1 = new_instancemethod(_HLRBRep.HLRBRep_CLProps_D1, None, HLRBRep_CLProps)
HLRBRep_CLProps.D2 = new_instancemethod(_HLRBRep.HLRBRep_CLProps_D2, None, HLRBRep_CLProps)
HLRBRep_CLProps.D3 = new_instancemethod(_HLRBRep.HLRBRep_CLProps_D3, None, HLRBRep_CLProps)
HLRBRep_CLProps.IsTangentDefined = new_instancemethod(_HLRBRep.HLRBRep_CLProps_IsTangentDefined, None, HLRBRep_CLProps)
HLRBRep_CLProps.Normal = new_instancemethod(_HLRBRep.HLRBRep_CLProps_Normal, None, HLRBRep_CLProps)
HLRBRep_CLProps.SetCurve = new_instancemethod(_HLRBRep.HLRBRep_CLProps_SetCurve, None, HLRBRep_CLProps)
HLRBRep_CLProps.SetParameter = new_instancemethod(_HLRBRep.HLRBRep_CLProps_SetParameter, None, HLRBRep_CLProps)
HLRBRep_CLProps.Tangent = new_instancemethod(_HLRBRep.HLRBRep_CLProps_Tangent, None, HLRBRep_CLProps)
HLRBRep_CLProps.Value = new_instancemethod(_HLRBRep.HLRBRep_CLProps_Value, None, HLRBRep_CLProps)
HLRBRep_CLProps_swigregister = _HLRBRep.HLRBRep_CLProps_swigregister
HLRBRep_CLProps_swigregister(HLRBRep_CLProps)

class HLRBRep_CLPropsATool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Continuity(*args) -> "Standard_Integer":
        """
        * returns the order of continuity of the curve <C>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable. returns 3 : first, second and third are computable.
        	:param A:
        	:type A: HLRBRep_Curve *
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_CLPropsATool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D1(*args) -> "void":
        """
        * Computes the point <P> and first derivative <V1> of parameter <U> on the curve <C>.
        	:param A:
        	:type A: HLRBRep_Curve *
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CLPropsATool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Computes the point <P>, the first derivative <V1> and second derivative <V2> of parameter <U> on the curve <C>.
        	:param A:
        	:type A: HLRBRep_Curve *
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CLPropsATool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        * Computes the point <P>, the first derivative <V1>, the second derivative <V2> and third derivative <V3> of parameter <U> on the curve <C>.
        	:param A:
        	:type A: HLRBRep_Curve *
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:param V3:
        	:type V3: gp_Vec2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CLPropsATool_D3(*args)

    D3 = staticmethod(D3)

    def FirstParameter(*args) -> "Standard_Real":
        """
        * returns the first parameter bound of the curve.
        	:param A:
        	:type A: HLRBRep_Curve *
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_CLPropsATool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args) -> "Standard_Real":
        """
        * returns the last parameter bound of the curve. FirstParameter must be less than LastParamenter.
        	:param A:
        	:type A: HLRBRep_Curve *
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_CLPropsATool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Value(*args) -> "void":
        """
        * Computes the point <P> of parameter <U> on the Curve from HLRBRep <C>.
        	:param A:
        	:type A: HLRBRep_Curve *
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: void
        """
        return _HLRBRep.HLRBRep_CLPropsATool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_CLPropsATool_swiginit(self, _HLRBRep.new_HLRBRep_CLPropsATool())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_CLPropsATool
HLRBRep_CLPropsATool_swigregister = _HLRBRep.HLRBRep_CLPropsATool_swigregister
HLRBRep_CLPropsATool_swigregister(HLRBRep_CLPropsATool)

def HLRBRep_CLPropsATool_Continuity(*args) -> "Standard_Integer":
    """
    * returns the order of continuity of the curve <C>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable. returns 3 : first, second and third are computable.
    	:param A:
    	:type A: HLRBRep_Curve *
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_CLPropsATool_Continuity(*args)

def HLRBRep_CLPropsATool_D1(*args) -> "void":
    """
    * Computes the point <P> and first derivative <V1> of parameter <U> on the curve <C>.
    	:param A:
    	:type A: HLRBRep_Curve *
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_CLPropsATool_D1(*args)

def HLRBRep_CLPropsATool_D2(*args) -> "void":
    """
    * Computes the point <P>, the first derivative <V1> and second derivative <V2> of parameter <U> on the curve <C>.
    	:param A:
    	:type A: HLRBRep_Curve *
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_CLPropsATool_D2(*args)

def HLRBRep_CLPropsATool_D3(*args) -> "void":
    """
    * Computes the point <P>, the first derivative <V1>, the second derivative <V2> and third derivative <V3> of parameter <U> on the curve <C>.
    	:param A:
    	:type A: HLRBRep_Curve *
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:param V3:
    	:type V3: gp_Vec2d
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_CLPropsATool_D3(*args)

def HLRBRep_CLPropsATool_FirstParameter(*args) -> "Standard_Real":
    """
    * returns the first parameter bound of the curve.
    	:param A:
    	:type A: HLRBRep_Curve *
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_CLPropsATool_FirstParameter(*args)

def HLRBRep_CLPropsATool_LastParameter(*args) -> "Standard_Real":
    """
    * returns the last parameter bound of the curve. FirstParameter must be less than LastParamenter.
    	:param A:
    	:type A: HLRBRep_Curve *
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_CLPropsATool_LastParameter(*args)

def HLRBRep_CLPropsATool_Value(*args) -> "void":
    """
    * Computes the point <P> of parameter <U> on the Curve from HLRBRep <C>.
    	:param A:
    	:type A: HLRBRep_Curve *
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:rtype: void
    """
    return _HLRBRep.HLRBRep_CLPropsATool_Value(*args)

class HLRBRep_Curve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Circle(self, *args) -> "gp_Circ2d":
        """:rtype: gp_Circ2d"""
        return _HLRBRep.HLRBRep_Curve_Circle(self, *args)


    def Continuity(self, *args) -> "GeomAbs_Shape":
        """:rtype: GeomAbs_Shape"""
        return _HLRBRep.HLRBRep_Curve_Continuity(self, *args)


    def Curve(self, *args) -> "void":
        """
        * Returns the 3D curve.
        	:rtype: BRepAdaptor_Curve
        * Sets the 3D curve to be projected.
        	:param E:
        	:type E: TopoDS_Edge
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_Curve(self, *args)


    def D0(self, *args) -> "void":
        """
        * Computes the 3D point of parameter U on the curve.
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        * Computes the point of parameter U on the curve.
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_D0(self, *args)


    def D1(self, *args) -> "void":
        """
        * Computes the point of parameter U on the curve with its first derivative.
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Vec
        	:rtype: None
        * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_D1(self, *args)


    def D2(self, *args) -> "void":
        """
        * Raised if the continuity of the current interval is not C2.
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_D2(self, *args)


    def D3(self, *args) -> "void":
        """
        * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:param V3:
        	:type V3: gp_Vec2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_D3(self, *args)


    def DN(self, *args) -> "gp_Vec2d":
        """
        * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
        	:param U:
        	:type U: float
        	:param N:
        	:type N: int
        	:rtype: gp_Vec2d
        """
        return _HLRBRep.HLRBRep_Curve_DN(self, *args)


    def Degree(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_Curve_Degree(self, *args)


    def Ellipse(self, *args) -> "gp_Elips2d":
        """:rtype: gp_Elips2d"""
        return _HLRBRep.HLRBRep_Curve_Ellipse(self, *args)


    def FirstParameter(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _HLRBRep.HLRBRep_Curve_FirstParameter(self, *args)


    def GetCurve(self, *args) -> "BRepAdaptor_Curve const &":
        """
        * Returns the 3D curve.
        	:rtype: BRepAdaptor_Curve
        """
        return _HLRBRep.HLRBRep_Curve_GetCurve(self, *args)


    def GetType(self, *args) -> "GeomAbs_CurveType":
        """
        * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
        	:rtype: GeomAbs_CurveType
        """
        return _HLRBRep.HLRBRep_Curve_GetType(self, *args)


    def __init__(self, *args):
        """
        * Creates an undefined Curve.
        	:rtype: None
        """
        _HLRBRep.HLRBRep_Curve_swiginit(self, _HLRBRep.new_HLRBRep_Curve(*args))

    def Hyperbola(self, *args) -> "gp_Hypr2d":
        """:rtype: gp_Hypr2d"""
        return _HLRBRep.HLRBRep_Curve_Hyperbola(self, *args)


    def Intervals(self, *args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_Intervals(self, *args)


    def IsClosed(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_Curve_IsClosed(self, *args)


    def IsPeriodic(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_Curve_IsPeriodic(self, *args)


    def IsRational(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_Curve_IsRational(self, *args)


    def Knots(self, *args) -> "void":
        """
        :param kn:
        	:type kn: TColStd_Array1OfReal
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_Knots(self, *args)


    def LastParameter(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _HLRBRep.HLRBRep_Curve_LastParameter(self, *args)


    def Line(self, *args) -> "gp_Lin2d":
        """:rtype: gp_Lin2d"""
        return _HLRBRep.HLRBRep_Curve_Line(self, *args)


    def Multiplicities(self, *args) -> "void":
        """
        :param mu:
        	:type mu: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_Multiplicities(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """
        * If necessary, breaks the curve in intervals of continuity <S>. And returns the number of intervals.
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_Curve_NbIntervals(self, *args)


    def NbKnots(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_Curve_NbKnots(self, *args)


    def NbPoles(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_Curve_NbPoles(self, *args)


    def Parabola(self, *args) -> "gp_Parab2d":
        """:rtype: gp_Parab2d"""
        return _HLRBRep.HLRBRep_Curve_Parabola(self, *args)


    def Parameter2d(self, *args) -> "Standard_Real":
        """
        * Returns the parameter on the 2d curve from the parameter on the 3d curve.
        	:param P3d:
        	:type P3d: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_Curve_Parameter2d(self, *args)


    def Parameter3d(self, *args) -> "Standard_Real":
        """
        * Returns the parameter on the 3d curve from the parameter on the 2d curve.
        	:param P2d:
        	:type P2d: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_Curve_Parameter3d(self, *args)


    def Period(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _HLRBRep.HLRBRep_Curve_Period(self, *args)


    def Poles(self, *args) -> "void":
        """
        :param TP:
        	:type TP: TColgp_Array1OfPnt2d
        	:rtype: None
        :param aCurve:
        	:type aCurve: Geom_BSplineCurve
        	:param TP:
        	:type TP: TColgp_Array1OfPnt2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_Poles(self, *args)


    def PolesAndWeights(self, *args) -> "void":
        """
        :param TP:
        	:type TP: TColgp_Array1OfPnt2d
        	:param TW:
        	:type TW: TColStd_Array1OfReal
        	:rtype: None
        :param aCurve:
        	:type aCurve: Geom_BSplineCurve
        	:param TP:
        	:type TP: TColgp_Array1OfPnt2d
        	:param TW:
        	:type TW: TColStd_Array1OfReal
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_PolesAndWeights(self, *args)


    def Projector(self, *args) -> "void":
        """
        :param Proj:
        	:type Proj: HLRAlgo_Projector *
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_Projector(self, *args)


    def Resolution(self, *args) -> "Standard_Real":
        """
        * Returns the parametric resolution corresponding to the real space resolution <R3d>.
        	:param R3d:
        	:type R3d: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_Curve_Resolution(self, *args)


    def Tangent(self, *args) -> "void":
        """
        * Depending on <AtStart> computes the 2D point and tangent on the curve at sart (or at end). If the first derivative is null look after at start (or before at end) with the second derivative.
        	:param AtStart:
        	:type AtStart: bool
        	:param P:
        	:type P: gp_Pnt2d
        	:param D:
        	:type D: gp_Dir2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Curve_Tangent(self, *args)


    def Update(self, *args) -> "Standard_Real":
        """
        * Update the minmax and the internal data
        	:param TotMin:
        	:type TotMin: float
        	:param TotMax:
        	:type TotMax: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_Curve_Update(self, *args)


    def UpdateMinMax(self, *args) -> "Standard_Real":
        """
        * Update the minmax returns tol for enlarge;
        	:param TotMin:
        	:type TotMin: float
        	:param TotMax:
        	:type TotMax: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_Curve_UpdateMinMax(self, *args)


    def Value(self, *args) -> "gp_Pnt2d":
        """
        * Computes the point of parameter U on the curve.
        	:param U:
        	:type U: float
        	:rtype: gp_Pnt2d
        """
        return _HLRBRep.HLRBRep_Curve_Value(self, *args)


    def Value3D(self, *args) -> "gp_Pnt":
        """
        * Computes the 3D point of parameter U on the curve.
        	:param U:
        	:type U: float
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_Curve_Value3D(self, *args)


    def Z(self, *args) -> "Standard_Real":
        """
        * Computes the Z coordinate of the point of parameter U on the curve in the viewing coordinate system
        	:param U:
        	:type U: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_Curve_Z(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Curve
HLRBRep_Curve.Circle = new_instancemethod(_HLRBRep.HLRBRep_Curve_Circle, None, HLRBRep_Curve)
HLRBRep_Curve.Continuity = new_instancemethod(_HLRBRep.HLRBRep_Curve_Continuity, None, HLRBRep_Curve)
HLRBRep_Curve.Curve = new_instancemethod(_HLRBRep.HLRBRep_Curve_Curve, None, HLRBRep_Curve)
HLRBRep_Curve.D0 = new_instancemethod(_HLRBRep.HLRBRep_Curve_D0, None, HLRBRep_Curve)
HLRBRep_Curve.D1 = new_instancemethod(_HLRBRep.HLRBRep_Curve_D1, None, HLRBRep_Curve)
HLRBRep_Curve.D2 = new_instancemethod(_HLRBRep.HLRBRep_Curve_D2, None, HLRBRep_Curve)
HLRBRep_Curve.D3 = new_instancemethod(_HLRBRep.HLRBRep_Curve_D3, None, HLRBRep_Curve)
HLRBRep_Curve.DN = new_instancemethod(_HLRBRep.HLRBRep_Curve_DN, None, HLRBRep_Curve)
HLRBRep_Curve.Degree = new_instancemethod(_HLRBRep.HLRBRep_Curve_Degree, None, HLRBRep_Curve)
HLRBRep_Curve.Ellipse = new_instancemethod(_HLRBRep.HLRBRep_Curve_Ellipse, None, HLRBRep_Curve)
HLRBRep_Curve.FirstParameter = new_instancemethod(_HLRBRep.HLRBRep_Curve_FirstParameter, None, HLRBRep_Curve)
HLRBRep_Curve.GetCurve = new_instancemethod(_HLRBRep.HLRBRep_Curve_GetCurve, None, HLRBRep_Curve)
HLRBRep_Curve.GetType = new_instancemethod(_HLRBRep.HLRBRep_Curve_GetType, None, HLRBRep_Curve)
HLRBRep_Curve.Hyperbola = new_instancemethod(_HLRBRep.HLRBRep_Curve_Hyperbola, None, HLRBRep_Curve)
HLRBRep_Curve.Intervals = new_instancemethod(_HLRBRep.HLRBRep_Curve_Intervals, None, HLRBRep_Curve)
HLRBRep_Curve.IsClosed = new_instancemethod(_HLRBRep.HLRBRep_Curve_IsClosed, None, HLRBRep_Curve)
HLRBRep_Curve.IsPeriodic = new_instancemethod(_HLRBRep.HLRBRep_Curve_IsPeriodic, None, HLRBRep_Curve)
HLRBRep_Curve.IsRational = new_instancemethod(_HLRBRep.HLRBRep_Curve_IsRational, None, HLRBRep_Curve)
HLRBRep_Curve.Knots = new_instancemethod(_HLRBRep.HLRBRep_Curve_Knots, None, HLRBRep_Curve)
HLRBRep_Curve.LastParameter = new_instancemethod(_HLRBRep.HLRBRep_Curve_LastParameter, None, HLRBRep_Curve)
HLRBRep_Curve.Line = new_instancemethod(_HLRBRep.HLRBRep_Curve_Line, None, HLRBRep_Curve)
HLRBRep_Curve.Multiplicities = new_instancemethod(_HLRBRep.HLRBRep_Curve_Multiplicities, None, HLRBRep_Curve)
HLRBRep_Curve.NbIntervals = new_instancemethod(_HLRBRep.HLRBRep_Curve_NbIntervals, None, HLRBRep_Curve)
HLRBRep_Curve.NbKnots = new_instancemethod(_HLRBRep.HLRBRep_Curve_NbKnots, None, HLRBRep_Curve)
HLRBRep_Curve.NbPoles = new_instancemethod(_HLRBRep.HLRBRep_Curve_NbPoles, None, HLRBRep_Curve)
HLRBRep_Curve.Parabola = new_instancemethod(_HLRBRep.HLRBRep_Curve_Parabola, None, HLRBRep_Curve)
HLRBRep_Curve.Parameter2d = new_instancemethod(_HLRBRep.HLRBRep_Curve_Parameter2d, None, HLRBRep_Curve)
HLRBRep_Curve.Parameter3d = new_instancemethod(_HLRBRep.HLRBRep_Curve_Parameter3d, None, HLRBRep_Curve)
HLRBRep_Curve.Period = new_instancemethod(_HLRBRep.HLRBRep_Curve_Period, None, HLRBRep_Curve)
HLRBRep_Curve.Poles = new_instancemethod(_HLRBRep.HLRBRep_Curve_Poles, None, HLRBRep_Curve)
HLRBRep_Curve.PolesAndWeights = new_instancemethod(_HLRBRep.HLRBRep_Curve_PolesAndWeights, None, HLRBRep_Curve)
HLRBRep_Curve.Projector = new_instancemethod(_HLRBRep.HLRBRep_Curve_Projector, None, HLRBRep_Curve)
HLRBRep_Curve.Resolution = new_instancemethod(_HLRBRep.HLRBRep_Curve_Resolution, None, HLRBRep_Curve)
HLRBRep_Curve.Tangent = new_instancemethod(_HLRBRep.HLRBRep_Curve_Tangent, None, HLRBRep_Curve)
HLRBRep_Curve.Update = new_instancemethod(_HLRBRep.HLRBRep_Curve_Update, None, HLRBRep_Curve)
HLRBRep_Curve.UpdateMinMax = new_instancemethod(_HLRBRep.HLRBRep_Curve_UpdateMinMax, None, HLRBRep_Curve)
HLRBRep_Curve.Value = new_instancemethod(_HLRBRep.HLRBRep_Curve_Value, None, HLRBRep_Curve)
HLRBRep_Curve.Value3D = new_instancemethod(_HLRBRep.HLRBRep_Curve_Value3D, None, HLRBRep_Curve)
HLRBRep_Curve.Z = new_instancemethod(_HLRBRep.HLRBRep_Curve_Z, None, HLRBRep_Curve)
HLRBRep_Curve_swigregister = _HLRBRep.HLRBRep_Curve_swigregister
HLRBRep_Curve_swigregister(HLRBRep_Curve)

class HLRBRep_CurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSpline(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _HLRBRep.HLRBRep_CurveTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def Bezier(*args) -> "opencascade::handle< Geom2d_BezierCurve >":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: opencascade::handle<Geom2d_BezierCurve>
        """
        return _HLRBRep.HLRBRep_CurveTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def Circle(*args) -> "gp_Circ2d":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: gp_Circ2d
        """
        return _HLRBRep.HLRBRep_CurveTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Continuity(*args) -> "GeomAbs_Shape":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: GeomAbs_Shape
        """
        return _HLRBRep.HLRBRep_CurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D0(*args) -> "void":
        """
        * Computes the point of parameter U on the curve.
        	:param C:
        	:type C: Standard_Address
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CurveTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args) -> "void":
        """
        * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.
        	:param C:
        	:type C: Standard_Address
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
        	:param C:
        	:type C: Standard_Address
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
        	:param C:
        	:type C: Standard_Address
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:param V3:
        	:type V3: gp_Vec2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CurveTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args) -> "gp_Vec2d":
        """
        * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
        	:param C:
        	:type C: Standard_Address
        	:param U:
        	:type U: float
        	:param N:
        	:type N: int
        	:rtype: gp_Vec2d
        """
        return _HLRBRep.HLRBRep_CurveTool_DN(*args)

    DN = staticmethod(DN)

    def Degree(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_CurveTool_Degree(*args)

    Degree = staticmethod(Degree)

    def Ellipse(*args) -> "gp_Elips2d":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: gp_Elips2d
        """
        return _HLRBRep.HLRBRep_CurveTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def EpsX(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_CurveTool_EpsX(*args)

    EpsX = staticmethod(EpsX)

    def FirstParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_CurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def GetInterval(*args) -> "Standard_Real &, Standard_Real &":
        """
        * output the bounds of interval of index <Index> used if Type == Composite.
        	:param C:
        	:type C: Standard_Address
        	:param Index:
        	:type Index: int
        	:param Tab:
        	:type Tab: TColStd_Array1OfReal
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CurveTool_GetInterval(*args)

    GetInterval = staticmethod(GetInterval)

    def GetType(*args) -> "GeomAbs_CurveType":
        """
        * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
        	:param C:
        	:type C: Standard_Address
        	:rtype: GeomAbs_CurveType
        """
        return _HLRBRep.HLRBRep_CurveTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Hyperbola(*args) -> "gp_Hypr2d":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: gp_Hypr2d
        """
        return _HLRBRep.HLRBRep_CurveTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Intervals(*args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param C:
        	:type C: Standard_Address
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_CurveTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_CurveTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_CurveTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def LastParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_CurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Line(*args) -> "gp_Lin2d":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: gp_Lin2d
        """
        return _HLRBRep.HLRBRep_CurveTool_Line(*args)

    Line = staticmethod(Line)

    def NbIntervals(*args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>
        	:param C:
        	:type C: Standard_Address
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_CurveTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def NbSamples(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: Standard_Address
        	:param U0:
        	:type U0: float
        	:param U1:
        	:type U1: float
        	:rtype: int
        :param C:
        	:type C: Standard_Address
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_CurveTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Parabola(*args) -> "gp_Parab2d":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: gp_Parab2d
        """
        return _HLRBRep.HLRBRep_CurveTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Period(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_CurveTool_Period(*args)

    Period = staticmethod(Period)

    def Resolution(*args) -> "Standard_Real":
        """
        * Returns the parametric resolution corresponding to the real space resolution <R3d>.
        	:param C:
        	:type C: Standard_Address
        	:param R3d:
        	:type R3d: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_CurveTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def TheType(*args) -> "GeomAbs_CurveType":
        """
        * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
        	:param C:
        	:type C: Standard_Address
        	:rtype: GeomAbs_CurveType
        """
        return _HLRBRep.HLRBRep_CurveTool_TheType(*args)

    TheType = staticmethod(TheType)

    def Value(*args) -> "gp_Pnt2d":
        """
        * Computes the point of parameter U on the curve.
        	:param C:
        	:type C: Standard_Address
        	:param U:
        	:type U: float
        	:rtype: gp_Pnt2d
        """
        return _HLRBRep.HLRBRep_CurveTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_CurveTool_swiginit(self, _HLRBRep.new_HLRBRep_CurveTool())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_CurveTool
HLRBRep_CurveTool_swigregister = _HLRBRep.HLRBRep_CurveTool_swigregister
HLRBRep_CurveTool_swigregister(HLRBRep_CurveTool)

def HLRBRep_CurveTool_BSpline(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: opencascade::handle<Geom2d_BSplineCurve>
    """
    return _HLRBRep.HLRBRep_CurveTool_BSpline(*args)

def HLRBRep_CurveTool_Bezier(*args) -> "opencascade::handle< Geom2d_BezierCurve >":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: opencascade::handle<Geom2d_BezierCurve>
    """
    return _HLRBRep.HLRBRep_CurveTool_Bezier(*args)

def HLRBRep_CurveTool_Circle(*args) -> "gp_Circ2d":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: gp_Circ2d
    """
    return _HLRBRep.HLRBRep_CurveTool_Circle(*args)

def HLRBRep_CurveTool_Continuity(*args) -> "GeomAbs_Shape":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: GeomAbs_Shape
    """
    return _HLRBRep.HLRBRep_CurveTool_Continuity(*args)

def HLRBRep_CurveTool_D0(*args) -> "void":
    """
    * Computes the point of parameter U on the curve.
    	:param C:
    	:type C: Standard_Address
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_CurveTool_D0(*args)

def HLRBRep_CurveTool_D1(*args) -> "void":
    """
    * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.
    	:param C:
    	:type C: Standard_Address
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param V:
    	:type V: gp_Vec2d
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_CurveTool_D1(*args)

def HLRBRep_CurveTool_D2(*args) -> "void":
    """
    * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
    	:param C:
    	:type C: Standard_Address
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_CurveTool_D2(*args)

def HLRBRep_CurveTool_D3(*args) -> "void":
    """
    * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
    	:param C:
    	:type C: Standard_Address
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:param V3:
    	:type V3: gp_Vec2d
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_CurveTool_D3(*args)

def HLRBRep_CurveTool_DN(*args) -> "gp_Vec2d":
    """
    * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
    	:param C:
    	:type C: Standard_Address
    	:param U:
    	:type U: float
    	:param N:
    	:type N: int
    	:rtype: gp_Vec2d
    """
    return _HLRBRep.HLRBRep_CurveTool_DN(*args)

def HLRBRep_CurveTool_Degree(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_CurveTool_Degree(*args)

def HLRBRep_CurveTool_Ellipse(*args) -> "gp_Elips2d":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: gp_Elips2d
    """
    return _HLRBRep.HLRBRep_CurveTool_Ellipse(*args)

def HLRBRep_CurveTool_EpsX(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_CurveTool_EpsX(*args)

def HLRBRep_CurveTool_FirstParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_CurveTool_FirstParameter(*args)

def HLRBRep_CurveTool_GetInterval(*args) -> "Standard_Real &, Standard_Real &":
    """
    * output the bounds of interval of index <Index> used if Type == Composite.
    	:param C:
    	:type C: Standard_Address
    	:param Index:
    	:type Index: int
    	:param Tab:
    	:type Tab: TColStd_Array1OfReal
    	:param U1:
    	:type U1: float
    	:param U2:
    	:type U2: float
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_CurveTool_GetInterval(*args)

def HLRBRep_CurveTool_GetType(*args) -> "GeomAbs_CurveType":
    """
    * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
    	:param C:
    	:type C: Standard_Address
    	:rtype: GeomAbs_CurveType
    """
    return _HLRBRep.HLRBRep_CurveTool_GetType(*args)

def HLRBRep_CurveTool_Hyperbola(*args) -> "gp_Hypr2d":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: gp_Hypr2d
    """
    return _HLRBRep.HLRBRep_CurveTool_Hyperbola(*args)

def HLRBRep_CurveTool_Intervals(*args) -> "void":
    """
    * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
    	:param C:
    	:type C: Standard_Address
    	:param T:
    	:type T: TColStd_Array1OfReal
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_CurveTool_Intervals(*args)

def HLRBRep_CurveTool_IsClosed(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_CurveTool_IsClosed(*args)

def HLRBRep_CurveTool_IsPeriodic(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_CurveTool_IsPeriodic(*args)

def HLRBRep_CurveTool_LastParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_CurveTool_LastParameter(*args)

def HLRBRep_CurveTool_Line(*args) -> "gp_Lin2d":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: gp_Lin2d
    """
    return _HLRBRep.HLRBRep_CurveTool_Line(*args)

def HLRBRep_CurveTool_NbIntervals(*args) -> "Standard_Integer":
    """
    * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>
    	:param C:
    	:type C: Standard_Address
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_CurveTool_NbIntervals(*args)

def HLRBRep_CurveTool_NbSamples(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: Standard_Address
    	:param U0:
    	:type U0: float
    	:param U1:
    	:type U1: float
    	:rtype: int
    :param C:
    	:type C: Standard_Address
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_CurveTool_NbSamples(*args)

def HLRBRep_CurveTool_Parabola(*args) -> "gp_Parab2d":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: gp_Parab2d
    """
    return _HLRBRep.HLRBRep_CurveTool_Parabola(*args)

def HLRBRep_CurveTool_Period(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_CurveTool_Period(*args)

def HLRBRep_CurveTool_Resolution(*args) -> "Standard_Real":
    """
    * Returns the parametric resolution corresponding to the real space resolution <R3d>.
    	:param C:
    	:type C: Standard_Address
    	:param R3d:
    	:type R3d: float
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_CurveTool_Resolution(*args)

def HLRBRep_CurveTool_TheType(*args) -> "GeomAbs_CurveType":
    """
    * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
    	:param C:
    	:type C: Standard_Address
    	:rtype: GeomAbs_CurveType
    """
    return _HLRBRep.HLRBRep_CurveTool_TheType(*args)

def HLRBRep_CurveTool_Value(*args) -> "gp_Pnt2d":
    """
    * Computes the point of parameter U on the curve.
    	:param C:
    	:type C: Standard_Address
    	:param U:
    	:type U: float
    	:rtype: gp_Pnt2d
    """
    return _HLRBRep.HLRBRep_CurveTool_Value(*args)

class HLRBRep_Data(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AboveInterference(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the rejected interference is above the face.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_Data_AboveInterference(self, *args)


    def Classify(self, *args) -> "TopAbs_State":
        """
        * Classification of an edge.
        	:param E:
        	:type E: int
        	:param ED:
        	:type ED: HLRBRep_EdgeData
        	:param LevelFlag:
        	:type LevelFlag: bool
        	:param Level:
        	:type Level: int
        	:param param:
        	:type param: float
        	:rtype: TopAbs_State
        """
        return _HLRBRep.HLRBRep_Data_Classify(self, *args)


    def Compare(self, *args) -> "TopAbs_State":
        """
        * Returns the state of the Edge <ED> after classification.
        	:param E:
        	:type E: int
        	:param ED:
        	:type ED: HLRBRep_EdgeData
        	:rtype: TopAbs_State
        """
        return _HLRBRep.HLRBRep_Data_Compare(self, *args)


    def Destroy(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_Data_Destroy(self, *args)


    def EDataArray(self, *args) -> "HLRBRep_Array1OfEData &":
        """:rtype: HLRBRep_Array1OfEData"""
        return _HLRBRep.HLRBRep_Data_EDataArray(self, *args)


    def Edge(self, *args) -> "Standard_Integer":
        """
        * Returns the current Edge
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_Data_Edge(self, *args)


    def EdgeMap(self, *args) -> "TopTools_IndexedMapOfShape &":
        """:rtype: TopTools_IndexedMapOfShape"""
        return _HLRBRep.HLRBRep_Data_EdgeMap(self, *args)


    def EdgeOfTheHidingFace(self, *args) -> "Standard_Boolean":
        """
        * Returns the true if the Edge <ED> belongs to the Hiding Face.
        	:param E:
        	:type E: int
        	:param ED:
        	:type ED: HLRBRep_EdgeData
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_Data_EdgeOfTheHidingFace(self, *args)


    def EdgeState(self, *args) -> "void":
        """
        * Returns the local 3D state of the intersection between the current edge and the current face at the <p1> and <p2> parameters.
        	:param p1:
        	:type p1: float
        	:param p2:
        	:type p2: float
        	:param stbef:
        	:type stbef: TopAbs_State
        	:param staf:
        	:type staf: TopAbs_State
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Data_EdgeState(self, *args)


    def FDataArray(self, *args) -> "HLRBRep_Array1OfFData &":
        """:rtype: HLRBRep_Array1OfFData"""
        return _HLRBRep.HLRBRep_Data_FDataArray(self, *args)


    def FaceMap(self, *args) -> "TopTools_IndexedMapOfShape &":
        """:rtype: TopTools_IndexedMapOfShape"""
        return _HLRBRep.HLRBRep_Data_FaceMap(self, *args)


    def __init__(self, *args):
        """
        * Create an empty data structure of <NV> vertices, <NE> edges and <NF> faces.
        	:param NV:
        	:type NV: int
        	:param NE:
        	:type NE: int
        	:param NF:
        	:type NF: int
        	:rtype: None
        """
        _HLRBRep.HLRBRep_Data_swiginit(self, _HLRBRep.new_HLRBRep_Data(*args))

    def HidingStartLevel(self, *args) -> "Standard_Integer":
        """
        * Returns the number of levels of hiding face above the first point of the edge <ED>. The InterferenceList is given to compute far away of the Interferences and then come back.
        	:param E:
        	:type E: int
        	:param ED:
        	:type ED: HLRBRep_EdgeData
        	:param IL:
        	:type IL: HLRAlgo_InterferenceList
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_Data_HidingStartLevel(self, *args)


    def HidingTheFace(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the current edge to be hidden belongs to the hiding face.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_Data_HidingTheFace(self, *args)


    def InitBoundSort(self, *args) -> "void":
        """
        * to compare with only non rejected edges.
        	:param MinMaxTot:
        	:type MinMaxTot: HLRAlgo_EdgesBlock::MinMaxIndices
        	:param e1:
        	:type e1: int
        	:param e2:
        	:type e2: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Data_InitBoundSort(self, *args)


    def InitEdge(self, *args) -> "void":
        """
        * Begin an iteration only on visible Edges crossing the face number <FI>.
        	:param FI:
        	:type FI: int
        	:param MST:
        	:type MST: BRepTopAdaptor_MapOfShapeTool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Data_InitEdge(self, *args)


    def InitInterference(self, *args) -> "void":
        """
        * Intersect the current Edge with the boundary of the hiding face. The interferences are given by the More, Next, and Value methods.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Data_InitInterference(self, *args)


    def Interference(self, *args) -> "HLRAlgo_Interference &":
        """:rtype: HLRAlgo_Interference"""
        return _HLRBRep.HLRBRep_Data_Interference(self, *args)


    def IsBadFace(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the current face is bad.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_Data_IsBadFace(self, *args)


    def LocalFEGeometry2D(self, *args) -> "void":
        """
        * Returns the local description of the projection of the current FEdge at parameter <Param>.
        	:param FE:
        	:type FE: int
        	:param Param:
        	:type Param: float
        	:param Tg:
        	:type Tg: gp_Dir2d
        	:param Nm:
        	:type Nm: gp_Dir2d
        	:param Cu:
        	:type Cu: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Data_LocalFEGeometry2D(self, *args)


    def LocalLEGeometry2D(self, *args) -> "void":
        """
        * Returns the local description of the projection of the current LEdge at parameter <Param>.
        	:param Param:
        	:type Param: float
        	:param Tg:
        	:type Tg: gp_Dir2d
        	:param Nm:
        	:type Nm: gp_Dir2d
        	:param Cu:
        	:type Cu: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Data_LocalLEGeometry2D(self, *args)


    def MoreEdge(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_Data_MoreEdge(self, *args)


    def MoreInterference(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_Data_MoreInterference(self, *args)


    def NbEdges(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_Data_NbEdges(self, *args)


    def NbFaces(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_Data_NbFaces(self, *args)


    def NbVertices(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_Data_NbVertices(self, *args)


    def NextEdge(self, *args) -> "void":
        """
        :param skip: default value is Standard_True
        	:type skip: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Data_NextEdge(self, *args)


    def NextInterference(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_Data_NextInterference(self, *args)


    def Projector(self, *args) -> "HLRAlgo_Projector &":
        """:rtype: HLRAlgo_Projector"""
        return _HLRBRep.HLRBRep_Data_Projector(self, *args)


    def RejectedInterference(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the interference is rejected.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_Data_RejectedInterference(self, *args)


    def SimplClassify(self, *args) -> "TopAbs_State":
        """
        * Simple classification of part of edge [p1, p2] returns OUT if at least 1 of Nbp points of edge is out othewise returns IN It is used to check 'suspision' hided part of edge.
        	:param E:
        	:type E: int
        	:param ED:
        	:type ED: HLRBRep_EdgeData
        	:param Nbp:
        	:type Nbp: int
        	:param p1:
        	:type p1: float
        	:param p2:
        	:type p2: float
        	:rtype: TopAbs_State
        """
        return _HLRBRep.HLRBRep_Data_SimplClassify(self, *args)


    def SimpleHidingFace(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the current hiding face is not an auto-intersected one.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_Data_SimpleHidingFace(self, *args)


    def Tolerance(self, *args) -> "Standard_ShortReal":
        """
        * Set the tolerance for the rejections during the exploration
        	:param tol:
        	:type tol: Standard_ShortReal
        	:rtype: None
        * returns the tolerance for the rejections during the exploration
        	:rtype: Standard_ShortReal
        """
        return _HLRBRep.HLRBRep_Data_Tolerance(self, *args)


    def Update(self, *args) -> "void":
        """
        * end of building of the Data and updating all the informations linked to the projection.
        	:param P:
        	:type P: HLRAlgo_Projector
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Data_Update(self, *args)


    def Write(self, *args) -> "void":
        """
        * Write <DS> in me with a translation of <dv>,<de>,<df>.
        	:param DS:
        	:type DS: HLRBRep_Data
        	:param dv:
        	:type dv: int
        	:param de:
        	:type de: int
        	:param df:
        	:type df: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Data_Write(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_HLRBRep_Data_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Data
HLRBRep_Data.AboveInterference = new_instancemethod(_HLRBRep.HLRBRep_Data_AboveInterference, None, HLRBRep_Data)
HLRBRep_Data.Classify = new_instancemethod(_HLRBRep.HLRBRep_Data_Classify, None, HLRBRep_Data)
HLRBRep_Data.Compare = new_instancemethod(_HLRBRep.HLRBRep_Data_Compare, None, HLRBRep_Data)
HLRBRep_Data.Destroy = new_instancemethod(_HLRBRep.HLRBRep_Data_Destroy, None, HLRBRep_Data)
HLRBRep_Data.EDataArray = new_instancemethod(_HLRBRep.HLRBRep_Data_EDataArray, None, HLRBRep_Data)
HLRBRep_Data.Edge = new_instancemethod(_HLRBRep.HLRBRep_Data_Edge, None, HLRBRep_Data)
HLRBRep_Data.EdgeMap = new_instancemethod(_HLRBRep.HLRBRep_Data_EdgeMap, None, HLRBRep_Data)
HLRBRep_Data.EdgeOfTheHidingFace = new_instancemethod(_HLRBRep.HLRBRep_Data_EdgeOfTheHidingFace, None, HLRBRep_Data)
HLRBRep_Data.EdgeState = new_instancemethod(_HLRBRep.HLRBRep_Data_EdgeState, None, HLRBRep_Data)
HLRBRep_Data.FDataArray = new_instancemethod(_HLRBRep.HLRBRep_Data_FDataArray, None, HLRBRep_Data)
HLRBRep_Data.FaceMap = new_instancemethod(_HLRBRep.HLRBRep_Data_FaceMap, None, HLRBRep_Data)
HLRBRep_Data.HidingStartLevel = new_instancemethod(_HLRBRep.HLRBRep_Data_HidingStartLevel, None, HLRBRep_Data)
HLRBRep_Data.HidingTheFace = new_instancemethod(_HLRBRep.HLRBRep_Data_HidingTheFace, None, HLRBRep_Data)
HLRBRep_Data.InitBoundSort = new_instancemethod(_HLRBRep.HLRBRep_Data_InitBoundSort, None, HLRBRep_Data)
HLRBRep_Data.InitEdge = new_instancemethod(_HLRBRep.HLRBRep_Data_InitEdge, None, HLRBRep_Data)
HLRBRep_Data.InitInterference = new_instancemethod(_HLRBRep.HLRBRep_Data_InitInterference, None, HLRBRep_Data)
HLRBRep_Data.Interference = new_instancemethod(_HLRBRep.HLRBRep_Data_Interference, None, HLRBRep_Data)
HLRBRep_Data.IsBadFace = new_instancemethod(_HLRBRep.HLRBRep_Data_IsBadFace, None, HLRBRep_Data)
HLRBRep_Data.LocalFEGeometry2D = new_instancemethod(_HLRBRep.HLRBRep_Data_LocalFEGeometry2D, None, HLRBRep_Data)
HLRBRep_Data.LocalLEGeometry2D = new_instancemethod(_HLRBRep.HLRBRep_Data_LocalLEGeometry2D, None, HLRBRep_Data)
HLRBRep_Data.MoreEdge = new_instancemethod(_HLRBRep.HLRBRep_Data_MoreEdge, None, HLRBRep_Data)
HLRBRep_Data.MoreInterference = new_instancemethod(_HLRBRep.HLRBRep_Data_MoreInterference, None, HLRBRep_Data)
HLRBRep_Data.NbEdges = new_instancemethod(_HLRBRep.HLRBRep_Data_NbEdges, None, HLRBRep_Data)
HLRBRep_Data.NbFaces = new_instancemethod(_HLRBRep.HLRBRep_Data_NbFaces, None, HLRBRep_Data)
HLRBRep_Data.NbVertices = new_instancemethod(_HLRBRep.HLRBRep_Data_NbVertices, None, HLRBRep_Data)
HLRBRep_Data.NextEdge = new_instancemethod(_HLRBRep.HLRBRep_Data_NextEdge, None, HLRBRep_Data)
HLRBRep_Data.NextInterference = new_instancemethod(_HLRBRep.HLRBRep_Data_NextInterference, None, HLRBRep_Data)
HLRBRep_Data.Projector = new_instancemethod(_HLRBRep.HLRBRep_Data_Projector, None, HLRBRep_Data)
HLRBRep_Data.RejectedInterference = new_instancemethod(_HLRBRep.HLRBRep_Data_RejectedInterference, None, HLRBRep_Data)
HLRBRep_Data.SimplClassify = new_instancemethod(_HLRBRep.HLRBRep_Data_SimplClassify, None, HLRBRep_Data)
HLRBRep_Data.SimpleHidingFace = new_instancemethod(_HLRBRep.HLRBRep_Data_SimpleHidingFace, None, HLRBRep_Data)
HLRBRep_Data.Tolerance = new_instancemethod(_HLRBRep.HLRBRep_Data_Tolerance, None, HLRBRep_Data)
HLRBRep_Data.Update = new_instancemethod(_HLRBRep.HLRBRep_Data_Update, None, HLRBRep_Data)
HLRBRep_Data.Write = new_instancemethod(_HLRBRep.HLRBRep_Data_Write, None, HLRBRep_Data)
HLRBRep_Data_swigregister = _HLRBRep.HLRBRep_Data_swigregister
HLRBRep_Data_swigregister(HLRBRep_Data)

class HLRBRep_EdgeBuilder(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AreaEdgeState(self, *args) -> "TopAbs_State":
        """
        * Returns the edge state of the current area.
        	:rtype: TopAbs_State
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_AreaEdgeState(self, *args)


    def AreaState(self, *args) -> "TopAbs_State":
        """
        * Returns the state of the current area.
        	:rtype: TopAbs_State
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_AreaState(self, *args)


    def Builds(self, *args) -> "void":
        """
        * Reinitialize the results iteration to the parts with State <ToBuild>. If this method is not called after construction the default is <ToBuild> = IN.
        	:param ToBuild:
        	:type ToBuild: TopAbs_State
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_Builds(self, *args)


    def Current(self, *args) -> "HLRAlgo_Intersection const &":
        """
        * Returns the current vertex of the current edge.
        	:rtype: HLRAlgo_Intersection
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_Current(self, *args)


    def Destroy(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_EdgeBuilder_Destroy(self, *args)


    def __init__(self, *args):
        """
        * Creates an EdgeBuilder algorithm. <VList> describes the edge and the interferences. AreaLimits are created from the vertices. Builds(IN) is automatically called.
        	:param VList:
        	:type VList: HLRBRep_VertexList
        	:rtype: None
        """
        _HLRBRep.HLRBRep_EdgeBuilder_swiginit(self, _HLRBRep.new_HLRBRep_EdgeBuilder(*args))

    def HasArea(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there is a current area.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_HasArea(self, *args)


    def InitAreas(self, *args) -> "void":
        """
        * Initialize an iteration on the areas.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_InitAreas(self, *args)


    def IsBoundary(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the current vertex comes from the boundary of the edge.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_IsBoundary(self, *args)


    def IsInterference(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the current vertex was an interference.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_IsInterference(self, *args)


    def LeftLimit(self, *args) -> "opencascade::handle< HLRBRep_AreaLimit >":
        """
        * Returns the AreaLimit beginning the current area. This is a NULL handle when the area is infinite on the left.
        	:rtype: opencascade::handle<HLRBRep_AreaLimit>
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_LeftLimit(self, *args)


    def MoreEdges(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there are more new edges to build.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_MoreEdges(self, *args)


    def MoreVertices(self, *args) -> "Standard_Boolean":
        """
        * True if there are more vertices in the current new edge.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_MoreVertices(self, *args)


    def NextArea(self, *args) -> "void":
        """
        * Set the current area to the next area.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_NextArea(self, *args)


    def NextEdge(self, *args) -> "void":
        """
        * Proceeds to the next edge to build. Skip all remaining vertices on the current edge.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_NextEdge(self, *args)


    def NextVertex(self, *args) -> "void":
        """
        * Proceeds to the next vertex of the current edge.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_NextVertex(self, *args)


    def Orientation(self, *args) -> "TopAbs_Orientation":
        """
        * Returns the new orientation of the current vertex.
        	:rtype: TopAbs_Orientation
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_Orientation(self, *args)


    def PreviousArea(self, *args) -> "void":
        """
        * Set the current area to the previous area.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_PreviousArea(self, *args)


    def RightLimit(self, *args) -> "opencascade::handle< HLRBRep_AreaLimit >":
        """
        * Returns the AreaLimit ending the current area. This is a NULL handle when the area is infinite on the right.
        	:rtype: opencascade::handle<HLRBRep_AreaLimit>
        """
        return _HLRBRep.HLRBRep_EdgeBuilder_RightLimit(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeBuilder
HLRBRep_EdgeBuilder.AreaEdgeState = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_AreaEdgeState, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.AreaState = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_AreaState, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.Builds = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_Builds, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.Current = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_Current, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.Destroy = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_Destroy, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.HasArea = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_HasArea, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.InitAreas = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_InitAreas, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.IsBoundary = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_IsBoundary, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.IsInterference = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_IsInterference, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.LeftLimit = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_LeftLimit, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.MoreEdges = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_MoreEdges, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.MoreVertices = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_MoreVertices, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.NextArea = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_NextArea, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.NextEdge = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_NextEdge, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.NextVertex = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_NextVertex, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.Orientation = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_Orientation, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.PreviousArea = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_PreviousArea, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder.RightLimit = new_instancemethod(_HLRBRep.HLRBRep_EdgeBuilder_RightLimit, None, HLRBRep_EdgeBuilder)
HLRBRep_EdgeBuilder_swigregister = _HLRBRep.HLRBRep_EdgeBuilder_swigregister
HLRBRep_EdgeBuilder_swigregister(HLRBRep_EdgeBuilder)

class HLRBRep_EdgeData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AutoIntersectionDone(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_AutoIntersectionDone(self, *args)


    def ChangeGeometry(self, *args) -> "HLRBRep_Curve &":
        """:rtype: HLRBRep_Curve"""
        return _HLRBRep.HLRBRep_EdgeData_ChangeGeometry(self, *args)


    def Curve(self, *args) -> "HLRBRep_Curve *":
        """:rtype: HLRBRep_Curve *"""
        return _HLRBRep.HLRBRep_EdgeData_Curve(self, *args)


    def CutAtEnd(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_CutAtEnd(self, *args)


    def CutAtSta(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_CutAtSta(self, *args)


    def Geometry(self, *args) -> "HLRBRep_Curve const &":
        """:rtype: HLRBRep_Curve"""
        return _HLRBRep.HLRBRep_EdgeData_Geometry(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _HLRBRep.HLRBRep_EdgeData_swiginit(self, _HLRBRep.new_HLRBRep_EdgeData(*args))

    def HideCount(self, *args) -> "void":
        """
        :rtype: int
        :param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_HideCount(self, *args)


    def MinMax(self, *args) -> "HLRAlgo_EdgesBlock::MinMaxIndices &":
        """:rtype: HLRAlgo_EdgesBlock::MinMaxIndices"""
        return _HLRBRep.HLRBRep_EdgeData_MinMax(self, *args)


    def OutLVEnd(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_OutLVEnd(self, *args)


    def OutLVSta(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_OutLVSta(self, *args)


    def Rg1Line(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_Rg1Line(self, *args)


    def RgNLine(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_RgNLine(self, *args)


    def Selected(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_Selected(self, *args)


    def Set(self, *args) -> "void":
        """
        :param Reg1:
        	:type Reg1: bool
        	:param RegN:
        	:type RegN: bool
        	:param EG:
        	:type EG: TopoDS_Edge
        	:param V1:
        	:type V1: int
        	:param V2:
        	:type V2: int
        	:param Out1:
        	:type Out1: bool
        	:param Out2:
        	:type Out2: bool
        	:param Cut1:
        	:type Cut1: bool
        	:param Cut2:
        	:type Cut2: bool
        	:param Start:
        	:type Start: float
        	:param TolStart:
        	:type TolStart: Standard_ShortReal
        	:param End:
        	:type End: float
        	:param TolEnd:
        	:type TolEnd: Standard_ShortReal
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_Set(self, *args)


    def Simple(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_Simple(self, *args)


    def Status(self, *args) -> "HLRAlgo_EdgeStatus &":
        """:rtype: HLRAlgo_EdgeStatus"""
        return _HLRBRep.HLRBRep_EdgeData_Status(self, *args)


    def Tolerance(self, *args) -> "Standard_ShortReal":
        """:rtype: Standard_ShortReal"""
        return _HLRBRep.HLRBRep_EdgeData_Tolerance(self, *args)


    def UpdateMinMax(self, *args) -> "void":
        """
        :param theTotMinMax:
        	:type theTotMinMax: HLRAlgo_EdgesBlock::MinMaxIndices
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_UpdateMinMax(self, *args)


    def Used(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_Used(self, *args)


    def VEnd(self, *args) -> "void":
        """
        :rtype: int
        :param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_VEnd(self, *args)


    def VSta(self, *args) -> "void":
        """
        :rtype: int
        :param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_VSta(self, *args)


    def VerAtEnd(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_VerAtEnd(self, *args)


    def VerAtSta(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_VerAtSta(self, *args)


    def Vertical(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeData_Vertical(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeData
HLRBRep_EdgeData.AutoIntersectionDone = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_AutoIntersectionDone, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.ChangeGeometry = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_ChangeGeometry, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Curve = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Curve, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.CutAtEnd = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_CutAtEnd, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.CutAtSta = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_CutAtSta, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Geometry = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Geometry, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.HideCount = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_HideCount, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.MinMax = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_MinMax, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.OutLVEnd = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_OutLVEnd, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.OutLVSta = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_OutLVSta, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Rg1Line = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Rg1Line, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.RgNLine = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_RgNLine, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Selected = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Selected, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Set = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Set, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Simple = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Simple, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Status = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Status, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Tolerance = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Tolerance, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.UpdateMinMax = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_UpdateMinMax, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Used = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Used, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.VEnd = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_VEnd, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.VSta = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_VSta, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.VerAtEnd = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_VerAtEnd, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.VerAtSta = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_VerAtSta, None, HLRBRep_EdgeData)
HLRBRep_EdgeData.Vertical = new_instancemethod(_HLRBRep.HLRBRep_EdgeData_Vertical, None, HLRBRep_EdgeData)
HLRBRep_EdgeData_swigregister = _HLRBRep.HLRBRep_EdgeData_swigregister
HLRBRep_EdgeData_swigregister(HLRBRep_EdgeData)

class HLRBRep_EdgeFaceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CurvatureValue(*args) -> "Standard_Real":
        """
        :param F:
        	:type F: Standard_Address
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param Tg:
        	:type Tg: gp_Dir
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_EdgeFaceTool_CurvatureValue(*args)

    CurvatureValue = staticmethod(CurvatureValue)

    def UVPoint(*args) -> "Standard_Real &, Standard_Real &":
        """
        * return True if U and V are found.
        	:param Par:
        	:type Par: float
        	:param E:
        	:type E: Standard_Address
        	:param F:
        	:type F: Standard_Address
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_EdgeFaceTool_UVPoint(*args)

    UVPoint = staticmethod(UVPoint)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_EdgeFaceTool_swiginit(self, _HLRBRep.new_HLRBRep_EdgeFaceTool())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeFaceTool
HLRBRep_EdgeFaceTool_swigregister = _HLRBRep.HLRBRep_EdgeFaceTool_swigregister
HLRBRep_EdgeFaceTool_swigregister(HLRBRep_EdgeFaceTool)

def HLRBRep_EdgeFaceTool_CurvatureValue(*args) -> "Standard_Real":
    """
    :param F:
    	:type F: Standard_Address
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param Tg:
    	:type Tg: gp_Dir
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_EdgeFaceTool_CurvatureValue(*args)

def HLRBRep_EdgeFaceTool_UVPoint(*args) -> "Standard_Real &, Standard_Real &":
    """
    * return True if U and V are found.
    	:param Par:
    	:type Par: float
    	:param E:
    	:type E: Standard_Address
    	:param F:
    	:type F: Standard_Address
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_EdgeFaceTool_UVPoint(*args)

class HLRBRep_EdgeIList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddInterference(*args) -> "void":
        """
        * Add the interference <I> to the list <IL>.
        	:param IL:
        	:type IL: HLRAlgo_InterferenceList
        	:param I:
        	:type I: HLRAlgo_Interference
        	:param T:
        	:type T: HLRBRep_EdgeInterferenceTool
        	:rtype: void
        """
        return _HLRBRep.HLRBRep_EdgeIList_AddInterference(*args)

    AddInterference = staticmethod(AddInterference)

    def ProcessComplex(*args) -> "void":
        """
        * Process complex transitions on the list IL.
        	:param IL:
        	:type IL: HLRAlgo_InterferenceList
        	:param T:
        	:type T: HLRBRep_EdgeInterferenceTool
        	:rtype: void
        """
        return _HLRBRep.HLRBRep_EdgeIList_ProcessComplex(*args)

    ProcessComplex = staticmethod(ProcessComplex)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_EdgeIList_swiginit(self, _HLRBRep.new_HLRBRep_EdgeIList())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeIList
HLRBRep_EdgeIList_swigregister = _HLRBRep.HLRBRep_EdgeIList_swigregister
HLRBRep_EdgeIList_swigregister(HLRBRep_EdgeIList)

def HLRBRep_EdgeIList_AddInterference(*args) -> "void":
    """
    * Add the interference <I> to the list <IL>.
    	:param IL:
    	:type IL: HLRAlgo_InterferenceList
    	:param I:
    	:type I: HLRAlgo_Interference
    	:param T:
    	:type T: HLRBRep_EdgeInterferenceTool
    	:rtype: void
    """
    return _HLRBRep.HLRBRep_EdgeIList_AddInterference(*args)

def HLRBRep_EdgeIList_ProcessComplex(*args) -> "void":
    """
    * Process complex transitions on the list IL.
    	:param IL:
    	:type IL: HLRAlgo_InterferenceList
    	:param T:
    	:type T: HLRBRep_EdgeInterferenceTool
    	:rtype: void
    """
    return _HLRBRep.HLRBRep_EdgeIList_ProcessComplex(*args)

class HLRBRep_EdgeInterferenceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CurrentOrientation(self, *args) -> "TopAbs_Orientation":
        """:rtype: TopAbs_Orientation"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_CurrentOrientation(self, *args)


    def CurrentParameter(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_CurrentParameter(self, *args)


    def CurrentVertex(self, *args) -> "HLRAlgo_Intersection const &":
        """:rtype: HLRAlgo_Intersection"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_CurrentVertex(self, *args)


    def EdgeGeometry(self, *args) -> "void":
        """
        * Returns local geometric description of the Edge at parameter <Para>. See method Reset of class EdgeFaceTransition from TopCnx for other arguments.
        	:param Param:
        	:type Param: float
        	:param Tgt:
        	:type Tgt: gp_Dir
        	:param Nrm:
        	:type Nrm: gp_Dir
        	:param Curv:
        	:type Curv: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_EdgeGeometry(self, *args)


    def __init__(self, *args):
        """
        :param DS:
        	:type DS: HLRBRep_Data
        	:rtype: None
        """
        _HLRBRep.HLRBRep_EdgeInterferenceTool_swiginit(self, _HLRBRep.new_HLRBRep_EdgeInterferenceTool(*args))

    def InitVertices(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_InitVertices(self, *args)


    def InterferenceBoundaryGeometry(self, *args) -> "void":
        """
        * Returns the geometry of the boundary at the interference <I>. See the AddInterference method of the class EdgeFaceTransition from TopCnx for the other arguments.
        	:param I:
        	:type I: HLRAlgo_Interference
        	:param Tang:
        	:type Tang: gp_Dir
        	:param Norm:
        	:type Norm: gp_Dir
        	:param Curv:
        	:type Curv: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_InterferenceBoundaryGeometry(self, *args)


    def IsPeriodic(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_IsPeriodic(self, *args)


    def LoadEdge(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_LoadEdge(self, *args)


    def MoreVertices(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_MoreVertices(self, *args)


    def NextVertex(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_NextVertex(self, *args)


    def ParameterOfInterference(self, *args) -> "Standard_Real":
        """
        :param I:
        	:type I: HLRAlgo_Interference
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_ParameterOfInterference(self, *args)


    def SameInterferences(self, *args) -> "Standard_Boolean":
        """
        * True if the two interferences are on the same geometric locus.
        	:param I1:
        	:type I1: HLRAlgo_Interference
        	:param I2:
        	:type I2: HLRAlgo_Interference
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_SameInterferences(self, *args)


    def SameVertexAndInterference(self, *args) -> "Standard_Boolean":
        """
        * True if the Interference and the current Vertex are on the same geometric locus.
        	:param I:
        	:type I: HLRAlgo_Interference
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_EdgeInterferenceTool_SameVertexAndInterference(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_EdgeInterferenceTool
HLRBRep_EdgeInterferenceTool.CurrentOrientation = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_CurrentOrientation, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.CurrentParameter = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_CurrentParameter, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.CurrentVertex = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_CurrentVertex, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.EdgeGeometry = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_EdgeGeometry, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.InitVertices = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_InitVertices, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.InterferenceBoundaryGeometry = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_InterferenceBoundaryGeometry, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.IsPeriodic = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_IsPeriodic, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.LoadEdge = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_LoadEdge, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.MoreVertices = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_MoreVertices, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.NextVertex = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_NextVertex, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.ParameterOfInterference = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_ParameterOfInterference, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.SameInterferences = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_SameInterferences, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool.SameVertexAndInterference = new_instancemethod(_HLRBRep.HLRBRep_EdgeInterferenceTool_SameVertexAndInterference, None, HLRBRep_EdgeInterferenceTool)
HLRBRep_EdgeInterferenceTool_swigregister = _HLRBRep.HLRBRep_EdgeInterferenceTool_swigregister
HLRBRep_EdgeInterferenceTool_swigregister(HLRBRep_EdgeInterferenceTool)

class HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AnErrorOccurred(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_AnErrorOccurred(self, *args)


    def __init__(self, *args):
        """
        :param C1:
        	:type C1: Standard_Address
        	:param C2:
        	:type C2: Standard_Address
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter(*args))

    def NbRoots(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_NbRoots(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param Poly1:
        	:type Poly1: HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter
        	:param Poly2:
        	:type Poly2: HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter
        	:param NumSegOn1:
        	:type NumSegOn1: int
        	:param NumSegOn2:
        	:type NumSegOn2: int
        	:param ParamOnSeg1:
        	:type ParamOnSeg1: float
        	:param ParamOnSeg2:
        	:type ParamOnSeg2: float
        	:rtype: None
        :param Uo:
        	:type Uo: float
        	:param Vo:
        	:type Vo: float
        	:param UInf:
        	:type UInf: float
        	:param VInf:
        	:type VInf: float
        	:param USup:
        	:type USup: float
        	:param VSup:
        	:type VSup: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_Perform(self, *args)


    def Roots(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_Roots(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter
HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter.AnErrorOccurred = new_instancemethod(_HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_AnErrorOccurred, None, HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter)
HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter.NbRoots = new_instancemethod(_HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_NbRoots, None, HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter)
HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter.Perform = new_instancemethod(_HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_Perform, None, HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter)
HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter.Roots = new_instancemethod(_HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_Roots, None, HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter)
HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_swigregister = _HLRBRep.HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_swigregister
HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter_swigregister(HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter)

class HLRBRep_FaceData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Back(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Back(self, *args)


    def Closed(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Closed(self, *args)


    def Cone(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Cone(self, *args)


    def Cut(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Cut(self, *args)


    def Cylinder(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Cylinder(self, *args)


    def Geometry(self, *args) -> "HLRBRep_Surface &":
        """:rtype: HLRBRep_Surface"""
        return _HLRBRep.HLRBRep_FaceData_Geometry(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _HLRBRep.HLRBRep_FaceData_swiginit(self, _HLRBRep.new_HLRBRep_FaceData(*args))

    def Hiding(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Hiding(self, *args)


    def Orientation(self, *args) -> "void":
        """
        :rtype: TopAbs_Orientation
        :param O:
        	:type O: TopAbs_Orientation
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Orientation(self, *args)


    def Plane(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Plane(self, *args)


    def Selected(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Selected(self, *args)


    def Set(self, *args) -> "void":
        """
        * <Or> is the orientation of the face. <Cl> is true if the face belongs to a closed volume. <NW> is the number of wires ( or block of edges ) of the face.
        	:param FG:
        	:type FG: TopoDS_Face
        	:param Or:
        	:type Or: TopAbs_Orientation
        	:param Cl:
        	:type Cl: bool
        	:param NW:
        	:type NW: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Set(self, *args)


    def SetWEdge(self, *args) -> "void":
        """
        * Set the edge number <EWI> of the wire <WI>.
        	:param WI:
        	:type WI: int
        	:param EWI:
        	:type EWI: int
        	:param EI:
        	:type EI: int
        	:param Or:
        	:type Or: TopAbs_Orientation
        	:param OutL:
        	:type OutL: bool
        	:param Inte:
        	:type Inte: bool
        	:param Dble:
        	:type Dble: bool
        	:param IsoL:
        	:type IsoL: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_SetWEdge(self, *args)


    def SetWire(self, *args) -> "void":
        """
        * Set <NE> the number of edges of the wire number <WI>.
        	:param WI:
        	:type WI: int
        	:param NE:
        	:type NE: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_SetWire(self, *args)


    def Side(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Side(self, *args)


    def Simple(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Simple(self, *args)


    def Size(self, *args) -> "void":
        """
        :rtype: float
        :param S:
        	:type S: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Size(self, *args)


    def Sphere(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Sphere(self, *args)


    def Tolerance(self, *args) -> "Standard_ShortReal":
        """:rtype: Standard_ShortReal"""
        return _HLRBRep.HLRBRep_FaceData_Tolerance(self, *args)


    def Torus(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_Torus(self, *args)


    def Wires(self, *args) -> "opencascade::handle< HLRAlgo_WiresBlock > &":
        """:rtype: opencascade::handle<HLRAlgo_WiresBlock>"""
        return _HLRBRep.HLRBRep_FaceData_Wires(self, *args)


    def WithOutL(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceData_WithOutL(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_FaceData
HLRBRep_FaceData.Back = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Back, None, HLRBRep_FaceData)
HLRBRep_FaceData.Closed = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Closed, None, HLRBRep_FaceData)
HLRBRep_FaceData.Cone = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Cone, None, HLRBRep_FaceData)
HLRBRep_FaceData.Cut = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Cut, None, HLRBRep_FaceData)
HLRBRep_FaceData.Cylinder = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Cylinder, None, HLRBRep_FaceData)
HLRBRep_FaceData.Geometry = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Geometry, None, HLRBRep_FaceData)
HLRBRep_FaceData.Hiding = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Hiding, None, HLRBRep_FaceData)
HLRBRep_FaceData.Orientation = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Orientation, None, HLRBRep_FaceData)
HLRBRep_FaceData.Plane = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Plane, None, HLRBRep_FaceData)
HLRBRep_FaceData.Selected = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Selected, None, HLRBRep_FaceData)
HLRBRep_FaceData.Set = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Set, None, HLRBRep_FaceData)
HLRBRep_FaceData.SetWEdge = new_instancemethod(_HLRBRep.HLRBRep_FaceData_SetWEdge, None, HLRBRep_FaceData)
HLRBRep_FaceData.SetWire = new_instancemethod(_HLRBRep.HLRBRep_FaceData_SetWire, None, HLRBRep_FaceData)
HLRBRep_FaceData.Side = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Side, None, HLRBRep_FaceData)
HLRBRep_FaceData.Simple = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Simple, None, HLRBRep_FaceData)
HLRBRep_FaceData.Size = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Size, None, HLRBRep_FaceData)
HLRBRep_FaceData.Sphere = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Sphere, None, HLRBRep_FaceData)
HLRBRep_FaceData.Tolerance = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Tolerance, None, HLRBRep_FaceData)
HLRBRep_FaceData.Torus = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Torus, None, HLRBRep_FaceData)
HLRBRep_FaceData.Wires = new_instancemethod(_HLRBRep.HLRBRep_FaceData_Wires, None, HLRBRep_FaceData)
HLRBRep_FaceData.WithOutL = new_instancemethod(_HLRBRep.HLRBRep_FaceData_WithOutL, None, HLRBRep_FaceData)
HLRBRep_FaceData_swigregister = _HLRBRep.HLRBRep_FaceData_swigregister
HLRBRep_FaceData_swigregister(HLRBRep_FaceData)

class HLRBRep_FaceIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BeginningOfWire(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the current edge is the first of a wire.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_FaceIterator_BeginningOfWire(self, *args)


    def Double(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_FaceIterator_Double(self, *args)


    def Edge(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_FaceIterator_Edge(self, *args)


    def EndOfWire(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the current edge is the last of a wire.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_FaceIterator_EndOfWire(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _HLRBRep.HLRBRep_FaceIterator_swiginit(self, _HLRBRep.new_HLRBRep_FaceIterator(*args))

    def InitEdge(self, *args) -> "void":
        """
        * Begin an exploration of the edges of the face <fd>
        	:param fd:
        	:type fd: HLRBRep_FaceData
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceIterator_InitEdge(self, *args)


    def Internal(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_FaceIterator_Internal(self, *args)


    def IsoLine(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_FaceIterator_IsoLine(self, *args)


    def MoreEdge(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_FaceIterator_MoreEdge(self, *args)


    def NextEdge(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_FaceIterator_NextEdge(self, *args)


    def Orientation(self, *args) -> "TopAbs_Orientation":
        """:rtype: TopAbs_Orientation"""
        return _HLRBRep.HLRBRep_FaceIterator_Orientation(self, *args)


    def OutLine(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_FaceIterator_OutLine(self, *args)


    def SkipWire(self, *args) -> "void":
        """
        * Skip the current wire in the exploration.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_FaceIterator_SkipWire(self, *args)


    def Wire(self, *args) -> "opencascade::handle< HLRAlgo_EdgesBlock >":
        """
        * Returns the edges of the current wire.
        	:rtype: opencascade::handle<HLRAlgo_EdgesBlock>
        """
        return _HLRBRep.HLRBRep_FaceIterator_Wire(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_FaceIterator
HLRBRep_FaceIterator.BeginningOfWire = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_BeginningOfWire, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.Double = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_Double, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.Edge = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_Edge, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.EndOfWire = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_EndOfWire, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.InitEdge = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_InitEdge, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.Internal = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_Internal, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.IsoLine = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_IsoLine, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.MoreEdge = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_MoreEdge, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.NextEdge = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_NextEdge, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.Orientation = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_Orientation, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.OutLine = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_OutLine, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.SkipWire = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_SkipWire, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator.Wire = new_instancemethod(_HLRBRep.HLRBRep_FaceIterator_Wire, None, HLRBRep_FaceIterator)
HLRBRep_FaceIterator_swigregister = _HLRBRep.HLRBRep_FaceIterator_swigregister
HLRBRep_FaceIterator_swigregister(HLRBRep_FaceIterator)

class HLRBRep_HLRToShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CompoundOfEdges(self, *args) -> "TopoDS_Shape":
        """
        * Returns compound of resulting edges of required type and visibility, taking into account the kind of space (2d or 3d)
        	:param type:
        	:type type: HLRBRep_TypeOfResultingEdge
        	:param visible:
        	:type visible: bool
        	:param In3d:
        	:type In3d: bool
        	:rtype: TopoDS_Shape
        * For specified shape returns compound of resulting edges of required type and visibility, taking into account the kind of space (2d or 3d)
        	:param S:
        	:type S: TopoDS_Shape
        	:param type:
        	:type type: HLRBRep_TypeOfResultingEdge
        	:param visible:
        	:type visible: bool
        	:param In3d:
        	:type In3d: bool
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_CompoundOfEdges(self, *args)


    def HCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_HCompound(self, *args)


    def __init__(self, *args):
        """
        * Constructs a framework for filtering the results of the HLRBRep_Algo algorithm, A. Use the extraction filters to obtain the results you want for A.
        	:param A:
        	:type A: HLRBRep_Algo
        	:rtype: None
        """
        _HLRBRep.HLRBRep_HLRToShape_swiginit(self, _HLRBRep.new_HLRBRep_HLRToShape(*args))

    def IsoLineHCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_IsoLineHCompound(self, *args)


    def IsoLineVCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_IsoLineVCompound(self, *args)


    def OutLineHCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_OutLineHCompound(self, *args)


    def OutLineVCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_OutLineVCompound(self, *args)


    def OutLineVCompound3d(self, *args) -> "TopoDS_Shape":
        """:rtype: TopoDS_Shape"""
        return _HLRBRep.HLRBRep_HLRToShape_OutLineVCompound3d(self, *args)


    def Rg1LineHCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_Rg1LineHCompound(self, *args)


    def Rg1LineVCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_Rg1LineVCompound(self, *args)


    def RgNLineHCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_RgNLineHCompound(self, *args)


    def RgNLineVCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_RgNLineVCompound(self, *args)


    def VCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_HLRToShape_VCompound(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_HLRToShape
HLRBRep_HLRToShape.CompoundOfEdges = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_CompoundOfEdges, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.HCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_HCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.IsoLineHCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_IsoLineHCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.IsoLineVCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_IsoLineVCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.OutLineHCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_OutLineHCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.OutLineVCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_OutLineVCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.OutLineVCompound3d = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_OutLineVCompound3d, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.Rg1LineHCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_Rg1LineHCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.Rg1LineVCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_Rg1LineVCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.RgNLineHCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_RgNLineHCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.RgNLineVCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_RgNLineVCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape.VCompound = new_instancemethod(_HLRBRep.HLRBRep_HLRToShape_VCompound, None, HLRBRep_HLRToShape)
HLRBRep_HLRToShape_swigregister = _HLRBRep.HLRBRep_HLRToShape_swigregister
HLRBRep_HLRToShape_swigregister(HLRBRep_HLRToShape)

class HLRBRep_Hider(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a Hider processing the set of Edges and hiding faces described by <DS>. Stores the hidden parts in <DS>.
        	:param DS:
        	:type DS: HLRBRep_Data
        	:rtype: None
        """
        _HLRBRep.HLRBRep_Hider_swiginit(self, _HLRBRep.new_HLRBRep_Hider(*args))

    def Hide(self, *args) -> "void":
        """
        * Removes from the edges, the parts hidden by the hiding face number <FI>.
        	:param FI:
        	:type FI: int
        	:param MST:
        	:type MST: BRepTopAdaptor_MapOfShapeTool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Hider_Hide(self, *args)


    def OwnHiding(self, *args) -> "void":
        """
        * own hiding the side face number <FI>.
        	:param FI:
        	:type FI: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Hider_OwnHiding(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Hider
HLRBRep_Hider.Hide = new_instancemethod(_HLRBRep.HLRBRep_Hider_Hide, None, HLRBRep_Hider)
HLRBRep_Hider.OwnHiding = new_instancemethod(_HLRBRep.HLRBRep_Hider_OwnHiding, None, HLRBRep_Hider)
HLRBRep_Hider_swigregister = _HLRBRep.HLRBRep_Hider_swigregister
HLRBRep_Hider_swigregister(HLRBRep_Hider)

class HLRBRep_IntConicCurveOfCInter(OCC.Core.IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Intersection between a line and a parametric curve.
        	:param L:
        	:type L: gp_Lin2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and a parametric curve.
        	:param C:
        	:type C: gp_Circ2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between an ellipse and a parametric curve.
        	:param E:
        	:type E: gp_Elips2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a parabola and a parametric curve.
        	:param Prb:
        	:type Prb: gp_Parab2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between the main branch of an hyperbola and a parametric curve.
        	:param H:
        	:type H: gp_Hypr2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_IntConicCurveOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_IntConicCurveOfCInter(*args))

    def Perform(self, *args) -> "void":
        """
        * Intersection between a line and a parametric curve.
        	:param L:
        	:type L: gp_Lin2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and a parametric curve.
        	:param C:
        	:type C: gp_Circ2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between an ellipse and a parametric curve.
        	:param E:
        	:type E: gp_Elips2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a parabola and a parametric curve.
        	:param Prb:
        	:type Prb: gp_Parab2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between the main branch of an hyperbola and a parametric curve.
        	:param H:
        	:type H: gp_Hypr2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_IntConicCurveOfCInter_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_IntConicCurveOfCInter
HLRBRep_IntConicCurveOfCInter.Perform = new_instancemethod(_HLRBRep.HLRBRep_IntConicCurveOfCInter_Perform, None, HLRBRep_IntConicCurveOfCInter)
HLRBRep_IntConicCurveOfCInter_swigregister = _HLRBRep.HLRBRep_IntConicCurveOfCInter_swigregister
HLRBRep_IntConicCurveOfCInter_swigregister(HLRBRep_IntConicCurveOfCInter)

class HLRBRep_InterCSurf(OCC.Core.IntCurveSurface.IntCurveSurface_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty Constructor
        	:rtype: None
        """
        _HLRBRep.HLRBRep_InterCSurf_swiginit(self, _HLRBRep.new_HLRBRep_InterCSurf(*args))

    def Perform(self, *args) -> "void":
        """
        * Compute the Intersection between the curve and the surface
        	:param Curve:
        	:type Curve: gp_Lin
        	:param Surface:
        	:type Surface: Standard_Address
        	:rtype: None
        * Compute the Intersection between the curve and the surface. The Curve is already sampled and its polygon : <Polygon> is given.
        	:param Curve:
        	:type Curve: gp_Lin
        	:param Polygon:
        	:type Polygon: HLRBRep_ThePolygonOfInterCSurf
        	:param Surface:
        	:type Surface: Standard_Address
        	:rtype: None
        * Compute the Intersection between the curve and the surface. The Curve is already sampled and its polygon : <Polygon> is given. The Surface is also sampled and <Polyhedron> is given.
        	:param Curve:
        	:type Curve: gp_Lin
        	:param ThePolygon:
        	:type ThePolygon: HLRBRep_ThePolygonOfInterCSurf
        	:param Surface:
        	:type Surface: Standard_Address
        	:param Polyhedron:
        	:type Polyhedron: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: None
        * Compute the Intersection between the curve and the surface. The Curve is already sampled and its polygon : <Polygon> is given. The Surface is also sampled and <Polyhedron> is given.
        	:param Curve:
        	:type Curve: gp_Lin
        	:param ThePolygon:
        	:type ThePolygon: HLRBRep_ThePolygonOfInterCSurf
        	:param Surface:
        	:type Surface: Standard_Address
        	:param Polyhedron:
        	:type Polyhedron: HLRBRep_ThePolyhedronOfInterCSurf
        	:param BndBSB:
        	:type BndBSB: Bnd_BoundSortBox
        	:rtype: None
        * Compute the Intersection between the curve and the surface. The Surface is already sampled and its polyhedron : <Polyhedron> is given.
        	:param Curve:
        	:type Curve: gp_Lin
        	:param Surface:
        	:type Surface: Standard_Address
        	:param Polyhedron:
        	:type Polyhedron: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InterCSurf_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_InterCSurf
HLRBRep_InterCSurf.Perform = new_instancemethod(_HLRBRep.HLRBRep_InterCSurf_Perform, None, HLRBRep_InterCSurf)
HLRBRep_InterCSurf_swigregister = _HLRBRep.HLRBRep_InterCSurf_swigregister
HLRBRep_InterCSurf_swigregister(HLRBRep_InterCSurf)

class HLRBRep_InternalAlgo(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DataStructure(self, *args) -> "opencascade::handle< HLRBRep_Data >":
        """:rtype: opencascade::handle<HLRBRep_Data>"""
        return _HLRBRep.HLRBRep_InternalAlgo_DataStructure(self, *args)


    def Debug(self, *args) -> "Standard_Boolean":
        """
        :param deb:
        	:type deb: bool
        	:rtype: None
        :rtype: bool
        """
        return _HLRBRep.HLRBRep_InternalAlgo_Debug(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param A:
        	:type A: HLRBRep_InternalAlgo
        	:rtype: None
        """
        _HLRBRep.HLRBRep_InternalAlgo_swiginit(self, _HLRBRep.new_HLRBRep_InternalAlgo(*args))

    def Hide(self, *args) -> "void":
        """
        * hide all the DataStructure.
        	:rtype: None
        * hide the Shape <S> by itself.
        	:param I:
        	:type I: int
        	:rtype: None
        * hide the Shape <S1> by the shape <S2>.
        	:param I:
        	:type I: int
        	:param J:
        	:type J: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_Hide(self, *args)


    def HideAll(self, *args) -> "void":
        """
        * set to hide all the edges.
        	:rtype: None
        * set to hide all the edges of the Shape <S>.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_HideAll(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        * return the index of the Shape <S> and return 0 if the Shape <S> is not found.
        	:param S:
        	:type S: HLRTopoBRep_OutLiner
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_InternalAlgo_Index(self, *args)


    def InitEdgeStatus(self, *args) -> "void":
        """
        * init the status of the selected edges depending of the back faces of a closed shell.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_InitEdgeStatus(self, *args)


    def Load(self, *args) -> "void":
        """
        * add the shape <S>.
        	:param S:
        	:type S: HLRTopoBRep_OutLiner
        	:param SData:
        	:type SData: Standard_Transient
        	:param nbIso: default value is 0
        	:type nbIso: int
        	:rtype: None
        * add the shape <S>.
        	:param S:
        	:type S: HLRTopoBRep_OutLiner
        	:param nbIso: default value is 0
        	:type nbIso: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_Load(self, *args)


    def NbShapes(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_InternalAlgo_NbShapes(self, *args)


    def PartialHide(self, *args) -> "void":
        """
        * own hiding of all the shapes of the DataStructure without hiding by each other.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_PartialHide(self, *args)


    def Projector(self, *args) -> "HLRAlgo_Projector &":
        """
        * set the projector.
        	:param P:
        	:type P: HLRAlgo_Projector
        	:rtype: None
        * set the projector.
        	:rtype: HLRAlgo_Projector
        """
        return _HLRBRep.HLRBRep_InternalAlgo_Projector(self, *args)


    def Remove(self, *args) -> "void":
        """
        * remove the Shape of Index <I>.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_Remove(self, *args)


    def Select(self, *args) -> "void":
        """
        * select all the DataStructure.
        	:rtype: None
        * select only the Shape of index <I>.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_Select(self, *args)


    def SelectEdge(self, *args) -> "void":
        """
        * select only the edges of the Shape <S>.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_SelectEdge(self, *args)


    def SelectFace(self, *args) -> "void":
        """
        * select only the faces of the Shape <S>.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_SelectFace(self, *args)


    def SeqOfShapeBounds(self, *args) -> "HLRBRep_SeqOfShapeBounds &":
        """:rtype: HLRBRep_SeqOfShapeBounds"""
        return _HLRBRep.HLRBRep_InternalAlgo_SeqOfShapeBounds(self, *args)


    def ShapeBounds(self, *args) -> "HLRBRep_ShapeBounds &":
        """
        :param I:
        	:type I: int
        	:rtype: HLRBRep_ShapeBounds
        """
        return _HLRBRep.HLRBRep_InternalAlgo_ShapeBounds(self, *args)


    def ShapeData(self, *args) -> "void":
        """
        * Change the Shape Data of the Shape of index <I>.
        	:param I:
        	:type I: int
        	:param SData:
        	:type SData: Standard_Transient
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_ShapeData(self, *args)


    def ShowAll(self, *args) -> "void":
        """
        * set to visible all the edges.
        	:rtype: None
        * set to visible all the edges of the Shape <S>.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_ShowAll(self, *args)


    def Update(self, *args) -> "void":
        """
        * update the DataStructure.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_InternalAlgo_Update(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_HLRBRep_InternalAlgo_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_InternalAlgo
HLRBRep_InternalAlgo.DataStructure = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_DataStructure, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.Debug = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_Debug, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.Hide = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_Hide, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.HideAll = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_HideAll, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.Index = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_Index, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.InitEdgeStatus = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_InitEdgeStatus, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.Load = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_Load, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.NbShapes = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_NbShapes, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.PartialHide = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_PartialHide, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.Projector = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_Projector, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.Remove = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_Remove, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.Select = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_Select, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.SelectEdge = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_SelectEdge, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.SelectFace = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_SelectFace, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.SeqOfShapeBounds = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_SeqOfShapeBounds, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.ShapeBounds = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_ShapeBounds, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.ShapeData = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_ShapeData, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.ShowAll = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_ShowAll, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo.Update = new_instancemethod(_HLRBRep.HLRBRep_InternalAlgo_Update, None, HLRBRep_InternalAlgo)
HLRBRep_InternalAlgo_swigregister = _HLRBRep.HLRBRep_InternalAlgo_swigregister
HLRBRep_InternalAlgo_swigregister(HLRBRep_InternalAlgo)

class HLRBRep_Intersector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CSPoint(self, *args) -> "IntCurveSurface_IntersectionPoint const &":
        """
        :param N:
        	:type N: int
        	:rtype: IntCurveSurface_IntersectionPoint
        """
        return _HLRBRep.HLRBRep_Intersector_CSPoint(self, *args)


    def CSSegment(self, *args) -> "IntCurveSurface_IntersectionSegment const &":
        """
        :param N:
        	:type N: int
        	:rtype: IntCurveSurface_IntersectionSegment
        """
        return _HLRBRep.HLRBRep_Intersector_CSSegment(self, *args)


    def Destroy(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_Intersector_Destroy(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _HLRBRep.HLRBRep_Intersector_swiginit(self, _HLRBRep.new_HLRBRep_Intersector(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_Intersector_IsDone(self, *args)


    def Load(self, *args) -> "void":
        """
        :param A:
        	:type A: Standard_Address
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Intersector_Load(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_Intersector_NbPoints(self, *args)


    def NbSegments(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_Intersector_NbSegments(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Performs the auto intersection of an edge. The edge domain is cutted at start with da1*(b-a) and at end with db1*(b-a).
        	:param A1:
        	:type A1: Standard_Address
        	:param da1:
        	:type da1: float
        	:param db1:
        	:type db1: float
        	:rtype: None
        * Performs the intersection between the two edges. The edges domains are cutted at start with da*(b-a) and at end with db*(b-a).
        	:param nA:
        	:type nA: int
        	:param A1:
        	:type A1: Standard_Address
        	:param da1:
        	:type da1: float
        	:param db1:
        	:type db1: float
        	:param nB:
        	:type nB: int
        	:param A2:
        	:type A2: Standard_Address
        	:param da2:
        	:type da2: float
        	:param db2:
        	:type db2: float
        	:param NoBound:
        	:type NoBound: bool
        	:rtype: None
        :param L:
        	:type L: gp_Lin
        	:param P:
        	:type P: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Intersector_Perform(self, *args)


    def Point(self, *args) -> "IntRes2d_IntersectionPoint const &":
        """
        :param N:
        	:type N: int
        	:rtype: IntRes2d_IntersectionPoint
        """
        return _HLRBRep.HLRBRep_Intersector_Point(self, *args)


    def Segment(self, *args) -> "IntRes2d_IntersectionSegment const &":
        """
        :param N:
        	:type N: int
        	:rtype: IntRes2d_IntersectionSegment
        """
        return _HLRBRep.HLRBRep_Intersector_Segment(self, *args)


    def SimulateOnePoint(self, *args) -> "void":
        """
        * Create a single IntersectionPoint (U on A1) (V on A2) The point is middle on both curves.
        	:param A1:
        	:type A1: Standard_Address
        	:param U:
        	:type U: float
        	:param A2:
        	:type A2: Standard_Address
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Intersector_SimulateOnePoint(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Intersector
HLRBRep_Intersector.CSPoint = new_instancemethod(_HLRBRep.HLRBRep_Intersector_CSPoint, None, HLRBRep_Intersector)
HLRBRep_Intersector.CSSegment = new_instancemethod(_HLRBRep.HLRBRep_Intersector_CSSegment, None, HLRBRep_Intersector)
HLRBRep_Intersector.Destroy = new_instancemethod(_HLRBRep.HLRBRep_Intersector_Destroy, None, HLRBRep_Intersector)
HLRBRep_Intersector.IsDone = new_instancemethod(_HLRBRep.HLRBRep_Intersector_IsDone, None, HLRBRep_Intersector)
HLRBRep_Intersector.Load = new_instancemethod(_HLRBRep.HLRBRep_Intersector_Load, None, HLRBRep_Intersector)
HLRBRep_Intersector.NbPoints = new_instancemethod(_HLRBRep.HLRBRep_Intersector_NbPoints, None, HLRBRep_Intersector)
HLRBRep_Intersector.NbSegments = new_instancemethod(_HLRBRep.HLRBRep_Intersector_NbSegments, None, HLRBRep_Intersector)
HLRBRep_Intersector.Perform = new_instancemethod(_HLRBRep.HLRBRep_Intersector_Perform, None, HLRBRep_Intersector)
HLRBRep_Intersector.Point = new_instancemethod(_HLRBRep.HLRBRep_Intersector_Point, None, HLRBRep_Intersector)
HLRBRep_Intersector.Segment = new_instancemethod(_HLRBRep.HLRBRep_Intersector_Segment, None, HLRBRep_Intersector)
HLRBRep_Intersector.SimulateOnePoint = new_instancemethod(_HLRBRep.HLRBRep_Intersector_SimulateOnePoint, None, HLRBRep_Intersector)
HLRBRep_Intersector_swigregister = _HLRBRep.HLRBRep_Intersector_swigregister
HLRBRep_Intersector_swigregister(HLRBRep_Intersector)

class HLRBRep_LineTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSpline(*args) -> "opencascade::handle< Geom_BSplineCurve >":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: opencascade::handle<Geom_BSplineCurve>
        """
        return _HLRBRep.HLRBRep_LineTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def Bezier(*args) -> "opencascade::handle< Geom_BezierCurve >":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: opencascade::handle<Geom_BezierCurve>
        """
        return _HLRBRep.HLRBRep_LineTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def Circle(*args) -> "gp_Circ":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: gp_Circ
        """
        return _HLRBRep.HLRBRep_LineTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Continuity(*args) -> "GeomAbs_Shape":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: GeomAbs_Shape
        """
        return _HLRBRep.HLRBRep_LineTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D0(*args) -> "void":
        """
        * Computes the point of parameter U on the line.
        	:param C:
        	:type C: gp_Lin
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_LineTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args) -> "void":
        """
        * Computes the point of parameter U on the line with its first derivative. Raised if the continuity of the current interval is not C1.
        	:param C:
        	:type C: gp_Lin
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_LineTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
        	:param C:
        	:type C: gp_Lin
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_LineTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
        	:param C:
        	:type C: gp_Lin
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:param V3:
        	:type V3: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_LineTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args) -> "gp_Vec":
        """
        * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
        	:param C:
        	:type C: gp_Lin
        	:param U:
        	:type U: float
        	:param N:
        	:type N: int
        	:rtype: gp_Vec
        """
        return _HLRBRep.HLRBRep_LineTool_DN(*args)

    DN = staticmethod(DN)

    def Degree(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_LineTool_Degree(*args)

    Degree = staticmethod(Degree)

    def Ellipse(*args) -> "gp_Elips":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: gp_Elips
        """
        return _HLRBRep.HLRBRep_LineTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def FirstParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_LineTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def GetType(*args) -> "GeomAbs_CurveType":
        """
        * Returns the type of the line in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
        	:param C:
        	:type C: gp_Lin
        	:rtype: GeomAbs_CurveType
        """
        return _HLRBRep.HLRBRep_LineTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Hyperbola(*args) -> "gp_Hypr":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: gp_Hypr
        """
        return _HLRBRep.HLRBRep_LineTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def IntervalContinuity(*args) -> "GeomAbs_Shape":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: GeomAbs_Shape
        """
        return _HLRBRep.HLRBRep_LineTool_IntervalContinuity(*args)

    IntervalContinuity = staticmethod(IntervalContinuity)

    def IntervalFirst(*args) -> "Standard_Real":
        """
        * Returns the first parameter of the current interval.
        	:param C:
        	:type C: gp_Lin
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_LineTool_IntervalFirst(*args)

    IntervalFirst = staticmethod(IntervalFirst)

    def IntervalLast(*args) -> "Standard_Real":
        """
        * Returns the last parameter of the current interval.
        	:param C:
        	:type C: gp_Lin
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_LineTool_IntervalLast(*args)

    IntervalLast = staticmethod(IntervalLast)

    def Intervals(*args) -> "void":
        """
        * Sets the current working interval.
        	:param C:
        	:type C: gp_Lin
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param Sh:
        	:type Sh: GeomAbs_Shape
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_LineTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_LineTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_LineTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def IsRational(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_LineTool_IsRational(*args)

    IsRational = staticmethod(IsRational)

    def KnotsAndMultiplicities(*args) -> "void":
        """
        :param C:
        	:type C: gp_Lin
        	:param TK:
        	:type TK: TColStd_Array1OfReal
        	:param TM:
        	:type TM: TColStd_Array1OfInteger
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_LineTool_KnotsAndMultiplicities(*args)

    KnotsAndMultiplicities = staticmethod(KnotsAndMultiplicities)

    def LastParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_LineTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Line(*args) -> "gp_Lin":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: gp_Lin
        """
        return _HLRBRep.HLRBRep_LineTool_Line(*args)

    Line = staticmethod(Line)

    def NbIntervals(*args) -> "Standard_Integer":
        """
        * If necessary, breaks the line in intervals of continuity <S>. And returns the number of intervals.
        	:param C:
        	:type C: gp_Lin
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_LineTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def NbKnots(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_LineTool_NbKnots(*args)

    NbKnots = staticmethod(NbKnots)

    def NbPoles(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_LineTool_NbPoles(*args)

    NbPoles = staticmethod(NbPoles)

    def NbSamples(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: gp_Lin
        	:param U0:
        	:type U0: float
        	:param U1:
        	:type U1: float
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_LineTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Parabola(*args) -> "gp_Parab":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: gp_Parab
        """
        return _HLRBRep.HLRBRep_LineTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Period(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: gp_Lin
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_LineTool_Period(*args)

    Period = staticmethod(Period)

    def Poles(*args) -> "void":
        """
        :param C:
        	:type C: gp_Lin
        	:param TP:
        	:type TP: TColgp_Array1OfPnt
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_LineTool_Poles(*args)

    Poles = staticmethod(Poles)

    def PolesAndWeights(*args) -> "void":
        """
        :param C:
        	:type C: gp_Lin
        	:param TP:
        	:type TP: TColgp_Array1OfPnt
        	:param TW:
        	:type TW: TColStd_Array1OfReal
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_LineTool_PolesAndWeights(*args)

    PolesAndWeights = staticmethod(PolesAndWeights)

    def Resolution(*args) -> "Standard_Real":
        """
        * Returns the parametric resolution corresponding to the real space resolution <R3d>.
        	:param C:
        	:type C: gp_Lin
        	:param R3d:
        	:type R3d: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_LineTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def SamplePars(*args) -> "void":
        """
        :param C:
        	:type C: gp_Lin
        	:param U0:
        	:type U0: float
        	:param U1:
        	:type U1: float
        	:param Defl:
        	:type Defl: float
        	:param NbMin:
        	:type NbMin: int
        	:param Pars:
        	:type Pars: TColStd_HArray1OfReal
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_LineTool_SamplePars(*args)

    SamplePars = staticmethod(SamplePars)

    def Value(*args) -> "gp_Pnt":
        """
        * Computes the point of parameter U on the line.
        	:param C:
        	:type C: gp_Lin
        	:param U:
        	:type U: float
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_LineTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_LineTool_swiginit(self, _HLRBRep.new_HLRBRep_LineTool())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_LineTool
HLRBRep_LineTool_swigregister = _HLRBRep.HLRBRep_LineTool_swigregister
HLRBRep_LineTool_swigregister(HLRBRep_LineTool)

def HLRBRep_LineTool_BSpline(*args) -> "opencascade::handle< Geom_BSplineCurve >":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: opencascade::handle<Geom_BSplineCurve>
    """
    return _HLRBRep.HLRBRep_LineTool_BSpline(*args)

def HLRBRep_LineTool_Bezier(*args) -> "opencascade::handle< Geom_BezierCurve >":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: opencascade::handle<Geom_BezierCurve>
    """
    return _HLRBRep.HLRBRep_LineTool_Bezier(*args)

def HLRBRep_LineTool_Circle(*args) -> "gp_Circ":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: gp_Circ
    """
    return _HLRBRep.HLRBRep_LineTool_Circle(*args)

def HLRBRep_LineTool_Continuity(*args) -> "GeomAbs_Shape":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: GeomAbs_Shape
    """
    return _HLRBRep.HLRBRep_LineTool_Continuity(*args)

def HLRBRep_LineTool_D0(*args) -> "void":
    """
    * Computes the point of parameter U on the line.
    	:param C:
    	:type C: gp_Lin
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_LineTool_D0(*args)

def HLRBRep_LineTool_D1(*args) -> "void":
    """
    * Computes the point of parameter U on the line with its first derivative. Raised if the continuity of the current interval is not C1.
    	:param C:
    	:type C: gp_Lin
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V:
    	:type V: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_LineTool_D1(*args)

def HLRBRep_LineTool_D2(*args) -> "void":
    """
    * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
    	:param C:
    	:type C: gp_Lin
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_LineTool_D2(*args)

def HLRBRep_LineTool_D3(*args) -> "void":
    """
    * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
    	:param C:
    	:type C: gp_Lin
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:param V3:
    	:type V3: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_LineTool_D3(*args)

def HLRBRep_LineTool_DN(*args) -> "gp_Vec":
    """
    * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
    	:param C:
    	:type C: gp_Lin
    	:param U:
    	:type U: float
    	:param N:
    	:type N: int
    	:rtype: gp_Vec
    """
    return _HLRBRep.HLRBRep_LineTool_DN(*args)

def HLRBRep_LineTool_Degree(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_LineTool_Degree(*args)

def HLRBRep_LineTool_Ellipse(*args) -> "gp_Elips":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: gp_Elips
    """
    return _HLRBRep.HLRBRep_LineTool_Ellipse(*args)

def HLRBRep_LineTool_FirstParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_LineTool_FirstParameter(*args)

def HLRBRep_LineTool_GetType(*args) -> "GeomAbs_CurveType":
    """
    * Returns the type of the line in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
    	:param C:
    	:type C: gp_Lin
    	:rtype: GeomAbs_CurveType
    """
    return _HLRBRep.HLRBRep_LineTool_GetType(*args)

def HLRBRep_LineTool_Hyperbola(*args) -> "gp_Hypr":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: gp_Hypr
    """
    return _HLRBRep.HLRBRep_LineTool_Hyperbola(*args)

def HLRBRep_LineTool_IntervalContinuity(*args) -> "GeomAbs_Shape":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: GeomAbs_Shape
    """
    return _HLRBRep.HLRBRep_LineTool_IntervalContinuity(*args)

def HLRBRep_LineTool_IntervalFirst(*args) -> "Standard_Real":
    """
    * Returns the first parameter of the current interval.
    	:param C:
    	:type C: gp_Lin
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_LineTool_IntervalFirst(*args)

def HLRBRep_LineTool_IntervalLast(*args) -> "Standard_Real":
    """
    * Returns the last parameter of the current interval.
    	:param C:
    	:type C: gp_Lin
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_LineTool_IntervalLast(*args)

def HLRBRep_LineTool_Intervals(*args) -> "void":
    """
    * Sets the current working interval.
    	:param C:
    	:type C: gp_Lin
    	:param T:
    	:type T: TColStd_Array1OfReal
    	:param Sh:
    	:type Sh: GeomAbs_Shape
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_LineTool_Intervals(*args)

def HLRBRep_LineTool_IsClosed(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_LineTool_IsClosed(*args)

def HLRBRep_LineTool_IsPeriodic(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_LineTool_IsPeriodic(*args)

def HLRBRep_LineTool_IsRational(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_LineTool_IsRational(*args)

def HLRBRep_LineTool_KnotsAndMultiplicities(*args) -> "void":
    """
    :param C:
    	:type C: gp_Lin
    	:param TK:
    	:type TK: TColStd_Array1OfReal
    	:param TM:
    	:type TM: TColStd_Array1OfInteger
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_LineTool_KnotsAndMultiplicities(*args)

def HLRBRep_LineTool_LastParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_LineTool_LastParameter(*args)

def HLRBRep_LineTool_Line(*args) -> "gp_Lin":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: gp_Lin
    """
    return _HLRBRep.HLRBRep_LineTool_Line(*args)

def HLRBRep_LineTool_NbIntervals(*args) -> "Standard_Integer":
    """
    * If necessary, breaks the line in intervals of continuity <S>. And returns the number of intervals.
    	:param C:
    	:type C: gp_Lin
    	:param S:
    	:type S: GeomAbs_Shape
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_LineTool_NbIntervals(*args)

def HLRBRep_LineTool_NbKnots(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_LineTool_NbKnots(*args)

def HLRBRep_LineTool_NbPoles(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_LineTool_NbPoles(*args)

def HLRBRep_LineTool_NbSamples(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: gp_Lin
    	:param U0:
    	:type U0: float
    	:param U1:
    	:type U1: float
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_LineTool_NbSamples(*args)

def HLRBRep_LineTool_Parabola(*args) -> "gp_Parab":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: gp_Parab
    """
    return _HLRBRep.HLRBRep_LineTool_Parabola(*args)

def HLRBRep_LineTool_Period(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: gp_Lin
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_LineTool_Period(*args)

def HLRBRep_LineTool_Poles(*args) -> "void":
    """
    :param C:
    	:type C: gp_Lin
    	:param TP:
    	:type TP: TColgp_Array1OfPnt
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_LineTool_Poles(*args)

def HLRBRep_LineTool_PolesAndWeights(*args) -> "void":
    """
    :param C:
    	:type C: gp_Lin
    	:param TP:
    	:type TP: TColgp_Array1OfPnt
    	:param TW:
    	:type TW: TColStd_Array1OfReal
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_LineTool_PolesAndWeights(*args)

def HLRBRep_LineTool_Resolution(*args) -> "Standard_Real":
    """
    * Returns the parametric resolution corresponding to the real space resolution <R3d>.
    	:param C:
    	:type C: gp_Lin
    	:param R3d:
    	:type R3d: float
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_LineTool_Resolution(*args)

def HLRBRep_LineTool_SamplePars(*args) -> "void":
    """
    :param C:
    	:type C: gp_Lin
    	:param U0:
    	:type U0: float
    	:param U1:
    	:type U1: float
    	:param Defl:
    	:type Defl: float
    	:param NbMin:
    	:type NbMin: int
    	:param Pars:
    	:type Pars: TColStd_HArray1OfReal
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_LineTool_SamplePars(*args)

def HLRBRep_LineTool_Value(*args) -> "gp_Pnt":
    """
    * Computes the point of parameter U on the line.
    	:param C:
    	:type C: gp_Lin
    	:param U:
    	:type U: float
    	:rtype: gp_Pnt
    """
    return _HLRBRep.HLRBRep_LineTool_Value(*args)

class HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter(OCC.Core.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor of the class.
        	:param IT:
        	:type IT: IntCurve_IConicTool
        	:param PC:
        	:type PC: Standard_Address
        	:rtype: None
        """
        _HLRBRep.HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter
HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_swigregister = _HLRBRep.HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_swigregister
HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter_swigregister(HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter)

class HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter(OCC.Core.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param P:
        	:type P: gp_Pnt2d
        	:param C:
        	:type C: Standard_Address
        	:rtype: None
        """
        _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter(*args))

    def Initialize(self, *args) -> "void":
        """
        * sets the field mycurve of the function.
        	:param C:
        	:type C: Standard_Address
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_Initialize(self, *args)


    def IsMin(self, *args) -> "Standard_Boolean":
        """
        * Shows if the Nth distance is a minimum.
        	:param N:
        	:type N: int
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_IsMin(self, *args)


    def NbExt(self, *args) -> "Standard_Integer":
        """
        * Return the nunber of found extrema.
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_NbExt(self, *args)


    def Point(self, *args) -> "Extrema_POnCurv2d const &":
        """
        * Returns the Nth extremum.
        	:param N:
        	:type N: int
        	:rtype: Extrema_POnCurv2d
        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_Point(self, *args)


    def SearchOfTolerance(self, *args) -> "Standard_Real":
        """
        * Computes a Tol value. If 1st derivative of curve |D1|<Tol, it is considered D1=0.
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SearchOfTolerance(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        * sets the field P of the function.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SetPoint(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        * Returns the Nth distance.
        	:param N:
        	:type N: int
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SquareDistance(self, *args)


    def SubIntervalInitialize(self, *args) -> "void":
        """
        * Determines boundaries of subinterval for find of root.
        	:param theUfirst:
        	:type theUfirst: float
        	:param theUlast:
        	:type theUlast: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SubIntervalInitialize(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter.Initialize = new_instancemethod(_HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_Initialize, None, HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter.IsMin = new_instancemethod(_HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_IsMin, None, HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter.NbExt = new_instancemethod(_HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_NbExt, None, HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter.Point = new_instancemethod(_HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_Point, None, HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter.SearchOfTolerance = new_instancemethod(_HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SearchOfTolerance, None, HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter.SetPoint = new_instancemethod(_HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SetPoint, None, HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter.SquareDistance = new_instancemethod(_HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SquareDistance, None, HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter.SubIntervalInitialize = new_instancemethod(_HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_SubIntervalInitialize, None, HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_swigregister = _HLRBRep.HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_swigregister
HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter_swigregister(HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter)

class HLRBRep_PolyAlgo(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Algo(self, *args) -> "opencascade::handle< HLRAlgo_PolyAlgo >":
        """:rtype: opencascade::handle<HLRAlgo_PolyAlgo>"""
        return _HLRBRep.HLRBRep_PolyAlgo_Algo(self, *args)


    def Angle(self, *args) -> "void":
        """
        :rtype: float
        :param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Angle(self, *args)


    def Debug(self, *args) -> "void":
        """
        :rtype: bool
        :param B:
        	:type B: bool
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Debug(self, *args)


    def __init__(self, *args):
        """
        * Constructs an empty framework for the calculation of the visible and hidden lines of a shape in a projection. Use the functions: - Projector to define the point of view - Load to select the shape or shapes to be visualized - Update to compute the visible and hidden lines of the shape. Warning The shape or shapes to be visualized must have already been triangulated.
        	:rtype: None
        :param A:
        	:type A: HLRBRep_PolyAlgo
        	:rtype: None
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: None
        """
        _HLRBRep.HLRBRep_PolyAlgo_swiginit(self, _HLRBRep.new_HLRBRep_PolyAlgo(*args))

    def Hide(self, *args) -> "HLRAlgo_BiPoint::PointsT &":
        """
        :param status:
        	:type status: HLRAlgo_EdgeStatus
        	:param S:
        	:type S: TopoDS_Shape
        	:param reg1:
        	:type reg1: bool
        	:param regn:
        	:type regn: bool
        	:param outl:
        	:type outl: bool
        	:param intl:
        	:type intl: bool
        	:rtype: HLRAlgo_BiPoint::PointsT
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Hide(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        * return the index of the Shape <S> and return 0 if the Shape <S> is not found.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Index(self, *args)


    def InitHide(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_PolyAlgo_InitHide(self, *args)


    def InitShow(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_PolyAlgo_InitShow(self, *args)


    def Load(self, *args) -> "void":
        """
        * Loads the shape S into this framework. Warning S must have already been triangulated.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Load(self, *args)


    def MoreHide(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_PolyAlgo_MoreHide(self, *args)


    def MoreShow(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_PolyAlgo_MoreShow(self, *args)


    def NbShapes(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_PolyAlgo_NbShapes(self, *args)


    def NextHide(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_PolyAlgo_NextHide(self, *args)


    def NextShow(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_PolyAlgo_NextShow(self, *args)


    def OutLinedShape(self, *args) -> "TopoDS_Shape":
        """
        * Make a shape with the internal outlines in each face.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyAlgo_OutLinedShape(self, *args)


    def Projector(self, *args) -> "void":
        """
        * Sets the parameters of the view for this framework. These parameters are defined by an HLRAlgo_Projector object, which is returned by the Projector function on a Prs3d_Projector object.
        	:rtype: HLRAlgo_Projector
        :param P:
        	:type P: HLRAlgo_Projector
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Projector(self, *args)


    def Remove(self, *args) -> "void":
        """
        * remove the Shape of Index <I>.
        	:param I:
        	:type I: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Remove(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape":
        """
        :param I:
        	:type I: int
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Shape(self, *args)


    def Show(self, *args) -> "HLRAlgo_BiPoint::PointsT &":
        """
        :param S:
        	:type S: TopoDS_Shape
        	:param reg1:
        	:type reg1: bool
        	:param regn:
        	:type regn: bool
        	:param outl:
        	:type outl: bool
        	:param intl:
        	:type intl: bool
        	:rtype: HLRAlgo_BiPoint::PointsT
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Show(self, *args)


    def TolAngular(self, *args) -> "void":
        """
        :rtype: float
        :param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PolyAlgo_TolAngular(self, *args)


    def TolCoef(self, *args) -> "void":
        """
        :rtype: float
        :param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PolyAlgo_TolCoef(self, *args)


    def Update(self, *args) -> "void":
        """
        * Launches calculation of outlines of the shape visualized by this framework. Used after setting the point of view and defining the shape or shapes to be visualized.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PolyAlgo_Update(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_HLRBRep_PolyAlgo_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_PolyAlgo
HLRBRep_PolyAlgo.Algo = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Algo, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Angle = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Angle, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Debug = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Debug, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Hide = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Hide, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Index = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Index, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.InitHide = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_InitHide, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.InitShow = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_InitShow, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Load = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Load, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.MoreHide = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_MoreHide, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.MoreShow = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_MoreShow, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.NbShapes = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_NbShapes, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.NextHide = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_NextHide, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.NextShow = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_NextShow, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.OutLinedShape = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_OutLinedShape, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Projector = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Projector, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Remove = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Remove, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Shape = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Shape, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Show = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Show, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.TolAngular = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_TolAngular, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.TolCoef = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_TolCoef, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo.Update = new_instancemethod(_HLRBRep.HLRBRep_PolyAlgo_Update, None, HLRBRep_PolyAlgo)
HLRBRep_PolyAlgo_swigregister = _HLRBRep.HLRBRep_PolyAlgo_swigregister
HLRBRep_PolyAlgo_swigregister(HLRBRep_PolyAlgo)

class HLRBRep_PolyHLRToShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_HCompound(self, *args)


    def __init__(self, *args):
        """
        * Constructs a framework for filtering the results of the HLRBRep_Algo algorithm, A. Use the extraction filters to obtain the results you want for A.
        	:rtype: None
        """
        _HLRBRep.HLRBRep_PolyHLRToShape_swiginit(self, _HLRBRep.new_HLRBRep_PolyHLRToShape(*args))

    def Hide(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_PolyHLRToShape_Hide(self, *args)


    def OutLineHCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        * Sets the extraction filter for hidden outlines. Hidden outlines occur, for instance, in tori. In this case, the inner outlines of the torus seen on its side are hidden.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_OutLineHCompound(self, *args)


    def OutLineVCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        * Sets the extraction filter for visible outlines.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_OutLineVCompound(self, *args)


    def Rg1LineHCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        * Sets the extraction filter for hidden smooth edges.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_Rg1LineHCompound(self, *args)


    def Rg1LineVCompound(self, *args) -> "TopoDS_Shape":
        """
        * Sets the extraction filter for visible smooth edges.
        	:rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_Rg1LineVCompound(self, *args)


    def RgNLineHCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        * Sets the extraction filter for hidden sewn edges.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_RgNLineHCompound(self, *args)


    def RgNLineVCompound(self, *args) -> "TopoDS_Shape":
        """
        * Sets the extraction filter for visible sewn edges.
        	:rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_RgNLineVCompound(self, *args)


    def Show(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_PolyHLRToShape_Show(self, *args)


    def Update(self, *args) -> "void":
        """
        :param A:
        	:type A: HLRBRep_PolyAlgo
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_Update(self, *args)


    def VCompound(self, *args) -> "TopoDS_Shape":
        """
        :rtype: TopoDS_Shape
        :param S:
        	:type S: TopoDS_Shape
        	:rtype: TopoDS_Shape
        """
        return _HLRBRep.HLRBRep_PolyHLRToShape_VCompound(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_PolyHLRToShape
HLRBRep_PolyHLRToShape.HCompound = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_HCompound, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.Hide = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_Hide, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.OutLineHCompound = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_OutLineHCompound, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.OutLineVCompound = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_OutLineVCompound, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.Rg1LineHCompound = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_Rg1LineHCompound, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.Rg1LineVCompound = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_Rg1LineVCompound, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.RgNLineHCompound = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_RgNLineHCompound, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.RgNLineVCompound = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_RgNLineVCompound, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.Show = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_Show, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.Update = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_Update, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape.VCompound = new_instancemethod(_HLRBRep.HLRBRep_PolyHLRToShape_VCompound, None, HLRBRep_PolyHLRToShape)
HLRBRep_PolyHLRToShape_swigregister = _HLRBRep.HLRBRep_PolyHLRToShape_swigregister
HLRBRep_PolyHLRToShape_swigregister(HLRBRep_PolyHLRToShape)

class HLRBRep_SLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CurvatureDirections(self, *args) -> "void":
        """
        * Returns the direction of the maximum and minimum curvature <MaxD> and <MinD>
        	:param MaxD:
        	:type MaxD: gp_Dir
        	:param MinD:
        	:type MinD: gp_Dir
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SLProps_CurvatureDirections(self, *args)


    def D1U(self, *args) -> "gp_Vec const":
        """
        * Returns the first U derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _HLRBRep.HLRBRep_SLProps_D1U(self, *args)


    def D1V(self, *args) -> "gp_Vec const":
        """
        * Returns the first V derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _HLRBRep.HLRBRep_SLProps_D1V(self, *args)


    def D2U(self, *args) -> "gp_Vec const":
        """
        * Returns the second U derivatives The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _HLRBRep.HLRBRep_SLProps_D2U(self, *args)


    def D2V(self, *args) -> "gp_Vec const":
        """
        * Returns the second V derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _HLRBRep.HLRBRep_SLProps_D2V(self, *args)


    def DUV(self, *args) -> "gp_Vec const":
        """
        * Returns the second UV cross-derivative. The derivative is computed if it has not been yet.
        	:rtype: gp_Vec
        """
        return _HLRBRep.HLRBRep_SLProps_DUV(self, *args)


    def GaussianCurvature(self, *args) -> "Standard_Real":
        """
        * Returns the Gaussian curvature
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SLProps_GaussianCurvature(self, *args)


    def __init__(self, *args):
        """
        * Initializes the local properties of the surface <S> for the parameter values (<U>, <V>). The current point and the derivatives are computed at the same time, which allows an optimization of the computation time. <N> indicates the maximum number of derivations to be done (0, 1, or 2). For example, to compute only the tangent, N should be equal to 1. <Resolution> is the linear tolerance (it is used to test if a vector is null).
        	:param S:
        	:type S: Standard_Address
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        * idem as previous constructor but without setting the value of parameters <U> and <V>.
        	:param S:
        	:type S: Standard_Address
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        * idem as previous constructor but without setting the value of parameters <U> and <V> and the surface. the surface can have an empty constructor.
        	:param N:
        	:type N: int
        	:param Resolution:
        	:type Resolution: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_SLProps_swiginit(self, _HLRBRep.new_HLRBRep_SLProps(*args))

    def IsCurvatureDefined(self, *args) -> "Standard_Boolean":
        """
        * returns True if the curvature is defined.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_SLProps_IsCurvatureDefined(self, *args)


    def IsNormalDefined(self, *args) -> "Standard_Boolean":
        """
        * Tells if the normal is defined.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_SLProps_IsNormalDefined(self, *args)


    def IsTangentUDefined(self, *args) -> "Standard_Boolean":
        """
        * returns True if the U tangent is defined. For example, the tangent is not defined if the two first U derivatives are null.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_SLProps_IsTangentUDefined(self, *args)


    def IsTangentVDefined(self, *args) -> "Standard_Boolean":
        """
        * returns if the V tangent is defined. For example, the tangent is not defined if the two first V derivatives are null.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_SLProps_IsTangentVDefined(self, *args)


    def IsUmbilic(self, *args) -> "Standard_Boolean":
        """
        * returns True if the point is umbilic (i.e. if the curvature is constant).
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_SLProps_IsUmbilic(self, *args)


    def MaxCurvature(self, *args) -> "Standard_Real":
        """
        * Returns the maximum curvature
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SLProps_MaxCurvature(self, *args)


    def MeanCurvature(self, *args) -> "Standard_Real":
        """
        * Returns the mean curvature.
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SLProps_MeanCurvature(self, *args)


    def MinCurvature(self, *args) -> "Standard_Real":
        """
        * Returns the minimum curvature
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SLProps_MinCurvature(self, *args)


    def Normal(self, *args) -> "gp_Dir const":
        """
        * Returns the normal direction.
        	:rtype: gp_Dir
        """
        return _HLRBRep.HLRBRep_SLProps_Normal(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        * Initializes the local properties of the surface S for the new parameter values (<U>, <V>).
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SLProps_SetParameters(self, *args)


    def SetSurface(self, *args) -> "void":
        """
        * Initializes the local properties of the surface S for the new surface.
        	:param S:
        	:type S: Standard_Address
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SLProps_SetSurface(self, *args)


    def TangentU(self, *args) -> "void":
        """
        * Returns the tangent direction <D> on the iso-V.
        	:param D:
        	:type D: gp_Dir
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SLProps_TangentU(self, *args)


    def TangentV(self, *args) -> "void":
        """
        * Returns the tangent direction <D> on the iso-V.
        	:param D:
        	:type D: gp_Dir
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SLProps_TangentV(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        * Returns the point.
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_SLProps_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_SLProps
HLRBRep_SLProps.CurvatureDirections = new_instancemethod(_HLRBRep.HLRBRep_SLProps_CurvatureDirections, None, HLRBRep_SLProps)
HLRBRep_SLProps.D1U = new_instancemethod(_HLRBRep.HLRBRep_SLProps_D1U, None, HLRBRep_SLProps)
HLRBRep_SLProps.D1V = new_instancemethod(_HLRBRep.HLRBRep_SLProps_D1V, None, HLRBRep_SLProps)
HLRBRep_SLProps.D2U = new_instancemethod(_HLRBRep.HLRBRep_SLProps_D2U, None, HLRBRep_SLProps)
HLRBRep_SLProps.D2V = new_instancemethod(_HLRBRep.HLRBRep_SLProps_D2V, None, HLRBRep_SLProps)
HLRBRep_SLProps.DUV = new_instancemethod(_HLRBRep.HLRBRep_SLProps_DUV, None, HLRBRep_SLProps)
HLRBRep_SLProps.GaussianCurvature = new_instancemethod(_HLRBRep.HLRBRep_SLProps_GaussianCurvature, None, HLRBRep_SLProps)
HLRBRep_SLProps.IsCurvatureDefined = new_instancemethod(_HLRBRep.HLRBRep_SLProps_IsCurvatureDefined, None, HLRBRep_SLProps)
HLRBRep_SLProps.IsNormalDefined = new_instancemethod(_HLRBRep.HLRBRep_SLProps_IsNormalDefined, None, HLRBRep_SLProps)
HLRBRep_SLProps.IsTangentUDefined = new_instancemethod(_HLRBRep.HLRBRep_SLProps_IsTangentUDefined, None, HLRBRep_SLProps)
HLRBRep_SLProps.IsTangentVDefined = new_instancemethod(_HLRBRep.HLRBRep_SLProps_IsTangentVDefined, None, HLRBRep_SLProps)
HLRBRep_SLProps.IsUmbilic = new_instancemethod(_HLRBRep.HLRBRep_SLProps_IsUmbilic, None, HLRBRep_SLProps)
HLRBRep_SLProps.MaxCurvature = new_instancemethod(_HLRBRep.HLRBRep_SLProps_MaxCurvature, None, HLRBRep_SLProps)
HLRBRep_SLProps.MeanCurvature = new_instancemethod(_HLRBRep.HLRBRep_SLProps_MeanCurvature, None, HLRBRep_SLProps)
HLRBRep_SLProps.MinCurvature = new_instancemethod(_HLRBRep.HLRBRep_SLProps_MinCurvature, None, HLRBRep_SLProps)
HLRBRep_SLProps.Normal = new_instancemethod(_HLRBRep.HLRBRep_SLProps_Normal, None, HLRBRep_SLProps)
HLRBRep_SLProps.SetParameters = new_instancemethod(_HLRBRep.HLRBRep_SLProps_SetParameters, None, HLRBRep_SLProps)
HLRBRep_SLProps.SetSurface = new_instancemethod(_HLRBRep.HLRBRep_SLProps_SetSurface, None, HLRBRep_SLProps)
HLRBRep_SLProps.TangentU = new_instancemethod(_HLRBRep.HLRBRep_SLProps_TangentU, None, HLRBRep_SLProps)
HLRBRep_SLProps.TangentV = new_instancemethod(_HLRBRep.HLRBRep_SLProps_TangentV, None, HLRBRep_SLProps)
HLRBRep_SLProps.Value = new_instancemethod(_HLRBRep.HLRBRep_SLProps_Value, None, HLRBRep_SLProps)
HLRBRep_SLProps_swigregister = _HLRBRep.HLRBRep_SLProps_swigregister
HLRBRep_SLProps_swigregister(HLRBRep_SLProps)

class HLRBRep_SLPropsATool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounds(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
        """
        * returns the bounds of the Surface.
        	:param A:
        	:type A: Standard_Address
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SLPropsATool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def Continuity(*args) -> "Standard_Integer":
        """
        * returns the order of continuity of the Surface <A>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable.
        	:param A:
        	:type A: Standard_Address
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_SLPropsATool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D1(*args) -> "void":
        """
        * Computes the point <P> and first derivative <D1*> of parameter <U> and <V> on the Surface <A>.
        	:param A:
        	:type A: Standard_Address
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param P:
        	:type P: gp_Pnt
        	:param D1U:
        	:type D1U: gp_Vec
        	:param D1V:
        	:type D1V: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SLPropsATool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Computes the point <P>, the first derivative <D1*> and second derivative <D2*> of parameter <U> and <V> on the Surface <A>.
        	:param A:
        	:type A: Standard_Address
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param P:
        	:type P: gp_Pnt
        	:param D1U:
        	:type D1U: gp_Vec
        	:param D1V:
        	:type D1V: gp_Vec
        	:param D2U:
        	:type D2U: gp_Vec
        	:param D2V:
        	:type D2V: gp_Vec
        	:param DUV:
        	:type DUV: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SLPropsATool_D2(*args)

    D2 = staticmethod(D2)

    def DN(*args) -> "gp_Vec":
        """
        :param A:
        	:type A: Standard_Address
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param Nu:
        	:type Nu: int
        	:param Nv:
        	:type Nv: int
        	:rtype: gp_Vec
        """
        return _HLRBRep.HLRBRep_SLPropsATool_DN(*args)

    DN = staticmethod(DN)

    def Value(*args) -> "void":
        """
        * Computes the point <P> of 	parameter <U> and <V> on the Surface <A>.
        	:param A:
        	:type A: Standard_Address
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param P:
        	:type P: gp_Pnt
        	:rtype: void
        """
        return _HLRBRep.HLRBRep_SLPropsATool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_SLPropsATool_swiginit(self, _HLRBRep.new_HLRBRep_SLPropsATool())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_SLPropsATool
HLRBRep_SLPropsATool_swigregister = _HLRBRep.HLRBRep_SLPropsATool_swigregister
HLRBRep_SLPropsATool_swigregister(HLRBRep_SLPropsATool)

def HLRBRep_SLPropsATool_Bounds(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
    """
    * returns the bounds of the Surface.
    	:param A:
    	:type A: Standard_Address
    	:param U1:
    	:type U1: float
    	:param V1:
    	:type V1: float
    	:param U2:
    	:type U2: float
    	:param V2:
    	:type V2: float
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_SLPropsATool_Bounds(*args)

def HLRBRep_SLPropsATool_Continuity(*args) -> "Standard_Integer":
    """
    * returns the order of continuity of the Surface <A>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable.
    	:param A:
    	:type A: Standard_Address
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_SLPropsATool_Continuity(*args)

def HLRBRep_SLPropsATool_D1(*args) -> "void":
    """
    * Computes the point <P> and first derivative <D1*> of parameter <U> and <V> on the Surface <A>.
    	:param A:
    	:type A: Standard_Address
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param P:
    	:type P: gp_Pnt
    	:param D1U:
    	:type D1U: gp_Vec
    	:param D1V:
    	:type D1V: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_SLPropsATool_D1(*args)

def HLRBRep_SLPropsATool_D2(*args) -> "void":
    """
    * Computes the point <P>, the first derivative <D1*> and second derivative <D2*> of parameter <U> and <V> on the Surface <A>.
    	:param A:
    	:type A: Standard_Address
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param P:
    	:type P: gp_Pnt
    	:param D1U:
    	:type D1U: gp_Vec
    	:param D1V:
    	:type D1V: gp_Vec
    	:param D2U:
    	:type D2U: gp_Vec
    	:param D2V:
    	:type D2V: gp_Vec
    	:param DUV:
    	:type DUV: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_SLPropsATool_D2(*args)

def HLRBRep_SLPropsATool_DN(*args) -> "gp_Vec":
    """
    :param A:
    	:type A: Standard_Address
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param Nu:
    	:type Nu: int
    	:param Nv:
    	:type Nv: int
    	:rtype: gp_Vec
    """
    return _HLRBRep.HLRBRep_SLPropsATool_DN(*args)

def HLRBRep_SLPropsATool_Value(*args) -> "void":
    """
    * Computes the point <P> of 	parameter <U> and <V> on the Surface <A>.
    	:param A:
    	:type A: Standard_Address
    	:param U:
    	:type U: float
    	:param V:
    	:type V: float
    	:param P:
    	:type P: gp_Pnt
    	:rtype: void
    """
    return _HLRBRep.HLRBRep_SLPropsATool_Value(*args)

class HLRBRep_ShapeBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounds(self, *args) -> "void":
        """
        :param V1:
        	:type V1: int
        	:param V2:
        	:type V2: int
        	:param E1:
        	:type E1: int
        	:param E2:
        	:type E2: int
        	:param F1:
        	:type F1: int
        	:param F2:
        	:type F2: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ShapeBounds_Bounds(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param S:
        	:type S: HLRTopoBRep_OutLiner
        	:param SData:
        	:type SData: Standard_Transient
        	:param nbIso:
        	:type nbIso: int
        	:param V1:
        	:type V1: int
        	:param V2:
        	:type V2: int
        	:param E1:
        	:type E1: int
        	:param E2:
        	:type E2: int
        	:param F1:
        	:type F1: int
        	:param F2:
        	:type F2: int
        	:rtype: None
        :param S:
        	:type S: HLRTopoBRep_OutLiner
        	:param nbIso:
        	:type nbIso: int
        	:param V1:
        	:type V1: int
        	:param V2:
        	:type V2: int
        	:param E1:
        	:type E1: int
        	:param E2:
        	:type E2: int
        	:param F1:
        	:type F1: int
        	:param F2:
        	:type F2: int
        	:rtype: None
        """
        _HLRBRep.HLRBRep_ShapeBounds_swiginit(self, _HLRBRep.new_HLRBRep_ShapeBounds(*args))

    def MinMax(self, *args) -> "HLRAlgo_EdgesBlock::MinMaxIndices &":
        """:rtype: HLRAlgo_EdgesBlock::MinMaxIndices"""
        return _HLRBRep.HLRBRep_ShapeBounds_MinMax(self, *args)


    def NbOfIso(self, *args) -> "Standard_Integer":
        """
        :param nbIso:
        	:type nbIso: int
        	:rtype: None
        :rtype: int
        """
        return _HLRBRep.HLRBRep_ShapeBounds_NbOfIso(self, *args)


    def Shape(self, *args) -> "opencascade::handle< HLRTopoBRep_OutLiner > const &":
        """
        :param S:
        	:type S: HLRTopoBRep_OutLiner
        	:rtype: None
        :rtype: opencascade::handle<HLRTopoBRep_OutLiner>
        """
        return _HLRBRep.HLRBRep_ShapeBounds_Shape(self, *args)


    def ShapeData(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        :param SD:
        	:type SD: Standard_Transient
        	:rtype: None
        :rtype: opencascade::handle<Standard_Transient>
        """
        return _HLRBRep.HLRBRep_ShapeBounds_ShapeData(self, *args)


    def Sizes(self, *args) -> "void":
        """
        :param NV:
        	:type NV: int
        	:param NE:
        	:type NE: int
        	:param NF:
        	:type NF: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ShapeBounds_Sizes(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param NV:
        	:type NV: int
        	:param NE:
        	:type NE: int
        	:param NF:
        	:type NF: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ShapeBounds_Translate(self, *args)


    def UpdateMinMax(self, *args) -> "void":
        """
        :param theTotMinMax:
        	:type theTotMinMax: HLRAlgo_EdgesBlock::MinMaxIndices
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ShapeBounds_UpdateMinMax(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ShapeBounds
HLRBRep_ShapeBounds.Bounds = new_instancemethod(_HLRBRep.HLRBRep_ShapeBounds_Bounds, None, HLRBRep_ShapeBounds)
HLRBRep_ShapeBounds.MinMax = new_instancemethod(_HLRBRep.HLRBRep_ShapeBounds_MinMax, None, HLRBRep_ShapeBounds)
HLRBRep_ShapeBounds.NbOfIso = new_instancemethod(_HLRBRep.HLRBRep_ShapeBounds_NbOfIso, None, HLRBRep_ShapeBounds)
HLRBRep_ShapeBounds.Shape = new_instancemethod(_HLRBRep.HLRBRep_ShapeBounds_Shape, None, HLRBRep_ShapeBounds)
HLRBRep_ShapeBounds.ShapeData = new_instancemethod(_HLRBRep.HLRBRep_ShapeBounds_ShapeData, None, HLRBRep_ShapeBounds)
HLRBRep_ShapeBounds.Sizes = new_instancemethod(_HLRBRep.HLRBRep_ShapeBounds_Sizes, None, HLRBRep_ShapeBounds)
HLRBRep_ShapeBounds.Translate = new_instancemethod(_HLRBRep.HLRBRep_ShapeBounds_Translate, None, HLRBRep_ShapeBounds)
HLRBRep_ShapeBounds.UpdateMinMax = new_instancemethod(_HLRBRep.HLRBRep_ShapeBounds_UpdateMinMax, None, HLRBRep_ShapeBounds)
HLRBRep_ShapeBounds_swigregister = _HLRBRep.HLRBRep_ShapeBounds_swigregister
HLRBRep_ShapeBounds_swigregister(HLRBRep_ShapeBounds)

class HLRBRep_ShapeToHLR(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Load(*args) -> "opencascade::handle< HLRBRep_Data >":
        """
        * Creates a DataStructure containing the OutLiner <S> depending on the projector <P> and nbIso.
        	:param S:
        	:type S: HLRTopoBRep_OutLiner
        	:param P:
        	:type P: HLRAlgo_Projector
        	:param MST:
        	:type MST: BRepTopAdaptor_MapOfShapeTool
        	:param nbIso: default value is 0
        	:type nbIso: int
        	:rtype: opencascade::handle<HLRBRep_Data>
        """
        return _HLRBRep.HLRBRep_ShapeToHLR_Load(*args)

    Load = staticmethod(Load)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_ShapeToHLR_swiginit(self, _HLRBRep.new_HLRBRep_ShapeToHLR())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ShapeToHLR
HLRBRep_ShapeToHLR_swigregister = _HLRBRep.HLRBRep_ShapeToHLR_swigregister
HLRBRep_ShapeToHLR_swigregister(HLRBRep_ShapeToHLR)

def HLRBRep_ShapeToHLR_Load(*args) -> "opencascade::handle< HLRBRep_Data >":
    """
    * Creates a DataStructure containing the OutLiner <S> depending on the projector <P> and nbIso.
    	:param S:
    	:type S: HLRTopoBRep_OutLiner
    	:param P:
    	:type P: HLRAlgo_Projector
    	:param MST:
    	:type MST: BRepTopAdaptor_MapOfShapeTool
    	:param nbIso: default value is 0
    	:type nbIso: int
    	:rtype: opencascade::handle<HLRBRep_Data>
    """
    return _HLRBRep.HLRBRep_ShapeToHLR_Load(*args)

class HLRBRep_SurfaceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AxeOfRevolution(*args) -> "gp_Ax1":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: gp_Ax1
        """
        return _HLRBRep.HLRBRep_SurfaceTool_AxeOfRevolution(*args)

    AxeOfRevolution = staticmethod(AxeOfRevolution)

    def BSpline(*args) -> "opencascade::handle< Geom_BSplineSurface >":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: opencascade::handle<Geom_BSplineSurface>
        """
        return _HLRBRep.HLRBRep_SurfaceTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def BasisCurve(*args) -> "opencascade::handle< Adaptor3d_HCurve >":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: opencascade::handle<Adaptor3d_HCurve>
        """
        return _HLRBRep.HLRBRep_SurfaceTool_BasisCurve(*args)

    BasisCurve = staticmethod(BasisCurve)

    def BasisSurface(*args) -> "opencascade::handle< Adaptor3d_HSurface >":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: opencascade::handle<Adaptor3d_HSurface>
        """
        return _HLRBRep.HLRBRep_SurfaceTool_BasisSurface(*args)

    BasisSurface = staticmethod(BasisSurface)

    def Bezier(*args) -> "opencascade::handle< Geom_BezierSurface >":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: opencascade::handle<Geom_BezierSurface>
        """
        return _HLRBRep.HLRBRep_SurfaceTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def Cone(*args) -> "gp_Cone":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: gp_Cone
        """
        return _HLRBRep.HLRBRep_SurfaceTool_Cone(*args)

    Cone = staticmethod(Cone)

    def Cylinder(*args) -> "gp_Cylinder":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: gp_Cylinder
        """
        return _HLRBRep.HLRBRep_SurfaceTool_Cylinder(*args)

    Cylinder = staticmethod(Cylinder)

    def D0(*args) -> "void":
        """
        :param S:
        	:type S: Standard_Address
        	:param u:
        	:type u: float
        	:param v:
        	:type v: float
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SurfaceTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args) -> "void":
        """
        :param S:
        	:type S: Standard_Address
        	:param u:
        	:type u: float
        	:param v:
        	:type v: float
        	:param P:
        	:type P: gp_Pnt
        	:param D1u:
        	:type D1u: gp_Vec
        	:param D1v:
        	:type D1v: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SurfaceTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        :param S:
        	:type S: Standard_Address
        	:param u:
        	:type u: float
        	:param v:
        	:type v: float
        	:param P:
        	:type P: gp_Pnt
        	:param D1U:
        	:type D1U: gp_Vec
        	:param D1V:
        	:type D1V: gp_Vec
        	:param D2U:
        	:type D2U: gp_Vec
        	:param D2V:
        	:type D2V: gp_Vec
        	:param D2UV:
        	:type D2UV: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SurfaceTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        :param S:
        	:type S: Standard_Address
        	:param u:
        	:type u: float
        	:param v:
        	:type v: float
        	:param P:
        	:type P: gp_Pnt
        	:param D1U:
        	:type D1U: gp_Vec
        	:param D1V:
        	:type D1V: gp_Vec
        	:param D2U:
        	:type D2U: gp_Vec
        	:param D2V:
        	:type D2V: gp_Vec
        	:param D2UV:
        	:type D2UV: gp_Vec
        	:param D3U:
        	:type D3U: gp_Vec
        	:param D3V:
        	:type D3V: gp_Vec
        	:param D3UUV:
        	:type D3UUV: gp_Vec
        	:param D3UVV:
        	:type D3UVV: gp_Vec
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SurfaceTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args) -> "gp_Vec":
        """
        :param S:
        	:type S: Standard_Address
        	:param u:
        	:type u: float
        	:param v:
        	:type v: float
        	:param Nu:
        	:type Nu: int
        	:param Nv:
        	:type Nv: int
        	:rtype: gp_Vec
        """
        return _HLRBRep.HLRBRep_SurfaceTool_DN(*args)

    DN = staticmethod(DN)

    def Direction(*args) -> "gp_Dir":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: gp_Dir
        """
        return _HLRBRep.HLRBRep_SurfaceTool_Direction(*args)

    Direction = staticmethod(Direction)

    def FirstUParameter(*args) -> "Standard_Real":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SurfaceTool_FirstUParameter(*args)

    FirstUParameter = staticmethod(FirstUParameter)

    def FirstVParameter(*args) -> "Standard_Real":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SurfaceTool_FirstVParameter(*args)

    FirstVParameter = staticmethod(FirstVParameter)

    def GetType(*args) -> "GeomAbs_SurfaceType":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: GeomAbs_SurfaceType
        """
        return _HLRBRep.HLRBRep_SurfaceTool_GetType(*args)

    GetType = staticmethod(GetType)

    def IsUClosed(*args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_SurfaceTool_IsUClosed(*args)

    IsUClosed = staticmethod(IsUClosed)

    def IsUPeriodic(*args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_SurfaceTool_IsUPeriodic(*args)

    IsUPeriodic = staticmethod(IsUPeriodic)

    def IsVClosed(*args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_SurfaceTool_IsVClosed(*args)

    IsVClosed = staticmethod(IsVClosed)

    def IsVPeriodic(*args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_SurfaceTool_IsVPeriodic(*args)

    IsVPeriodic = staticmethod(IsVPeriodic)

    def LastUParameter(*args) -> "Standard_Real":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SurfaceTool_LastUParameter(*args)

    LastUParameter = staticmethod(LastUParameter)

    def LastVParameter(*args) -> "Standard_Real":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SurfaceTool_LastVParameter(*args)

    LastVParameter = staticmethod(LastVParameter)

    def NbSamplesU(*args) -> "Standard_Integer":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: int
        :param S:
        	:type S: Standard_Address
        	:param u1:
        	:type u1: float
        	:param u2:
        	:type u2: float
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_SurfaceTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args) -> "Standard_Integer":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: int
        :param S:
        	:type S: Standard_Address
        	:param v1:
        	:type v1: float
        	:param v2:
        	:type v2: float
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_SurfaceTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def NbUIntervals(*args) -> "Standard_Integer":
        """
        :param S:
        	:type S: Standard_Address
        	:param Sh:
        	:type Sh: GeomAbs_Shape
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_SurfaceTool_NbUIntervals(*args)

    NbUIntervals = staticmethod(NbUIntervals)

    def NbVIntervals(*args) -> "Standard_Integer":
        """
        :param S:
        	:type S: Standard_Address
        	:param Sh:
        	:type Sh: GeomAbs_Shape
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_SurfaceTool_NbVIntervals(*args)

    NbVIntervals = staticmethod(NbVIntervals)

    def OffsetValue(*args) -> "Standard_Real":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SurfaceTool_OffsetValue(*args)

    OffsetValue = staticmethod(OffsetValue)

    def Plane(*args) -> "gp_Pln":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: gp_Pln
        """
        return _HLRBRep.HLRBRep_SurfaceTool_Plane(*args)

    Plane = staticmethod(Plane)

    def Sphere(*args) -> "gp_Sphere":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: gp_Sphere
        """
        return _HLRBRep.HLRBRep_SurfaceTool_Sphere(*args)

    Sphere = staticmethod(Sphere)

    def Torus(*args) -> "gp_Torus":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: gp_Torus
        """
        return _HLRBRep.HLRBRep_SurfaceTool_Torus(*args)

    Torus = staticmethod(Torus)

    def UIntervals(*args) -> "void":
        """
        :param S:
        	:type S: Standard_Address
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param Sh:
        	:type Sh: GeomAbs_Shape
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SurfaceTool_UIntervals(*args)

    UIntervals = staticmethod(UIntervals)

    def UPeriod(*args) -> "Standard_Real":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SurfaceTool_UPeriod(*args)

    UPeriod = staticmethod(UPeriod)

    def UResolution(*args) -> "Standard_Real":
        """
        :param S:
        	:type S: Standard_Address
        	:param R3d:
        	:type R3d: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SurfaceTool_UResolution(*args)

    UResolution = staticmethod(UResolution)

    def UTrim(*args) -> "opencascade::handle< Adaptor3d_HSurface >":
        """
        * If <First> >= <Last>
        	:param S:
        	:type S: Standard_Address
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Tol:
        	:type Tol: float
        	:rtype: opencascade::handle<Adaptor3d_HSurface>
        """
        return _HLRBRep.HLRBRep_SurfaceTool_UTrim(*args)

    UTrim = staticmethod(UTrim)

    def VIntervals(*args) -> "void":
        """
        :param S:
        	:type S: Standard_Address
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param Sh:
        	:type Sh: GeomAbs_Shape
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_SurfaceTool_VIntervals(*args)

    VIntervals = staticmethod(VIntervals)

    def VPeriod(*args) -> "Standard_Real":
        """
        :param S:
        	:type S: Standard_Address
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SurfaceTool_VPeriod(*args)

    VPeriod = staticmethod(VPeriod)

    def VResolution(*args) -> "Standard_Real":
        """
        :param S:
        	:type S: Standard_Address
        	:param R3d:
        	:type R3d: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_SurfaceTool_VResolution(*args)

    VResolution = staticmethod(VResolution)

    def VTrim(*args) -> "opencascade::handle< Adaptor3d_HSurface >":
        """
        * If <First> >= <Last>
        	:param S:
        	:type S: Standard_Address
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Tol:
        	:type Tol: float
        	:rtype: opencascade::handle<Adaptor3d_HSurface>
        """
        return _HLRBRep.HLRBRep_SurfaceTool_VTrim(*args)

    VTrim = staticmethod(VTrim)

    def Value(*args) -> "gp_Pnt":
        """
        :param S:
        	:type S: Standard_Address
        	:param u:
        	:type u: float
        	:param v:
        	:type v: float
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_SurfaceTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_SurfaceTool_swiginit(self, _HLRBRep.new_HLRBRep_SurfaceTool())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_SurfaceTool
HLRBRep_SurfaceTool_swigregister = _HLRBRep.HLRBRep_SurfaceTool_swigregister
HLRBRep_SurfaceTool_swigregister(HLRBRep_SurfaceTool)

def HLRBRep_SurfaceTool_AxeOfRevolution(*args) -> "gp_Ax1":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: gp_Ax1
    """
    return _HLRBRep.HLRBRep_SurfaceTool_AxeOfRevolution(*args)

def HLRBRep_SurfaceTool_BSpline(*args) -> "opencascade::handle< Geom_BSplineSurface >":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: opencascade::handle<Geom_BSplineSurface>
    """
    return _HLRBRep.HLRBRep_SurfaceTool_BSpline(*args)

def HLRBRep_SurfaceTool_BasisCurve(*args) -> "opencascade::handle< Adaptor3d_HCurve >":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: opencascade::handle<Adaptor3d_HCurve>
    """
    return _HLRBRep.HLRBRep_SurfaceTool_BasisCurve(*args)

def HLRBRep_SurfaceTool_BasisSurface(*args) -> "opencascade::handle< Adaptor3d_HSurface >":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: opencascade::handle<Adaptor3d_HSurface>
    """
    return _HLRBRep.HLRBRep_SurfaceTool_BasisSurface(*args)

def HLRBRep_SurfaceTool_Bezier(*args) -> "opencascade::handle< Geom_BezierSurface >":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: opencascade::handle<Geom_BezierSurface>
    """
    return _HLRBRep.HLRBRep_SurfaceTool_Bezier(*args)

def HLRBRep_SurfaceTool_Cone(*args) -> "gp_Cone":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: gp_Cone
    """
    return _HLRBRep.HLRBRep_SurfaceTool_Cone(*args)

def HLRBRep_SurfaceTool_Cylinder(*args) -> "gp_Cylinder":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: gp_Cylinder
    """
    return _HLRBRep.HLRBRep_SurfaceTool_Cylinder(*args)

def HLRBRep_SurfaceTool_D0(*args) -> "void":
    """
    :param S:
    	:type S: Standard_Address
    	:param u:
    	:type u: float
    	:param v:
    	:type v: float
    	:param P:
    	:type P: gp_Pnt
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_SurfaceTool_D0(*args)

def HLRBRep_SurfaceTool_D1(*args) -> "void":
    """
    :param S:
    	:type S: Standard_Address
    	:param u:
    	:type u: float
    	:param v:
    	:type v: float
    	:param P:
    	:type P: gp_Pnt
    	:param D1u:
    	:type D1u: gp_Vec
    	:param D1v:
    	:type D1v: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_SurfaceTool_D1(*args)

def HLRBRep_SurfaceTool_D2(*args) -> "void":
    """
    :param S:
    	:type S: Standard_Address
    	:param u:
    	:type u: float
    	:param v:
    	:type v: float
    	:param P:
    	:type P: gp_Pnt
    	:param D1U:
    	:type D1U: gp_Vec
    	:param D1V:
    	:type D1V: gp_Vec
    	:param D2U:
    	:type D2U: gp_Vec
    	:param D2V:
    	:type D2V: gp_Vec
    	:param D2UV:
    	:type D2UV: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_SurfaceTool_D2(*args)

def HLRBRep_SurfaceTool_D3(*args) -> "void":
    """
    :param S:
    	:type S: Standard_Address
    	:param u:
    	:type u: float
    	:param v:
    	:type v: float
    	:param P:
    	:type P: gp_Pnt
    	:param D1U:
    	:type D1U: gp_Vec
    	:param D1V:
    	:type D1V: gp_Vec
    	:param D2U:
    	:type D2U: gp_Vec
    	:param D2V:
    	:type D2V: gp_Vec
    	:param D2UV:
    	:type D2UV: gp_Vec
    	:param D3U:
    	:type D3U: gp_Vec
    	:param D3V:
    	:type D3V: gp_Vec
    	:param D3UUV:
    	:type D3UUV: gp_Vec
    	:param D3UVV:
    	:type D3UVV: gp_Vec
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_SurfaceTool_D3(*args)

def HLRBRep_SurfaceTool_DN(*args) -> "gp_Vec":
    """
    :param S:
    	:type S: Standard_Address
    	:param u:
    	:type u: float
    	:param v:
    	:type v: float
    	:param Nu:
    	:type Nu: int
    	:param Nv:
    	:type Nv: int
    	:rtype: gp_Vec
    """
    return _HLRBRep.HLRBRep_SurfaceTool_DN(*args)

def HLRBRep_SurfaceTool_Direction(*args) -> "gp_Dir":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: gp_Dir
    """
    return _HLRBRep.HLRBRep_SurfaceTool_Direction(*args)

def HLRBRep_SurfaceTool_FirstUParameter(*args) -> "Standard_Real":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_SurfaceTool_FirstUParameter(*args)

def HLRBRep_SurfaceTool_FirstVParameter(*args) -> "Standard_Real":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_SurfaceTool_FirstVParameter(*args)

def HLRBRep_SurfaceTool_GetType(*args) -> "GeomAbs_SurfaceType":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: GeomAbs_SurfaceType
    """
    return _HLRBRep.HLRBRep_SurfaceTool_GetType(*args)

def HLRBRep_SurfaceTool_IsUClosed(*args) -> "Standard_Boolean":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_SurfaceTool_IsUClosed(*args)

def HLRBRep_SurfaceTool_IsUPeriodic(*args) -> "Standard_Boolean":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_SurfaceTool_IsUPeriodic(*args)

def HLRBRep_SurfaceTool_IsVClosed(*args) -> "Standard_Boolean":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_SurfaceTool_IsVClosed(*args)

def HLRBRep_SurfaceTool_IsVPeriodic(*args) -> "Standard_Boolean":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_SurfaceTool_IsVPeriodic(*args)

def HLRBRep_SurfaceTool_LastUParameter(*args) -> "Standard_Real":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_SurfaceTool_LastUParameter(*args)

def HLRBRep_SurfaceTool_LastVParameter(*args) -> "Standard_Real":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_SurfaceTool_LastVParameter(*args)

def HLRBRep_SurfaceTool_NbSamplesU(*args) -> "Standard_Integer":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: int
    :param S:
    	:type S: Standard_Address
    	:param u1:
    	:type u1: float
    	:param u2:
    	:type u2: float
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_SurfaceTool_NbSamplesU(*args)

def HLRBRep_SurfaceTool_NbSamplesV(*args) -> "Standard_Integer":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: int
    :param S:
    	:type S: Standard_Address
    	:param v1:
    	:type v1: float
    	:param v2:
    	:type v2: float
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_SurfaceTool_NbSamplesV(*args)

def HLRBRep_SurfaceTool_NbUIntervals(*args) -> "Standard_Integer":
    """
    :param S:
    	:type S: Standard_Address
    	:param Sh:
    	:type Sh: GeomAbs_Shape
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_SurfaceTool_NbUIntervals(*args)

def HLRBRep_SurfaceTool_NbVIntervals(*args) -> "Standard_Integer":
    """
    :param S:
    	:type S: Standard_Address
    	:param Sh:
    	:type Sh: GeomAbs_Shape
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_SurfaceTool_NbVIntervals(*args)

def HLRBRep_SurfaceTool_OffsetValue(*args) -> "Standard_Real":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_SurfaceTool_OffsetValue(*args)

def HLRBRep_SurfaceTool_Plane(*args) -> "gp_Pln":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: gp_Pln
    """
    return _HLRBRep.HLRBRep_SurfaceTool_Plane(*args)

def HLRBRep_SurfaceTool_Sphere(*args) -> "gp_Sphere":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: gp_Sphere
    """
    return _HLRBRep.HLRBRep_SurfaceTool_Sphere(*args)

def HLRBRep_SurfaceTool_Torus(*args) -> "gp_Torus":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: gp_Torus
    """
    return _HLRBRep.HLRBRep_SurfaceTool_Torus(*args)

def HLRBRep_SurfaceTool_UIntervals(*args) -> "void":
    """
    :param S:
    	:type S: Standard_Address
    	:param T:
    	:type T: TColStd_Array1OfReal
    	:param Sh:
    	:type Sh: GeomAbs_Shape
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_SurfaceTool_UIntervals(*args)

def HLRBRep_SurfaceTool_UPeriod(*args) -> "Standard_Real":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_SurfaceTool_UPeriod(*args)

def HLRBRep_SurfaceTool_UResolution(*args) -> "Standard_Real":
    """
    :param S:
    	:type S: Standard_Address
    	:param R3d:
    	:type R3d: float
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_SurfaceTool_UResolution(*args)

def HLRBRep_SurfaceTool_UTrim(*args) -> "opencascade::handle< Adaptor3d_HSurface >":
    """
    * If <First> >= <Last>
    	:param S:
    	:type S: Standard_Address
    	:param First:
    	:type First: float
    	:param Last:
    	:type Last: float
    	:param Tol:
    	:type Tol: float
    	:rtype: opencascade::handle<Adaptor3d_HSurface>
    """
    return _HLRBRep.HLRBRep_SurfaceTool_UTrim(*args)

def HLRBRep_SurfaceTool_VIntervals(*args) -> "void":
    """
    :param S:
    	:type S: Standard_Address
    	:param T:
    	:type T: TColStd_Array1OfReal
    	:param Sh:
    	:type Sh: GeomAbs_Shape
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_SurfaceTool_VIntervals(*args)

def HLRBRep_SurfaceTool_VPeriod(*args) -> "Standard_Real":
    """
    :param S:
    	:type S: Standard_Address
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_SurfaceTool_VPeriod(*args)

def HLRBRep_SurfaceTool_VResolution(*args) -> "Standard_Real":
    """
    :param S:
    	:type S: Standard_Address
    	:param R3d:
    	:type R3d: float
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_SurfaceTool_VResolution(*args)

def HLRBRep_SurfaceTool_VTrim(*args) -> "opencascade::handle< Adaptor3d_HSurface >":
    """
    * If <First> >= <Last>
    	:param S:
    	:type S: Standard_Address
    	:param First:
    	:type First: float
    	:param Last:
    	:type Last: float
    	:param Tol:
    	:type Tol: float
    	:rtype: opencascade::handle<Adaptor3d_HSurface>
    """
    return _HLRBRep.HLRBRep_SurfaceTool_VTrim(*args)

def HLRBRep_SurfaceTool_Value(*args) -> "gp_Pnt":
    """
    :param S:
    	:type S: Standard_Address
    	:param u:
    	:type u: float
    	:param v:
    	:type v: float
    	:rtype: gp_Pnt
    """
    return _HLRBRep.HLRBRep_SurfaceTool_Value(*args)

class HLRBRep_TheCSFunctionOfInterCSurf(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AuxillarCurve(self, *args) -> "gp_Lin const":
        """:rtype: gp_Lin"""
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_AuxillarCurve(self, *args)


    def AuxillarSurface(self, *args) -> "Standard_Address const &":
        """:rtype: Standard_Address"""
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_AuxillarSurface(self, *args)


    def __init__(self, *args):
        """
        :param S:
        	:type S: Standard_Address
        	:param C:
        	:type C: gp_Lin
        	:rtype: None
        """
        _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_swiginit(self, _HLRBRep.new_HLRBRep_TheCSFunctionOfInterCSurf(*args))

    def Point(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_Root(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheCSFunctionOfInterCSurf
HLRBRep_TheCSFunctionOfInterCSurf.AuxillarCurve = new_instancemethod(_HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_AuxillarCurve, None, HLRBRep_TheCSFunctionOfInterCSurf)
HLRBRep_TheCSFunctionOfInterCSurf.AuxillarSurface = new_instancemethod(_HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_AuxillarSurface, None, HLRBRep_TheCSFunctionOfInterCSurf)
HLRBRep_TheCSFunctionOfInterCSurf.Point = new_instancemethod(_HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_Point, None, HLRBRep_TheCSFunctionOfInterCSurf)
HLRBRep_TheCSFunctionOfInterCSurf.Root = new_instancemethod(_HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_Root, None, HLRBRep_TheCSFunctionOfInterCSurf)
HLRBRep_TheCSFunctionOfInterCSurf_swigregister = _HLRBRep.HLRBRep_TheCSFunctionOfInterCSurf_swigregister
HLRBRep_TheCSFunctionOfInterCSurf_swigregister(HLRBRep_TheCSFunctionOfInterCSurf)

class HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param curve1:
        	:type curve1: Standard_Address
        	:param curve2:
        	:type curve2: Standard_Address
        	:rtype: None
        """
        _HLRBRep.HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter
HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_swigregister = _HLRBRep.HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_swigregister
HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter_swigregister(HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter)

class HLRBRep_TheExactInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Function(self, *args) -> "HLRBRep_TheCSFunctionOfInterCSurf &":
        """
        * return the math function which is used to compute the intersection
        	:rtype: HLRBRep_TheCSFunctionOfInterCSurf
        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_Function(self, *args)


    def __init__(self, *args):
        """
        * compute the solution point with the close point MarginCoef is the coefficient for extension of UV bounds. Ex., UFirst -= MarginCoef*(ULast-UFirst)
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:param F:
        	:type F: HLRBRep_TheCSFunctionOfInterCSurf
        	:param TolTangency:
        	:type TolTangency: float
        	:param MarginCoef: default value is 0.0
        	:type MarginCoef: float
        	:rtype: None
        * initialize the parameters to compute the solution
        	:param F:
        	:type F: HLRBRep_TheCSFunctionOfInterCSurf
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_TheExactInterCSurf_swiginit(self, _HLRBRep.new_HLRBRep_TheExactInterCSurf(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the creation completed without failure.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_TheExactInterCSurf_IsEmpty(self, *args)


    def ParameterOnCurve(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _HLRBRep.HLRBRep_TheExactInterCSurf_ParameterOnCurve(self, *args)


    def ParameterOnSurface(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_ParameterOnSurface(self, *args)


    def Perform(self, *args) -> "void":
        """
        * compute the solution it's possible to write to optimize: IntImp_IntCS inter(S1,C1,Toltangency) math_FunctionSetRoot rsnld(Inter.function()) while ...{ u=... v=... w=... inter.Perform(u,v,w,rsnld) } or IntImp_IntCS inter(Toltangency) inter.SetSurface(S); math_FunctionSetRoot rsnld(Inter.function()) while ...{ C=... inter.SetCurve(C); u=... v=... w=... inter.Perform(u,v,w,rsnld) }
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:param Rsnld:
        	:type Rsnld: math_FunctionSetRoot
        	:param u0:
        	:type u0: float
        	:param v0:
        	:type v0: float
        	:param u1:
        	:type u1: float
        	:param v1:
        	:type v1: float
        	:param w0:
        	:type w0: float
        	:param w1:
        	:type w1: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_Perform(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        * returns the intersection point The exception NotDone is raised if IsDone is false. The exception DomainError is raised if IsEmpty is true.
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_TheExactInterCSurf_Point(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheExactInterCSurf
HLRBRep_TheExactInterCSurf.Function = new_instancemethod(_HLRBRep.HLRBRep_TheExactInterCSurf_Function, None, HLRBRep_TheExactInterCSurf)
HLRBRep_TheExactInterCSurf.IsDone = new_instancemethod(_HLRBRep.HLRBRep_TheExactInterCSurf_IsDone, None, HLRBRep_TheExactInterCSurf)
HLRBRep_TheExactInterCSurf.IsEmpty = new_instancemethod(_HLRBRep.HLRBRep_TheExactInterCSurf_IsEmpty, None, HLRBRep_TheExactInterCSurf)
HLRBRep_TheExactInterCSurf.ParameterOnCurve = new_instancemethod(_HLRBRep.HLRBRep_TheExactInterCSurf_ParameterOnCurve, None, HLRBRep_TheExactInterCSurf)
HLRBRep_TheExactInterCSurf.ParameterOnSurface = new_instancemethod(_HLRBRep.HLRBRep_TheExactInterCSurf_ParameterOnSurface, None, HLRBRep_TheExactInterCSurf)
HLRBRep_TheExactInterCSurf.Perform = new_instancemethod(_HLRBRep.HLRBRep_TheExactInterCSurf_Perform, None, HLRBRep_TheExactInterCSurf)
HLRBRep_TheExactInterCSurf.Point = new_instancemethod(_HLRBRep.HLRBRep_TheExactInterCSurf_Point, None, HLRBRep_TheExactInterCSurf)
HLRBRep_TheExactInterCSurf_swigregister = _HLRBRep.HLRBRep_TheExactInterCSurf_swigregister
HLRBRep_TheExactInterCSurf_swigregister(HLRBRep_TheExactInterCSurf)

class HLRBRep_TheIntConicCurveOfCInter(OCC.Core.IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Intersection between a line and a parametric curve.
        	:param L:
        	:type L: gp_Lin2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and a parametric curve.
        	:param C:
        	:type C: gp_Circ2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between an ellipse and a parametric curve.
        	:param E:
        	:type E: gp_Elips2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a parabola and a parametric curve.
        	:param Prb:
        	:type Prb: gp_Parab2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between the main branch of an hyperbola and a parametric curve.
        	:param H:
        	:type H: gp_Hypr2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_TheIntConicCurveOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_TheIntConicCurveOfCInter(*args))

    def Perform(self, *args) -> "void":
        """
        * Intersection between a line and a parametric curve.
        	:param L:
        	:type L: gp_Lin2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a line and a parametric curve.
        	:param C:
        	:type C: gp_Circ2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between an ellipse and a parametric curve.
        	:param E:
        	:type E: gp_Elips2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a parabola and a parametric curve.
        	:param Prb:
        	:type Prb: gp_Parab2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between the main branch of an hyperbola and a parametric curve.
        	:param H:
        	:type H: gp_Hypr2d
        	:param D1:
        	:type D1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param D2:
        	:type D2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheIntConicCurveOfCInter_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheIntConicCurveOfCInter
HLRBRep_TheIntConicCurveOfCInter.Perform = new_instancemethod(_HLRBRep.HLRBRep_TheIntConicCurveOfCInter_Perform, None, HLRBRep_TheIntConicCurveOfCInter)
HLRBRep_TheIntConicCurveOfCInter_swigregister = _HLRBRep.HLRBRep_TheIntConicCurveOfCInter_swigregister
HLRBRep_TheIntConicCurveOfCInter_swigregister(HLRBRep_TheIntConicCurveOfCInter)

class HLRBRep_TheIntPCurvePCurveOfCInter(OCC.Core.IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetMinNbSamples(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_GetMinNbSamples(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_TheIntPCurvePCurveOfCInter(*args))

    def Perform(self, *args) -> "void":
        """
        :param Curve1:
        	:type Curve1: Standard_Address
        	:param Domain1:
        	:type Domain1: IntRes2d_Domain
        	:param Curve2:
        	:type Curve2: Standard_Address
        	:param Domain2:
        	:type Domain2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        :param Curve1:
        	:type Curve1: Standard_Address
        	:param Domain1:
        	:type Domain1: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_Perform(self, *args)


    def SetMinNbSamples(self, *args) -> "void":
        """
        * Set / get minimum number of points in polygon for intersection.
        	:param theMinNbSamples:
        	:type theMinNbSamples: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_SetMinNbSamples(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheIntPCurvePCurveOfCInter
HLRBRep_TheIntPCurvePCurveOfCInter.GetMinNbSamples = new_instancemethod(_HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_GetMinNbSamples, None, HLRBRep_TheIntPCurvePCurveOfCInter)
HLRBRep_TheIntPCurvePCurveOfCInter.Perform = new_instancemethod(_HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_Perform, None, HLRBRep_TheIntPCurvePCurveOfCInter)
HLRBRep_TheIntPCurvePCurveOfCInter.SetMinNbSamples = new_instancemethod(_HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_SetMinNbSamples, None, HLRBRep_TheIntPCurvePCurveOfCInter)
HLRBRep_TheIntPCurvePCurveOfCInter_swigregister = _HLRBRep.HLRBRep_TheIntPCurvePCurveOfCInter_swigregister
HLRBRep_TheIntPCurvePCurveOfCInter_swigregister(HLRBRep_TheIntPCurvePCurveOfCInter)

class HLRBRep_TheInterferenceOfInterCSurf(OCC.Core.Intf.Intf_Interference):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an empty interference between Polygon and Polyhedron.
        	:rtype: None
        * Constructs and computes an interference between the Polygon and the Polyhedron.
        	:param thePolyg:
        	:type thePolyg: HLRBRep_ThePolygonOfInterCSurf
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: None
        * Constructs and computes an interference between the Straight Line and the Polyhedron.
        	:param theLin:
        	:type theLin: gp_Lin
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: None
        * Constructs and computes an interference between the Straight Lines and the Polyhedron.
        	:param theLins:
        	:type theLins: Intf_Array1OfLin
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: None
        * Constructs and computes an interference between the Polygon and the Polyhedron.
        	:param thePolyg:
        	:type thePolyg: HLRBRep_ThePolygonOfInterCSurf
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Constructs and computes an interference between the Straight Line and the Polyhedron.
        	:param theLin:
        	:type theLin: gp_Lin
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Constructs and computes an interference between the Straight Lines and the Polyhedron.
        	:param theLins:
        	:type theLins: Intf_Array1OfLin
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        """
        _HLRBRep.HLRBRep_TheInterferenceOfInterCSurf_swiginit(self, _HLRBRep.new_HLRBRep_TheInterferenceOfInterCSurf(*args))

    def Interference(self, *args) -> "void":
        """
        * Compares the boundings between the segment of <thePolyg> and the facets of <thePolyh>.
        	:param thePolyg:
        	:type thePolyg: HLRBRep_ThePolygonOfInterCSurf
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Compares the boundings between the segment of <thePolyg> and the facets of <thePolyh>.
        	:param thePolyg:
        	:type thePolyg: HLRBRep_ThePolygonOfInterCSurf
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheInterferenceOfInterCSurf_Interference(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Computes an interference between the Polygon and the Polyhedron.
        	:param thePolyg:
        	:type thePolyg: HLRBRep_ThePolygonOfInterCSurf
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: None
        * Computes an interference between the Straight Line and the Polyhedron.
        	:param theLin:
        	:type theLin: gp_Lin
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: None
        * Computes an interference between the Straight Lines and the Polyhedron.
        	:param theLins:
        	:type theLins: Intf_Array1OfLin
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: None
        * Computes an interference between the Polygon and the Polyhedron.
        	:param thePolyg:
        	:type thePolyg: HLRBRep_ThePolygonOfInterCSurf
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Computes an interference between the Straight Line and the Polyhedron.
        	:param theLin:
        	:type theLin: gp_Lin
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Computes an interference between the Straight Lines and the Polyhedron.
        	:param theLins:
        	:type theLins: Intf_Array1OfLin
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheInterferenceOfInterCSurf_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheInterferenceOfInterCSurf
HLRBRep_TheInterferenceOfInterCSurf.Interference = new_instancemethod(_HLRBRep.HLRBRep_TheInterferenceOfInterCSurf_Interference, None, HLRBRep_TheInterferenceOfInterCSurf)
HLRBRep_TheInterferenceOfInterCSurf.Perform = new_instancemethod(_HLRBRep.HLRBRep_TheInterferenceOfInterCSurf_Perform, None, HLRBRep_TheInterferenceOfInterCSurf)
HLRBRep_TheInterferenceOfInterCSurf_swigregister = _HLRBRep.HLRBRep_TheInterferenceOfInterCSurf_swigregister
HLRBRep_TheInterferenceOfInterCSurf_swigregister(HLRBRep_TheInterferenceOfInterCSurf)

class HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter(OCC.Core.IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def And_Domaine_Objet1_Intersections(self, *args) -> "void":
        """
        :param TheImpTool:
        	:type TheImpTool: IntCurve_IConicTool
        	:param TheParCurve:
        	:type TheParCurve: Standard_Address
        	:param TheImpCurveDomain:
        	:type TheImpCurveDomain: IntRes2d_Domain
        	:param TheParCurveDomain:
        	:type TheParCurveDomain: IntRes2d_Domain
        	:param NbResultats:
        	:type NbResultats: int
        	:param Inter2_And_Domain2:
        	:type Inter2_And_Domain2: TColStd_Array1OfReal
        	:param Inter1:
        	:type Inter1: TColStd_Array1OfReal
        	:param Resultat1:
        	:type Resultat1: TColStd_Array1OfReal
        	:param Resultat2:
        	:type Resultat2: TColStd_Array1OfReal
        	:param EpsNul:
        	:type EpsNul: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_And_Domaine_Objet1_Intersections(self, *args)


    def FindU(self, *args) -> "Standard_Real":
        """
        :param parameter:
        	:type parameter: float
        	:param point:
        	:type point: gp_Pnt2d
        	:param TheParCurev:
        	:type TheParCurev: Standard_Address
        	:param TheImpTool:
        	:type TheImpTool: IntCurve_IConicTool
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_FindU(self, *args)


    def FindV(self, *args) -> "Standard_Real":
        """
        :param parameter:
        	:type parameter: float
        	:param point:
        	:type point: gp_Pnt2d
        	:param TheImpTool:
        	:type TheImpTool: IntCurve_IConicTool
        	:param ParCurve:
        	:type ParCurve: Standard_Address
        	:param TheParCurveDomain:
        	:type TheParCurveDomain: IntRes2d_Domain
        	:param V0:
        	:type V0: float
        	:param V1:
        	:type V1: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_FindV(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Intersection between an implicit curve and a parametrised curve. The exception ConstructionError is raised if the domain of the parametrised curve does not verify HasFirstPoint and HasLastPoint return True.
        	:param ITool:
        	:type ITool: IntCurve_IConicTool
        	:param Dom1:
        	:type Dom1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param Dom2:
        	:type Dom2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter(*args))

    def Perform(self, *args) -> "void":
        """
        * Intersection between an implicit curve and a parametrised curve. The exception ConstructionError is raised if the domain of the parametrised curve does not verify HasFirstPoint and HasLastPoint return True.
        	:param ITool:
        	:type ITool: IntCurve_IConicTool
        	:param Dom1:
        	:type Dom1: IntRes2d_Domain
        	:param PCurve:
        	:type PCurve: Standard_Address
        	:param Dom2:
        	:type Dom2: IntRes2d_Domain
        	:param TolConf:
        	:type TolConf: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter
HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter.And_Domaine_Objet1_Intersections = new_instancemethod(_HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_And_Domaine_Objet1_Intersections, None, HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter)
HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter.FindU = new_instancemethod(_HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_FindU, None, HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter)
HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter.FindV = new_instancemethod(_HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_FindV, None, HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter)
HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter.Perform = new_instancemethod(_HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_Perform, None, HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter)
HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_swigregister = _HLRBRep.HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_swigregister
HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter_swigregister(HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter)

class HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        * Calculates the distance with a close point. The close point is defined by the parameter value U0. The function F(u)=distance(P,C(u)) has an extremum when g(u)=dF/du=0. The algorithm searchs a zero near the close point. TolU is used to decide to stop the iterations. At the nth iteration, the criteria is: abs(Un - Un-1) < TolU.
        	:param P:
        	:type P: gp_Pnt2d
        	:param C:
        	:type C: Standard_Address
        	:param U0:
        	:type U0: float
        	:param TolU:
        	:type TolU: float
        	:rtype: None
        * Calculates the distance with a close point. The close point is defined by the parameter value U0. The function F(u)=distance(P,C(u)) has an extremum when g(u)=dF/du=0. The algorithm searchs a zero near the close point. Zeros are searched between Umin et Usup. TolU is used to decide to stop the iterations. At the nth iteration, the criteria is: abs(Un - Un-1) < TolU.
        	:param P:
        	:type P: gp_Pnt2d
        	:param C:
        	:type C: Standard_Address
        	:param U0:
        	:type U0: float
        	:param Umin:
        	:type Umin: float
        	:param Usup:
        	:type Usup: float
        	:param TolU:
        	:type TolU: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter(*args))

    def Initialize(self, *args) -> "void":
        """
        * sets the fields of the algorithm.
        	:param C:
        	:type C: Standard_Address
        	:param Umin:
        	:type Umin: float
        	:param Usup:
        	:type Usup: float
        	:param TolU:
        	:type TolU: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_Initialize(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the distance is found.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_IsDone(self, *args)


    def IsMin(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the extremum distance is a minimum.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_IsMin(self, *args)


    def Perform(self, *args) -> "void":
        """
        * the algorithm is done with the point P. An exception is raised if the fields have not been initialized.
        	:param P:
        	:type P: gp_Pnt2d
        	:param U0:
        	:type U0: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_Perform(self, *args)


    def Point(self, *args) -> "Extrema_POnCurv2d const &":
        """
        * Returns the point of the extremum distance.
        	:rtype: Extrema_POnCurv2d
        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_Point(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        * Returns the value of the extremum square distance.
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_SquareDistance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter.Initialize = new_instancemethod(_HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_Initialize, None, HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter.IsDone = new_instancemethod(_HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_IsDone, None, HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter.IsMin = new_instancemethod(_HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_IsMin, None, HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter.Perform = new_instancemethod(_HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_Perform, None, HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter.Point = new_instancemethod(_HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_Point, None, HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter.SquareDistance = new_instancemethod(_HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_SquareDistance, None, HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter)
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_swigregister = _HLRBRep.HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_swigregister
HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter_swigregister(HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter)

class HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter(OCC.Core.Intf.Intf_Polygon2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ApproxParamOnCurve(self, *args) -> "Standard_Real":
        """
        * Give an approximation of the parameter on the curve according to the discretization of the Curve.
        	:param Index:
        	:type Index: int
        	:param ParamOnLine:
        	:type ParamOnLine: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_ApproxParamOnCurve(self, *args)


    def AutoIntersectionIsPossible(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_AutoIntersectionIsPossible(self, *args)


    def CalculRegion(self, *args) -> "Standard_Integer":
        """
        :param x:
        	:type x: float
        	:param y:
        	:type y: float
        	:param x1:
        	:type x1: float
        	:param x2:
        	:type x2: float
        	:param y1:
        	:type y1: float
        	:param y2:
        	:type y2: float
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_CalculRegion(self, *args)


    def Closed(self, *args) -> "Standard_Boolean":
        """
        :param clos:
        	:type clos: bool
        	:rtype: None
        * Returns True if the polyline is closed.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_Closed(self, *args)


    def ComputeWithBox(self, *args) -> "void":
        """
        * The current polygon is modified if most of the points of the polygon are are outside the box <OtherBox>. In this situation, bounds are computed to build a polygon inside or near the OtherBox.
        	:param Curve:
        	:type Curve: Standard_Address
        	:param OtherBox:
        	:type OtherBox: Bnd_Box2d
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_ComputeWithBox(self, *args)


    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_Dump(self, *args)


    def __init__(self, *args):
        """
        * Compute a polygon on the domain of the curve.
        	:param Curve:
        	:type Curve: Standard_Address
        	:param NbPnt:
        	:type NbPnt: int
        	:param Domain:
        	:type Domain: IntRes2d_Domain
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter(*args))

    def InfParameter(self, *args) -> "Standard_Real":
        """
        * Returns the parameter (On the curve) of the first point of the Polygon
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_InfParameter(self, *args)


    def SetDeflectionOverEstimation(self, *args) -> "void":
        """
        :param x:
        	:type x: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_SetDeflectionOverEstimation(self, *args)


    def SupParameter(self, *args) -> "Standard_Real":
        """
        * Returns the parameter (On the curve) of the last point of the Polygon
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_SupParameter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter.ApproxParamOnCurve = new_instancemethod(_HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_ApproxParamOnCurve, None, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter.AutoIntersectionIsPossible = new_instancemethod(_HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_AutoIntersectionIsPossible, None, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter.CalculRegion = new_instancemethod(_HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_CalculRegion, None, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter.Closed = new_instancemethod(_HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_Closed, None, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter.ComputeWithBox = new_instancemethod(_HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_ComputeWithBox, None, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter.Dump = new_instancemethod(_HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_Dump, None, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter.InfParameter = new_instancemethod(_HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_InfParameter, None, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter.SetDeflectionOverEstimation = new_instancemethod(_HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_SetDeflectionOverEstimation, None, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter.SupParameter = new_instancemethod(_HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_SupParameter, None, HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_swigregister = _HLRBRep.HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_swigregister
HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter_swigregister(HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter)

class HLRBRep_ThePolygonOfInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ApproxParamOnCurve(self, *args) -> "Standard_Real":
        """
        * Give an approximation of the parameter on the curve according to the discretization of the Curve.
        	:param Index:
        	:type Index: int
        	:param ParamOnLine:
        	:type ParamOnLine: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_ApproxParamOnCurve(self, *args)


    def BeginOfSeg(self, *args) -> "gp_Pnt const":
        """
        * Give the point of range Index in the Polygon.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_BeginOfSeg(self, *args)


    def Bounding(self, *args) -> "Bnd_Box const &":
        """
        * Give the bounding box of the polygon.
        	:rtype: Bnd_Box
        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_Bounding(self, *args)


    def Closed(self, *args) -> "Standard_Boolean":
        """
        :param clos:
        	:type clos: bool
        	:rtype: None
        :rtype: bool
        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_Closed(self, *args)


    def DeflectionOverEstimation(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_DeflectionOverEstimation(self, *args)


    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_Dump(self, *args)


    def EndOfSeg(self, *args) -> "gp_Pnt const":
        """
        * Give the point of range Index in the Polygon.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_EndOfSeg(self, *args)


    def __init__(self, *args):
        """
        :param Curve:
        	:type Curve: gp_Lin
        	:param NbPnt:
        	:type NbPnt: int
        	:rtype: None
        :param Curve:
        	:type Curve: gp_Lin
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param NbPnt:
        	:type NbPnt: int
        	:rtype: None
        :param Curve:
        	:type Curve: gp_Lin
        	:param Upars:
        	:type Upars: TColStd_Array1OfReal
        	:rtype: None
        """
        _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_swiginit(self, _HLRBRep.new_HLRBRep_ThePolygonOfInterCSurf(*args))

    def InfParameter(self, *args) -> "Standard_Real":
        """
        * Returns the parameter (On the curve) of the first point of the Polygon
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_InfParameter(self, *args)


    def NbSegments(self, *args) -> "Standard_Integer":
        """
        * Give the number of Segments in the polyline.
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_NbSegments(self, *args)


    def SetDeflectionOverEstimation(self, *args) -> "void":
        """
        :param x:
        	:type x: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_SetDeflectionOverEstimation(self, *args)


    def SupParameter(self, *args) -> "Standard_Real":
        """
        * Returns the parameter (On the curve) of the last point of the Polygon
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_SupParameter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ThePolygonOfInterCSurf
HLRBRep_ThePolygonOfInterCSurf.ApproxParamOnCurve = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_ApproxParamOnCurve, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.BeginOfSeg = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_BeginOfSeg, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.Bounding = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_Bounding, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.Closed = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_Closed, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.DeflectionOverEstimation = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_DeflectionOverEstimation, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.Dump = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_Dump, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.EndOfSeg = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_EndOfSeg, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.InfParameter = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_InfParameter, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.NbSegments = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_NbSegments, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.SetDeflectionOverEstimation = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_SetDeflectionOverEstimation, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf.SupParameter = new_instancemethod(_HLRBRep.HLRBRep_ThePolygonOfInterCSurf_SupParameter, None, HLRBRep_ThePolygonOfInterCSurf)
HLRBRep_ThePolygonOfInterCSurf_swigregister = _HLRBRep.HLRBRep_ThePolygonOfInterCSurf_swigregister
HLRBRep_ThePolygonOfInterCSurf_swigregister(HLRBRep_ThePolygonOfInterCSurf)

class HLRBRep_ThePolygonToolOfInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BeginOfSeg(*args) -> "gp_Pnt const":
        """
        * Give the point of range Index in the Polygon.
        	:param thePolygon:
        	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_BeginOfSeg(*args)

    BeginOfSeg = staticmethod(BeginOfSeg)

    def Bounding(*args) -> "Bnd_Box const &":
        """
        * Give the bounding box of the polygon.
        	:param thePolygon:
        	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
        	:rtype: Bnd_Box
        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def Closed(*args) -> "Standard_Boolean":
        """
        :param thePolygon:
        	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Closed(*args)

    Closed = staticmethod(Closed)

    def DeflectionOverEstimation(*args) -> "Standard_Real":
        """
        :param thePolygon:
        	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def Dump(*args) -> "void":
        """
        :param thePolygon:
        	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
        	:rtype: void
        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Dump(*args)

    Dump = staticmethod(Dump)

    def EndOfSeg(*args) -> "gp_Pnt const":
        """
        * Give the point of range Index in the Polygon.
        	:param thePolygon:
        	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_EndOfSeg(*args)

    EndOfSeg = staticmethod(EndOfSeg)

    def NbSegments(*args) -> "Standard_Integer":
        """
        :param thePolygon:
        	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_NbSegments(*args)

    NbSegments = staticmethod(NbSegments)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_swiginit(self, _HLRBRep.new_HLRBRep_ThePolygonToolOfInterCSurf())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ThePolygonToolOfInterCSurf
HLRBRep_ThePolygonToolOfInterCSurf_swigregister = _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_swigregister
HLRBRep_ThePolygonToolOfInterCSurf_swigregister(HLRBRep_ThePolygonToolOfInterCSurf)

def HLRBRep_ThePolygonToolOfInterCSurf_BeginOfSeg(*args) -> "gp_Pnt const":
    """
    * Give the point of range Index in the Polygon.
    	:param thePolygon:
    	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
    	:param Index:
    	:type Index: int
    	:rtype: gp_Pnt
    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_BeginOfSeg(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_Bounding(*args) -> "Bnd_Box const &":
    """
    * Give the bounding box of the polygon.
    	:param thePolygon:
    	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
    	:rtype: Bnd_Box
    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Bounding(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_Closed(*args) -> "Standard_Boolean":
    """
    :param thePolygon:
    	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Closed(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_DeflectionOverEstimation(*args) -> "Standard_Real":
    """
    :param thePolygon:
    	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_DeflectionOverEstimation(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_Dump(*args) -> "void":
    """
    :param thePolygon:
    	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
    	:rtype: void
    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_Dump(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_EndOfSeg(*args) -> "gp_Pnt const":
    """
    * Give the point of range Index in the Polygon.
    	:param thePolygon:
    	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
    	:param Index:
    	:type Index: int
    	:rtype: gp_Pnt
    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_EndOfSeg(*args)

def HLRBRep_ThePolygonToolOfInterCSurf_NbSegments(*args) -> "Standard_Integer":
    """
    :param thePolygon:
    	:type thePolygon: HLRBRep_ThePolygonOfInterCSurf
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_ThePolygonToolOfInterCSurf_NbSegments(*args)

class HLRBRep_ThePolyhedronToolOfInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounding(*args) -> "Bnd_Box const &":
        """
        * Give the bounding box of the PolyhedronTool.
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: Bnd_Box
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def ComponentsBounding(*args) -> "opencascade::handle< Bnd_HArray1OfBox > const &":
        """
        * Give the array of boxes. The box <n> corresponding to the triangle <n>.
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: opencascade::handle<Bnd_HArray1OfBox>
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_ComponentsBounding(*args)

    ComponentsBounding = staticmethod(ComponentsBounding)

    def DeflectionOverEstimation(*args) -> "Standard_Real":
        """
        * Give the tolerance of the polygon.
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def Dump(*args) -> "void":
        """
        :param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: void
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Dump(*args)

    Dump = staticmethod(Dump)

    def GetBorderDeflection(*args) -> "Standard_Real":
        """
        * This method returns a border deflection of the polyhedron.
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_GetBorderDeflection(*args)

    GetBorderDeflection = staticmethod(GetBorderDeflection)

    def IsOnBound(*args) -> "Standard_Boolean":
        """
        * This method returns true if the edge based on points with indices Index1 and Index2 represents a boundary edge. It is necessary to take into account the boundary deflection for this edge.
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param Index1:
        	:type Index1: int
        	:param Index2:
        	:type Index2: int
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_IsOnBound(*args)

    IsOnBound = staticmethod(IsOnBound)

    def NbTriangles(*args) -> "Standard_Integer":
        """
        * Give the number of triangles in this polyedral surface.
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_NbTriangles(*args)

    NbTriangles = staticmethod(NbTriangles)

    def Point(*args) -> "gp_Pnt const":
        """
        * Give the point of index i in the polyedral surface.
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Point(*args)

    Point = staticmethod(Point)

    def TriConnex(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * Give the addresse Tricon of the triangle connexe to the triangle of address Triang by the edge Pivot Pedge and the third point of this connexe triangle. When we are on a free edge TriCon==0 but the function return the value of the triangle in the other side of Pivot on the free edge. Used to turn around a vertex.
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param Triang:
        	:type Triang: int
        	:param Pivot:
        	:type Pivot: int
        	:param Pedge:
        	:type Pedge: int
        	:param TriCon:
        	:type TriCon: int
        	:param OtherP:
        	:type OtherP: int
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_TriConnex(*args)

    TriConnex = staticmethod(TriConnex)

    def Triangle(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
        """
        * Give the indices of the 3 points of the triangle of address Index in the PolyhedronTool.
        	:param thePolyh:
        	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
        	:param Index:
        	:type Index: int
        	:param P1:
        	:type P1: int
        	:param P2:
        	:type P2: int
        	:param P3:
        	:type P3: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Triangle(*args)

    Triangle = staticmethod(Triangle)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_swiginit(self, _HLRBRep.new_HLRBRep_ThePolyhedronToolOfInterCSurf())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_ThePolyhedronToolOfInterCSurf
HLRBRep_ThePolyhedronToolOfInterCSurf_swigregister = _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_swigregister
HLRBRep_ThePolyhedronToolOfInterCSurf_swigregister(HLRBRep_ThePolyhedronToolOfInterCSurf)

def HLRBRep_ThePolyhedronToolOfInterCSurf_Bounding(*args) -> "Bnd_Box const &":
    """
    * Give the bounding box of the PolyhedronTool.
    	:param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:rtype: Bnd_Box
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Bounding(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_ComponentsBounding(*args) -> "opencascade::handle< Bnd_HArray1OfBox > const &":
    """
    * Give the array of boxes. The box <n> corresponding to the triangle <n>.
    	:param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:rtype: opencascade::handle<Bnd_HArray1OfBox>
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_ComponentsBounding(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_DeflectionOverEstimation(*args) -> "Standard_Real":
    """
    * Give the tolerance of the polygon.
    	:param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_DeflectionOverEstimation(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_Dump(*args) -> "void":
    """
    :param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:rtype: void
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Dump(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_GetBorderDeflection(*args) -> "Standard_Real":
    """
    * This method returns a border deflection of the polyhedron.
    	:param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_GetBorderDeflection(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_IsOnBound(*args) -> "Standard_Boolean":
    """
    * This method returns true if the edge based on points with indices Index1 and Index2 represents a boundary edge. It is necessary to take into account the boundary deflection for this edge.
    	:param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:param Index1:
    	:type Index1: int
    	:param Index2:
    	:type Index2: int
    	:rtype: bool
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_IsOnBound(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_NbTriangles(*args) -> "Standard_Integer":
    """
    * Give the number of triangles in this polyedral surface.
    	:param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_NbTriangles(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_Point(*args) -> "gp_Pnt const":
    """
    * Give the point of index i in the polyedral surface.
    	:param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:param Index:
    	:type Index: int
    	:rtype: gp_Pnt
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Point(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_TriConnex(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * Give the addresse Tricon of the triangle connexe to the triangle of address Triang by the edge Pivot Pedge and the third point of this connexe triangle. When we are on a free edge TriCon==0 but the function return the value of the triangle in the other side of Pivot on the free edge. Used to turn around a vertex.
    	:param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:param Triang:
    	:type Triang: int
    	:param Pivot:
    	:type Pivot: int
    	:param Pedge:
    	:type Pedge: int
    	:param TriCon:
    	:type TriCon: int
    	:param OtherP:
    	:type OtherP: int
    	:rtype: int
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_TriConnex(*args)

def HLRBRep_ThePolyhedronToolOfInterCSurf_Triangle(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
    """
    * Give the indices of the 3 points of the triangle of address Index in the PolyhedronTool.
    	:param thePolyh:
    	:type thePolyh: HLRBRep_ThePolyhedronOfInterCSurf
    	:param Index:
    	:type Index: int
    	:param P1:
    	:type P1: int
    	:param P2:
    	:type P2: int
    	:param P3:
    	:type P3: int
    	:rtype: None
    """
    return _HLRBRep.HLRBRep_ThePolyhedronToolOfInterCSurf_Triangle(*args)

class HLRBRep_TheProjPCurOfCInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FindParameter(*args) -> "Standard_Real":
        """
        * Returns the parameter V of the point on the parametric curve corresponding to the Point Pnt. The Correspondance between Pnt and the point P(V) on the parametric curve must be coherent with the way of determination of the signed distance between a point and the implicit curve. Tol is the tolerance on the distance between a point and the parametrised curve. In that case, no bounds are given. The research of the rigth parameter has to be made on the natural parametric domain of the curve.
        	:param C:
        	:type C: Standard_Address
        	:param Pnt:
        	:type Pnt: gp_Pnt2d
        	:param Tol:
        	:type Tol: float
        	:rtype: float
        * Returns the parameter V of the point on the parametric curve corresponding to the Point Pnt. The Correspondance between Pnt and the point P(V) on the parametric curve must be coherent with the way of determination of the signed distance between a point and the implicit curve. Tol is the tolerance on the distance between a point and the parametrised curve. LowParameter and HighParameter give the boundaries of the interval in wich the parameter certainly lies. These parameters are given to implement a more efficient algoritm. So, it is not necessary to check that the returned value verifies LowParameter <= Value <= HighParameter.
        	:param C:
        	:type C: Standard_Address
        	:param Pnt:
        	:type Pnt: gp_Pnt2d
        	:param LowParameter:
        	:type LowParameter: float
        	:param HighParameter:
        	:type HighParameter: float
        	:param Tol:
        	:type Tol: float
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_TheProjPCurOfCInter_FindParameter(*args)

    FindParameter = staticmethod(FindParameter)

    __repr__ = _dumps_object


    def __init__(self):
        _HLRBRep.HLRBRep_TheProjPCurOfCInter_swiginit(self, _HLRBRep.new_HLRBRep_TheProjPCurOfCInter())
    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheProjPCurOfCInter
HLRBRep_TheProjPCurOfCInter_swigregister = _HLRBRep.HLRBRep_TheProjPCurOfCInter_swigregister
HLRBRep_TheProjPCurOfCInter_swigregister(HLRBRep_TheProjPCurOfCInter)

def HLRBRep_TheProjPCurOfCInter_FindParameter(*args) -> "Standard_Real":
    """
    * Returns the parameter V of the point on the parametric curve corresponding to the Point Pnt. The Correspondance between Pnt and the point P(V) on the parametric curve must be coherent with the way of determination of the signed distance between a point and the implicit curve. Tol is the tolerance on the distance between a point and the parametrised curve. In that case, no bounds are given. The research of the rigth parameter has to be made on the natural parametric domain of the curve.
    	:param C:
    	:type C: Standard_Address
    	:param Pnt:
    	:type Pnt: gp_Pnt2d
    	:param Tol:
    	:type Tol: float
    	:rtype: float
    * Returns the parameter V of the point on the parametric curve corresponding to the Point Pnt. The Correspondance between Pnt and the point P(V) on the parametric curve must be coherent with the way of determination of the signed distance between a point and the implicit curve. Tol is the tolerance on the distance between a point and the parametrised curve. LowParameter and HighParameter give the boundaries of the interval in wich the parameter certainly lies. These parameters are given to implement a more efficient algoritm. So, it is not necessary to check that the returned value verifies LowParameter <= Value <= HighParameter.
    	:param C:
    	:type C: Standard_Address
    	:param Pnt:
    	:type Pnt: gp_Pnt2d
    	:param LowParameter:
    	:type LowParameter: float
    	:param HighParameter:
    	:type HighParameter: float
    	:param Tol:
    	:type Tol: float
    	:rtype: float
    """
    return _HLRBRep.HLRBRep_TheProjPCurOfCInter_FindParameter(*args)

class HLRBRep_TheQuadCurvExactInterCSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Provides the signed distance function : Q(w) and its first derivative dQ(w)/dw
        	:param S:
        	:type S: Standard_Address
        	:param C:
        	:type C: gp_Lin
        	:rtype: None
        """
        _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_swiginit(self, _HLRBRep.new_HLRBRep_TheQuadCurvExactInterCSurf(*args))

    def Intervals(self, *args) -> "void":
        """
        * U1 and U2 are the parameters of a segment on the curve.
        	:param Index:
        	:type Index: int
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_Intervals(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_IsDone(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_NbIntervals(self, *args)


    def NbRoots(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_NbRoots(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        :param Index:
        	:type Index: int
        	:rtype: float
        """
        return _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_Root(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheQuadCurvExactInterCSurf
HLRBRep_TheQuadCurvExactInterCSurf.Intervals = new_instancemethod(_HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_Intervals, None, HLRBRep_TheQuadCurvExactInterCSurf)
HLRBRep_TheQuadCurvExactInterCSurf.IsDone = new_instancemethod(_HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_IsDone, None, HLRBRep_TheQuadCurvExactInterCSurf)
HLRBRep_TheQuadCurvExactInterCSurf.NbIntervals = new_instancemethod(_HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_NbIntervals, None, HLRBRep_TheQuadCurvExactInterCSurf)
HLRBRep_TheQuadCurvExactInterCSurf.NbRoots = new_instancemethod(_HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_NbRoots, None, HLRBRep_TheQuadCurvExactInterCSurf)
HLRBRep_TheQuadCurvExactInterCSurf.Root = new_instancemethod(_HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_Root, None, HLRBRep_TheQuadCurvExactInterCSurf)
HLRBRep_TheQuadCurvExactInterCSurf_swigregister = _HLRBRep.HLRBRep_TheQuadCurvExactInterCSurf_swigregister
HLRBRep_TheQuadCurvExactInterCSurf_swigregister(HLRBRep_TheQuadCurvExactInterCSurf)

class HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf(OCC.Core.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Create the function.
        	:param Q:
        	:type Q: IntSurf_Quadric
        	:param C:
        	:type C: gp_Lin
        	:rtype: None
        """
        _HLRBRep.HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_swiginit(self, _HLRBRep.new_HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf
HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_swigregister = _HLRBRep.HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_swigregister
HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf_swigregister(HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf)

class HLRBRep_VertexList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BoundaryTransition(self, *args) -> "TopAbs_Orientation":
        """
        * Returns the transition of the current vertex relative to the boundary if it is an interference.
        	:rtype: TopAbs_Orientation
        """
        return _HLRBRep.HLRBRep_VertexList_BoundaryTransition(self, *args)


    def Current(self, *args) -> "HLRAlgo_Intersection const &":
        """
        * Returns the current vertex
        	:rtype: HLRAlgo_Intersection
        """
        return _HLRBRep.HLRBRep_VertexList_Current(self, *args)


    def __init__(self, *args):
        """
        :param T:
        	:type T: HLRBRep_EdgeInterferenceTool
        	:param I:
        	:type I: HLRAlgo_ListIteratorOfInterferenceList
        	:rtype: None
        """
        _HLRBRep.HLRBRep_VertexList_swiginit(self, _HLRBRep.new_HLRBRep_VertexList(*args))

    def IsBoundary(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the current vertex is is on the boundary of the edge.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_VertexList_IsBoundary(self, *args)


    def IsInterference(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the current vertex is an interference.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_VertexList_IsInterference(self, *args)


    def IsPeriodic(self, *args) -> "Standard_Boolean":
        """
        * Returns True when the curve is periodic.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_VertexList_IsPeriodic(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        * Returns True when there are more vertices.
        	:rtype: bool
        """
        return _HLRBRep.HLRBRep_VertexList_More(self, *args)


    def Next(self, *args) -> "void":
        """
        * Proceeds to the next vertex.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_VertexList_Next(self, *args)


    def Orientation(self, *args) -> "TopAbs_Orientation":
        """
        * Returns the orientation of the current vertex if it is on the boundary of the edge.
        	:rtype: TopAbs_Orientation
        """
        return _HLRBRep.HLRBRep_VertexList_Orientation(self, *args)


    def Transition(self, *args) -> "TopAbs_Orientation":
        """
        * Returns the transition of the current vertex if it is an interference.
        	:rtype: TopAbs_Orientation
        """
        return _HLRBRep.HLRBRep_VertexList_Transition(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_VertexList
HLRBRep_VertexList.BoundaryTransition = new_instancemethod(_HLRBRep.HLRBRep_VertexList_BoundaryTransition, None, HLRBRep_VertexList)
HLRBRep_VertexList.Current = new_instancemethod(_HLRBRep.HLRBRep_VertexList_Current, None, HLRBRep_VertexList)
HLRBRep_VertexList.IsBoundary = new_instancemethod(_HLRBRep.HLRBRep_VertexList_IsBoundary, None, HLRBRep_VertexList)
HLRBRep_VertexList.IsInterference = new_instancemethod(_HLRBRep.HLRBRep_VertexList_IsInterference, None, HLRBRep_VertexList)
HLRBRep_VertexList.IsPeriodic = new_instancemethod(_HLRBRep.HLRBRep_VertexList_IsPeriodic, None, HLRBRep_VertexList)
HLRBRep_VertexList.More = new_instancemethod(_HLRBRep.HLRBRep_VertexList_More, None, HLRBRep_VertexList)
HLRBRep_VertexList.Next = new_instancemethod(_HLRBRep.HLRBRep_VertexList_Next, None, HLRBRep_VertexList)
HLRBRep_VertexList.Orientation = new_instancemethod(_HLRBRep.HLRBRep_VertexList_Orientation, None, HLRBRep_VertexList)
HLRBRep_VertexList.Transition = new_instancemethod(_HLRBRep.HLRBRep_VertexList_Transition, None, HLRBRep_VertexList)
HLRBRep_VertexList_swigregister = _HLRBRep.HLRBRep_VertexList_swigregister
HLRBRep_VertexList_swigregister(HLRBRep_VertexList)

class HLRBRep_Algo(HLRBRep_InternalAlgo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * add the Shape <S>.
        	:param S:
        	:type S: TopoDS_Shape
        	:param SData:
        	:type SData: Standard_Transient
        	:param nbIso: default value is 0
        	:type nbIso: int
        	:rtype: None
        * Adds the shape S to this framework, and specifies the number of isoparameters nbiso desired in visualizing S. You may add as many shapes as you wish. Use the function Add once for each shape.
        	:param S:
        	:type S: TopoDS_Shape
        	:param nbIso: default value is 0
        	:type nbIso: int
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Algo_Add(self, *args)


    def __init__(self, *args):
        """
        * Constructs an empty framework for the calculation of visible and hidden lines of a shape in a projection. Use the function: - Projector to define the point of view - Add to select the shape or shapes to be visualized - Update to compute the outlines of the shape, and - Hide to compute the visible and hidden lines of the shape.
        	:rtype: None
        :param A:
        	:type A: HLRBRep_Algo
        	:rtype: None
        """
        _HLRBRep.HLRBRep_Algo_swiginit(self, _HLRBRep.new_HLRBRep_Algo(*args))

    def Index(self, *args) -> "Standard_Integer":
        """
        * return the index of the Shape <S> and return 0 if the Shape <S> is not found.
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: int
        """
        return _HLRBRep.HLRBRep_Algo_Index(self, *args)


    def OutLinedShapeNullify(self, *args) -> "void":
        """
        * nullify all the results of OutLiner from HLRTopoBRep.
        	:rtype: None
        """
        return _HLRBRep.HLRBRep_Algo_OutLinedShapeNullify(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_HLRBRep_Algo_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _HLRBRep.delete_HLRBRep_Algo
HLRBRep_Algo.Add = new_instancemethod(_HLRBRep.HLRBRep_Algo_Add, None, HLRBRep_Algo)
HLRBRep_Algo.Index = new_instancemethod(_HLRBRep.HLRBRep_Algo_Index, None, HLRBRep_Algo)
HLRBRep_Algo.OutLinedShapeNullify = new_instancemethod(_HLRBRep.HLRBRep_Algo_OutLinedShapeNullify, None, HLRBRep_Algo)
HLRBRep_Algo_swigregister = _HLRBRep.HLRBRep_Algo_swigregister
HLRBRep_Algo_swigregister(HLRBRep_Algo)



