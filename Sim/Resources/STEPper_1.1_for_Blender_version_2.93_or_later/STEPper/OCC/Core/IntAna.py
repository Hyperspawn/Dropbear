# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IntAna module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_intana.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _IntAna.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntAna')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntAna')
    _IntAna = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntAna', [dirname(__file__)])
        except ImportError:
            import _IntAna
            return _IntAna
        try:
            _mod = imp.load_module('_IntAna', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntAna = swig_import_helper()
    del swig_import_helper
else:
    import _IntAna
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntAna.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_IntAna.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_IntAna.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_IntAna.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_IntAna.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_IntAna.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_IntAna.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_IntAna.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_IntAna.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_IntAna.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_IntAna.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_IntAna.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_IntAna.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_IntAna.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_IntAna.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_IntAna.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_IntAna.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _IntAna.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _IntAna.process_exception(error, method_name, class_name)
process_exception = _IntAna.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection
IntAna_Point = _IntAna.IntAna_Point
IntAna_Line = _IntAna.IntAna_Line
IntAna_Circle = _IntAna.IntAna_Circle
IntAna_PointAndCircle = _IntAna.IntAna_PointAndCircle
IntAna_Ellipse = _IntAna.IntAna_Ellipse
IntAna_Parabola = _IntAna.IntAna_Parabola
IntAna_Hyperbola = _IntAna.IntAna_Hyperbola
IntAna_Empty = _IntAna.IntAna_Empty
IntAna_Same = _IntAna.IntAna_Same
IntAna_NoGeometricSolution = _IntAna.IntAna_NoGeometricSolution
class IntAna_ListOfCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntAna.IntAna_ListOfCurve_swiginit(self, _IntAna.new_IntAna_ListOfCurve(*args))
    __swig_destroy__ = _IntAna.delete_IntAna_ListOfCurve
IntAna_ListOfCurve.begin = new_instancemethod(_IntAna.IntAna_ListOfCurve_begin, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.end = new_instancemethod(_IntAna.IntAna_ListOfCurve_end, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.cbegin = new_instancemethod(_IntAna.IntAna_ListOfCurve_cbegin, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.cend = new_instancemethod(_IntAna.IntAna_ListOfCurve_cend, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.Size = new_instancemethod(_IntAna.IntAna_ListOfCurve_Size, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.Assign = new_instancemethod(_IntAna.IntAna_ListOfCurve_Assign, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.Set = new_instancemethod(_IntAna.IntAna_ListOfCurve_Set, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.Clear = new_instancemethod(_IntAna.IntAna_ListOfCurve_Clear, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.First = new_instancemethod(_IntAna.IntAna_ListOfCurve_First, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.Last = new_instancemethod(_IntAna.IntAna_ListOfCurve_Last, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.Append = new_instancemethod(_IntAna.IntAna_ListOfCurve_Append, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.Prepend = new_instancemethod(_IntAna.IntAna_ListOfCurve_Prepend, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.RemoveFirst = new_instancemethod(_IntAna.IntAna_ListOfCurve_RemoveFirst, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.Remove = new_instancemethod(_IntAna.IntAna_ListOfCurve_Remove, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.InsertBefore = new_instancemethod(_IntAna.IntAna_ListOfCurve_InsertBefore, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.InsertAfter = new_instancemethod(_IntAna.IntAna_ListOfCurve_InsertAfter, None, IntAna_ListOfCurve)
IntAna_ListOfCurve.Reverse = new_instancemethod(_IntAna.IntAna_ListOfCurve_Reverse, None, IntAna_ListOfCurve)
IntAna_ListOfCurve_swigregister = _IntAna.IntAna_ListOfCurve_swigregister
IntAna_ListOfCurve_swigregister(IntAna_ListOfCurve)

class IntAna_ListIteratorOfListOfCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntAna.IntAna_ListIteratorOfListOfCurve_swiginit(self, _IntAna.new_IntAna_ListIteratorOfListOfCurve(*args))
    __swig_destroy__ = _IntAna.delete_IntAna_ListIteratorOfListOfCurve
IntAna_ListIteratorOfListOfCurve.More = new_instancemethod(_IntAna.IntAna_ListIteratorOfListOfCurve_More, None, IntAna_ListIteratorOfListOfCurve)
IntAna_ListIteratorOfListOfCurve.Next = new_instancemethod(_IntAna.IntAna_ListIteratorOfListOfCurve_Next, None, IntAna_ListIteratorOfListOfCurve)
IntAna_ListIteratorOfListOfCurve.Value = new_instancemethod(_IntAna.IntAna_ListIteratorOfListOfCurve_Value, None, IntAna_ListIteratorOfListOfCurve)
IntAna_ListIteratorOfListOfCurve.ChangeValue = new_instancemethod(_IntAna.IntAna_ListIteratorOfListOfCurve_ChangeValue, None, IntAna_ListIteratorOfListOfCurve)
IntAna_ListIteratorOfListOfCurve_swigregister = _IntAna.IntAna_ListIteratorOfListOfCurve_swigregister
IntAna_ListIteratorOfListOfCurve_swigregister(IntAna_ListIteratorOfListOfCurve)

class IntAna_Curve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def D1u(self, *args) -> "Standard_Boolean":
        """
        * Returns the point and the first derivative at parameter Theta on the curve.
        	:param Theta:
        	:type Theta: float
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Vec
        	:rtype: bool
        """
        return _IntAna.IntAna_Curve_D1u(self, *args)


    def Domain(self, *args) -> "void":
        """
        * Returns the paramatric domain of the curve.
        	:param theFirst:
        	:type theFirst: float
        	:param theLast:
        	:type theLast: float
        	:rtype: None
        """
        return _IntAna.IntAna_Curve_Domain(self, *args)


    def FindParameter(self, *args) -> "void":
        """
        * Tries to find the parameter of the point P on the curve. If the method returns False, the 'projection' is impossible. If the method returns True at least one parameter has been found. theParams is always sorted in ascending order.
        	:param P:
        	:type P: gp_Pnt
        	:param theParams:
        	:type theParams: TColStd_ListOfReal
        	:rtype: None
        """
        return _IntAna.IntAna_Curve_FindParameter(self, *args)


    def __init__(self, *args):
        """
        * Empty Constructor
        	:rtype: None
        """
        _IntAna.IntAna_Curve_swiginit(self, _IntAna.new_IntAna_Curve(*args))

    def IsConstant(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the function is constant.
        	:rtype: bool
        """
        return _IntAna.IntAna_Curve_IsConstant(self, *args)


    def IsFirstOpen(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the domain is open at the beginning.
        	:rtype: bool
        """
        return _IntAna.IntAna_Curve_IsFirstOpen(self, *args)


    def IsLastOpen(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the domain is open at the end.
        	:rtype: bool
        """
        return _IntAna.IntAna_Curve_IsLastOpen(self, *args)


    def IsOpen(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the curve is not infinite at the last parameter or at the first parameter of the domain.
        	:rtype: bool
        """
        return _IntAna.IntAna_Curve_IsOpen(self, *args)


    def SetConeQuadValues(self, *args) -> "void":
        """
        * Sets the parameters used to compute Points and Derivative on the curve.
        	:param Cone:
        	:type Cone: gp_Cone
        	:param Qxx:
        	:type Qxx: float
        	:param Qyy:
        	:type Qyy: float
        	:param Qzz:
        	:type Qzz: float
        	:param Qxy:
        	:type Qxy: float
        	:param Qxz:
        	:type Qxz: float
        	:param Qyz:
        	:type Qyz: float
        	:param Qx:
        	:type Qx: float
        	:param Qy:
        	:type Qy: float
        	:param Qz:
        	:type Qz: float
        	:param Q1:
        	:type Q1: float
        	:param Tol:
        	:type Tol: float
        	:param DomInf:
        	:type DomInf: float
        	:param DomSup:
        	:type DomSup: float
        	:param TwoZForATheta:
        	:type TwoZForATheta: bool
        	:param ZIsPositive:
        	:type ZIsPositive: bool
        	:rtype: None
        """
        return _IntAna.IntAna_Curve_SetConeQuadValues(self, *args)


    def SetCylinderQuadValues(self, *args) -> "void":
        """
        * Sets the parameters used to compute Points and Derivative on the curve.
        	:param Cylinder:
        	:type Cylinder: gp_Cylinder
        	:param Qxx:
        	:type Qxx: float
        	:param Qyy:
        	:type Qyy: float
        	:param Qzz:
        	:type Qzz: float
        	:param Qxy:
        	:type Qxy: float
        	:param Qxz:
        	:type Qxz: float
        	:param Qyz:
        	:type Qyz: float
        	:param Qx:
        	:type Qx: float
        	:param Qy:
        	:type Qy: float
        	:param Qz:
        	:type Qz: float
        	:param Q1:
        	:type Q1: float
        	:param Tol:
        	:type Tol: float
        	:param DomInf:
        	:type DomInf: float
        	:param DomSup:
        	:type DomSup: float
        	:param TwoZForATheta:
        	:type TwoZForATheta: bool
        	:param ZIsPositive:
        	:type ZIsPositive: bool
        	:rtype: None
        """
        return _IntAna.IntAna_Curve_SetCylinderQuadValues(self, *args)


    def SetDomain(self, *args) -> "void":
        """
        * Trims this curve
        	:param theFirst:
        	:type theFirst: float
        	:param theLast:
        	:type theLast: float
        	:rtype: None
        """
        return _IntAna.IntAna_Curve_SetDomain(self, *args)


    def SetIsFirstOpen(self, *args) -> "void":
        """
        * If flag is True, the Curve is not defined at the first parameter of its domain.
        	:param Flag:
        	:type Flag: bool
        	:rtype: None
        """
        return _IntAna.IntAna_Curve_SetIsFirstOpen(self, *args)


    def SetIsLastOpen(self, *args) -> "void":
        """
        * If flag is True, the Curve is not defined at the first parameter of its domain.
        	:param Flag:
        	:type Flag: bool
        	:rtype: None
        """
        return _IntAna.IntAna_Curve_SetIsLastOpen(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        * Returns the point at parameter Theta on the curve.
        	:param Theta:
        	:type Theta: float
        	:rtype: gp_Pnt
        """
        return _IntAna.IntAna_Curve_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntAna.delete_IntAna_Curve
IntAna_Curve.D1u = new_instancemethod(_IntAna.IntAna_Curve_D1u, None, IntAna_Curve)
IntAna_Curve.Domain = new_instancemethod(_IntAna.IntAna_Curve_Domain, None, IntAna_Curve)
IntAna_Curve.FindParameter = new_instancemethod(_IntAna.IntAna_Curve_FindParameter, None, IntAna_Curve)
IntAna_Curve.IsConstant = new_instancemethod(_IntAna.IntAna_Curve_IsConstant, None, IntAna_Curve)
IntAna_Curve.IsFirstOpen = new_instancemethod(_IntAna.IntAna_Curve_IsFirstOpen, None, IntAna_Curve)
IntAna_Curve.IsLastOpen = new_instancemethod(_IntAna.IntAna_Curve_IsLastOpen, None, IntAna_Curve)
IntAna_Curve.IsOpen = new_instancemethod(_IntAna.IntAna_Curve_IsOpen, None, IntAna_Curve)
IntAna_Curve.SetConeQuadValues = new_instancemethod(_IntAna.IntAna_Curve_SetConeQuadValues, None, IntAna_Curve)
IntAna_Curve.SetCylinderQuadValues = new_instancemethod(_IntAna.IntAna_Curve_SetCylinderQuadValues, None, IntAna_Curve)
IntAna_Curve.SetDomain = new_instancemethod(_IntAna.IntAna_Curve_SetDomain, None, IntAna_Curve)
IntAna_Curve.SetIsFirstOpen = new_instancemethod(_IntAna.IntAna_Curve_SetIsFirstOpen, None, IntAna_Curve)
IntAna_Curve.SetIsLastOpen = new_instancemethod(_IntAna.IntAna_Curve_SetIsLastOpen, None, IntAna_Curve)
IntAna_Curve.Value = new_instancemethod(_IntAna.IntAna_Curve_Value, None, IntAna_Curve)
IntAna_Curve_swigregister = _IntAna.IntAna_Curve_swigregister
IntAna_Curve_swigregister(IntAna_Curve)

class IntAna_Int3Pln(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        * Determination of the intersection point between 3 planes.
        	:param P1:
        	:type P1: gp_Pln
        	:param P2:
        	:type P2: gp_Pln
        	:param P3:
        	:type P3: gp_Pln
        	:rtype: None
        """
        _IntAna.IntAna_Int3Pln_swiginit(self, _IntAna.new_IntAna_Int3Pln(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the computation was successful.
        	:rtype: bool
        """
        return _IntAna.IntAna_Int3Pln_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there is no intersection POINT. If 2 planes are identical or parallel, IsEmpty will return True.
        	:rtype: bool
        """
        return _IntAna.IntAna_Int3Pln_IsEmpty(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Determination of the intersection point between 3 planes.
        	:param P1:
        	:type P1: gp_Pln
        	:param P2:
        	:type P2: gp_Pln
        	:param P3:
        	:type P3: gp_Pln
        	:rtype: None
        """
        return _IntAna.IntAna_Int3Pln_Perform(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        * Returns the intersection point.
        	:rtype: gp_Pnt
        """
        return _IntAna.IntAna_Int3Pln_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntAna.delete_IntAna_Int3Pln
IntAna_Int3Pln.IsDone = new_instancemethod(_IntAna.IntAna_Int3Pln_IsDone, None, IntAna_Int3Pln)
IntAna_Int3Pln.IsEmpty = new_instancemethod(_IntAna.IntAna_Int3Pln_IsEmpty, None, IntAna_Int3Pln)
IntAna_Int3Pln.Perform = new_instancemethod(_IntAna.IntAna_Int3Pln_Perform, None, IntAna_Int3Pln)
IntAna_Int3Pln.Value = new_instancemethod(_IntAna.IntAna_Int3Pln_Value, None, IntAna_Int3Pln)
IntAna_Int3Pln_swigregister = _IntAna.IntAna_Int3Pln_swigregister
IntAna_Int3Pln_swigregister(IntAna_Int3Pln)

class IntAna_IntConicQuad(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Creates the intersection between a line and a quadric.
        	:param L:
        	:type L: gp_Lin
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Creates the intersection between a circle and a quadric.
        	:param C:
        	:type C: gp_Circ
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Creates the intersection between an ellipse and a quadric.
        	:param E:
        	:type E: gp_Elips
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Creates the intersection between a parabola and a quadric.
        	:param P:
        	:type P: gp_Parab
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Creates the intersection between an hyperbola and a quadric.
        	:param H:
        	:type H: gp_Hypr
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Intersection between a line and a plane. Tolang is used to determine if the angle between two vectors is null. Tol is used to check the distance between line and plane on the distance <Len> from the origin of the line.
        	:param L:
        	:type L: gp_Lin
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:param Tol: default value is 0
        	:type Tol: float
        	:param Len: default value is 0
        	:type Len: float
        	:rtype: None
        * Intersection between a circle and a plane. Tolang is used to determine if the angle between two vectors is null. Tol is used to determine if a distance is null.
        	:param C:
        	:type C: gp_Circ
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between an ellipse and a plane. Tolang is used to determine if the angle between two vectors is null. Tol is used to determine if a distance is null.
        	:param E:
        	:type E: gp_Elips
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersection between a parabola and a plane. Tolang is used to determine if the angle between two vectors is null.
        	:param Pb:
        	:type Pb: gp_Parab
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:rtype: None
        * Intersection between an hyperbola and a plane. Tolang is used to determine if the angle between two vectors is null.
        	:param H:
        	:type H: gp_Hypr
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:rtype: None
        """
        _IntAna.IntAna_IntConicQuad_swiginit(self, _IntAna.new_IntAna_IntConicQuad(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the creation completed.
        	:rtype: bool
        """
        return _IntAna.IntAna_IntConicQuad_IsDone(self, *args)


    def IsInQuadric(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the conic is in the quadric.
        	:rtype: bool
        """
        return _IntAna.IntAna_IntConicQuad_IsInQuadric(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line is in a quadric which is parallel to the quadric.
        	:rtype: bool
        """
        return _IntAna.IntAna_IntConicQuad_IsParallel(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection point.
        	:rtype: int
        """
        return _IntAna.IntAna_IntConicQuad_NbPoints(self, *args)


    def ParamOnConic(self, *args) -> "Standard_Real":
        """
        * Returns the parameter on the line of the intersection point of range N.
        	:param N:
        	:type N: int
        	:rtype: float
        """
        return _IntAna.IntAna_IntConicQuad_ParamOnConic(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Intersects a line and a quadric.
        	:param L:
        	:type L: gp_Lin
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Intersects a circle and a quadric.
        	:param C:
        	:type C: gp_Circ
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Intersects an ellipse and a quadric.
        	:param E:
        	:type E: gp_Elips
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Intersects a parabola and a quadric.
        	:param P:
        	:type P: gp_Parab
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Intersects an hyperbola and a quadric.
        	:param H:
        	:type H: gp_Hypr
        	:param Q:
        	:type Q: IntAna_Quadric
        	:rtype: None
        * Intersects a line and a plane. Tolang is used to determine if the angle between two vectors is null. Tol is used to check the distance between line and plane on the distance <Len> from the origin of the line.
        	:param L:
        	:type L: gp_Lin
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:param Tol: default value is 0
        	:type Tol: float
        	:param Len: default value is 0
        	:type Len: float
        	:rtype: None
        * Intersects a circle and a plane. Tolang is used to determine if the angle between two vectors is null. Tol is used to determine if a distance is null.
        	:param C:
        	:type C: gp_Circ
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects an ellipse and a plane. Tolang is used to determine if the angle between two vectors is null. Tol is used to determine if a distance is null.
        	:param E:
        	:type E: gp_Elips
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects a parabola and a plane. Tolang is used to determine if the angle between two vectors is null.
        	:param Pb:
        	:type Pb: gp_Parab
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:rtype: None
        * Intersects an hyperbola and a plane. Tolang is used to determine if the angle between two vectors is null.
        	:param H:
        	:type H: gp_Hypr
        	:param P:
        	:type P: gp_Pln
        	:param Tolang:
        	:type Tolang: float
        	:rtype: None
        """
        return _IntAna.IntAna_IntConicQuad_Perform(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        * Returns the point of range N.
        	:param N:
        	:type N: int
        	:rtype: gp_Pnt
        """
        return _IntAna.IntAna_IntConicQuad_Point(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntAna.delete_IntAna_IntConicQuad
IntAna_IntConicQuad.IsDone = new_instancemethod(_IntAna.IntAna_IntConicQuad_IsDone, None, IntAna_IntConicQuad)
IntAna_IntConicQuad.IsInQuadric = new_instancemethod(_IntAna.IntAna_IntConicQuad_IsInQuadric, None, IntAna_IntConicQuad)
IntAna_IntConicQuad.IsParallel = new_instancemethod(_IntAna.IntAna_IntConicQuad_IsParallel, None, IntAna_IntConicQuad)
IntAna_IntConicQuad.NbPoints = new_instancemethod(_IntAna.IntAna_IntConicQuad_NbPoints, None, IntAna_IntConicQuad)
IntAna_IntConicQuad.ParamOnConic = new_instancemethod(_IntAna.IntAna_IntConicQuad_ParamOnConic, None, IntAna_IntConicQuad)
IntAna_IntConicQuad.Perform = new_instancemethod(_IntAna.IntAna_IntConicQuad_Perform, None, IntAna_IntConicQuad)
IntAna_IntConicQuad.Point = new_instancemethod(_IntAna.IntAna_IntConicQuad_Point, None, IntAna_IntConicQuad)
IntAna_IntConicQuad_swigregister = _IntAna.IntAna_IntConicQuad_swigregister
IntAna_IntConicQuad_swigregister(IntAna_IntConicQuad)

class IntAna_IntLinTorus(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        * Creates the intersection between a line and a torus.
        	:param L:
        	:type L: gp_Lin
        	:param T:
        	:type T: gp_Torus
        	:rtype: None
        """
        _IntAna.IntAna_IntLinTorus_swiginit(self, _IntAna.new_IntAna_IntLinTorus(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the computation was successful.
        	:rtype: bool
        """
        return _IntAna.IntAna_IntLinTorus_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection points.
        	:rtype: int
        """
        return _IntAna.IntAna_IntLinTorus_NbPoints(self, *args)


    def ParamOnLine(self, *args) -> "Standard_Real":
        """
        * Returns the parameter on the line of the intersection point of range Index.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _IntAna.IntAna_IntLinTorus_ParamOnLine(self, *args)


    def ParamOnTorus(self, *args) -> "void":
        """
        * Returns the parameters on the torus of the intersection point of range Index.
        	:param Index:
        	:type Index: int
        	:param FI:
        	:type FI: float
        	:param THETA:
        	:type THETA: float
        	:rtype: None
        """
        return _IntAna.IntAna_IntLinTorus_ParamOnTorus(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Intersects a line and a torus.
        	:param L:
        	:type L: gp_Lin
        	:param T:
        	:type T: gp_Torus
        	:rtype: None
        """
        return _IntAna.IntAna_IntLinTorus_Perform(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        * Returns the intersection point of range Index.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _IntAna.IntAna_IntLinTorus_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntAna.delete_IntAna_IntLinTorus
IntAna_IntLinTorus.IsDone = new_instancemethod(_IntAna.IntAna_IntLinTorus_IsDone, None, IntAna_IntLinTorus)
IntAna_IntLinTorus.NbPoints = new_instancemethod(_IntAna.IntAna_IntLinTorus_NbPoints, None, IntAna_IntLinTorus)
IntAna_IntLinTorus.ParamOnLine = new_instancemethod(_IntAna.IntAna_IntLinTorus_ParamOnLine, None, IntAna_IntLinTorus)
IntAna_IntLinTorus.ParamOnTorus = new_instancemethod(_IntAna.IntAna_IntLinTorus_ParamOnTorus, None, IntAna_IntLinTorus)
IntAna_IntLinTorus.Perform = new_instancemethod(_IntAna.IntAna_IntLinTorus_Perform, None, IntAna_IntLinTorus)
IntAna_IntLinTorus.Value = new_instancemethod(_IntAna.IntAna_IntLinTorus_Value, None, IntAna_IntLinTorus)
IntAna_IntLinTorus_swigregister = _IntAna.IntAna_IntLinTorus_swigregister
IntAna_IntLinTorus_swigregister(IntAna_IntLinTorus)

class IntAna_IntQuadQuad(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Curve(self, *args) -> "IntAna_Curve const &":
        """
        * Returns the curve of range N.
        	:param N:
        	:type N: int
        	:rtype: IntAna_Curve
        """
        return _IntAna.IntAna_IntQuadQuad_Curve(self, *args)


    def HasNextCurve(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the Curve I shares its last bound with another curve.
        	:param I:
        	:type I: int
        	:rtype: bool
        """
        return _IntAna.IntAna_IntQuadQuad_HasNextCurve(self, *args)


    def HasPreviousCurve(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the Curve I shares its first bound with another curve.
        	:param I:
        	:type I: int
        	:rtype: bool
        """
        return _IntAna.IntAna_IntQuadQuad_HasPreviousCurve(self, *args)


    def IdenticalElements(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the cylinder, the cone or the sphere is identical to the quadric.
        	:rtype: bool
        """
        return _IntAna.IntAna_IntQuadQuad_IdenticalElements(self, *args)


    def __init__(self, *args):
        """
        * Empty Constructor
        	:rtype: None
        * Creates the intersection between a cylinder and a quadric . Tol est a definir plus precisemment.
        	:param C:
        	:type C: gp_Cylinder
        	:param Q:
        	:type Q: IntAna_Quadric
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection between a cone and a quadric. Tol est a definir plus precisemment.
        	:param C:
        	:type C: gp_Cone
        	:param Q:
        	:type Q: IntAna_Quadric
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _IntAna.IntAna_IntQuadQuad_swiginit(self, _IntAna.new_IntAna_IntQuadQuad(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the computation was successful.
        	:rtype: bool
        """
        return _IntAna.IntAna_IntQuadQuad_IsDone(self, *args)


    def NbCurve(self, *args) -> "Standard_Integer":
        """
        * Returns the number of curves solution.
        	:rtype: int
        """
        return _IntAna.IntAna_IntQuadQuad_NbCurve(self, *args)


    def NbPnt(self, *args) -> "Standard_Integer":
        """
        * Returns the number of contact point.
        	:rtype: int
        """
        return _IntAna.IntAna_IntQuadQuad_NbPnt(self, *args)


    def NextCurve(self, *args) -> "Standard_Integer":
        """
        * If HasNextCurve(I) returns True, this function returns the Index J of the curve which has a common bound with the curve I. If theOpposite == True , then the last parameter of the curve I, and the last parameter of the curve J give the same point. Else the last parameter of the curve I and the first parameter of the curve J are the same point.
        	:param I:
        	:type I: int
        	:param theOpposite:
        	:type theOpposite: bool
        	:rtype: int
        """
        return _IntAna.IntAna_IntQuadQuad_NextCurve(self, *args)


    def Parameters(self, *args) -> "void":
        """
        * Returns the paramaters on the 'explicit quadric' (i.e the cylinder or the cone, the first argument given to the constructor) of the point of range N.
        	:param N:
        	:type N: int
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:rtype: None
        """
        return _IntAna.IntAna_IntQuadQuad_Parameters(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Intersects a cylinder and a quadric . Tol est a definir plus precisemment.
        	:param C:
        	:type C: gp_Cylinder
        	:param Q:
        	:type Q: IntAna_Quadric
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects a cone and a quadric. Tol est a definir plus precisemment.
        	:param C:
        	:type C: gp_Cone
        	:param Q:
        	:type Q: IntAna_Quadric
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntAna.IntAna_IntQuadQuad_Perform(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        * Returns the point of range N.
        	:param N:
        	:type N: int
        	:rtype: gp_Pnt
        """
        return _IntAna.IntAna_IntQuadQuad_Point(self, *args)


    def PreviousCurve(self, *args) -> "Standard_Integer":
        """
        * if HasPreviousCurve(I) returns True, this function returns the Index J of the curve which has a common bound with the curve I. If theOpposite == True , then the first parameter of the curve I, and the first parameter of the curve J give the same point. Else the first parameter of the curve I and the last parameter of the curve J are the same point.
        	:param I:
        	:type I: int
        	:param theOpposite:
        	:type theOpposite: bool
        	:rtype: int
        """
        return _IntAna.IntAna_IntQuadQuad_PreviousCurve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntAna.delete_IntAna_IntQuadQuad
IntAna_IntQuadQuad.Curve = new_instancemethod(_IntAna.IntAna_IntQuadQuad_Curve, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.HasNextCurve = new_instancemethod(_IntAna.IntAna_IntQuadQuad_HasNextCurve, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.HasPreviousCurve = new_instancemethod(_IntAna.IntAna_IntQuadQuad_HasPreviousCurve, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.IdenticalElements = new_instancemethod(_IntAna.IntAna_IntQuadQuad_IdenticalElements, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.IsDone = new_instancemethod(_IntAna.IntAna_IntQuadQuad_IsDone, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.NbCurve = new_instancemethod(_IntAna.IntAna_IntQuadQuad_NbCurve, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.NbPnt = new_instancemethod(_IntAna.IntAna_IntQuadQuad_NbPnt, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.NextCurve = new_instancemethod(_IntAna.IntAna_IntQuadQuad_NextCurve, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.Parameters = new_instancemethod(_IntAna.IntAna_IntQuadQuad_Parameters, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.Perform = new_instancemethod(_IntAna.IntAna_IntQuadQuad_Perform, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.Point = new_instancemethod(_IntAna.IntAna_IntQuadQuad_Point, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad.PreviousCurve = new_instancemethod(_IntAna.IntAna_IntQuadQuad_PreviousCurve, None, IntAna_IntQuadQuad)
IntAna_IntQuadQuad_swigregister = _IntAna.IntAna_IntQuadQuad_swigregister
IntAna_IntQuadQuad_swigregister(IntAna_IntQuadQuad)

class IntAna_QuadQuadGeo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Circle(self, *args) -> "gp_Circ":
        """
        * Returns the circle solution of range Num.
        	:param Num:
        	:type Num: int
        	:rtype: gp_Circ
        """
        return _IntAna.IntAna_QuadQuadGeo_Circle(self, *args)


    def Ellipse(self, *args) -> "gp_Elips":
        """
        * Returns the ellipse solution of range Num.
        	:param Num:
        	:type Num: int
        	:rtype: gp_Elips
        """
        return _IntAna.IntAna_QuadQuadGeo_Ellipse(self, *args)


    def HasCommonGen(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntAna.IntAna_QuadQuadGeo_HasCommonGen(self, *args)


    def Hyperbola(self, *args) -> "gp_Hypr":
        """
        * Returns the hyperbola solution of range Num.
        	:param Num:
        	:type Num: int
        	:rtype: gp_Hypr
        """
        return _IntAna.IntAna_QuadQuadGeo_Hyperbola(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * Creates the intersection between two planes. TolAng is the angular tolerance used to determine if the planes are parallel. Tol is the tolerance used to determine if the planes are identical (only when they are parallel).
        	:param P1:
        	:type P1: gp_Pln
        	:param P2:
        	:type P2: gp_Pln
        	:param TolAng:
        	:type TolAng: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection between a plane and a cylinder. TolAng is the angular tolerance used to determine if the axis of the cylinder is parallel to the plane. Tol is the tolerance used to determine if the result is a circle or an ellipse. If the maximum distance between the ellipse solution and the circle centered at the ellipse center is less than Tol, the result will be the circle. H is the height of the cylinder <Cyl>. It is used to check whether the plane and cylinder are parallel.
        	:param P:
        	:type P: gp_Pln
        	:param C:
        	:type C: gp_Cylinder
        	:param Tolang:
        	:type Tolang: float
        	:param Tol:
        	:type Tol: float
        	:param H: default value is 0
        	:type H: float
        	:rtype: None
        * Creates the intersection between a plane and a sphere.
        	:param P:
        	:type P: gp_Pln
        	:param S:
        	:type S: gp_Sphere
        	:rtype: None
        * Creates the intersection between a plane and a cone. TolAng is the angular tolerance used to determine if the axis of the cone is parallel or perpendicular to the plane, and if the generating line of the cone is parallel to the plane. Tol is the tolerance used to determine if the apex of the cone is in the plane.
        	:param P:
        	:type P: gp_Pln
        	:param C:
        	:type C: gp_Cone
        	:param Tolang:
        	:type Tolang: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection between two cylinders.
        	:param Cyl1:
        	:type Cyl1: gp_Cylinder
        	:param Cyl2:
        	:type Cyl2: gp_Cylinder
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection between a Cylinder and a Sphere.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param Sph:
        	:type Sph: gp_Sphere
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection between a Cylinder and a Cone
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param Con:
        	:type Con: gp_Cone
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection between two Spheres.
        	:param Sph1:
        	:type Sph1: gp_Sphere
        	:param Sph2:
        	:type Sph2: gp_Sphere
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection beween a Sphere and a Cone.
        	:param Sph:
        	:type Sph: gp_Sphere
        	:param Con:
        	:type Con: gp_Cone
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection beween two cones.
        	:param Con1:
        	:type Con1: gp_Cone
        	:param Con2:
        	:type Con2: gp_Cone
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection beween plane and torus.
        	:param Pln:
        	:type Pln: gp_Pln
        	:param Tor:
        	:type Tor: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection beween cylinder and torus.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param Tor:
        	:type Tor: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection beween cone and torus.
        	:param Con:
        	:type Con: gp_Cone
        	:param Tor:
        	:type Tor: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection beween sphere and torus.
        	:param Sph:
        	:type Sph: gp_Sphere
        	:param Tor:
        	:type Tor: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Creates the intersection beween two toruses.
        	:param Tor1:
        	:type Tor1: gp_Torus
        	:param Tor2:
        	:type Tor2: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _IntAna.IntAna_QuadQuadGeo_swiginit(self, _IntAna.new_IntAna_QuadQuadGeo(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if the computation was successful.
        	:rtype: bool
        """
        return _IntAna.IntAna_QuadQuadGeo_IsDone(self, *args)


    def Line(self, *args) -> "gp_Lin":
        """
        * Returns the line solution of range Num.
        	:param Num:
        	:type Num: int
        	:rtype: gp_Lin
        """
        return _IntAna.IntAna_QuadQuadGeo_Line(self, *args)


    def NbSolutions(self, *args) -> "Standard_Integer":
        """
        * Returns the number of interesections. The possible intersections are : - 1 point - 1 or 2 line(s) - 1 Point and 1 Line - 1 circle - 1 ellipse - 1 parabola - 1 or 2 hyperbola(s).
        	:rtype: int
        """
        return _IntAna.IntAna_QuadQuadGeo_NbSolutions(self, *args)


    def PChar(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _IntAna.IntAna_QuadQuadGeo_PChar(self, *args)


    def Parabola(self, *args) -> "gp_Parab":
        """
        * Returns the parabola solution of range Num.
        	:param Num:
        	:type Num: int
        	:rtype: gp_Parab
        """
        return _IntAna.IntAna_QuadQuadGeo_Parabola(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Intersects two planes. TolAng is the angular tolerance used to determine if the planes are parallel. Tol is the tolerance used to determine if the planes are identical (only when they are parallel).
        	:param P1:
        	:type P1: gp_Pln
        	:param P2:
        	:type P2: gp_Pln
        	:param TolAng:
        	:type TolAng: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects a plane and a cylinder. TolAng is the angular tolerance used to determine if the axis of the cylinder is parallel to the plane. Tol is the tolerance used to determine if the result is a circle or an ellipse. If the maximum distance between the ellipse solution and the circle centered at the ellipse center is less than Tol, the result will be the circle. H is the height of the cylinder <Cyl>. It is used to check whether the plane and cylinder are parallel.
        	:param P:
        	:type P: gp_Pln
        	:param C:
        	:type C: gp_Cylinder
        	:param Tolang:
        	:type Tolang: float
        	:param Tol:
        	:type Tol: float
        	:param H: default value is 0
        	:type H: float
        	:rtype: None
        * Intersects a plane and a sphere.
        	:param P:
        	:type P: gp_Pln
        	:param S:
        	:type S: gp_Sphere
        	:rtype: None
        * Intersects a plane and a cone. TolAng is the angular tolerance used to determine if the axis of the cone is parallel or perpendicular to the plane, and if the generating line of the cone is parallel to the plane. Tol is the tolerance used to determine if the apex of the cone is in the plane.
        	:param P:
        	:type P: gp_Pln
        	:param C:
        	:type C: gp_Cone
        	:param Tolang:
        	:type Tolang: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects two cylinders
        	:param Cyl1:
        	:type Cyl1: gp_Cylinder
        	:param Cyl2:
        	:type Cyl2: gp_Cylinder
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects a cylinder and a sphere.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param Sph:
        	:type Sph: gp_Sphere
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects a cylinder and a cone.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param Con:
        	:type Con: gp_Cone
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects a two spheres.
        	:param Sph1:
        	:type Sph1: gp_Sphere
        	:param Sph2:
        	:type Sph2: gp_Sphere
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects a sphere and a cone.
        	:param Sph:
        	:type Sph: gp_Sphere
        	:param Con:
        	:type Con: gp_Cone
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects two cones.
        	:param Con1:
        	:type Con1: gp_Cone
        	:param Con2:
        	:type Con2: gp_Cone
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects plane and torus.
        	:param Pln:
        	:type Pln: gp_Pln
        	:param Tor:
        	:type Tor: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects cylinder and torus.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param Tor:
        	:type Tor: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects cone and torus.
        	:param Con:
        	:type Con: gp_Cone
        	:param Tor:
        	:type Tor: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects sphere and torus.
        	:param Sph:
        	:type Sph: gp_Sphere
        	:param Tor:
        	:type Tor: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Intersects two toruses.
        	:param Tor1:
        	:type Tor1: gp_Torus
        	:param Tor2:
        	:type Tor2: gp_Torus
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntAna.IntAna_QuadQuadGeo_Perform(self, *args)


    def Point(self, *args) -> "gp_Pnt":
        """
        * Returns the point solution of range Num.
        	:param Num:
        	:type Num: int
        	:rtype: gp_Pnt
        """
        return _IntAna.IntAna_QuadQuadGeo_Point(self, *args)


    def TypeInter(self, *args) -> "IntAna_ResultType":
        """
        * Returns the type of intersection.
        	:rtype: IntAna_ResultType
        """
        return _IntAna.IntAna_QuadQuadGeo_TypeInter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntAna.delete_IntAna_QuadQuadGeo
IntAna_QuadQuadGeo.Circle = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_Circle, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.Ellipse = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_Ellipse, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.HasCommonGen = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_HasCommonGen, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.Hyperbola = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_Hyperbola, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.IsDone = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_IsDone, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.Line = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_Line, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.NbSolutions = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_NbSolutions, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.PChar = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_PChar, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.Parabola = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_Parabola, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.Perform = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_Perform, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.Point = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_Point, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo.TypeInter = new_instancemethod(_IntAna.IntAna_QuadQuadGeo_TypeInter, None, IntAna_QuadQuadGeo)
IntAna_QuadQuadGeo_swigregister = _IntAna.IntAna_QuadQuadGeo_swigregister
IntAna_QuadQuadGeo_swigregister(IntAna_QuadQuadGeo)

class IntAna_Quadric(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Coefficients(self, *args) -> "void":
        """
        * Returns the coefficients of the polynomial equation which define the quadric: xCXX x**2 + xCYY y**2 + xCZZ z**2 + 2 ( xCXY x y + xCXZ x z + xCYZ y z ) + 2 ( xCX x + xCY y + xCZ z ) + xCCte
        	:param xCXX:
        	:type xCXX: float
        	:param xCYY:
        	:type xCYY: float
        	:param xCZZ:
        	:type xCZZ: float
        	:param xCXY:
        	:type xCXY: float
        	:param xCXZ:
        	:type xCXZ: float
        	:param xCYZ:
        	:type xCYZ: float
        	:param xCX:
        	:type xCX: float
        	:param xCY:
        	:type xCY: float
        	:param xCZ:
        	:type xCZ: float
        	:param xCCte:
        	:type xCCte: float
        	:rtype: None
        """
        return _IntAna.IntAna_Quadric_Coefficients(self, *args)


    def __init__(self, *args):
        """
        * Empty Constructor
        	:rtype: None
        * Creates a Quadric from a Pln
        	:param P:
        	:type P: gp_Pln
        	:rtype: None
        * Creates a Quadric from a Sphere
        	:param Sph:
        	:type Sph: gp_Sphere
        	:rtype: None
        * Creates a Quadric from a Cylinder
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:rtype: None
        * Creates a Quadric from a Cone
        	:param Cone:
        	:type Cone: gp_Cone
        	:rtype: None
        """
        _IntAna.IntAna_Quadric_swiginit(self, _IntAna.new_IntAna_Quadric(*args))

    def NewCoefficients(self, *args) -> "void":
        """
        * Returns the coefficients of the polynomial equation ( written in the natural coordinates system ) in the local coordinates system defined by Axis
        	:param xCXX:
        	:type xCXX: float
        	:param xCYY:
        	:type xCYY: float
        	:param xCZZ:
        	:type xCZZ: float
        	:param xCXY:
        	:type xCXY: float
        	:param xCXZ:
        	:type xCXZ: float
        	:param xCYZ:
        	:type xCYZ: float
        	:param xCX:
        	:type xCX: float
        	:param xCY:
        	:type xCY: float
        	:param xCZ:
        	:type xCZ: float
        	:param xCCte:
        	:type xCCte: float
        	:param Axis:
        	:type Axis: gp_Ax3
        	:rtype: None
        """
        return _IntAna.IntAna_Quadric_NewCoefficients(self, *args)


    def SetQuadric(self, *args) -> "void":
        """
        * Initializes the quadric with a Pln
        	:param P:
        	:type P: gp_Pln
        	:rtype: None
        * Initialize the quadric with a Sphere
        	:param Sph:
        	:type Sph: gp_Sphere
        	:rtype: None
        * Initializes the quadric with a Cone
        	:param Con:
        	:type Con: gp_Cone
        	:rtype: None
        * Initializes the quadric with a Cylinder
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:rtype: None
        """
        return _IntAna.IntAna_Quadric_SetQuadric(self, *args)


    def SpecialPoints(self, *args) -> "NCollection_List< gp_Pnt > const":
        """
        * Returns the list of special points (with singularities)
        	:rtype: NCollection_List<gp_Pnt>
        """
        return _IntAna.IntAna_Quadric_SpecialPoints(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntAna.delete_IntAna_Quadric
IntAna_Quadric.Coefficients = new_instancemethod(_IntAna.IntAna_Quadric_Coefficients, None, IntAna_Quadric)
IntAna_Quadric.NewCoefficients = new_instancemethod(_IntAna.IntAna_Quadric_NewCoefficients, None, IntAna_Quadric)
IntAna_Quadric.SetQuadric = new_instancemethod(_IntAna.IntAna_Quadric_SetQuadric, None, IntAna_Quadric)
IntAna_Quadric.SpecialPoints = new_instancemethod(_IntAna.IntAna_Quadric_SpecialPoints, None, IntAna_Quadric)
IntAna_Quadric_swigregister = _IntAna.IntAna_Quadric_swigregister
IntAna_Quadric_swigregister(IntAna_Quadric)



