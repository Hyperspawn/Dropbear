# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IntCurveSurface module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_intcurvesurface.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _IntCurveSurface.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntCurveSurface')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntCurveSurface')
    _IntCurveSurface = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntCurveSurface', [dirname(__file__)])
        except ImportError:
            import _IntCurveSurface
            return _IntCurveSurface
        try:
            _mod = imp.load_module('_IntCurveSurface', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntCurveSurface = swig_import_helper()
    del swig_import_helper
else:
    import _IntCurveSurface
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntCurveSurface.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_IntCurveSurface.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_IntCurveSurface.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_IntCurveSurface.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_IntCurveSurface.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_IntCurveSurface.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_IntCurveSurface.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_IntCurveSurface.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_IntCurveSurface.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_IntCurveSurface.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_IntCurveSurface.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_IntCurveSurface.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_IntCurveSurface.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_IntCurveSurface.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_IntCurveSurface.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_IntCurveSurface.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_IntCurveSurface.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _IntCurveSurface.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _IntCurveSurface.process_exception(error, method_name, class_name)
process_exception = _IntCurveSurface.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
import OCC.Core.math
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.Intf
import OCC.Core.Bnd
import OCC.Core.BVH
import OCC.Core.IntSurf
IntCurveSurface_Tangent = _IntCurveSurface.IntCurveSurface_Tangent
IntCurveSurface_In = _IntCurveSurface.IntCurveSurface_In
IntCurveSurface_Out = _IntCurveSurface.IntCurveSurface_Out
class IntCurveSurface_SequenceOfSeg(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntCurveSurface.IntCurveSurface_SequenceOfSeg_swiginit(self, _IntCurveSurface.new_IntCurveSurface_SequenceOfSeg(*args))
    delNode = staticmethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_delNode)
    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_SequenceOfSeg
IntCurveSurface_SequenceOfSeg.begin = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_begin, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.end = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_end, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.cbegin = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_cbegin, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.cend = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_cend, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Size = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Size, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Length = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Length, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Lower = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Lower, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Upper = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Upper, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.IsEmpty = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_IsEmpty, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Reverse = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Reverse, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Exchange = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Exchange, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Clear = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Clear, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Assign = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Assign, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Set = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Set, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Remove = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Remove, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Append = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Append, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Prepend = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Prepend, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.InsertBefore = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_InsertBefore, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.InsertAfter = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_InsertAfter, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Split = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Split, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.First = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_First, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.ChangeFirst = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_ChangeFirst, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Last = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Last, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.ChangeLast = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_ChangeLast, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.Value = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_Value, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.ChangeValue = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_ChangeValue, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.__call__ = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg___call__, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg.SetValue = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfSeg_SetValue, None, IntCurveSurface_SequenceOfSeg)
IntCurveSurface_SequenceOfSeg_swigregister = _IntCurveSurface.IntCurveSurface_SequenceOfSeg_swigregister
IntCurveSurface_SequenceOfSeg_swigregister(IntCurveSurface_SequenceOfSeg)

def IntCurveSurface_SequenceOfSeg_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntCurveSurface.IntCurveSurface_SequenceOfSeg_delNode(theNode, theAl)
IntCurveSurface_SequenceOfSeg_delNode = _IntCurveSurface.IntCurveSurface_SequenceOfSeg_delNode

class IntCurveSurface_SequenceOfPnt(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntCurveSurface.IntCurveSurface_SequenceOfPnt_swiginit(self, _IntCurveSurface.new_IntCurveSurface_SequenceOfPnt(*args))
    delNode = staticmethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_delNode)
    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_SequenceOfPnt
IntCurveSurface_SequenceOfPnt.begin = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_begin, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.end = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_end, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.cbegin = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_cbegin, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.cend = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_cend, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Size = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Size, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Length = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Length, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Lower = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Lower, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Upper = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Upper, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.IsEmpty = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_IsEmpty, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Reverse = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Reverse, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Exchange = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Exchange, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Clear = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Clear, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Assign = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Assign, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Set = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Set, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Remove = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Remove, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Append = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Append, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Prepend = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Prepend, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.InsertBefore = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_InsertBefore, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.InsertAfter = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_InsertAfter, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Split = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Split, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.First = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_First, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.ChangeFirst = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_ChangeFirst, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Last = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Last, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.ChangeLast = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_ChangeLast, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.Value = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_Value, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.ChangeValue = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_ChangeValue, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.__call__ = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt___call__, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt.SetValue = new_instancemethod(_IntCurveSurface.IntCurveSurface_SequenceOfPnt_SetValue, None, IntCurveSurface_SequenceOfPnt)
IntCurveSurface_SequenceOfPnt_swigregister = _IntCurveSurface.IntCurveSurface_SequenceOfPnt_swigregister
IntCurveSurface_SequenceOfPnt_swigregister(IntCurveSurface_SequenceOfPnt)

def IntCurveSurface_SequenceOfPnt_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntCurveSurface.IntCurveSurface_SequenceOfPnt_delNode(theNode, theAl)
IntCurveSurface_SequenceOfPnt_delNode = _IntCurveSurface.IntCurveSurface_SequenceOfPnt_delNode

class IntCurveSurface_Intersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Dump(self, *args) -> "void":
        """
        * Dump all the fields.
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_Intersection_Dump(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns the <done> field.
        	:rtype: bool
        """
        return _IntCurveSurface.IntCurveSurface_Intersection_IsDone(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * Returns true if curve is parallel or belongs surface This case is recognized only for some pairs of analytical curves and surfaces (plane - line, ...)
        	:rtype: bool
        """
        return _IntCurveSurface.IntCurveSurface_Intersection_IsParallel(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * returns the number of IntersectionPoint if IsDone returns True. else NotDone is raised.
        	:rtype: int
        """
        return _IntCurveSurface.IntCurveSurface_Intersection_NbPoints(self, *args)


    def NbSegments(self, *args) -> "Standard_Integer":
        """
        * returns the number of IntersectionSegment if IsDone returns True. else NotDone is raised.
        	:rtype: int
        """
        return _IntCurveSurface.IntCurveSurface_Intersection_NbSegments(self, *args)


    def Point(self, *args) -> "IntCurveSurface_IntersectionPoint const &":
        """
        * returns the IntersectionPoint of range <Index> raises NotDone if the computation has failed or if the computation has not been done raises OutOfRange if Index is not in the range <1..NbPoints>
        	:param Index:
        	:type Index: int
        	:rtype: IntCurveSurface_IntersectionPoint
        """
        return _IntCurveSurface.IntCurveSurface_Intersection_Point(self, *args)


    def Segment(self, *args) -> "IntCurveSurface_IntersectionSegment const &":
        """
        * returns the IntersectionSegment of range <Index> raises NotDone if the computation has failed or if the computation has not been done raises OutOfRange if Index is not in the range <1..NbSegment>
        	:param Index:
        	:type Index: int
        	:rtype: IntCurveSurface_IntersectionSegment
        """
        return _IntCurveSurface.IntCurveSurface_Intersection_Segment(self, *args)


    __repr__ = _dumps_object

IntCurveSurface_Intersection.Dump = new_instancemethod(_IntCurveSurface.IntCurveSurface_Intersection_Dump, None, IntCurveSurface_Intersection)
IntCurveSurface_Intersection.IsDone = new_instancemethod(_IntCurveSurface.IntCurveSurface_Intersection_IsDone, None, IntCurveSurface_Intersection)
IntCurveSurface_Intersection.IsParallel = new_instancemethod(_IntCurveSurface.IntCurveSurface_Intersection_IsParallel, None, IntCurveSurface_Intersection)
IntCurveSurface_Intersection.NbPoints = new_instancemethod(_IntCurveSurface.IntCurveSurface_Intersection_NbPoints, None, IntCurveSurface_Intersection)
IntCurveSurface_Intersection.NbSegments = new_instancemethod(_IntCurveSurface.IntCurveSurface_Intersection_NbSegments, None, IntCurveSurface_Intersection)
IntCurveSurface_Intersection.Point = new_instancemethod(_IntCurveSurface.IntCurveSurface_Intersection_Point, None, IntCurveSurface_Intersection)
IntCurveSurface_Intersection.Segment = new_instancemethod(_IntCurveSurface.IntCurveSurface_Intersection_Segment, None, IntCurveSurface_Intersection)
IntCurveSurface_Intersection_swigregister = _IntCurveSurface.IntCurveSurface_Intersection_swigregister
IntCurveSurface_Intersection_swigregister(IntCurveSurface_Intersection)

class IntCurveSurface_IntersectionPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dump(self, *args) -> "void":
        """
        * Dump all the fields.
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_Dump(self, *args)


    def __init__(self, *args):
        """
        * Empty Constructor.
        	:rtype: None
        * Create an IntersectionPoint.
        	:param P:
        	:type P: gp_Pnt
        	:param USurf:
        	:type USurf: float
        	:param VSurf:
        	:type VSurf: float
        	:param UCurv:
        	:type UCurv: float
        	:param TrCurv:
        	:type TrCurv: IntCurveSurface_TransitionOnCurve
        	:rtype: None
        """
        _IntCurveSurface.IntCurveSurface_IntersectionPoint_swiginit(self, _IntCurveSurface.new_IntCurveSurface_IntersectionPoint(*args))

    def Pnt(self, *args) -> "gp_Pnt const":
        """
        * returns the geometric point.
        	:rtype: gp_Pnt
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_Pnt(self, *args)


    def SetValues(self, *args) -> "void":
        """
        * Set the fields of the current IntersectionPoint.
        	:param P:
        	:type P: gp_Pnt
        	:param USurf:
        	:type USurf: float
        	:param VSurf:
        	:type VSurf: float
        	:param UCurv:
        	:type UCurv: float
        	:param TrCurv:
        	:type TrCurv: IntCurveSurface_TransitionOnCurve
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_SetValues(self, *args)


    def Transition(self, *args) -> "IntCurveSurface_TransitionOnCurve":
        """
        * returns the Transition of the point.
        	:rtype: IntCurveSurface_TransitionOnCurve
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_Transition(self, *args)


    def U(self, *args) -> "Standard_Real":
        """
        * returns the U parameter on the surface.
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_U(self, *args)


    def V(self, *args) -> "Standard_Real":
        """
        * returns the V parameter on the surface.
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_V(self, *args)


    def Values(self, *args) -> "void":
        """
        * Get the fields of the current IntersectionPoint.
        	:param P:
        	:type P: gp_Pnt
        	:param USurf:
        	:type USurf: float
        	:param VSurf:
        	:type VSurf: float
        	:param UCurv:
        	:type UCurv: float
        	:param TrCurv:
        	:type TrCurv: IntCurveSurface_TransitionOnCurve
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_Values(self, *args)


    def W(self, *args) -> "Standard_Real":
        """
        * returns the parameter on the curve.
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_W(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_IntersectionPoint
IntCurveSurface_IntersectionPoint.Dump = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionPoint_Dump, None, IntCurveSurface_IntersectionPoint)
IntCurveSurface_IntersectionPoint.Pnt = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionPoint_Pnt, None, IntCurveSurface_IntersectionPoint)
IntCurveSurface_IntersectionPoint.SetValues = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionPoint_SetValues, None, IntCurveSurface_IntersectionPoint)
IntCurveSurface_IntersectionPoint.Transition = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionPoint_Transition, None, IntCurveSurface_IntersectionPoint)
IntCurveSurface_IntersectionPoint.U = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionPoint_U, None, IntCurveSurface_IntersectionPoint)
IntCurveSurface_IntersectionPoint.V = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionPoint_V, None, IntCurveSurface_IntersectionPoint)
IntCurveSurface_IntersectionPoint.Values = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionPoint_Values, None, IntCurveSurface_IntersectionPoint)
IntCurveSurface_IntersectionPoint.W = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionPoint_W, None, IntCurveSurface_IntersectionPoint)
IntCurveSurface_IntersectionPoint_swigregister = _IntCurveSurface.IntCurveSurface_IntersectionPoint_swigregister
IntCurveSurface_IntersectionPoint_swigregister(IntCurveSurface_IntersectionPoint)

class IntCurveSurface_IntersectionSegment(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _IntCurveSurface.IntCurveSurface_IntersectionSegment_Dump(self, *args)


    def FirstPoint(self, *args) -> "IntCurveSurface_IntersectionPoint const &":
        """
        :param P1:
        	:type P1: IntCurveSurface_IntersectionPoint
        	:rtype: None
        :rtype: IntCurveSurface_IntersectionPoint
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionSegment_FirstPoint(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param P1:
        	:type P1: IntCurveSurface_IntersectionPoint
        	:param P2:
        	:type P2: IntCurveSurface_IntersectionPoint
        	:rtype: None
        """
        _IntCurveSurface.IntCurveSurface_IntersectionSegment_swiginit(self, _IntCurveSurface.new_IntCurveSurface_IntersectionSegment(*args))

    def SecondPoint(self, *args) -> "IntCurveSurface_IntersectionPoint const &":
        """
        :param P2:
        	:type P2: IntCurveSurface_IntersectionPoint
        	:rtype: None
        :rtype: IntCurveSurface_IntersectionPoint
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionSegment_SecondPoint(self, *args)


    def SetValues(self, *args) -> "void":
        """
        :param P1:
        	:type P1: IntCurveSurface_IntersectionPoint
        	:param P2:
        	:type P2: IntCurveSurface_IntersectionPoint
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionSegment_SetValues(self, *args)


    def Values(self, *args) -> "void":
        """
        :param P1:
        	:type P1: IntCurveSurface_IntersectionPoint
        	:param P2:
        	:type P2: IntCurveSurface_IntersectionPoint
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_IntersectionSegment_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_IntersectionSegment
IntCurveSurface_IntersectionSegment.Dump = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionSegment_Dump, None, IntCurveSurface_IntersectionSegment)
IntCurveSurface_IntersectionSegment.FirstPoint = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionSegment_FirstPoint, None, IntCurveSurface_IntersectionSegment)
IntCurveSurface_IntersectionSegment.SecondPoint = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionSegment_SecondPoint, None, IntCurveSurface_IntersectionSegment)
IntCurveSurface_IntersectionSegment.SetValues = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionSegment_SetValues, None, IntCurveSurface_IntersectionSegment)
IntCurveSurface_IntersectionSegment.Values = new_instancemethod(_IntCurveSurface.IntCurveSurface_IntersectionSegment_Values, None, IntCurveSurface_IntersectionSegment)
IntCurveSurface_IntersectionSegment_swigregister = _IntCurveSurface.IntCurveSurface_IntersectionSegment_swigregister
IntCurveSurface_IntersectionSegment_swigregister(IntCurveSurface_IntersectionSegment)

class IntCurveSurface_TheCSFunctionOfHInter(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AuxillarCurve(self, *args) -> "opencascade::handle< Adaptor3d_HCurve > const &":
        """:rtype: opencascade::handle<Adaptor3d_HCurve>"""
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_AuxillarCurve(self, *args)


    def AuxillarSurface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """:rtype: opencascade::handle<Adaptor3d_HSurface>"""
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_AuxillarSurface(self, *args)


    def __init__(self, *args):
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: None
        """
        _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_swiginit(self, _IntCurveSurface.new_IntCurveSurface_TheCSFunctionOfHInter(*args))

    def Point(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_Root(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheCSFunctionOfHInter
IntCurveSurface_TheCSFunctionOfHInter.AuxillarCurve = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_AuxillarCurve, None, IntCurveSurface_TheCSFunctionOfHInter)
IntCurveSurface_TheCSFunctionOfHInter.AuxillarSurface = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_AuxillarSurface, None, IntCurveSurface_TheCSFunctionOfHInter)
IntCurveSurface_TheCSFunctionOfHInter.Point = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_Point, None, IntCurveSurface_TheCSFunctionOfHInter)
IntCurveSurface_TheCSFunctionOfHInter.Root = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_Root, None, IntCurveSurface_TheCSFunctionOfHInter)
IntCurveSurface_TheCSFunctionOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_swigregister
IntCurveSurface_TheCSFunctionOfHInter_swigregister(IntCurveSurface_TheCSFunctionOfHInter)

class IntCurveSurface_TheExactHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Function(self, *args) -> "IntCurveSurface_TheCSFunctionOfHInter &":
        """
        * return the math function which is used to compute the intersection
        	:rtype: IntCurveSurface_TheCSFunctionOfHInter
        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_Function(self, *args)


    def __init__(self, *args):
        """
        * compute the solution point with the close point MarginCoef is the coefficient for extension of UV bounds. Ex., UFirst -= MarginCoef*(ULast-UFirst)
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:param F:
        	:type F: IntCurveSurface_TheCSFunctionOfHInter
        	:param TolTangency:
        	:type TolTangency: float
        	:param MarginCoef: default value is 0.0
        	:type MarginCoef: float
        	:rtype: None
        * initialize the parameters to compute the solution
        	:param F:
        	:type F: IntCurveSurface_TheCSFunctionOfHInter
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None
        """
        _IntCurveSurface.IntCurveSurface_TheExactHInter_swiginit(self, _IntCurveSurface.new_IntCurveSurface_TheExactHInter(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the creation completed without failure.
        	:rtype: bool
        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_IsEmpty(self, *args)


    def ParameterOnCurve(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_ParameterOnCurve(self, *args)


    def ParameterOnSurface(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_ParameterOnSurface(self, *args)


    def Perform(self, *args) -> "void":
        """
        * compute the solution it's possible to write to optimize: IntImp_IntCS inter(S1,C1,Toltangency) math_FunctionSetRoot rsnld(Inter.function()) while ...{ u=... v=... w=... inter.Perform(u,v,w,rsnld) } or IntImp_IntCS inter(Toltangency) inter.SetSurface(S); math_FunctionSetRoot rsnld(Inter.function()) while ...{ C=... inter.SetCurve(C); u=... v=... w=... inter.Perform(u,v,w,rsnld) }
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:param Rsnld:
        	:type Rsnld: math_FunctionSetRoot
        	:param u0:
        	:type u0: float
        	:param v0:
        	:type v0: float
        	:param u1:
        	:type u1: float
        	:param v1:
        	:type v1: float
        	:param w0:
        	:type w0: float
        	:param w1:
        	:type w1: float
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_Perform(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        * returns the intersection point The exception NotDone is raised if IsDone is false. The exception DomainError is raised if IsEmpty is true.
        	:rtype: gp_Pnt
        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_Point(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheExactHInter
IntCurveSurface_TheExactHInter.Function = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheExactHInter_Function, None, IntCurveSurface_TheExactHInter)
IntCurveSurface_TheExactHInter.IsDone = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheExactHInter_IsDone, None, IntCurveSurface_TheExactHInter)
IntCurveSurface_TheExactHInter.IsEmpty = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheExactHInter_IsEmpty, None, IntCurveSurface_TheExactHInter)
IntCurveSurface_TheExactHInter.ParameterOnCurve = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheExactHInter_ParameterOnCurve, None, IntCurveSurface_TheExactHInter)
IntCurveSurface_TheExactHInter.ParameterOnSurface = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheExactHInter_ParameterOnSurface, None, IntCurveSurface_TheExactHInter)
IntCurveSurface_TheExactHInter.Perform = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheExactHInter_Perform, None, IntCurveSurface_TheExactHInter)
IntCurveSurface_TheExactHInter.Point = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheExactHInter_Point, None, IntCurveSurface_TheExactHInter)
IntCurveSurface_TheExactHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheExactHInter_swigregister
IntCurveSurface_TheExactHInter_swigregister(IntCurveSurface_TheExactHInter)

class IntCurveSurface_TheHCurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSpline(*args) -> "opencascade::handle< Geom_BSplineCurve >":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: opencascade::handle<Geom_BSplineCurve>
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def Bezier(*args) -> "opencascade::handle< Geom_BezierCurve >":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: opencascade::handle<Geom_BezierCurve>
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def Circle(*args) -> "gp_Circ":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: gp_Circ
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Continuity(*args) -> "GeomAbs_Shape":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: GeomAbs_Shape
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D0(*args) -> "void":
        """
        * Computes the point of parameter U on the curve.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args) -> "void":
        """
        * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Vec
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:param V3:
        	:type V3: gp_Vec
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args) -> "gp_Vec":
        """
        * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param U:
        	:type U: float
        	:param N:
        	:type N: int
        	:rtype: gp_Vec
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_DN(*args)

    DN = staticmethod(DN)

    def Ellipse(*args) -> "gp_Elips":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: gp_Elips
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def FirstParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def GetType(*args) -> "GeomAbs_CurveType":
        """
        * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: GeomAbs_CurveType
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Hyperbola(*args) -> "gp_Hypr":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: gp_Hypr
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Intervals(*args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: bool
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: bool
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def LastParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Line(*args) -> "gp_Lin":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: gp_Lin
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Line(*args)

    Line = staticmethod(Line)

    def NbIntervals(*args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def NbSamples(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:param U0:
        	:type U0: float
        	:param U1:
        	:type U1: float
        	:rtype: int
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Parabola(*args) -> "gp_Parab":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: gp_Parab
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Period(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Period(*args)

    Period = staticmethod(Period)

    def Resolution(*args) -> "Standard_Real":
        """
        * Returns the parametric resolution corresponding to the real space resolution <R3d>.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param R3d:
        	:type R3d: float
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def SamplePars(*args) -> "void":
        """
        :param C:
        	:type C: Adaptor3d_HCurve
        	:param U0:
        	:type U0: float
        	:param U1:
        	:type U1: float
        	:param Defl:
        	:type Defl: float
        	:param NbMin:
        	:type NbMin: int
        	:param Pars:
        	:type Pars: TColStd_HArray1OfReal
        	:rtype: void
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_SamplePars(*args)

    SamplePars = staticmethod(SamplePars)

    def Value(*args) -> "gp_Pnt":
        """
        * Computes the point of parameter U on the curve.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param U:
        	:type U: float
        	:rtype: gp_Pnt
        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _IntCurveSurface.IntCurveSurface_TheHCurveTool_swiginit(self, _IntCurveSurface.new_IntCurveSurface_TheHCurveTool())
    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheHCurveTool
IntCurveSurface_TheHCurveTool_swigregister = _IntCurveSurface.IntCurveSurface_TheHCurveTool_swigregister
IntCurveSurface_TheHCurveTool_swigregister(IntCurveSurface_TheHCurveTool)

def IntCurveSurface_TheHCurveTool_BSpline(*args) -> "opencascade::handle< Geom_BSplineCurve >":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: opencascade::handle<Geom_BSplineCurve>
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_BSpline(*args)

def IntCurveSurface_TheHCurveTool_Bezier(*args) -> "opencascade::handle< Geom_BezierCurve >":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: opencascade::handle<Geom_BezierCurve>
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Bezier(*args)

def IntCurveSurface_TheHCurveTool_Circle(*args) -> "gp_Circ":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: gp_Circ
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Circle(*args)

def IntCurveSurface_TheHCurveTool_Continuity(*args) -> "GeomAbs_Shape":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: GeomAbs_Shape
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Continuity(*args)

def IntCurveSurface_TheHCurveTool_D0(*args) -> "void":
    """
    * Computes the point of parameter U on the curve.
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:rtype: None
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D0(*args)

def IntCurveSurface_TheHCurveTool_D1(*args) -> "void":
    """
    * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V:
    	:type V: gp_Vec
    	:rtype: None
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D1(*args)

def IntCurveSurface_TheHCurveTool_D2(*args) -> "void":
    """
    * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:rtype: None
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D2(*args)

def IntCurveSurface_TheHCurveTool_D3(*args) -> "void":
    """
    * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt
    	:param V1:
    	:type V1: gp_Vec
    	:param V2:
    	:type V2: gp_Vec
    	:param V3:
    	:type V3: gp_Vec
    	:rtype: None
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D3(*args)

def IntCurveSurface_TheHCurveTool_DN(*args) -> "gp_Vec":
    """
    * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:param U:
    	:type U: float
    	:param N:
    	:type N: int
    	:rtype: gp_Vec
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_DN(*args)

def IntCurveSurface_TheHCurveTool_Ellipse(*args) -> "gp_Elips":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: gp_Elips
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Ellipse(*args)

def IntCurveSurface_TheHCurveTool_FirstParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: float
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_FirstParameter(*args)

def IntCurveSurface_TheHCurveTool_GetType(*args) -> "GeomAbs_CurveType":
    """
    * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: GeomAbs_CurveType
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_GetType(*args)

def IntCurveSurface_TheHCurveTool_Hyperbola(*args) -> "gp_Hypr":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: gp_Hypr
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Hyperbola(*args)

def IntCurveSurface_TheHCurveTool_Intervals(*args) -> "void":
    """
    * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:param T:
    	:type T: TColStd_Array1OfReal
    	:param S:
    	:type S: GeomAbs_Shape
    	:rtype: None
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Intervals(*args)

def IntCurveSurface_TheHCurveTool_IsClosed(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: bool
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_IsClosed(*args)

def IntCurveSurface_TheHCurveTool_IsPeriodic(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: bool
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_IsPeriodic(*args)

def IntCurveSurface_TheHCurveTool_LastParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: float
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_LastParameter(*args)

def IntCurveSurface_TheHCurveTool_Line(*args) -> "gp_Lin":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: gp_Lin
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Line(*args)

def IntCurveSurface_TheHCurveTool_NbIntervals(*args) -> "Standard_Integer":
    """
    * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:param S:
    	:type S: GeomAbs_Shape
    	:rtype: int
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_NbIntervals(*args)

def IntCurveSurface_TheHCurveTool_NbSamples(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:param U0:
    	:type U0: float
    	:param U1:
    	:type U1: float
    	:rtype: int
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_NbSamples(*args)

def IntCurveSurface_TheHCurveTool_Parabola(*args) -> "gp_Parab":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: gp_Parab
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Parabola(*args)

def IntCurveSurface_TheHCurveTool_Period(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:rtype: float
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Period(*args)

def IntCurveSurface_TheHCurveTool_Resolution(*args) -> "Standard_Real":
    """
    * Returns the parametric resolution corresponding to the real space resolution <R3d>.
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:param R3d:
    	:type R3d: float
    	:rtype: float
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Resolution(*args)

def IntCurveSurface_TheHCurveTool_SamplePars(*args) -> "void":
    """
    :param C:
    	:type C: Adaptor3d_HCurve
    	:param U0:
    	:type U0: float
    	:param U1:
    	:type U1: float
    	:param Defl:
    	:type Defl: float
    	:param NbMin:
    	:type NbMin: int
    	:param Pars:
    	:type Pars: TColStd_HArray1OfReal
    	:rtype: void
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_SamplePars(*args)

def IntCurveSurface_TheHCurveTool_Value(*args) -> "gp_Pnt":
    """
    * Computes the point of parameter U on the curve.
    	:param C:
    	:type C: Adaptor3d_HCurve
    	:param U:
    	:type U: float
    	:rtype: gp_Pnt
    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Value(*args)

class IntCurveSurface_TheInterferenceOfHInter(OCC.Core.Intf.Intf_Interference):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an empty interference between Polygon and Polyhedron.
        	:rtype: None
        * Constructs and computes an interference between the Polygon and the Polyhedron.
        	:param thePolyg:
        	:type thePolyg: IntCurveSurface_ThePolygonOfHInter
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: None
        * Constructs and computes an interference between the Straight Line and the Polyhedron.
        	:param theLin:
        	:type theLin: gp_Lin
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: None
        * Constructs and computes an interference between the Straight Lines and the Polyhedron.
        	:param theLins:
        	:type theLins: Intf_Array1OfLin
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: None
        * Constructs and computes an interference between the Polygon and the Polyhedron.
        	:param thePolyg:
        	:type thePolyg: IntCurveSurface_ThePolygonOfHInter
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Constructs and computes an interference between the Straight Line and the Polyhedron.
        	:param theLin:
        	:type theLin: gp_Lin
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Constructs and computes an interference between the Straight Lines and the Polyhedron.
        	:param theLins:
        	:type theLins: Intf_Array1OfLin
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        """
        _IntCurveSurface.IntCurveSurface_TheInterferenceOfHInter_swiginit(self, _IntCurveSurface.new_IntCurveSurface_TheInterferenceOfHInter(*args))

    def Interference(self, *args) -> "void":
        """
        * Compares the boundings between the segment of <thePolyg> and the facets of <thePolyh>.
        	:param thePolyg:
        	:type thePolyg: IntCurveSurface_ThePolygonOfHInter
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Compares the boundings between the segment of <thePolyg> and the facets of <thePolyh>.
        	:param thePolyg:
        	:type thePolyg: IntCurveSurface_ThePolygonOfHInter
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheInterferenceOfHInter_Interference(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Computes an interference between the Polygon and the Polyhedron.
        	:param thePolyg:
        	:type thePolyg: IntCurveSurface_ThePolygonOfHInter
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: None
        * Computes an interference between the Straight Line and the Polyhedron.
        	:param theLin:
        	:type theLin: gp_Lin
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: None
        * Computes an interference between the Straight Lines and the Polyhedron.
        	:param theLins:
        	:type theLins: Intf_Array1OfLin
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: None
        * Computes an interference between the Polygon and the Polyhedron.
        	:param thePolyg:
        	:type thePolyg: IntCurveSurface_ThePolygonOfHInter
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Computes an interference between the Straight Line and the Polyhedron.
        	:param theLin:
        	:type theLin: gp_Lin
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        * Computes an interference between the Straight Lines and the Polyhedron.
        	:param theLins:
        	:type theLins: Intf_Array1OfLin
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param theBoundSB:
        	:type theBoundSB: Bnd_BoundSortBox
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheInterferenceOfHInter_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheInterferenceOfHInter
IntCurveSurface_TheInterferenceOfHInter.Interference = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheInterferenceOfHInter_Interference, None, IntCurveSurface_TheInterferenceOfHInter)
IntCurveSurface_TheInterferenceOfHInter.Perform = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheInterferenceOfHInter_Perform, None, IntCurveSurface_TheInterferenceOfHInter)
IntCurveSurface_TheInterferenceOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheInterferenceOfHInter_swigregister
IntCurveSurface_TheInterferenceOfHInter_swigregister(IntCurveSurface_TheInterferenceOfHInter)

class IntCurveSurface_ThePolygonOfHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ApproxParamOnCurve(self, *args) -> "Standard_Real":
        """
        * Give an approximation of the parameter on the curve according to the discretization of the Curve.
        	:param Index:
        	:type Index: int
        	:param ParamOnLine:
        	:type ParamOnLine: float
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_ApproxParamOnCurve(self, *args)


    def BeginOfSeg(self, *args) -> "gp_Pnt const":
        """
        * Give the point of range Index in the Polygon.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_BeginOfSeg(self, *args)


    def Bounding(self, *args) -> "Bnd_Box const &":
        """
        * Give the bounding box of the polygon.
        	:rtype: Bnd_Box
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_Bounding(self, *args)


    def Closed(self, *args) -> "Standard_Boolean":
        """
        :param clos:
        	:type clos: bool
        	:rtype: None
        :rtype: bool
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_Closed(self, *args)


    def DeflectionOverEstimation(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_DeflectionOverEstimation(self, *args)


    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_Dump(self, *args)


    def EndOfSeg(self, *args) -> "gp_Pnt const":
        """
        * Give the point of range Index in the Polygon.
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_EndOfSeg(self, *args)


    def InfParameter(self, *args) -> "Standard_Real":
        """
        * Returns the parameter (On the curve) of the first point of the Polygon
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_InfParameter(self, *args)


    def __init__(self, *args):
        """
        :param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param NbPnt:
        	:type NbPnt: int
        	:rtype: None
        :param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param NbPnt:
        	:type NbPnt: int
        	:rtype: None
        :param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param Upars:
        	:type Upars: TColStd_Array1OfReal
        	:rtype: None
        """
        _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_swiginit(self, _IntCurveSurface.new_IntCurveSurface_ThePolygonOfHInter(*args))

    def NbSegments(self, *args) -> "Standard_Integer":
        """
        * Give the number of Segments in the polyline.
        	:rtype: int
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_NbSegments(self, *args)


    def SetDeflectionOverEstimation(self, *args) -> "void":
        """
        :param x:
        	:type x: float
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_SetDeflectionOverEstimation(self, *args)


    def SupParameter(self, *args) -> "Standard_Real":
        """
        * Returns the parameter (On the curve) of the last point of the Polygon
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_SupParameter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_ThePolygonOfHInter
IntCurveSurface_ThePolygonOfHInter.ApproxParamOnCurve = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_ApproxParamOnCurve, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.BeginOfSeg = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_BeginOfSeg, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.Bounding = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_Bounding, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.Closed = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_Closed, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.DeflectionOverEstimation = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_DeflectionOverEstimation, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.Dump = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_Dump, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.EndOfSeg = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_EndOfSeg, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.InfParameter = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_InfParameter, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.NbSegments = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_NbSegments, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.SetDeflectionOverEstimation = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_SetDeflectionOverEstimation, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter.SupParameter = new_instancemethod(_IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_SupParameter, None, IntCurveSurface_ThePolygonOfHInter)
IntCurveSurface_ThePolygonOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_swigregister
IntCurveSurface_ThePolygonOfHInter_swigregister(IntCurveSurface_ThePolygonOfHInter)

class IntCurveSurface_ThePolygonToolOfHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BeginOfSeg(*args) -> "gp_Pnt const":
        """
        * Give the point of range Index in the Polygon.
        	:param thePolygon:
        	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_BeginOfSeg(*args)

    BeginOfSeg = staticmethod(BeginOfSeg)

    def Bounding(*args) -> "Bnd_Box const &":
        """
        * Give the bounding box of the polygon.
        	:param thePolygon:
        	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
        	:rtype: Bnd_Box
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def Closed(*args) -> "Standard_Boolean":
        """
        :param thePolygon:
        	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
        	:rtype: bool
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Closed(*args)

    Closed = staticmethod(Closed)

    def DeflectionOverEstimation(*args) -> "Standard_Real":
        """
        :param thePolygon:
        	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def Dump(*args) -> "void":
        """
        :param thePolygon:
        	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
        	:rtype: void
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Dump(*args)

    Dump = staticmethod(Dump)

    def EndOfSeg(*args) -> "gp_Pnt const":
        """
        * Give the point of range Index in the Polygon.
        	:param thePolygon:
        	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_EndOfSeg(*args)

    EndOfSeg = staticmethod(EndOfSeg)

    def NbSegments(*args) -> "Standard_Integer":
        """
        :param thePolygon:
        	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
        	:rtype: int
        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_NbSegments(*args)

    NbSegments = staticmethod(NbSegments)

    __repr__ = _dumps_object


    def __init__(self):
        _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_swiginit(self, _IntCurveSurface.new_IntCurveSurface_ThePolygonToolOfHInter())
    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_ThePolygonToolOfHInter
IntCurveSurface_ThePolygonToolOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_swigregister
IntCurveSurface_ThePolygonToolOfHInter_swigregister(IntCurveSurface_ThePolygonToolOfHInter)

def IntCurveSurface_ThePolygonToolOfHInter_BeginOfSeg(*args) -> "gp_Pnt const":
    """
    * Give the point of range Index in the Polygon.
    	:param thePolygon:
    	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
    	:param Index:
    	:type Index: int
    	:rtype: gp_Pnt
    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_BeginOfSeg(*args)

def IntCurveSurface_ThePolygonToolOfHInter_Bounding(*args) -> "Bnd_Box const &":
    """
    * Give the bounding box of the polygon.
    	:param thePolygon:
    	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
    	:rtype: Bnd_Box
    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Bounding(*args)

def IntCurveSurface_ThePolygonToolOfHInter_Closed(*args) -> "Standard_Boolean":
    """
    :param thePolygon:
    	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
    	:rtype: bool
    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Closed(*args)

def IntCurveSurface_ThePolygonToolOfHInter_DeflectionOverEstimation(*args) -> "Standard_Real":
    """
    :param thePolygon:
    	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
    	:rtype: float
    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_DeflectionOverEstimation(*args)

def IntCurveSurface_ThePolygonToolOfHInter_Dump(*args) -> "void":
    """
    :param thePolygon:
    	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
    	:rtype: void
    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Dump(*args)

def IntCurveSurface_ThePolygonToolOfHInter_EndOfSeg(*args) -> "gp_Pnt const":
    """
    * Give the point of range Index in the Polygon.
    	:param thePolygon:
    	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
    	:param Index:
    	:type Index: int
    	:rtype: gp_Pnt
    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_EndOfSeg(*args)

def IntCurveSurface_ThePolygonToolOfHInter_NbSegments(*args) -> "Standard_Integer":
    """
    :param thePolygon:
    	:type thePolygon: IntCurveSurface_ThePolygonOfHInter
    	:rtype: int
    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_NbSegments(*args)

class IntCurveSurface_ThePolyhedronToolOfHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounding(*args) -> "Bnd_Box const &":
        """
        * Give the bounding box of the PolyhedronTool.
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: Bnd_Box
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def ComponentsBounding(*args) -> "opencascade::handle< Bnd_HArray1OfBox > const &":
        """
        * Give the array of boxes. The box <n> corresponding to the triangle <n>.
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: opencascade::handle<Bnd_HArray1OfBox>
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_ComponentsBounding(*args)

    ComponentsBounding = staticmethod(ComponentsBounding)

    def DeflectionOverEstimation(*args) -> "Standard_Real":
        """
        * Give the tolerance of the polygon.
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def Dump(*args) -> "void":
        """
        :param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: void
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Dump(*args)

    Dump = staticmethod(Dump)

    def GetBorderDeflection(*args) -> "Standard_Real":
        """
        * This method returns a border deflection of the polyhedron.
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_GetBorderDeflection(*args)

    GetBorderDeflection = staticmethod(GetBorderDeflection)

    def IsOnBound(*args) -> "Standard_Boolean":
        """
        * This method returns true if the edge based on points with indices Index1 and Index2 represents a boundary edge. It is necessary to take into account the boundary deflection for this edge.
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param Index1:
        	:type Index1: int
        	:param Index2:
        	:type Index2: int
        	:rtype: bool
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_IsOnBound(*args)

    IsOnBound = staticmethod(IsOnBound)

    def NbTriangles(*args) -> "Standard_Integer":
        """
        * Give the number of triangles in this polyedral surface.
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: int
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_NbTriangles(*args)

    NbTriangles = staticmethod(NbTriangles)

    def Point(*args) -> "gp_Pnt const":
        """
        * Give the point of index i in the polyedral surface.
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Point(*args)

    Point = staticmethod(Point)

    def TriConnex(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * Give the addresse Tricon of the triangle connexe to the triangle of address Triang by the edge Pivot Pedge and the third point of this connexe triangle. When we are on a free edge TriCon==0 but the function return the value of the triangle in the other side of Pivot on the free edge. Used to turn around a vertex.
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param Triang:
        	:type Triang: int
        	:param Pivot:
        	:type Pivot: int
        	:param Pedge:
        	:type Pedge: int
        	:param TriCon:
        	:type TriCon: int
        	:param OtherP:
        	:type OtherP: int
        	:rtype: int
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_TriConnex(*args)

    TriConnex = staticmethod(TriConnex)

    def Triangle(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
        """
        * Give the indices of the 3 points of the triangle of address Index in the PolyhedronTool.
        	:param thePolyh:
        	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
        	:param Index:
        	:type Index: int
        	:param P1:
        	:type P1: int
        	:param P2:
        	:type P2: int
        	:param P3:
        	:type P3: int
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Triangle(*args)

    Triangle = staticmethod(Triangle)

    __repr__ = _dumps_object


    def __init__(self):
        _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_swiginit(self, _IntCurveSurface.new_IntCurveSurface_ThePolyhedronToolOfHInter())
    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_ThePolyhedronToolOfHInter
IntCurveSurface_ThePolyhedronToolOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_swigregister
IntCurveSurface_ThePolyhedronToolOfHInter_swigregister(IntCurveSurface_ThePolyhedronToolOfHInter)

def IntCurveSurface_ThePolyhedronToolOfHInter_Bounding(*args) -> "Bnd_Box const &":
    """
    * Give the bounding box of the PolyhedronTool.
    	:param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:rtype: Bnd_Box
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Bounding(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_ComponentsBounding(*args) -> "opencascade::handle< Bnd_HArray1OfBox > const &":
    """
    * Give the array of boxes. The box <n> corresponding to the triangle <n>.
    	:param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:rtype: opencascade::handle<Bnd_HArray1OfBox>
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_ComponentsBounding(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_DeflectionOverEstimation(*args) -> "Standard_Real":
    """
    * Give the tolerance of the polygon.
    	:param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:rtype: float
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_DeflectionOverEstimation(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_Dump(*args) -> "void":
    """
    :param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:rtype: void
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Dump(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_GetBorderDeflection(*args) -> "Standard_Real":
    """
    * This method returns a border deflection of the polyhedron.
    	:param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:rtype: float
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_GetBorderDeflection(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_IsOnBound(*args) -> "Standard_Boolean":
    """
    * This method returns true if the edge based on points with indices Index1 and Index2 represents a boundary edge. It is necessary to take into account the boundary deflection for this edge.
    	:param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:param Index1:
    	:type Index1: int
    	:param Index2:
    	:type Index2: int
    	:rtype: bool
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_IsOnBound(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_NbTriangles(*args) -> "Standard_Integer":
    """
    * Give the number of triangles in this polyedral surface.
    	:param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:rtype: int
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_NbTriangles(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_Point(*args) -> "gp_Pnt const":
    """
    * Give the point of index i in the polyedral surface.
    	:param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:param Index:
    	:type Index: int
    	:rtype: gp_Pnt
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Point(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_TriConnex(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * Give the addresse Tricon of the triangle connexe to the triangle of address Triang by the edge Pivot Pedge and the third point of this connexe triangle. When we are on a free edge TriCon==0 but the function return the value of the triangle in the other side of Pivot on the free edge. Used to turn around a vertex.
    	:param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:param Triang:
    	:type Triang: int
    	:param Pivot:
    	:type Pivot: int
    	:param Pedge:
    	:type Pedge: int
    	:param TriCon:
    	:type TriCon: int
    	:param OtherP:
    	:type OtherP: int
    	:rtype: int
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_TriConnex(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_Triangle(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
    """
    * Give the indices of the 3 points of the triangle of address Index in the PolyhedronTool.
    	:param thePolyh:
    	:type thePolyh: IntCurveSurface_ThePolyhedronOfHInter
    	:param Index:
    	:type Index: int
    	:param P1:
    	:type P1: int
    	:param P2:
    	:type P2: int
    	:param P3:
    	:type P3: int
    	:rtype: None
    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Triangle(*args)

class IntCurveSurface_TheQuadCurvExactHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Provides the signed distance function : Q(w) and its first derivative dQ(w)/dw
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: None
        """
        _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_swiginit(self, _IntCurveSurface.new_IntCurveSurface_TheQuadCurvExactHInter(*args))

    def Intervals(self, *args) -> "void":
        """
        * U1 and U2 are the parameters of a segment on the curve.
        	:param Index:
        	:type Index: int
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_Intervals(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_IsDone(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_NbIntervals(self, *args)


    def NbRoots(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_NbRoots(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        :param Index:
        	:type Index: int
        	:rtype: float
        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_Root(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheQuadCurvExactHInter
IntCurveSurface_TheQuadCurvExactHInter.Intervals = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_Intervals, None, IntCurveSurface_TheQuadCurvExactHInter)
IntCurveSurface_TheQuadCurvExactHInter.IsDone = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_IsDone, None, IntCurveSurface_TheQuadCurvExactHInter)
IntCurveSurface_TheQuadCurvExactHInter.NbIntervals = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_NbIntervals, None, IntCurveSurface_TheQuadCurvExactHInter)
IntCurveSurface_TheQuadCurvExactHInter.NbRoots = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_NbRoots, None, IntCurveSurface_TheQuadCurvExactHInter)
IntCurveSurface_TheQuadCurvExactHInter.Root = new_instancemethod(_IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_Root, None, IntCurveSurface_TheQuadCurvExactHInter)
IntCurveSurface_TheQuadCurvExactHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_swigregister
IntCurveSurface_TheQuadCurvExactHInter_swigregister(IntCurveSurface_TheQuadCurvExactHInter)

class IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter(OCC.Core.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Create the function.
        	:param Q:
        	:type Q: IntSurf_Quadric
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: None
        """
        _IntCurveSurface.IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_swiginit(self, _IntCurveSurface.new_IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter
IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_swigregister
IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_swigregister(IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter)

class IntCurveSurface_HInter(IntCurveSurface_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Empty Constructor
        	:rtype: None
        """
        _IntCurveSurface.IntCurveSurface_HInter_swiginit(self, _IntCurveSurface.new_IntCurveSurface_HInter(*args))

    def Perform(self, *args) -> "void":
        """
        * Compute the Intersection between the curve and the surface
        	:param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param Surface:
        	:type Surface: Adaptor3d_HSurface
        	:rtype: None
        * Compute the Intersection between the curve and the surface. The Curve is already sampled and its polygon : <Polygon> is given.
        	:param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param Polygon:
        	:type Polygon: IntCurveSurface_ThePolygonOfHInter
        	:param Surface:
        	:type Surface: Adaptor3d_HSurface
        	:rtype: None
        * Compute the Intersection between the curve and the surface. The Curve is already sampled and its polygon : <Polygon> is given. The Surface is also sampled and <Polyhedron> is given.
        	:param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param ThePolygon:
        	:type ThePolygon: IntCurveSurface_ThePolygonOfHInter
        	:param Surface:
        	:type Surface: Adaptor3d_HSurface
        	:param Polyhedron:
        	:type Polyhedron: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: None
        * Compute the Intersection between the curve and the surface. The Curve is already sampled and its polygon : <Polygon> is given. The Surface is also sampled and <Polyhedron> is given.
        	:param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param ThePolygon:
        	:type ThePolygon: IntCurveSurface_ThePolygonOfHInter
        	:param Surface:
        	:type Surface: Adaptor3d_HSurface
        	:param Polyhedron:
        	:type Polyhedron: IntCurveSurface_ThePolyhedronOfHInter
        	:param BndBSB:
        	:type BndBSB: Bnd_BoundSortBox
        	:rtype: None
        * Compute the Intersection between the curve and the surface. The Surface is already sampled and its polyhedron : <Polyhedron> is given.
        	:param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param Surface:
        	:type Surface: Adaptor3d_HSurface
        	:param Polyhedron:
        	:type Polyhedron: IntCurveSurface_ThePolyhedronOfHInter
        	:rtype: None
        """
        return _IntCurveSurface.IntCurveSurface_HInter_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_HInter
IntCurveSurface_HInter.Perform = new_instancemethod(_IntCurveSurface.IntCurveSurface_HInter_Perform, None, IntCurveSurface_HInter)
IntCurveSurface_HInter_swigregister = _IntCurveSurface.IntCurveSurface_HInter_swigregister
IntCurveSurface_HInter_swigregister(IntCurveSurface_HInter)



