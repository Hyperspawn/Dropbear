# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IntPatch module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_intpatch.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _IntPatch.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntPatch')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntPatch')
    _IntPatch = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntPatch', [dirname(__file__)])
        except ImportError:
            import _IntPatch
            return _IntPatch
        try:
            _mod = imp.load_module('_IntPatch', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntPatch = swig_import_helper()
    del swig_import_helper
else:
    import _IntPatch
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntPatch.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_IntPatch.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_IntPatch.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_IntPatch.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_IntPatch.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_IntPatch.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_IntPatch.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_IntPatch.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_IntPatch.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_IntPatch.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_IntPatch.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_IntPatch.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_IntPatch.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_IntPatch.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_IntPatch.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_IntPatch.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_IntPatch.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _IntPatch.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _IntPatch.process_exception(error, method_name, class_name)
process_exception = _IntPatch.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Intf
import OCC.Core.gp
import OCC.Core.Bnd
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.TColgp
import OCC.Core.BVH
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.IntSurf
import OCC.Core.IntAna
IntPatch_SPntNone = _IntPatch.IntPatch_SPntNone
IntPatch_SPntSeamU = _IntPatch.IntPatch_SPntSeamU
IntPatch_SPntSeamV = _IntPatch.IntPatch_SPntSeamV
IntPatch_SPntSeamUV = _IntPatch.IntPatch_SPntSeamUV
IntPatch_SPntPoleSeamU = _IntPatch.IntPatch_SPntPoleSeamU
IntPatch_SPntPole = _IntPatch.IntPatch_SPntPole
IntPatch_Lin = _IntPatch.IntPatch_Lin
IntPatch_Circle = _IntPatch.IntPatch_Circle
IntPatch_Ellipse = _IntPatch.IntPatch_Ellipse
IntPatch_Parabola = _IntPatch.IntPatch_Parabola
IntPatch_Hyperbola = _IntPatch.IntPatch_Hyperbola
IntPatch_Analytic = _IntPatch.IntPatch_Analytic
IntPatch_Walking = _IntPatch.IntPatch_Walking
IntPatch_Restriction = _IntPatch.IntPatch_Restriction

def Handle_IntPatch_Line_Create() -> "opencascade::handle< IntPatch_Line >":
    return _IntPatch.Handle_IntPatch_Line_Create()
Handle_IntPatch_Line_Create = _IntPatch.Handle_IntPatch_Line_Create

def Handle_IntPatch_Line_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_Line >":
    return _IntPatch.Handle_IntPatch_Line_DownCast(t)
Handle_IntPatch_Line_DownCast = _IntPatch.Handle_IntPatch_Line_DownCast

def Handle_IntPatch_Line_IsNull(t: 'opencascade::handle< IntPatch_Line > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_Line_IsNull(t)
Handle_IntPatch_Line_IsNull = _IntPatch.Handle_IntPatch_Line_IsNull

def Handle_IntPatch_TheIWLineOfTheIWalking_Create() -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking >":
    return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Create()
Handle_IntPatch_TheIWLineOfTheIWalking_Create = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Create

def Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking >":
    return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(t)
Handle_IntPatch_TheIWLineOfTheIWalking_DownCast = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast

def Handle_IntPatch_TheIWLineOfTheIWalking_IsNull(t: 'opencascade::handle< IntPatch_TheIWLineOfTheIWalking > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsNull(t)
Handle_IntPatch_TheIWLineOfTheIWalking_IsNull = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsNull

def Handle_IntPatch_ALine_Create() -> "opencascade::handle< IntPatch_ALine >":
    return _IntPatch.Handle_IntPatch_ALine_Create()
Handle_IntPatch_ALine_Create = _IntPatch.Handle_IntPatch_ALine_Create

def Handle_IntPatch_ALine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_ALine >":
    return _IntPatch.Handle_IntPatch_ALine_DownCast(t)
Handle_IntPatch_ALine_DownCast = _IntPatch.Handle_IntPatch_ALine_DownCast

def Handle_IntPatch_ALine_IsNull(t: 'opencascade::handle< IntPatch_ALine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_ALine_IsNull(t)
Handle_IntPatch_ALine_IsNull = _IntPatch.Handle_IntPatch_ALine_IsNull

def Handle_IntPatch_GLine_Create() -> "opencascade::handle< IntPatch_GLine >":
    return _IntPatch.Handle_IntPatch_GLine_Create()
Handle_IntPatch_GLine_Create = _IntPatch.Handle_IntPatch_GLine_Create

def Handle_IntPatch_GLine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_GLine >":
    return _IntPatch.Handle_IntPatch_GLine_DownCast(t)
Handle_IntPatch_GLine_DownCast = _IntPatch.Handle_IntPatch_GLine_DownCast

def Handle_IntPatch_GLine_IsNull(t: 'opencascade::handle< IntPatch_GLine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_GLine_IsNull(t)
Handle_IntPatch_GLine_IsNull = _IntPatch.Handle_IntPatch_GLine_IsNull

def Handle_IntPatch_PointLine_Create() -> "opencascade::handle< IntPatch_PointLine >":
    return _IntPatch.Handle_IntPatch_PointLine_Create()
Handle_IntPatch_PointLine_Create = _IntPatch.Handle_IntPatch_PointLine_Create

def Handle_IntPatch_PointLine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_PointLine >":
    return _IntPatch.Handle_IntPatch_PointLine_DownCast(t)
Handle_IntPatch_PointLine_DownCast = _IntPatch.Handle_IntPatch_PointLine_DownCast

def Handle_IntPatch_PointLine_IsNull(t: 'opencascade::handle< IntPatch_PointLine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_PointLine_IsNull(t)
Handle_IntPatch_PointLine_IsNull = _IntPatch.Handle_IntPatch_PointLine_IsNull

def Handle_IntPatch_RLine_Create() -> "opencascade::handle< IntPatch_RLine >":
    return _IntPatch.Handle_IntPatch_RLine_Create()
Handle_IntPatch_RLine_Create = _IntPatch.Handle_IntPatch_RLine_Create

def Handle_IntPatch_RLine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_RLine >":
    return _IntPatch.Handle_IntPatch_RLine_DownCast(t)
Handle_IntPatch_RLine_DownCast = _IntPatch.Handle_IntPatch_RLine_DownCast

def Handle_IntPatch_RLine_IsNull(t: 'opencascade::handle< IntPatch_RLine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_RLine_IsNull(t)
Handle_IntPatch_RLine_IsNull = _IntPatch.Handle_IntPatch_RLine_IsNull

def Handle_IntPatch_WLine_Create() -> "opencascade::handle< IntPatch_WLine >":
    return _IntPatch.Handle_IntPatch_WLine_Create()
Handle_IntPatch_WLine_Create = _IntPatch.Handle_IntPatch_WLine_Create

def Handle_IntPatch_WLine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_WLine >":
    return _IntPatch.Handle_IntPatch_WLine_DownCast(t)
Handle_IntPatch_WLine_DownCast = _IntPatch.Handle_IntPatch_WLine_DownCast

def Handle_IntPatch_WLine_IsNull(t: 'opencascade::handle< IntPatch_WLine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_WLine_IsNull(t)
Handle_IntPatch_WLine_IsNull = _IntPatch.Handle_IntPatch_WLine_IsNull
class IntPatch_SequenceOfPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.IntPatch_SequenceOfPoint_swiginit(self, _IntPatch.new_IntPatch_SequenceOfPoint(*args))
    delNode = staticmethod(_IntPatch.IntPatch_SequenceOfPoint_delNode)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfPoint
IntPatch_SequenceOfPoint.begin = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_begin, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.end = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_end, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.cbegin = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_cbegin, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.cend = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_cend, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Size = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Size, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Length = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Length, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Lower = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Lower, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Upper = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Upper, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.IsEmpty = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_IsEmpty, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Reverse = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Reverse, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Exchange = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Exchange, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Clear, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Assign, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Set, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Remove, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Append, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Prepend, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_InsertBefore, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_InsertAfter, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Split, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_First, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.ChangeFirst = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_ChangeFirst, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Last, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.ChangeLast = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_ChangeLast, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_Value, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_ChangeValue, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.__call__ = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint___call__, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfPoint_SetValue, None, IntPatch_SequenceOfPoint)
IntPatch_SequenceOfPoint_swigregister = _IntPatch.IntPatch_SequenceOfPoint_swigregister
IntPatch_SequenceOfPoint_swigregister(IntPatch_SequenceOfPoint)

def IntPatch_SequenceOfPoint_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfPoint_delNode(theNode, theAl)
IntPatch_SequenceOfPoint_delNode = _IntPatch.IntPatch_SequenceOfPoint_delNode

class IntPatch_SequenceOfPathPointOfTheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_SequenceOfPathPointOfTheSOnBounds(*args))
    delNode = staticmethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfPathPointOfTheSOnBounds
IntPatch_SequenceOfPathPointOfTheSOnBounds.begin = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_begin, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.end = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_end, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.cbegin = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_cbegin, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.cend = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_cend, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Size = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Size, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Length = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Length, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Lower = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Lower, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Upper = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Upper, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.IsEmpty = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_IsEmpty, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Reverse = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Reverse, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Exchange = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Exchange, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Clear, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Assign, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Set, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Remove, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Append, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Prepend, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_InsertBefore, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_InsertAfter, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Split, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_First, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.ChangeFirst = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_ChangeFirst, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Last, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.ChangeLast = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_ChangeLast, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Value, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_ChangeValue, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.__call__ = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds___call__, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_SetValue, None, IntPatch_SequenceOfPathPointOfTheSOnBounds)
IntPatch_SequenceOfPathPointOfTheSOnBounds_swigregister = _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_swigregister
IntPatch_SequenceOfPathPointOfTheSOnBounds_swigregister(IntPatch_SequenceOfPathPointOfTheSOnBounds)

def IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode(theNode, theAl)
IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode = _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode

class IntPatch_SequenceOfSegmentOfTheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_SequenceOfSegmentOfTheSOnBounds(*args))
    delNode = staticmethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfSegmentOfTheSOnBounds
IntPatch_SequenceOfSegmentOfTheSOnBounds.begin = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_begin, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.end = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_end, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.cbegin = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_cbegin, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.cend = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_cend, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Size = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Size, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Length = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Length, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Lower = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Lower, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Upper = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Upper, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.IsEmpty = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_IsEmpty, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Reverse = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Reverse, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Exchange = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Exchange, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Clear, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Assign, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Set, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Remove, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Append, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Prepend, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_InsertBefore, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_InsertAfter, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Split, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_First, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.ChangeFirst = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_ChangeFirst, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Last, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.ChangeLast = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_ChangeLast, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Value, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_ChangeValue, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.__call__ = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds___call__, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_SetValue, None, IntPatch_SequenceOfSegmentOfTheSOnBounds)
IntPatch_SequenceOfSegmentOfTheSOnBounds_swigregister = _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_swigregister
IntPatch_SequenceOfSegmentOfTheSOnBounds_swigregister(IntPatch_SequenceOfSegmentOfTheSOnBounds)

def IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode(theNode, theAl)
IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode = _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode

class IntPatch_SequenceOfLine(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.IntPatch_SequenceOfLine_swiginit(self, _IntPatch.new_IntPatch_SequenceOfLine(*args))
    delNode = staticmethod(_IntPatch.IntPatch_SequenceOfLine_delNode)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfLine
IntPatch_SequenceOfLine.begin = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_begin, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.end = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_end, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.cbegin = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_cbegin, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.cend = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_cend, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Size = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Size, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Length = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Length, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Lower = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Lower, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Upper = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Upper, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.IsEmpty = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_IsEmpty, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Reverse = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Reverse, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Exchange = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Exchange, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Clear, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Assign, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Set, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Remove, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Append, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Prepend, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_InsertBefore, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_InsertAfter, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Split, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_First, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.ChangeFirst = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_ChangeFirst, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Last, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.ChangeLast = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_ChangeLast, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_Value, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_ChangeValue, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.__call__ = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine___call__, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfLine_SetValue, None, IntPatch_SequenceOfLine)
IntPatch_SequenceOfLine_swigregister = _IntPatch.IntPatch_SequenceOfLine_swigregister
IntPatch_SequenceOfLine_swigregister(IntPatch_SequenceOfLine)

def IntPatch_SequenceOfLine_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfLine_delNode(theNode, theAl)
IntPatch_SequenceOfLine_delNode = _IntPatch.IntPatch_SequenceOfLine_delNode

class IntPatch_SequenceOfIWLineOfTheIWalking(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_swiginit(self, _IntPatch.new_IntPatch_SequenceOfIWLineOfTheIWalking(*args))
    delNode = staticmethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_delNode)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfIWLineOfTheIWalking
IntPatch_SequenceOfIWLineOfTheIWalking.begin = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_begin, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.end = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_end, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.cbegin = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_cbegin, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.cend = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_cend, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Size = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Size, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Length = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Length, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Lower = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Lower, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Upper = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Upper, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.IsEmpty = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_IsEmpty, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Reverse = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Reverse, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Exchange = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Exchange, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Clear = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Clear, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Assign = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Assign, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Set = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Set, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Remove = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Remove, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Append = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Append, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Prepend = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Prepend, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.InsertBefore = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_InsertBefore, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.InsertAfter = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_InsertAfter, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Split = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Split, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.First = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_First, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.ChangeFirst = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_ChangeFirst, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Last = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Last, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.ChangeLast = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_ChangeLast, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.Value = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Value, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.ChangeValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_ChangeValue, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.__call__ = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking___call__, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking.SetValue = new_instancemethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_SetValue, None, IntPatch_SequenceOfIWLineOfTheIWalking)
IntPatch_SequenceOfIWLineOfTheIWalking_swigregister = _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_swigregister
IntPatch_SequenceOfIWLineOfTheIWalking_swigregister(IntPatch_SequenceOfIWLineOfTheIWalking)

def IntPatch_SequenceOfIWLineOfTheIWalking_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_delNode(theNode, theAl)
IntPatch_SequenceOfIWLineOfTheIWalking_delNode = _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_delNode

class IntPatch_ALineToWLine(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor
        	:param theS1:
        	:type theS1: Adaptor3d_HSurface
        	:param theS2:
        	:type theS2: Adaptor3d_HSurface
        	:param theNbPoints: default value is 200
        	:type theNbPoints: int
        	:rtype: None
        """
        _IntPatch.IntPatch_ALineToWLine_swiginit(self, _IntPatch.new_IntPatch_ALineToWLine(*args))

    def MakeWLine(self, *args) -> "void":
        """
        * Converts aline to the set of Walking-lines and adds them in theLines.
        	:param aline:
        	:type aline: IntPatch_ALine
        	:param theLines:
        	:type theLines: IntPatch_SequenceOfLine
        	:rtype: None
        * Converts aline (limitted by paraminf and paramsup) to the set of Walking-lines and adds them in theLines.
        	:param aline:
        	:type aline: IntPatch_ALine
        	:param paraminf:
        	:type paraminf: float
        	:param paramsup:
        	:type paramsup: float
        	:param theLines:
        	:type theLines: IntPatch_SequenceOfLine
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALineToWLine_MakeWLine(self, *args)


    def SetTol3D(self, *args) -> "void":
        """
        :param aT:
        	:type aT: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALineToWLine_SetTol3D(self, *args)


    def SetTolOpenDomain(self, *args) -> "void":
        """
        :param aT:
        	:type aT: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALineToWLine_SetTolOpenDomain(self, *args)


    def SetTolTransition(self, *args) -> "void":
        """
        :param aT:
        	:type aT: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALineToWLine_SetTolTransition(self, *args)


    def Tol3D(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_ALineToWLine_Tol3D(self, *args)


    def TolOpenDomain(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_ALineToWLine_TolOpenDomain(self, *args)


    def TolTransition(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_ALineToWLine_TolTransition(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ALineToWLine
IntPatch_ALineToWLine.MakeWLine = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_MakeWLine, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.SetTol3D = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetTol3D, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.SetTolOpenDomain = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetTolOpenDomain, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.SetTolTransition = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_SetTolTransition, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.Tol3D = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_Tol3D, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.TolOpenDomain = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_TolOpenDomain, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine.TolTransition = new_instancemethod(_IntPatch.IntPatch_ALineToWLine_TolTransition, None, IntPatch_ALineToWLine)
IntPatch_ALineToWLine_swigregister = _IntPatch.IntPatch_ALineToWLine_swigregister
IntPatch_ALineToWLine_swigregister(IntPatch_ALineToWLine)

class IntPatch_ArcFunction(OCC.Core.math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Arc(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """:rtype: opencascade::handle<Adaptor2d_HCurve2d>"""
        return _IntPatch.IntPatch_ArcFunction_Arc(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _IntPatch.IntPatch_ArcFunction_swiginit(self, _IntPatch.new_IntPatch_ArcFunction(*args))

    def LastComputedPoint(self, *args) -> "gp_Pnt const":
        """
        * Returns the point, which has been computed while the last calling Value() method
        	:rtype: gp_Pnt
        """
        return _IntPatch.IntPatch_ArcFunction_LastComputedPoint(self, *args)


    def NbSamples(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _IntPatch.IntPatch_ArcFunction_NbSamples(self, *args)


    def Quadric(self, *args) -> "IntSurf_Quadric const &":
        """:rtype: IntSurf_Quadric"""
        return _IntPatch.IntPatch_ArcFunction_Quadric(self, *args)


    def Set(self, *args) -> "void":
        """
        :param A:
        	:type A: Adaptor2d_HCurve2d
        	:rtype: None
        :param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: None
        """
        return _IntPatch.IntPatch_ArcFunction_Set(self, *args)


    def SetQuadric(self, *args) -> "void":
        """
        :param Q:
        	:type Q: IntSurf_Quadric
        	:rtype: None
        """
        return _IntPatch.IntPatch_ArcFunction_SetQuadric(self, *args)


    def Surface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """:rtype: opencascade::handle<Adaptor3d_HSurface>"""
        return _IntPatch.IntPatch_ArcFunction_Surface(self, *args)


    def Valpoint(self, *args) -> "gp_Pnt const":
        """
        :param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _IntPatch.IntPatch_ArcFunction_Valpoint(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ArcFunction
IntPatch_ArcFunction.Arc = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Arc, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.LastComputedPoint = new_instancemethod(_IntPatch.IntPatch_ArcFunction_LastComputedPoint, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.NbSamples = new_instancemethod(_IntPatch.IntPatch_ArcFunction_NbSamples, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.Quadric = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Quadric, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.Set = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Set, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.SetQuadric = new_instancemethod(_IntPatch.IntPatch_ArcFunction_SetQuadric, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.Surface = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Surface, None, IntPatch_ArcFunction)
IntPatch_ArcFunction.Valpoint = new_instancemethod(_IntPatch.IntPatch_ArcFunction_Valpoint, None, IntPatch_ArcFunction)
IntPatch_ArcFunction_swigregister = _IntPatch.IntPatch_ArcFunction_swigregister
IntPatch_ArcFunction_swigregister(IntPatch_ArcFunction)

class IntPatch_CSFunction(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AuxillarCurve(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """:rtype: opencascade::handle<Adaptor2d_HCurve2d>"""
        return _IntPatch.IntPatch_CSFunction_AuxillarCurve(self, *args)


    def AuxillarSurface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """:rtype: opencascade::handle<Adaptor3d_HSurface>"""
        return _IntPatch.IntPatch_CSFunction_AuxillarSurface(self, *args)


    def __init__(self, *args):
        """
        * S1 is the surface on which the intersection is searched. C is a curve on the surface S2.
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:rtype: None
        """
        _IntPatch.IntPatch_CSFunction_swiginit(self, _IntPatch.new_IntPatch_CSFunction(*args))

    def Point(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _IntPatch.IntPatch_CSFunction_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_CSFunction_Root(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_CSFunction
IntPatch_CSFunction.AuxillarCurve = new_instancemethod(_IntPatch.IntPatch_CSFunction_AuxillarCurve, None, IntPatch_CSFunction)
IntPatch_CSFunction.AuxillarSurface = new_instancemethod(_IntPatch.IntPatch_CSFunction_AuxillarSurface, None, IntPatch_CSFunction)
IntPatch_CSFunction.Point = new_instancemethod(_IntPatch.IntPatch_CSFunction_Point, None, IntPatch_CSFunction)
IntPatch_CSFunction.Root = new_instancemethod(_IntPatch.IntPatch_CSFunction_Root, None, IntPatch_CSFunction)
IntPatch_CSFunction_swigregister = _IntPatch.IntPatch_CSFunction_swigregister
IntPatch_CSFunction_swigregister(IntPatch_CSFunction)

class IntPatch_CurvIntSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Function(self, *args) -> "IntPatch_CSFunction &":
        """
        * return the math function which is used to compute the intersection
        	:rtype: IntPatch_CSFunction
        """
        return _IntPatch.IntPatch_CurvIntSurf_Function(self, *args)


    def __init__(self, *args):
        """
        * compute the solution point with the close point MarginCoef is the coefficient for extension of UV bounds. Ex., UFirst -= MarginCoef*(ULast-UFirst)
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:param F:
        	:type F: IntPatch_CSFunction
        	:param TolTangency:
        	:type TolTangency: float
        	:param MarginCoef: default value is 0.0
        	:type MarginCoef: float
        	:rtype: None
        * initialize the parameters to compute the solution
        	:param F:
        	:type F: IntPatch_CSFunction
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None
        """
        _IntPatch.IntPatch_CurvIntSurf_swiginit(self, _IntPatch.new_IntPatch_CurvIntSurf(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the creation completed without failure.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_CurvIntSurf_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntPatch.IntPatch_CurvIntSurf_IsEmpty(self, *args)


    def ParameterOnCurve(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_CurvIntSurf_ParameterOnCurve(self, *args)


    def ParameterOnSurface(self, *args) -> "void":
        """
        :param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_CurvIntSurf_ParameterOnSurface(self, *args)


    def Perform(self, *args) -> "void":
        """
        * compute the solution it's possible to write to optimize: IntImp_IntCS inter(S1,C1,Toltangency) math_FunctionSetRoot rsnld(Inter.function()) while ...{ u=... v=... w=... inter.Perform(u,v,w,rsnld) } or IntImp_IntCS inter(Toltangency) inter.SetSurface(S); math_FunctionSetRoot rsnld(Inter.function()) while ...{ C=... inter.SetCurve(C); u=... v=... w=... inter.Perform(u,v,w,rsnld) }
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param W:
        	:type W: float
        	:param Rsnld:
        	:type Rsnld: math_FunctionSetRoot
        	:param u0:
        	:type u0: float
        	:param v0:
        	:type v0: float
        	:param u1:
        	:type u1: float
        	:param v1:
        	:type v1: float
        	:param w0:
        	:type w0: float
        	:param w1:
        	:type w1: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_CurvIntSurf_Perform(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        * returns the intersection point The exception NotDone is raised if IsDone is false. The exception DomainError is raised if IsEmpty is true.
        	:rtype: gp_Pnt
        """
        return _IntPatch.IntPatch_CurvIntSurf_Point(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_CurvIntSurf
IntPatch_CurvIntSurf.Function = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_Function, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.IsDone = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_IsDone, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.IsEmpty = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_IsEmpty, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.ParameterOnCurve = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_ParameterOnCurve, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.ParameterOnSurface = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_ParameterOnSurface, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.Perform = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_Perform, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf.Point = new_instancemethod(_IntPatch.IntPatch_CurvIntSurf_Point, None, IntPatch_CurvIntSurf)
IntPatch_CurvIntSurf_swigregister = _IntPatch.IntPatch_CurvIntSurf_swigregister
IntPatch_CurvIntSurf_swigregister(IntPatch_CurvIntSurf)

class IntPatch_HCurve2dTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSpline(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _IntPatch.IntPatch_HCurve2dTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def Bezier(*args) -> "opencascade::handle< Geom2d_BezierCurve >":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: opencascade::handle<Geom2d_BezierCurve>
        """
        return _IntPatch.IntPatch_HCurve2dTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def Circle(*args) -> "gp_Circ2d":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: gp_Circ2d
        """
        return _IntPatch.IntPatch_HCurve2dTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Continuity(*args) -> "GeomAbs_Shape":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: GeomAbs_Shape
        """
        return _IntPatch.IntPatch_HCurve2dTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D0(*args) -> "void":
        """
        * Computes the point of parameter U on the curve.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _IntPatch.IntPatch_HCurve2dTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args) -> "void":
        """
        * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None
        """
        return _IntPatch.IntPatch_HCurve2dTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:rtype: None
        """
        return _IntPatch.IntPatch_HCurve2dTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt2d
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:param V3:
        	:type V3: gp_Vec2d
        	:rtype: None
        """
        return _IntPatch.IntPatch_HCurve2dTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args) -> "gp_Vec2d":
        """
        * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param U:
        	:type U: float
        	:param N:
        	:type N: int
        	:rtype: gp_Vec2d
        """
        return _IntPatch.IntPatch_HCurve2dTool_DN(*args)

    DN = staticmethod(DN)

    def Ellipse(*args) -> "gp_Elips2d":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: gp_Elips2d
        """
        return _IntPatch.IntPatch_HCurve2dTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def FirstParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: float
        """
        return _IntPatch.IntPatch_HCurve2dTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def GetType(*args) -> "GeomAbs_CurveType":
        """
        * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: GeomAbs_CurveType
        """
        return _IntPatch.IntPatch_HCurve2dTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Hyperbola(*args) -> "gp_Hypr2d":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: gp_Hypr2d
        """
        return _IntPatch.IntPatch_HCurve2dTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Intervals(*args) -> "void":
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param T:
        	:type T: TColStd_Array1OfReal
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: None
        """
        return _IntPatch.IntPatch_HCurve2dTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HCurve2dTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args) -> "Standard_Boolean":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HCurve2dTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def LastParameter(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: float
        """
        return _IntPatch.IntPatch_HCurve2dTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Line(*args) -> "gp_Lin2d":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: gp_Lin2d
        """
        return _IntPatch.IntPatch_HCurve2dTool_Line(*args)

    Line = staticmethod(Line)

    def NbIntervals(*args) -> "Standard_Integer":
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param S:
        	:type S: GeomAbs_Shape
        	:rtype: int
        """
        return _IntPatch.IntPatch_HCurve2dTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def NbSamples(*args) -> "Standard_Integer":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:param U0:
        	:type U0: float
        	:param U1:
        	:type U1: float
        	:rtype: int
        """
        return _IntPatch.IntPatch_HCurve2dTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Parabola(*args) -> "gp_Parab2d":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: gp_Parab2d
        """
        return _IntPatch.IntPatch_HCurve2dTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Period(*args) -> "Standard_Real":
        """
        :param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: float
        """
        return _IntPatch.IntPatch_HCurve2dTool_Period(*args)

    Period = staticmethod(Period)

    def Resolution(*args) -> "Standard_Real":
        """
        * Returns the parametric resolution corresponding to the real space resolution <R3d>.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param R3d:
        	:type R3d: float
        	:rtype: float
        """
        return _IntPatch.IntPatch_HCurve2dTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def Value(*args) -> "gp_Pnt2d":
        """
        * Computes the point of parameter U on the curve.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param U:
        	:type U: float
        	:rtype: gp_Pnt2d
        """
        return _IntPatch.IntPatch_HCurve2dTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        _IntPatch.IntPatch_HCurve2dTool_swiginit(self, _IntPatch.new_IntPatch_HCurve2dTool())
    __swig_destroy__ = _IntPatch.delete_IntPatch_HCurve2dTool
IntPatch_HCurve2dTool_swigregister = _IntPatch.IntPatch_HCurve2dTool_swigregister
IntPatch_HCurve2dTool_swigregister(IntPatch_HCurve2dTool)

def IntPatch_HCurve2dTool_BSpline(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: opencascade::handle<Geom2d_BSplineCurve>
    """
    return _IntPatch.IntPatch_HCurve2dTool_BSpline(*args)

def IntPatch_HCurve2dTool_Bezier(*args) -> "opencascade::handle< Geom2d_BezierCurve >":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: opencascade::handle<Geom2d_BezierCurve>
    """
    return _IntPatch.IntPatch_HCurve2dTool_Bezier(*args)

def IntPatch_HCurve2dTool_Circle(*args) -> "gp_Circ2d":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: gp_Circ2d
    """
    return _IntPatch.IntPatch_HCurve2dTool_Circle(*args)

def IntPatch_HCurve2dTool_Continuity(*args) -> "GeomAbs_Shape":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: GeomAbs_Shape
    """
    return _IntPatch.IntPatch_HCurve2dTool_Continuity(*args)

def IntPatch_HCurve2dTool_D0(*args) -> "void":
    """
    * Computes the point of parameter U on the curve.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:rtype: None
    """
    return _IntPatch.IntPatch_HCurve2dTool_D0(*args)

def IntPatch_HCurve2dTool_D1(*args) -> "void":
    """
    * Computes the point of parameter U on the curve with its first derivative. Raised if the continuity of the current interval is not C1.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param V:
    	:type V: gp_Vec2d
    	:rtype: None
    """
    return _IntPatch.IntPatch_HCurve2dTool_D1(*args)

def IntPatch_HCurve2dTool_D2(*args) -> "void":
    """
    * Returns the point P of parameter U, the first and second derivatives V1 and V2. Raised if the continuity of the current interval is not C2.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:rtype: None
    """
    return _IntPatch.IntPatch_HCurve2dTool_D2(*args)

def IntPatch_HCurve2dTool_D3(*args) -> "void":
    """
    * Returns the point P of parameter U, the first, the second and the third derivative. Raised if the continuity of the current interval is not C3.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param U:
    	:type U: float
    	:param P:
    	:type P: gp_Pnt2d
    	:param V1:
    	:type V1: gp_Vec2d
    	:param V2:
    	:type V2: gp_Vec2d
    	:param V3:
    	:type V3: gp_Vec2d
    	:rtype: None
    """
    return _IntPatch.IntPatch_HCurve2dTool_D3(*args)

def IntPatch_HCurve2dTool_DN(*args) -> "gp_Vec2d":
    """
    * The returned vector gives the value of the derivative for the order of derivation N. Raised if the continuity of the current interval is not CN. Raised if N < 1.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param U:
    	:type U: float
    	:param N:
    	:type N: int
    	:rtype: gp_Vec2d
    """
    return _IntPatch.IntPatch_HCurve2dTool_DN(*args)

def IntPatch_HCurve2dTool_Ellipse(*args) -> "gp_Elips2d":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: gp_Elips2d
    """
    return _IntPatch.IntPatch_HCurve2dTool_Ellipse(*args)

def IntPatch_HCurve2dTool_FirstParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: float
    """
    return _IntPatch.IntPatch_HCurve2dTool_FirstParameter(*args)

def IntPatch_HCurve2dTool_GetType(*args) -> "GeomAbs_CurveType":
    """
    * Returns the type of the curve in the current interval : Line, Circle, Ellipse, Hyperbola, Parabola, BezierCurve, BSplineCurve, OtherCurve.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: GeomAbs_CurveType
    """
    return _IntPatch.IntPatch_HCurve2dTool_GetType(*args)

def IntPatch_HCurve2dTool_Hyperbola(*args) -> "gp_Hypr2d":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: gp_Hypr2d
    """
    return _IntPatch.IntPatch_HCurve2dTool_Hyperbola(*args)

def IntPatch_HCurve2dTool_Intervals(*args) -> "void":
    """
    * Stores in <T> the parameters bounding the intervals of continuity <S>. //! The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param T:
    	:type T: TColStd_Array1OfReal
    	:param S:
    	:type S: GeomAbs_Shape
    	:rtype: None
    """
    return _IntPatch.IntPatch_HCurve2dTool_Intervals(*args)

def IntPatch_HCurve2dTool_IsClosed(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HCurve2dTool_IsClosed(*args)

def IntPatch_HCurve2dTool_IsPeriodic(*args) -> "Standard_Boolean":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HCurve2dTool_IsPeriodic(*args)

def IntPatch_HCurve2dTool_LastParameter(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: float
    """
    return _IntPatch.IntPatch_HCurve2dTool_LastParameter(*args)

def IntPatch_HCurve2dTool_Line(*args) -> "gp_Lin2d":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: gp_Lin2d
    """
    return _IntPatch.IntPatch_HCurve2dTool_Line(*args)

def IntPatch_HCurve2dTool_NbIntervals(*args) -> "Standard_Integer":
    """
    * Returns the number of intervals for continuity <S>. May be one if Continuity(myclass) >= <S>
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param S:
    	:type S: GeomAbs_Shape
    	:rtype: int
    """
    return _IntPatch.IntPatch_HCurve2dTool_NbIntervals(*args)

def IntPatch_HCurve2dTool_NbSamples(*args) -> "Standard_Integer":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:param U0:
    	:type U0: float
    	:param U1:
    	:type U1: float
    	:rtype: int
    """
    return _IntPatch.IntPatch_HCurve2dTool_NbSamples(*args)

def IntPatch_HCurve2dTool_Parabola(*args) -> "gp_Parab2d":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: gp_Parab2d
    """
    return _IntPatch.IntPatch_HCurve2dTool_Parabola(*args)

def IntPatch_HCurve2dTool_Period(*args) -> "Standard_Real":
    """
    :param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: float
    """
    return _IntPatch.IntPatch_HCurve2dTool_Period(*args)

def IntPatch_HCurve2dTool_Resolution(*args) -> "Standard_Real":
    """
    * Returns the parametric resolution corresponding to the real space resolution <R3d>.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param R3d:
    	:type R3d: float
    	:rtype: float
    """
    return _IntPatch.IntPatch_HCurve2dTool_Resolution(*args)

def IntPatch_HCurve2dTool_Value(*args) -> "gp_Pnt2d":
    """
    * Computes the point of parameter U on the curve.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param U:
    	:type U: float
    	:rtype: gp_Pnt2d
    """
    return _IntPatch.IntPatch_HCurve2dTool_Value(*args)

class IntPatch_HInterTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounds(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Returns the parametric limits on the arc C. These limits must be finite : they are either the real limits of the arc, for a finite arc, or a bounding box for an infinite arc.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param Ufirst:
        	:type Ufirst: float
        	:param Ulast:
        	:type Ulast: float
        	:rtype: void
        """
        return _IntPatch.IntPatch_HInterTool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def HasBeenSeen(*args) -> "Standard_Boolean":
        """
        * Returns True if all the intersection point and edges are known on the Arc. The intersection point are given as vertices. The intersection edges are given as intervals between two vertices.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_HasBeenSeen(*args)

    HasBeenSeen = staticmethod(HasBeenSeen)

    def HasFirstPoint(*args) -> "Standard_Integer &":
        """
        * Returns True when the segment of range Index is not open at the left side. In that case, IndFirst is the range in the list intersection points (see NbPoints) of the one which defines the left bound of the segment. Otherwise, the method has to return False, and IndFirst has no meaning.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param Index:
        	:type Index: int
        	:param IndFirst:
        	:type IndFirst: int
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_HasFirstPoint(*args)

    HasFirstPoint = staticmethod(HasFirstPoint)

    def HasLastPoint(*args) -> "Standard_Integer &":
        """
        * Returns True when the segment of range Index is not open at the right side. In that case, IndLast is the range in the list intersection points (see NbPoints) of the one which defines the right bound of the segment. Otherwise, the method has to return False, and IndLast has no meaning.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param Index:
        	:type Index: int
        	:param IndLast:
        	:type IndLast: int
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_HasLastPoint(*args)

    HasLastPoint = staticmethod(HasLastPoint)

    def __init__(self, *args):
        """:rtype: None"""
        _IntPatch.IntPatch_HInterTool_swiginit(self, _IntPatch.new_IntPatch_HInterTool(*args))

    def IsAllSolution(*args) -> "Standard_Boolean":
        """
        * Returns True when the whole restriction is solution of the intersection problem.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_IsAllSolution(*args)

    IsAllSolution = staticmethod(IsAllSolution)

    def IsVertex(*args) -> "Standard_Boolean":
        """
        * Returns True if the intersection point of range Index corresponds with a vertex on the arc A.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param Index:
        	:type Index: int
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_IsVertex(*args)

    IsVertex = staticmethod(IsVertex)

    def NbPoints(*args) -> "Standard_Integer":
        """
        * Returns the number of intersection points on the arc A.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: int
        """
        return _IntPatch.IntPatch_HInterTool_NbPoints(*args)

    NbPoints = staticmethod(NbPoints)

    def NbSamplePoints(self, *args) -> "Standard_Integer":
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: int
        """
        return _IntPatch.IntPatch_HInterTool_NbSamplePoints(self, *args)


    def NbSamplesOnArc(*args) -> "Standard_Integer":
        """
        * returns the number of points which is used to make a sample on the arc. this number is a function of the Surface and the CurveOnSurface complexity.
        	:param A:
        	:type A: Adaptor2d_HCurve2d
        	:rtype: int
        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesOnArc(*args)

    NbSamplesOnArc = staticmethod(NbSamplesOnArc)

    def NbSamplesU(*args) -> "Standard_Integer":
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:param u1:
        	:type u1: float
        	:param u2:
        	:type u2: float
        	:rtype: int
        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args) -> "Standard_Integer":
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:param v1:
        	:type v1: float
        	:param v2:
        	:type v2: float
        	:rtype: int
        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def NbSegments(*args) -> "Standard_Integer":
        """
        * returns the number of part of A solution of the of intersection problem.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: int
        """
        return _IntPatch.IntPatch_HInterTool_NbSegments(*args)

    NbSegments = staticmethod(NbSegments)

    def Parameter(*args) -> "Standard_Real":
        """
        * Returns the parameter of the vertex V on the arc A.
        	:param V:
        	:type V: Adaptor3d_HVertex
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: float
        """
        return _IntPatch.IntPatch_HInterTool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    def Project(*args) -> "Standard_Real &":
        """
        * Projects the point P on the arc C. If the methods returns Standard_True, the projection is successful, and Paramproj is the parameter on the arc of the projected point, Ptproj is the projected Point. If the method returns Standard_False, Param proj and Ptproj are not significant.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param P:
        	:type P: gp_Pnt2d
        	:param Paramproj:
        	:type Paramproj: float
        	:param Ptproj:
        	:type Ptproj: gp_Pnt2d
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_Project(*args)

    Project = staticmethod(Project)

    def SamplePoint(self, *args) -> "void":
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:param Index:
        	:type Index: int
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_HInterTool_SamplePoint(self, *args)


    def SingularOnUMax(*args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_SingularOnUMax(*args)

    SingularOnUMax = staticmethod(SingularOnUMax)

    def SingularOnUMin(*args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_SingularOnUMin(*args)

    SingularOnUMin = staticmethod(SingularOnUMin)

    def SingularOnVMax(*args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_SingularOnVMax(*args)

    SingularOnVMax = staticmethod(SingularOnVMax)

    def SingularOnVMin(*args) -> "Standard_Boolean":
        """
        :param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: bool
        """
        return _IntPatch.IntPatch_HInterTool_SingularOnVMin(*args)

    SingularOnVMin = staticmethod(SingularOnVMin)

    def Tolerance(*args) -> "Standard_Real":
        """
        * Returns the parametric tolerance used to consider that the vertex and another point meet, i-e if Abs(parameter(Vertex) - parameter(OtherPnt))<= Tolerance, the points are 'merged'.
        	:param V:
        	:type V: Adaptor3d_HVertex
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:rtype: float
        """
        return _IntPatch.IntPatch_HInterTool_Tolerance(*args)

    Tolerance = staticmethod(Tolerance)

    def Value(*args) -> "Standard_Real &, Standard_Real &":
        """
        * Returns the value (Pt), the tolerance (Tol), and the parameter (U) on the arc A , of the intersection point of range Index.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param Index:
        	:type Index: int
        	:param Pt:
        	:type Pt: gp_Pnt
        	:param Tol:
        	:type Tol: float
        	:param U:
        	:type U: float
        	:rtype: void
        """
        return _IntPatch.IntPatch_HInterTool_Value(*args)

    Value = staticmethod(Value)

    def Vertex(*args) -> "void":
        """
        * When IsVertex returns True, this method returns the vertex on the arc A.
        	:param C:
        	:type C: Adaptor2d_HCurve2d
        	:param Index:
        	:type Index: int
        	:param V:
        	:type V: Adaptor3d_HVertex
        	:rtype: void
        """
        return _IntPatch.IntPatch_HInterTool_Vertex(*args)

    Vertex = staticmethod(Vertex)

    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_HInterTool
IntPatch_HInterTool.NbSamplePoints = new_instancemethod(_IntPatch.IntPatch_HInterTool_NbSamplePoints, None, IntPatch_HInterTool)
IntPatch_HInterTool.SamplePoint = new_instancemethod(_IntPatch.IntPatch_HInterTool_SamplePoint, None, IntPatch_HInterTool)
IntPatch_HInterTool_swigregister = _IntPatch.IntPatch_HInterTool_swigregister
IntPatch_HInterTool_swigregister(IntPatch_HInterTool)

def IntPatch_HInterTool_Bounds(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Returns the parametric limits on the arc C. These limits must be finite : they are either the real limits of the arc, for a finite arc, or a bounding box for an infinite arc.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param Ufirst:
    	:type Ufirst: float
    	:param Ulast:
    	:type Ulast: float
    	:rtype: void
    """
    return _IntPatch.IntPatch_HInterTool_Bounds(*args)

def IntPatch_HInterTool_HasBeenSeen(*args) -> "Standard_Boolean":
    """
    * Returns True if all the intersection point and edges are known on the Arc. The intersection point are given as vertices. The intersection edges are given as intervals between two vertices.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_HasBeenSeen(*args)

def IntPatch_HInterTool_HasFirstPoint(*args) -> "Standard_Integer &":
    """
    * Returns True when the segment of range Index is not open at the left side. In that case, IndFirst is the range in the list intersection points (see NbPoints) of the one which defines the left bound of the segment. Otherwise, the method has to return False, and IndFirst has no meaning.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param Index:
    	:type Index: int
    	:param IndFirst:
    	:type IndFirst: int
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_HasFirstPoint(*args)

def IntPatch_HInterTool_HasLastPoint(*args) -> "Standard_Integer &":
    """
    * Returns True when the segment of range Index is not open at the right side. In that case, IndLast is the range in the list intersection points (see NbPoints) of the one which defines the right bound of the segment. Otherwise, the method has to return False, and IndLast has no meaning.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param Index:
    	:type Index: int
    	:param IndLast:
    	:type IndLast: int
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_HasLastPoint(*args)

def IntPatch_HInterTool_IsAllSolution(*args) -> "Standard_Boolean":
    """
    * Returns True when the whole restriction is solution of the intersection problem.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_IsAllSolution(*args)

def IntPatch_HInterTool_IsVertex(*args) -> "Standard_Boolean":
    """
    * Returns True if the intersection point of range Index corresponds with a vertex on the arc A.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param Index:
    	:type Index: int
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_IsVertex(*args)

def IntPatch_HInterTool_NbPoints(*args) -> "Standard_Integer":
    """
    * Returns the number of intersection points on the arc A.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: int
    """
    return _IntPatch.IntPatch_HInterTool_NbPoints(*args)

def IntPatch_HInterTool_NbSamplesOnArc(*args) -> "Standard_Integer":
    """
    * returns the number of points which is used to make a sample on the arc. this number is a function of the Surface and the CurveOnSurface complexity.
    	:param A:
    	:type A: Adaptor2d_HCurve2d
    	:rtype: int
    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesOnArc(*args)

def IntPatch_HInterTool_NbSamplesU(*args) -> "Standard_Integer":
    """
    :param S:
    	:type S: Adaptor3d_HSurface
    	:param u1:
    	:type u1: float
    	:param u2:
    	:type u2: float
    	:rtype: int
    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesU(*args)

def IntPatch_HInterTool_NbSamplesV(*args) -> "Standard_Integer":
    """
    :param S:
    	:type S: Adaptor3d_HSurface
    	:param v1:
    	:type v1: float
    	:param v2:
    	:type v2: float
    	:rtype: int
    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesV(*args)

def IntPatch_HInterTool_NbSegments(*args) -> "Standard_Integer":
    """
    * returns the number of part of A solution of the of intersection problem.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: int
    """
    return _IntPatch.IntPatch_HInterTool_NbSegments(*args)

def IntPatch_HInterTool_Parameter(*args) -> "Standard_Real":
    """
    * Returns the parameter of the vertex V on the arc A.
    	:param V:
    	:type V: Adaptor3d_HVertex
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: float
    """
    return _IntPatch.IntPatch_HInterTool_Parameter(*args)

def IntPatch_HInterTool_Project(*args) -> "Standard_Real &":
    """
    * Projects the point P on the arc C. If the methods returns Standard_True, the projection is successful, and Paramproj is the parameter on the arc of the projected point, Ptproj is the projected Point. If the method returns Standard_False, Param proj and Ptproj are not significant.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param P:
    	:type P: gp_Pnt2d
    	:param Paramproj:
    	:type Paramproj: float
    	:param Ptproj:
    	:type Ptproj: gp_Pnt2d
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_Project(*args)

def IntPatch_HInterTool_SingularOnUMax(*args) -> "Standard_Boolean":
    """
    :param S:
    	:type S: Adaptor3d_HSurface
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_SingularOnUMax(*args)

def IntPatch_HInterTool_SingularOnUMin(*args) -> "Standard_Boolean":
    """
    :param S:
    	:type S: Adaptor3d_HSurface
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_SingularOnUMin(*args)

def IntPatch_HInterTool_SingularOnVMax(*args) -> "Standard_Boolean":
    """
    :param S:
    	:type S: Adaptor3d_HSurface
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_SingularOnVMax(*args)

def IntPatch_HInterTool_SingularOnVMin(*args) -> "Standard_Boolean":
    """
    :param S:
    	:type S: Adaptor3d_HSurface
    	:rtype: bool
    """
    return _IntPatch.IntPatch_HInterTool_SingularOnVMin(*args)

def IntPatch_HInterTool_Tolerance(*args) -> "Standard_Real":
    """
    * Returns the parametric tolerance used to consider that the vertex and another point meet, i-e if Abs(parameter(Vertex) - parameter(OtherPnt))<= Tolerance, the points are 'merged'.
    	:param V:
    	:type V: Adaptor3d_HVertex
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:rtype: float
    """
    return _IntPatch.IntPatch_HInterTool_Tolerance(*args)

def IntPatch_HInterTool_Value(*args) -> "Standard_Real &, Standard_Real &":
    """
    * Returns the value (Pt), the tolerance (Tol), and the parameter (U) on the arc A , of the intersection point of range Index.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param Index:
    	:type Index: int
    	:param Pt:
    	:type Pt: gp_Pnt
    	:param Tol:
    	:type Tol: float
    	:param U:
    	:type U: float
    	:rtype: void
    """
    return _IntPatch.IntPatch_HInterTool_Value(*args)

def IntPatch_HInterTool_Vertex(*args) -> "void":
    """
    * When IsVertex returns True, this method returns the vertex on the arc A.
    	:param C:
    	:type C: Adaptor2d_HCurve2d
    	:param Index:
    	:type Index: int
    	:param V:
    	:type V: Adaptor3d_HVertex
    	:rtype: void
    """
    return _IntPatch.IntPatch_HInterTool_Vertex(*args)

class IntPatch_ImpImpIntersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        * Flag theIsReqToKeepRLine has been entered only for compatibility with TopOpeBRep package. It shall be deleted after deleting TopOpeBRep. When intersection result returns IntPatch_RLine and another IntPatch_Line (not restriction) we (in case of theIsReqToKeepRLine==True) will always keep both lines even if they are coincided.
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:param theIsReqToKeepRLine: default value is Standard_False
        	:type theIsReqToKeepRLine: bool
        	:rtype: None
        """
        _IntPatch.IntPatch_ImpImpIntersection_swiginit(self, _IntPatch.new_IntPatch_ImpImpIntersection(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the calculus was successful.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_ImpImpIntersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the is no intersection.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_ImpImpIntersection_IsEmpty(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntPatch_Line > const &":
        """
        * Returns the line of range Index. An exception is raised if Index<=0 or Index>NbLine.
        	:param Index:
        	:type Index: int
        	:rtype: opencascade::handle<IntPatch_Line>
        """
        return _IntPatch.IntPatch_ImpImpIntersection_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection lines.
        	:rtype: int
        """
        return _IntPatch.IntPatch_ImpImpIntersection_NbLines(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 'single' points.
        	:rtype: int
        """
        return _IntPatch.IntPatch_ImpImpIntersection_NbPnts(self, *args)


    def OppositeFaces(self, *args) -> "Standard_Boolean":
        """
        * Returns True when the TangentFaces returns True and the normal vectors evaluated at a point on the first and the second surface are opposite. The exception DomainError is raised if TangentFaces returns False.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_ImpImpIntersection_OppositeFaces(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Flag theIsReqToKeepRLine has been entered only for compatibility with TopOpeBRep package. It shall be deleted after deleting TopOpeBRep. When intersection result returns IntPatch_RLine and another IntPatch_Line (not restriction) we (in case of theIsReqToKeepRLine==True) will always keep both lines even if they are coincided.
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:param theIsReqToKeepRLine: default value is Standard_False
        	:type theIsReqToKeepRLine: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_ImpImpIntersection_Perform(self, *args)


    def Point(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the point of range Index. An exception is raised if Index<=0 or Index>NbPnt.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_ImpImpIntersection_Point(self, *args)


    def TangentFaces(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the two patches are considered as entirely tangent, i.e every restriction arc of one patch is inside the geometric base of the other patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_ImpImpIntersection_TangentFaces(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ImpImpIntersection
IntPatch_ImpImpIntersection.IsDone = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_IsDone, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.IsEmpty = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_IsEmpty, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.Line = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_Line, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.NbLines = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_NbLines, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.NbPnts = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_NbPnts, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.OppositeFaces = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_OppositeFaces, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.Perform = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_Perform, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.Point = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_Point, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection.TangentFaces = new_instancemethod(_IntPatch.IntPatch_ImpImpIntersection_TangentFaces, None, IntPatch_ImpImpIntersection)
IntPatch_ImpImpIntersection_swigregister = _IntPatch.IntPatch_ImpImpIntersection_swigregister
IntPatch_ImpImpIntersection_swigregister(IntPatch_ImpImpIntersection)

class IntPatch_ImpPrmIntersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param Surf1:
        	:type Surf1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param Surf2:
        	:type Surf2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:param Fleche:
        	:type Fleche: float
        	:param Pas:
        	:type Pas: float
        	:rtype: None
        """
        _IntPatch.IntPatch_ImpPrmIntersection_swiginit(self, _IntPatch.new_IntPatch_ImpPrmIntersection(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the calculus was succesfull.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_ImpPrmIntersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the is no intersection.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_ImpPrmIntersection_IsEmpty(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntPatch_Line > const &":
        """
        * Returns the line of range Index. An exception is raised if Index<=0 or Index>NbLine.
        	:param Index:
        	:type Index: int
        	:rtype: opencascade::handle<IntPatch_Line>
        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection lines.
        	:rtype: int
        """
        return _IntPatch.IntPatch_ImpPrmIntersection_NbLines(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 'single' points.
        	:rtype: int
        """
        return _IntPatch.IntPatch_ImpPrmIntersection_NbPnts(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param Surf1:
        	:type Surf1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param Surf2:
        	:type Surf2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:param Fleche:
        	:type Fleche: float
        	:param Pas:
        	:type Pas: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Perform(self, *args)


    def Point(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the point of range Index. An exception is raised if Index<=0 or Index>NbPnt.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Point(self, *args)


    def SetStartPoint(self, *args) -> "void":
        """
        * to search for solution from the given point
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_ImpPrmIntersection_SetStartPoint(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ImpPrmIntersection
IntPatch_ImpPrmIntersection.IsDone = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_IsDone, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.IsEmpty = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_IsEmpty, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.Line = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_Line, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.NbLines = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_NbLines, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.NbPnts = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_NbPnts, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.Perform = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_Perform, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.Point = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_Point, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection.SetStartPoint = new_instancemethod(_IntPatch.IntPatch_ImpPrmIntersection_SetStartPoint, None, IntPatch_ImpPrmIntersection)
IntPatch_ImpPrmIntersection_swigregister = _IntPatch.IntPatch_ImpPrmIntersection_swigregister
IntPatch_ImpPrmIntersection_swigregister(IntPatch_ImpPrmIntersection)

class IntPatch_InterferencePolyhedron(OCC.Core.Intf.Intf_Interference):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructs an empty interference of Polyhedron.
        	:rtype: None
        * Constructs and computes an interference between the two Polyhedra.
        	:param Obje1:
        	:type Obje1: IntPatch_Polyhedron
        	:param Obje2:
        	:type Obje2: IntPatch_Polyhedron
        	:rtype: None
        * Constructs and computes the self interference of a Polyhedron.
        	:param Obje:
        	:type Obje: IntPatch_Polyhedron
        	:rtype: None
        """
        _IntPatch.IntPatch_InterferencePolyhedron_swiginit(self, _IntPatch.new_IntPatch_InterferencePolyhedron(*args))

    def Perform(self, *args) -> "void":
        """
        * Computes the interference between the two Polyhedra.
        	:param Obje1:
        	:type Obje1: IntPatch_Polyhedron
        	:param Obje2:
        	:type Obje2: IntPatch_Polyhedron
        	:rtype: None
        * Computes the self interference of a Polyhedron.
        	:param Obje:
        	:type Obje: IntPatch_Polyhedron
        	:rtype: None
        """
        return _IntPatch.IntPatch_InterferencePolyhedron_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_InterferencePolyhedron
IntPatch_InterferencePolyhedron.Perform = new_instancemethod(_IntPatch.IntPatch_InterferencePolyhedron_Perform, None, IntPatch_InterferencePolyhedron)
IntPatch_InterferencePolyhedron_swigregister = _IntPatch.IntPatch_InterferencePolyhedron_swigregister
IntPatch_InterferencePolyhedron_swigregister(IntPatch_InterferencePolyhedron)

class IntPatch_Intersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dump(self, *args) -> "void":
        """
        * Dump of each result line. Mode for more accurate dumps.
        	:param Mode:
        	:type Mode: int
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:rtype: None
        """
        return _IntPatch.IntPatch_Intersection_Dump(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:rtype: None
        :param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:rtype: None
        """
        _IntPatch.IntPatch_Intersection_swiginit(self, _IntPatch.new_IntPatch_Intersection(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the calculus was successful.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Intersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the is no intersection.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Intersection_IsEmpty(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntPatch_Line > const &":
        """
        * Returns the line of range Index. An exception is raised if Index<=0 or Index>NbLine.
        	:param Index:
        	:type Index: int
        	:rtype: opencascade::handle<IntPatch_Line>
        """
        return _IntPatch.IntPatch_Intersection_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection lines.
        	:rtype: int
        """
        return _IntPatch.IntPatch_Intersection_NbLines(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of 'single' points.
        	:rtype: int
        """
        return _IntPatch.IntPatch_Intersection_NbPnts(self, *args)


    def OppositeFaces(self, *args) -> "Standard_Boolean":
        """
        * Returns True when the TangentFaces returns True and the normal vectors evaluated at a point on the first and the second surface are opposite. The exception DomainError is raised if TangentFaces returns False.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Intersection_OppositeFaces(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Flag theIsReqToKeepRLine has been entered only for compatibility with TopOpeBRep package. It shall be deleted after deleting TopOpeBRep. When intersection result returns IntPatch_RLine and another IntPatch_Line (not restriction) we (in case of theIsReqToKeepRLine==True) will always keep both lines even if they are coincided. Flag theIsReqToPostWLProc has been entered only for compatibility with TopOpeBRep package. It shall be deleted after deleting TopOpeBRep. If theIsReqToPostWLProc == False, then we will work with Walking-line obtained after intersection algorithm directly (wothout any post-processing).
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:param isGeomInt: default value is Standard_True
        	:type isGeomInt: bool
        	:param theIsReqToKeepRLine: default value is Standard_False
        	:type theIsReqToKeepRLine: bool
        	:param theIsReqToPostWLProc: default value is Standard_True
        	:type theIsReqToPostWLProc: bool
        	:rtype: None
        * If isGeomInt == Standard_False, then method Param-Param intersection will be used. Flag theIsReqToKeepRLine has been entered only for compatibility with TopOpeBRep package. It shall be deleted after deleting TopOpeBRep. When intersection result returns IntPatch_RLine and another IntPatch_Line (not restriction) we (in case of theIsReqToKeepRLine==True) will always keep both lines even if they are coincided. Flag theIsReqToPostWLProc has been entered only for compatibility with TopOpeBRep package. It shall be deleted after deleting TopOpeBRep. If theIsReqToPostWLProc == False, then we will work with Walking-line obtained after intersection algorithm directly (without any post-processing).
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:param LOfPnts:
        	:type LOfPnts: IntSurf_ListOfPntOn2S
        	:param isGeomInt: default value is Standard_True
        	:type isGeomInt: bool
        	:param theIsReqToKeepRLine: default value is Standard_False
        	:type theIsReqToKeepRLine: bool
        	:param theIsReqToPostWLProc: default value is Standard_True
        	:type theIsReqToPostWLProc: bool
        	:rtype: None
        * Perform with start point
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:rtype: None
        * Uses for finding self-intersected surfaces.
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_Intersection_Perform(self, *args)


    def Point(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the point of range Index. An exception is raised if Index<=0 or Index>NbPnt.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_Intersection_Point(self, *args)


    def SequenceOfLine(self, *args) -> "IntPatch_SequenceOfLine const &":
        """:rtype: IntPatch_SequenceOfLine"""
        return _IntPatch.IntPatch_Intersection_SequenceOfLine(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        * Set the tolerances used by the algorithms: --- Implicit - Parametric --- Parametric - Parametric --- Implicit - Implicit //! TolArc is used to compute the intersections between the restrictions of a surface and a walking line. //! TolTang is used to compute the points on a walking line, and in geometric algorithms. //! Fleche is a parameter used in the walking algorithms to provide small curvatures on a line. //! UVMaxStep is a parameter used in the walking algorithms to compute the distance between to points in their respective parametric spaces.
        	:param TolArc:
        	:type TolArc: float
        	:param TolTang:
        	:type TolTang: float
        	:param UVMaxStep:
        	:type UVMaxStep: float
        	:param Fleche:
        	:type Fleche: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_Intersection_SetTolerances(self, *args)


    def TangentFaces(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the two patches are considered as entirely tangent, i-e every restriction arc of one patch is inside the geometric base of the other patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Intersection_TangentFaces(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Intersection
IntPatch_Intersection.Dump = new_instancemethod(_IntPatch.IntPatch_Intersection_Dump, None, IntPatch_Intersection)
IntPatch_Intersection.IsDone = new_instancemethod(_IntPatch.IntPatch_Intersection_IsDone, None, IntPatch_Intersection)
IntPatch_Intersection.IsEmpty = new_instancemethod(_IntPatch.IntPatch_Intersection_IsEmpty, None, IntPatch_Intersection)
IntPatch_Intersection.Line = new_instancemethod(_IntPatch.IntPatch_Intersection_Line, None, IntPatch_Intersection)
IntPatch_Intersection.NbLines = new_instancemethod(_IntPatch.IntPatch_Intersection_NbLines, None, IntPatch_Intersection)
IntPatch_Intersection.NbPnts = new_instancemethod(_IntPatch.IntPatch_Intersection_NbPnts, None, IntPatch_Intersection)
IntPatch_Intersection.OppositeFaces = new_instancemethod(_IntPatch.IntPatch_Intersection_OppositeFaces, None, IntPatch_Intersection)
IntPatch_Intersection.Perform = new_instancemethod(_IntPatch.IntPatch_Intersection_Perform, None, IntPatch_Intersection)
IntPatch_Intersection.Point = new_instancemethod(_IntPatch.IntPatch_Intersection_Point, None, IntPatch_Intersection)
IntPatch_Intersection.SequenceOfLine = new_instancemethod(_IntPatch.IntPatch_Intersection_SequenceOfLine, None, IntPatch_Intersection)
IntPatch_Intersection.SetTolerances = new_instancemethod(_IntPatch.IntPatch_Intersection_SetTolerances, None, IntPatch_Intersection)
IntPatch_Intersection.TangentFaces = new_instancemethod(_IntPatch.IntPatch_Intersection_TangentFaces, None, IntPatch_Intersection)
IntPatch_Intersection_swigregister = _IntPatch.IntPatch_Intersection_swigregister
IntPatch_Intersection_swigregister(IntPatch_Intersection)

class IntPatch_Line(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ArcType(self, *args) -> "IntPatch_IType":
        """
        * Returns the type of geometry 3d (Line, Circle, Parabola, Hyperbola, Ellipse, Analytic, Walking, Restriction)
        	:rtype: IntPatch_IType
        """
        return _IntPatch.IntPatch_Line_ArcType(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a line of tangency between the 2 patches.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Line_IsTangent(self, *args)


    def IsUIsoOnS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a U isoparametric curve on the first patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Line_IsUIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a U isoparametric curve on the second patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Line_IsUIsoOnS2(self, *args)


    def IsVIsoOnS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a V isoparametric curve on the first patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Line_IsVIsoOnS1(self, *args)


    def IsVIsoOnS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is a V isoparametric curve on the second patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Line_IsVIsoOnS2(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * To set the values returned by IsUIsoS1,.... The default values are False.
        	:param Uiso1:
        	:type Uiso1: bool
        	:param Viso1:
        	:type Viso1: bool
        	:param Uiso2:
        	:type Uiso2: bool
        	:param Viso2:
        	:type Viso2: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_Line_SetValue(self, *args)


    def SituationS1(self, *args) -> "IntSurf_Situation":
        """
        * Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of the first patch compared to the second one, when TransitionOnS1 or TransitionOnS2 returns TOUCH. Otherwise, an exception is raised.
        	:rtype: IntSurf_Situation
        """
        return _IntPatch.IntPatch_Line_SituationS1(self, *args)


    def SituationS2(self, *args) -> "IntSurf_Situation":
        """
        * Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of the second patch compared to the first one, when TransitionOnS1 or TransitionOnS2 returns TOUCH. Otherwise, an exception is raised.
        	:rtype: IntSurf_Situation
        """
        return _IntPatch.IntPatch_Line_SituationS2(self, *args)


    def TransitionOnS1(self, *args) -> "IntSurf_TypeTrans":
        """
        * Returns the type of the transition of the line for the first surface. The transition is 'constant' along the line. The transition is IN if the line is oriented in such a way that the system of vector (N1,N2,T) is right-handed, where N1 is the normal to the first surface at a point P, N2 is the normal to the second surface at a point P, T is the tangent to the intersection line at P. If the system of vector is left-handed, the transition is OUT. When N1 and N2 are colinear all along the intersection line, the transition will be - TOUCH, if it is possible to use the 2nd derivatives to determine the position of one surafce compared to the other (see Situation) - UNDECIDED otherwise. //! If one of the transition is TOUCH or UNDECIDED, the other one has got the same value.
        	:rtype: IntSurf_TypeTrans
        """
        return _IntPatch.IntPatch_Line_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args) -> "IntSurf_TypeTrans":
        """
        * Returns the type of the transition of the line for the second surface. The transition is 'constant' along the line.
        	:rtype: IntSurf_TypeTrans
        """
        return _IntPatch.IntPatch_Line_TransitionOnS2(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_Line_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Line
IntPatch_Line.ArcType = new_instancemethod(_IntPatch.IntPatch_Line_ArcType, None, IntPatch_Line)
IntPatch_Line.IsTangent = new_instancemethod(_IntPatch.IntPatch_Line_IsTangent, None, IntPatch_Line)
IntPatch_Line.IsUIsoOnS1 = new_instancemethod(_IntPatch.IntPatch_Line_IsUIsoOnS1, None, IntPatch_Line)
IntPatch_Line.IsUIsoOnS2 = new_instancemethod(_IntPatch.IntPatch_Line_IsUIsoOnS2, None, IntPatch_Line)
IntPatch_Line.IsVIsoOnS1 = new_instancemethod(_IntPatch.IntPatch_Line_IsVIsoOnS1, None, IntPatch_Line)
IntPatch_Line.IsVIsoOnS2 = new_instancemethod(_IntPatch.IntPatch_Line_IsVIsoOnS2, None, IntPatch_Line)
IntPatch_Line.SetValue = new_instancemethod(_IntPatch.IntPatch_Line_SetValue, None, IntPatch_Line)
IntPatch_Line.SituationS1 = new_instancemethod(_IntPatch.IntPatch_Line_SituationS1, None, IntPatch_Line)
IntPatch_Line.SituationS2 = new_instancemethod(_IntPatch.IntPatch_Line_SituationS2, None, IntPatch_Line)
IntPatch_Line.TransitionOnS1 = new_instancemethod(_IntPatch.IntPatch_Line_TransitionOnS1, None, IntPatch_Line)
IntPatch_Line.TransitionOnS2 = new_instancemethod(_IntPatch.IntPatch_Line_TransitionOnS2, None, IntPatch_Line)
IntPatch_Line_swigregister = _IntPatch.IntPatch_Line_swigregister
IntPatch_Line_swigregister(IntPatch_Line)

class IntPatch_LineConstructor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param mode:
        	:type mode: int
        	:rtype: None
        """
        _IntPatch.IntPatch_LineConstructor_swiginit(self, _IntPatch.new_IntPatch_LineConstructor(*args))

    def Line(self, *args) -> "opencascade::handle< IntPatch_Line >":
        """
        :param index:
        	:type index: int
        	:rtype: opencascade::handle<IntPatch_Line>
        """
        return _IntPatch.IntPatch_LineConstructor_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _IntPatch.IntPatch_LineConstructor_NbLines(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param SL:
        	:type SL: IntPatch_SequenceOfLine
        	:param L:
        	:type L: IntPatch_Line
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param D1:
        	:type D1: Adaptor3d_TopolTool
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param D2:
        	:type D2: Adaptor3d_TopolTool
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_LineConstructor_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_LineConstructor
IntPatch_LineConstructor.Line = new_instancemethod(_IntPatch.IntPatch_LineConstructor_Line, None, IntPatch_LineConstructor)
IntPatch_LineConstructor.NbLines = new_instancemethod(_IntPatch.IntPatch_LineConstructor_NbLines, None, IntPatch_LineConstructor)
IntPatch_LineConstructor.Perform = new_instancemethod(_IntPatch.IntPatch_LineConstructor_Perform, None, IntPatch_LineConstructor)
IntPatch_LineConstructor_swigregister = _IntPatch.IntPatch_LineConstructor_swigregister
IntPatch_LineConstructor_swigregister(IntPatch_LineConstructor)

class IntPatch_Point(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ArcOnS1(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        * Returns the arc of restriction containing the vertex. The exception DomainError is raised if IsOnDomS1 returns False.
        	:rtype: opencascade::handle<Adaptor2d_HCurve2d>
        """
        return _IntPatch.IntPatch_Point_ArcOnS1(self, *args)


    def ArcOnS2(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        * Returns the arc of restriction containing the vertex. The exception DomainError is raised if IsOnDomS2 returns False.
        	:rtype: opencascade::handle<Adaptor2d_HCurve2d>
        """
        return _IntPatch.IntPatch_Point_ArcOnS2(self, *args)


    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _IntPatch.IntPatch_Point_Dump(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        """
        _IntPatch.IntPatch_Point_swiginit(self, _IntPatch.new_IntPatch_Point(*args))

    def IsMultiple(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point belongs to several intersection lines.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Point_IsMultiple(self, *args)


    def IsOnDomS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point is on a boundary of the domain of the first patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Point_IsOnDomS1(self, *args)


    def IsOnDomS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point is on a boundary of the domain of the second patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Point_IsOnDomS2(self, *args)


    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the Point is a tangency point between the surfaces. If the Point is on one of the domain (IsOnDomS1 returns True or IsOnDomS2 returns True), an exception is raised.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Point_IsTangencyPoint(self, *args)


    def IsVertexOnS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point is a vertex on the initial restriction facet of the first surface.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Point_IsVertexOnS1(self, *args)


    def IsVertexOnS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point is a vertex on the initial restriction facet of the first surface.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_Point_IsVertexOnS2(self, *args)


    def ParameterOnArc1(self, *args) -> "Standard_Real":
        """
        * Returns the parameter of the point on the arc returned by the method ArcOnS2. The exception DomainError is raised if IsOnDomS1 returns False.
        	:rtype: float
        """
        return _IntPatch.IntPatch_Point_ParameterOnArc1(self, *args)


    def ParameterOnArc2(self, *args) -> "Standard_Real":
        """
        * Returns the parameter of the point on the arc returned by the method ArcOnS2. The exception DomainError is raised if IsOnDomS2 returns False.
        	:rtype: float
        """
        return _IntPatch.IntPatch_Point_ParameterOnArc2(self, *args)


    def ParameterOnLine(self, *args) -> "Standard_Real":
        """
        * This method returns the parameter of the point on the intersection line. If the points does not belong to an intersection line, the value returned does not have any sens.
        	:rtype: float
        """
        return _IntPatch.IntPatch_Point_ParameterOnLine(self, *args)


    def Parameters(self, *args) -> "void":
        """
        * Returns the parameters on the first and on the second surface of the point.
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_Parameters(self, *args)


    def ParametersOnS1(self, *args) -> "void":
        """
        * Returns the parameters on the first surface of the point.
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args) -> "void":
        """
        * Returns the parameters on the second surface of the point.
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_ParametersOnS2(self, *args)


    def PntOn2S(self, *args) -> "IntSurf_PntOn2S const &":
        """
        * Returns the PntOn2S (geometric Point and the parameters)
        	:rtype: IntSurf_PntOn2S
        """
        return _IntPatch.IntPatch_Point_PntOn2S(self, *args)


    def ReverseTransition(self, *args) -> "void":
        """:rtype: None"""
        return _IntPatch.IntPatch_Point_ReverseTransition(self, *args)


    def SetArc(self, *args) -> "void":
        """
        * Sets the values of a point which is on one of the domain, when both surfaces are implicit ones. If OnFirst is True, the point is on the domain of the first patch, otherwise the point is on the domain of the second surface.
        	:param OnFirst:
        	:type OnFirst: bool
        	:param A:
        	:type A: Adaptor2d_HCurve2d
        	:param Param:
        	:type Param: float
        	:param TLine:
        	:type TLine: IntSurf_Transition
        	:param TArc:
        	:type TArc: IntSurf_Transition
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_SetArc(self, *args)


    def SetMultiple(self, *args) -> "void":
        """
        * Sets (or unsets) the point as a point on several intersection line.
        	:param IsMult:
        	:type IsMult: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_SetMultiple(self, *args)


    def SetParameter(self, *args) -> "void":
        """
        * Set the value of the parameter on the intersection line.
        	:param Para:
        	:type Para: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_SetParameter(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        * Sets the values of the parameters of the point on each surface.
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_SetParameters(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        :param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_SetTolerance(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Sets the values of a point which is on no domain, when both surfaces are implicit ones. If Tangent is True, the point is a point of tangency between the surfaces.
        	:param Pt:
        	:type Pt: gp_Pnt
        	:param Tol:
        	:type Tol: float
        	:param Tangent:
        	:type Tangent: bool
        	:rtype: None
        :param Pt:
        	:type Pt: gp_Pnt
        	:rtype: None
        * Sets the value of <pt> member
        	:param thePOn2S:
        	:type thePOn2S: IntSurf_PntOn2S
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_SetValue(self, *args)


    def SetVertex(self, *args) -> "void":
        """
        * Sets the values of a point which is a vertex on the initial facet of restriction of one of the surface. If OnFirst is True, the point is on the domain of the first patch, otherwise the point is on the domain of the second surface.
        	:param OnFirst:
        	:type OnFirst: bool
        	:param V:
        	:type V: Adaptor3d_HVertex
        	:rtype: None
        """
        return _IntPatch.IntPatch_Point_SetVertex(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * This method returns the fuzziness on the point.
        	:rtype: float
        """
        return _IntPatch.IntPatch_Point_Tolerance(self, *args)


    def TransitionLineArc1(self, *args) -> "IntSurf_Transition const &":
        """
        * Returns the transition of the point on the intersection line with the arc on S1. The exception DomainError is raised if IsOnDomS1 returns False.
        	:rtype: IntSurf_Transition
        """
        return _IntPatch.IntPatch_Point_TransitionLineArc1(self, *args)


    def TransitionLineArc2(self, *args) -> "IntSurf_Transition const &":
        """
        * Returns the transition of the point on the intersection line with the arc on S2. The exception DomainError is raised if IsOnDomS2 returns False.
        	:rtype: IntSurf_Transition
        """
        return _IntPatch.IntPatch_Point_TransitionLineArc2(self, *args)


    def TransitionOnS1(self, *args) -> "IntSurf_Transition const &":
        """
        * Returns the transition between the intersection line returned by the method Line and the arc on S1 returned by ArcOnS1(). The exception DomainError is raised if IsOnDomS1 returns False.
        	:rtype: IntSurf_Transition
        """
        return _IntPatch.IntPatch_Point_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args) -> "IntSurf_Transition const &":
        """
        * Returns the transition between the intersection line returned by the method Line and the arc on S2 returned by ArcOnS2. The exception DomainError is raised if IsOnDomS2 returns False.
        	:rtype: IntSurf_Transition
        """
        return _IntPatch.IntPatch_Point_TransitionOnS2(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        * Returns the intersection point (geometric information).
        	:rtype: gp_Pnt
        """
        return _IntPatch.IntPatch_Point_Value(self, *args)


    def VertexOnS1(self, *args) -> "opencascade::handle< Adaptor3d_HVertex > const &":
        """
        * Returns the information about the point when it is on the domain of the first patch, i-e when the function IsVertexOnS1 returns True. Otherwise, an exception is raised.
        	:rtype: opencascade::handle<Adaptor3d_HVertex>
        """
        return _IntPatch.IntPatch_Point_VertexOnS1(self, *args)


    def VertexOnS2(self, *args) -> "opencascade::handle< Adaptor3d_HVertex > const &":
        """
        * Returns the information about the point when it is on the domain of the second patch, i-e when the function IsVertexOnS2 returns True. Otherwise, an exception is raised.
        	:rtype: opencascade::handle<Adaptor3d_HVertex>
        """
        return _IntPatch.IntPatch_Point_VertexOnS2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Point
IntPatch_Point.ArcOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_ArcOnS1, None, IntPatch_Point)
IntPatch_Point.ArcOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_ArcOnS2, None, IntPatch_Point)
IntPatch_Point.Dump = new_instancemethod(_IntPatch.IntPatch_Point_Dump, None, IntPatch_Point)
IntPatch_Point.IsMultiple = new_instancemethod(_IntPatch.IntPatch_Point_IsMultiple, None, IntPatch_Point)
IntPatch_Point.IsOnDomS1 = new_instancemethod(_IntPatch.IntPatch_Point_IsOnDomS1, None, IntPatch_Point)
IntPatch_Point.IsOnDomS2 = new_instancemethod(_IntPatch.IntPatch_Point_IsOnDomS2, None, IntPatch_Point)
IntPatch_Point.IsTangencyPoint = new_instancemethod(_IntPatch.IntPatch_Point_IsTangencyPoint, None, IntPatch_Point)
IntPatch_Point.IsVertexOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_IsVertexOnS1, None, IntPatch_Point)
IntPatch_Point.IsVertexOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_IsVertexOnS2, None, IntPatch_Point)
IntPatch_Point.ParameterOnArc1 = new_instancemethod(_IntPatch.IntPatch_Point_ParameterOnArc1, None, IntPatch_Point)
IntPatch_Point.ParameterOnArc2 = new_instancemethod(_IntPatch.IntPatch_Point_ParameterOnArc2, None, IntPatch_Point)
IntPatch_Point.ParameterOnLine = new_instancemethod(_IntPatch.IntPatch_Point_ParameterOnLine, None, IntPatch_Point)
IntPatch_Point.Parameters = new_instancemethod(_IntPatch.IntPatch_Point_Parameters, None, IntPatch_Point)
IntPatch_Point.ParametersOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_ParametersOnS1, None, IntPatch_Point)
IntPatch_Point.ParametersOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_ParametersOnS2, None, IntPatch_Point)
IntPatch_Point.PntOn2S = new_instancemethod(_IntPatch.IntPatch_Point_PntOn2S, None, IntPatch_Point)
IntPatch_Point.ReverseTransition = new_instancemethod(_IntPatch.IntPatch_Point_ReverseTransition, None, IntPatch_Point)
IntPatch_Point.SetArc = new_instancemethod(_IntPatch.IntPatch_Point_SetArc, None, IntPatch_Point)
IntPatch_Point.SetMultiple = new_instancemethod(_IntPatch.IntPatch_Point_SetMultiple, None, IntPatch_Point)
IntPatch_Point.SetParameter = new_instancemethod(_IntPatch.IntPatch_Point_SetParameter, None, IntPatch_Point)
IntPatch_Point.SetParameters = new_instancemethod(_IntPatch.IntPatch_Point_SetParameters, None, IntPatch_Point)
IntPatch_Point.SetTolerance = new_instancemethod(_IntPatch.IntPatch_Point_SetTolerance, None, IntPatch_Point)
IntPatch_Point.SetValue = new_instancemethod(_IntPatch.IntPatch_Point_SetValue, None, IntPatch_Point)
IntPatch_Point.SetVertex = new_instancemethod(_IntPatch.IntPatch_Point_SetVertex, None, IntPatch_Point)
IntPatch_Point.Tolerance = new_instancemethod(_IntPatch.IntPatch_Point_Tolerance, None, IntPatch_Point)
IntPatch_Point.TransitionLineArc1 = new_instancemethod(_IntPatch.IntPatch_Point_TransitionLineArc1, None, IntPatch_Point)
IntPatch_Point.TransitionLineArc2 = new_instancemethod(_IntPatch.IntPatch_Point_TransitionLineArc2, None, IntPatch_Point)
IntPatch_Point.TransitionOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_TransitionOnS1, None, IntPatch_Point)
IntPatch_Point.TransitionOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_TransitionOnS2, None, IntPatch_Point)
IntPatch_Point.Value = new_instancemethod(_IntPatch.IntPatch_Point_Value, None, IntPatch_Point)
IntPatch_Point.VertexOnS1 = new_instancemethod(_IntPatch.IntPatch_Point_VertexOnS1, None, IntPatch_Point)
IntPatch_Point.VertexOnS2 = new_instancemethod(_IntPatch.IntPatch_Point_VertexOnS2, None, IntPatch_Point)
IntPatch_Point_swigregister = _IntPatch.IntPatch_Point_swigregister
IntPatch_Point_swigregister(IntPatch_Point)

class IntPatch_Polygo(OCC.Core.Intf.Intf_Polygon2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Dump(self, *args) -> "void":
        """:rtype: None"""
        return _IntPatch.IntPatch_Polygo_Dump(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_Polygo_Error(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _IntPatch.IntPatch_Polygo_NbPoints(self, *args)


    def Point(self, *args) -> "gp_Pnt2d":
        """
        :param Index:
        	:type Index: int
        	:rtype: gp_Pnt2d
        """
        return _IntPatch.IntPatch_Polygo_Point(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Polygo
IntPatch_Polygo.Dump = new_instancemethod(_IntPatch.IntPatch_Polygo_Dump, None, IntPatch_Polygo)
IntPatch_Polygo.Error = new_instancemethod(_IntPatch.IntPatch_Polygo_Error, None, IntPatch_Polygo)
IntPatch_Polygo.NbPoints = new_instancemethod(_IntPatch.IntPatch_Polygo_NbPoints, None, IntPatch_Polygo)
IntPatch_Polygo.Point = new_instancemethod(_IntPatch.IntPatch_Polygo_Point, None, IntPatch_Polygo)
IntPatch_Polygo_swigregister = _IntPatch.IntPatch_Polygo_swigregister
IntPatch_Polygo_swigregister(IntPatch_Polygo)

class IntPatch_PolyhedronTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounding(*args) -> "Bnd_Box const &":
        """
        * Give the bounding box of the Polyhedron.
        	:param thePolyh:
        	:type thePolyh: IntPatch_Polyhedron
        	:rtype: Bnd_Box
        """
        return _IntPatch.IntPatch_PolyhedronTool_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def ComponentsBounding(*args) -> "opencascade::handle< Bnd_HArray1OfBox > const &":
        """
        * Give the array of boxes. The box <n> corresponding to the triangle <n>.
        	:param thePolyh:
        	:type thePolyh: IntPatch_Polyhedron
        	:rtype: opencascade::handle<Bnd_HArray1OfBox>
        """
        return _IntPatch.IntPatch_PolyhedronTool_ComponentsBounding(*args)

    ComponentsBounding = staticmethod(ComponentsBounding)

    def DeflectionOverEstimation(*args) -> "Standard_Real":
        """
        * Give the tolerance of the polygon.
        	:param thePolyh:
        	:type thePolyh: IntPatch_Polyhedron
        	:rtype: float
        """
        return _IntPatch.IntPatch_PolyhedronTool_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def NbTriangles(*args) -> "Standard_Integer":
        """
        * Give the number of triangles in this polyedral surface.
        	:param thePolyh:
        	:type thePolyh: IntPatch_Polyhedron
        	:rtype: int
        """
        return _IntPatch.IntPatch_PolyhedronTool_NbTriangles(*args)

    NbTriangles = staticmethod(NbTriangles)

    def Point(*args) -> "gp_Pnt const":
        """
        * Give the point of index i in the polyedral surface.
        	:param thePolyh:
        	:type thePolyh: IntPatch_Polyhedron
        	:param Index:
        	:type Index: int
        	:rtype: gp_Pnt
        """
        return _IntPatch.IntPatch_PolyhedronTool_Point(*args)

    Point = staticmethod(Point)

    def TriConnex(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        * Gives the addresse Tricon of the triangle connexe to the triangle of address Triang by the edge Pivot Pedge and the third point of this connexe triangle. When we are on a free edge TriCon==0 but the function return the value of the triangle in the other side of Pivot on the free edge. Used to turn around a vertex.
        	:param thePolyh:
        	:type thePolyh: IntPatch_Polyhedron
        	:param Triang:
        	:type Triang: int
        	:param Pivot:
        	:type Pivot: int
        	:param Pedge:
        	:type Pedge: int
        	:param TriCon:
        	:type TriCon: int
        	:param OtherP:
        	:type OtherP: int
        	:rtype: int
        """
        return _IntPatch.IntPatch_PolyhedronTool_TriConnex(*args)

    TriConnex = staticmethod(TriConnex)

    def Triangle(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
        """
        * Give the indices of the 3 points of the triangle of address Index in the Polyhedron.
        	:param thePolyh:
        	:type thePolyh: IntPatch_Polyhedron
        	:param Index:
        	:type Index: int
        	:param P1:
        	:type P1: int
        	:param P2:
        	:type P2: int
        	:param P3:
        	:type P3: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_PolyhedronTool_Triangle(*args)

    Triangle = staticmethod(Triangle)

    __repr__ = _dumps_object


    def __init__(self):
        _IntPatch.IntPatch_PolyhedronTool_swiginit(self, _IntPatch.new_IntPatch_PolyhedronTool())
    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyhedronTool
IntPatch_PolyhedronTool_swigregister = _IntPatch.IntPatch_PolyhedronTool_swigregister
IntPatch_PolyhedronTool_swigregister(IntPatch_PolyhedronTool)

def IntPatch_PolyhedronTool_Bounding(*args) -> "Bnd_Box const &":
    """
    * Give the bounding box of the Polyhedron.
    	:param thePolyh:
    	:type thePolyh: IntPatch_Polyhedron
    	:rtype: Bnd_Box
    """
    return _IntPatch.IntPatch_PolyhedronTool_Bounding(*args)

def IntPatch_PolyhedronTool_ComponentsBounding(*args) -> "opencascade::handle< Bnd_HArray1OfBox > const &":
    """
    * Give the array of boxes. The box <n> corresponding to the triangle <n>.
    	:param thePolyh:
    	:type thePolyh: IntPatch_Polyhedron
    	:rtype: opencascade::handle<Bnd_HArray1OfBox>
    """
    return _IntPatch.IntPatch_PolyhedronTool_ComponentsBounding(*args)

def IntPatch_PolyhedronTool_DeflectionOverEstimation(*args) -> "Standard_Real":
    """
    * Give the tolerance of the polygon.
    	:param thePolyh:
    	:type thePolyh: IntPatch_Polyhedron
    	:rtype: float
    """
    return _IntPatch.IntPatch_PolyhedronTool_DeflectionOverEstimation(*args)

def IntPatch_PolyhedronTool_NbTriangles(*args) -> "Standard_Integer":
    """
    * Give the number of triangles in this polyedral surface.
    	:param thePolyh:
    	:type thePolyh: IntPatch_Polyhedron
    	:rtype: int
    """
    return _IntPatch.IntPatch_PolyhedronTool_NbTriangles(*args)

def IntPatch_PolyhedronTool_Point(*args) -> "gp_Pnt const":
    """
    * Give the point of index i in the polyedral surface.
    	:param thePolyh:
    	:type thePolyh: IntPatch_Polyhedron
    	:param Index:
    	:type Index: int
    	:rtype: gp_Pnt
    """
    return _IntPatch.IntPatch_PolyhedronTool_Point(*args)

def IntPatch_PolyhedronTool_TriConnex(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    * Gives the addresse Tricon of the triangle connexe to the triangle of address Triang by the edge Pivot Pedge and the third point of this connexe triangle. When we are on a free edge TriCon==0 but the function return the value of the triangle in the other side of Pivot on the free edge. Used to turn around a vertex.
    	:param thePolyh:
    	:type thePolyh: IntPatch_Polyhedron
    	:param Triang:
    	:type Triang: int
    	:param Pivot:
    	:type Pivot: int
    	:param Pedge:
    	:type Pedge: int
    	:param TriCon:
    	:type TriCon: int
    	:param OtherP:
    	:type OtherP: int
    	:rtype: int
    """
    return _IntPatch.IntPatch_PolyhedronTool_TriConnex(*args)

def IntPatch_PolyhedronTool_Triangle(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
    """
    * Give the indices of the 3 points of the triangle of address Index in the Polyhedron.
    	:param thePolyh:
    	:type thePolyh: IntPatch_Polyhedron
    	:param Index:
    	:type Index: int
    	:param P1:
    	:type P1: int
    	:param P2:
    	:type P2: int
    	:param P3:
    	:type P3: int
    	:rtype: None
    """
    return _IntPatch.IntPatch_PolyhedronTool_Triangle(*args)

class IntPatch_PrmPrmIntersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CodeReject(self, *args) -> "Standard_Integer":
        """
        :param x1:
        	:type x1: float
        	:param y1:
        	:type y1: float
        	:param z1:
        	:type z1: float
        	:param x2:
        	:type x2: float
        	:param y2:
        	:type y2: float
        	:param z2:
        	:type z2: float
        	:param x3:
        	:type x3: float
        	:param y3:
        	:type y3: float
        	:param z3:
        	:type z3: float
        	:rtype: int
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_CodeReject(self, *args)


    def DansGrille(self, *args) -> "Standard_Integer":
        """
        :param t:
        	:type t: int
        	:rtype: int
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_DansGrille(self, *args)


    def GrilleInteger(self, *args) -> "Standard_Integer":
        """
        :param ix:
        	:type ix: int
        	:param iy:
        	:type iy: int
        	:param iz:
        	:type iz: int
        	:rtype: int
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_GrilleInteger(self, *args)


    def __init__(self, *args):
        """
        * Empty Constructor
        	:rtype: None
        """
        _IntPatch.IntPatch_PrmPrmIntersection_swiginit(self, _IntPatch.new_IntPatch_PrmPrmIntersection(*args))

    def IntegerGrille(self, *args) -> "void":
        """
        :param t:
        	:type t: int
        	:param ix:
        	:type ix: int
        	:param iy:
        	:type iy: int
        	:param iz:
        	:type iz: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IntegerGrille(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the calculus was succesfull.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the is no intersection.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IsEmpty(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntPatch_Line > const &":
        """
        * Returns the line of range Index. An exception is raised if Index<=0 or Index>NbLine.
        	:param Index:
        	:type Index: int
        	:rtype: opencascade::handle<IntPatch_Line>
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection lines.
        	:rtype: int
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NbLines(self, *args)


    def NbPointsGrille(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _IntPatch.IntPatch_PrmPrmIntersection_NbPointsGrille(self, *args)


    def NewLine(self, *args) -> "opencascade::handle< IntPatch_Line >":
        """
        * Computes about <NbPoints> Intersection Points on the Line <IndexLine> between the Points of Index <LowPoint> and <HighPoint>. //! All the points of the line of index <IndexLine> with an index between <LowPoint> and <HighPoint> are in the returned line. New Points are inserted between existing points if those points are not too closed. //! An exception is raised if Index<=0 or Index>NbLine. or if IsDone returns False
        	:param Caro1:
        	:type Caro1: Adaptor3d_HSurface
        	:param Caro2:
        	:type Caro2: Adaptor3d_HSurface
        	:param IndexLine:
        	:type IndexLine: int
        	:param LowPoint:
        	:type LowPoint: int
        	:param HighPoint:
        	:type HighPoint: int
        	:param NbPoints:
        	:type NbPoints: int
        	:rtype: opencascade::handle<IntPatch_Line>
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NewLine(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Performs the intersection between <Caro1> and <Caro2>. Associated Polyhedrons <Polyhedron1> and <Polyhedron2> are given.
        	:param Caro1:
        	:type Caro1: Adaptor3d_HSurface
        	:param Polyhedron1:
        	:type Polyhedron1: IntPatch_Polyhedron
        	:param Domain1:
        	:type Domain1: Adaptor3d_TopolTool
        	:param Caro2:
        	:type Caro2: Adaptor3d_HSurface
        	:param Polyhedron2:
        	:type Polyhedron2: IntPatch_Polyhedron
        	:param Domain2:
        	:type Domain2: Adaptor3d_TopolTool
        	:param TolTangency:
        	:type TolTangency: float
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Increment:
        	:type Increment: float
        	:rtype: None
        :param Caro1:
        	:type Caro1: Adaptor3d_HSurface
        	:param Polyhedron1:
        	:type Polyhedron1: IntPatch_Polyhedron
        	:param Domain1:
        	:type Domain1: Adaptor3d_TopolTool
        	:param TolTangency:
        	:type TolTangency: float
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Increment:
        	:type Increment: float
        	:rtype: None
        * Performs the intersection between <Caro1> and <Caro2>. The method computes the polyhedron on each surface.
        	:param Caro1:
        	:type Caro1: Adaptor3d_HSurface
        	:param Domain1:
        	:type Domain1: Adaptor3d_TopolTool
        	:param Caro2:
        	:type Caro2: Adaptor3d_HSurface
        	:param Domain2:
        	:type Domain2: Adaptor3d_TopolTool
        	:param TolTangency:
        	:type TolTangency: float
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Increment:
        	:type Increment: float
        	:param ClearFlag: default value is Standard_True
        	:type ClearFlag: bool
        	:rtype: None
        * Performs the intersection between <Caro1> and <Caro2>. The method computes the polyhedron on each surface.
        	:param Caro1:
        	:type Caro1: Adaptor3d_HSurface
        	:param Domain1:
        	:type Domain1: Adaptor3d_TopolTool
        	:param Caro2:
        	:type Caro2: Adaptor3d_HSurface
        	:param Domain2:
        	:type Domain2: Adaptor3d_TopolTool
        	:param TolTangency:
        	:type TolTangency: float
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Increment:
        	:type Increment: float
        	:param ListOfPnts:
        	:type ListOfPnts: IntSurf_ListOfPntOn2S
        	:rtype: None
        * Performs the intersection between <Caro1> and <Caro2>. The method computes the polyhedron on each surface.
        	:param Caro1:
        	:type Caro1: Adaptor3d_HSurface
        	:param Domain1:
        	:type Domain1: Adaptor3d_TopolTool
        	:param Caro2:
        	:type Caro2: Adaptor3d_HSurface
        	:param Domain2:
        	:type Domain2: Adaptor3d_TopolTool
        	:param U1:
        	:type U1: float
        	:param V1:
        	:type V1: float
        	:param U2:
        	:type U2: float
        	:param V2:
        	:type V2: float
        	:param TolTangency:
        	:type TolTangency: float
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Increment:
        	:type Increment: float
        	:rtype: None
        * Performs the intersection between <Caro1> and <Caro2>. The method computes the polyhedron on each surface.
        	:param Caro1:
        	:type Caro1: Adaptor3d_HSurface
        	:param Domain1:
        	:type Domain1: Adaptor3d_TopolTool
        	:param TolTangency:
        	:type TolTangency: float
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Increment:
        	:type Increment: float
        	:rtype: None
        * Performs the intersection between <Caro1> and <Caro2>. //! The polyhedron which approximates <Caro2>, <Polyhedron2> is given. The other one is computed.
        	:param Caro1:
        	:type Caro1: Adaptor3d_HSurface
        	:param Domain1:
        	:type Domain1: Adaptor3d_TopolTool
        	:param Caro2:
        	:type Caro2: Adaptor3d_HSurface
        	:param Polyhedron2:
        	:type Polyhedron2: IntPatch_Polyhedron
        	:param Domain2:
        	:type Domain2: Adaptor3d_TopolTool
        	:param TolTangency:
        	:type TolTangency: float
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Increment:
        	:type Increment: float
        	:rtype: None
        * Performs the intersection between <Caro1> and <Caro2>. //! The polyhedron which approximates <Caro1>, <Polyhedron1> is given. The other one is computed.
        	:param Caro1:
        	:type Caro1: Adaptor3d_HSurface
        	:param Polyhedron1:
        	:type Polyhedron1: IntPatch_Polyhedron
        	:param Domain1:
        	:type Domain1: Adaptor3d_TopolTool
        	:param Caro2:
        	:type Caro2: Adaptor3d_HSurface
        	:param Domain2:
        	:type Domain2: Adaptor3d_TopolTool
        	:param TolTangency:
        	:type TolTangency: float
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Increment:
        	:type Increment: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Perform(self, *args)


    def PointDepart(self, *args) -> "void":
        """
        :param LineOn2S:
        	:type LineOn2S: IntSurf_LineOn2S
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param SU1:
        	:type SU1: int
        	:param SV1:
        	:type SV1: int
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param SU2:
        	:type SU2: int
        	:param SV2:
        	:type SV2: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_PointDepart(self, *args)


    def Remplit(self, *args) -> "void":
        """
        :param a:
        	:type a: int
        	:param b:
        	:type b: int
        	:param c:
        	:type c: int
        	:param Map:
        	:type Map: IntPatch_PrmPrmIntersection_T3Bits
        	:rtype: None
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Remplit(self, *args)


    def RemplitLin(self, *args) -> "void":
        """
        :param x1:
        	:type x1: int
        	:param y1:
        	:type y1: int
        	:param z1:
        	:type z1: int
        	:param x2:
        	:type x2: int
        	:param y2:
        	:type y2: int
        	:param z2:
        	:type z2: int
        	:param Map:
        	:type Map: IntPatch_PrmPrmIntersection_T3Bits
        	:rtype: None
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_RemplitLin(self, *args)


    def RemplitTri(self, *args) -> "void":
        """
        :param x1:
        	:type x1: int
        	:param y1:
        	:type y1: int
        	:param z1:
        	:type z1: int
        	:param x2:
        	:type x2: int
        	:param y2:
        	:type y2: int
        	:param z2:
        	:type z2: int
        	:param x3:
        	:type x3: int
        	:param y3:
        	:type y3: int
        	:param z3:
        	:type z3: int
        	:param Map:
        	:type Map: IntPatch_PrmPrmIntersection_T3Bits
        	:rtype: None
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_RemplitTri(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PrmPrmIntersection
IntPatch_PrmPrmIntersection.CodeReject = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_CodeReject, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.DansGrille = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_DansGrille, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.GrilleInteger = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_GrilleInteger, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.IntegerGrille = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_IntegerGrille, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.IsDone = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_IsDone, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.IsEmpty = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_IsEmpty, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.Line = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_Line, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.NbLines = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_NbLines, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.NbPointsGrille = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_NbPointsGrille, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.NewLine = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_NewLine, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.Perform = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_Perform, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.PointDepart = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_PointDepart, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.Remplit = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_Remplit, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.RemplitLin = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_RemplitLin, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection.RemplitTri = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_RemplitTri, None, IntPatch_PrmPrmIntersection)
IntPatch_PrmPrmIntersection_swigregister = _IntPatch.IntPatch_PrmPrmIntersection_swigregister
IntPatch_PrmPrmIntersection_swigregister(IntPatch_PrmPrmIntersection)

class IntPatch_PrmPrmIntersection_T3Bits(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        :param t:
        	:type t: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Add(self, *args)


    def And(self, *args) -> "Standard_Integer":
        """
        :param Oth:
        	:type Oth: IntPatch_PrmPrmIntersection_T3Bits
        	:param indiceprecedent:
        	:type indiceprecedent: int
        	:rtype: int
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_And(self, *args)


    def Destroy(self, *args) -> "void":
        """:rtype: None"""
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Destroy(self, *args)


    def __init__(self, *args):
        """
        :param size:
        	:type size: int
        	:rtype: None
        """
        _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_swiginit(self, _IntPatch.new_IntPatch_PrmPrmIntersection_T3Bits(*args))

    def Raz(self, *args) -> "void":
        """
        :param t:
        	:type t: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Raz(self, *args)


    def ResetAnd(self, *args) -> "void":
        """:rtype: None"""
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_ResetAnd(self, *args)


    def Val(self, *args) -> "Standard_Integer":
        """
        :param t:
        	:type t: int
        	:rtype: int
        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Val(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PrmPrmIntersection_T3Bits
IntPatch_PrmPrmIntersection_T3Bits.Add = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Add, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.And = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_And, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.Destroy = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Destroy, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.Raz = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Raz, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.ResetAnd = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_ResetAnd, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits.Val = new_instancemethod(_IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Val, None, IntPatch_PrmPrmIntersection_T3Bits)
IntPatch_PrmPrmIntersection_T3Bits_swigregister = _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_swigregister
IntPatch_PrmPrmIntersection_T3Bits_swigregister(IntPatch_PrmPrmIntersection_T3Bits)

class IntPatch_RstInt(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def PutVertexOnLine(*args) -> "void":
        """
        :param L:
        	:type L: IntPatch_Line
        	:param Surf:
        	:type Surf: Adaptor3d_HSurface
        	:param Domain:
        	:type Domain: Adaptor3d_TopolTool
        	:param OtherSurf:
        	:type OtherSurf: Adaptor3d_HSurface
        	:param OnFirst:
        	:type OnFirst: bool
        	:param Tol:
        	:type Tol: float
        	:rtype: void
        """
        return _IntPatch.IntPatch_RstInt_PutVertexOnLine(*args)

    PutVertexOnLine = staticmethod(PutVertexOnLine)

    __repr__ = _dumps_object


    def __init__(self):
        _IntPatch.IntPatch_RstInt_swiginit(self, _IntPatch.new_IntPatch_RstInt())
    __swig_destroy__ = _IntPatch.delete_IntPatch_RstInt
IntPatch_RstInt_swigregister = _IntPatch.IntPatch_RstInt_swigregister
IntPatch_RstInt_swigregister(IntPatch_RstInt)

def IntPatch_RstInt_PutVertexOnLine(*args) -> "void":
    """
    :param L:
    	:type L: IntPatch_Line
    	:param Surf:
    	:type Surf: Adaptor3d_HSurface
    	:param Domain:
    	:type Domain: Adaptor3d_TopolTool
    	:param OtherSurf:
    	:type OtherSurf: Adaptor3d_HSurface
    	:param OnFirst:
    	:type OnFirst: bool
    	:param Tol:
    	:type Tol: float
    	:rtype: void
    """
    return _IntPatch.IntPatch_RstInt_PutVertexOnLine(*args)

class IntPatch_SpecialPoints(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddCrossUVIsoPoint(*args) -> "Standard_Boolean":
        """
        * Adds the point defined as intersection of two isolines (U = 0 and V = 0) on theQSurf in theLine. theRefPt is used to correct adjusting parameters. If theIsReversed is True then theQSurf correspond to the second (otherwise, the first) surface while forming intersection point IntSurf_PntOn2S.
        	:param theQSurf:
        	:type theQSurf: Adaptor3d_HSurface
        	:param thePSurf:
        	:type thePSurf: Adaptor3d_HSurface
        	:param theRefPt:
        	:type theRefPt: IntSurf_PntOn2S
        	:param theTol3d:
        	:type theTol3d: float
        	:param theAddedPoint:
        	:type theAddedPoint: IntSurf_PntOn2S
        	:param theIsReversed: default value is Standard_False
        	:type theIsReversed: bool
        	:rtype: bool
        """
        return _IntPatch.IntPatch_SpecialPoints_AddCrossUVIsoPoint(*args)

    AddCrossUVIsoPoint = staticmethod(AddCrossUVIsoPoint)

    def AddPointOnUorVIso(*args) -> "Standard_Boolean":
        """
        * Adds the point lain strictly in the isoline U = 0 or V = 0 of theQSurf, in theLine. theRefPt is used to correct adjusting parameters. If theIsReversed is True then theQSurf corresponds to the second (otherwise, the first) surface while forming intersection point IntSurf_PntOn2S. All math_Vector-objects must be filled as follows: [1] - U-parameter of thePSurf; [2] - V-parameter of thePSurf; [3] - U- (if V-isoline is considered) or V-parameter (if U-isoline is considered) of theQSurf.
        	:param theQSurf:
        	:type theQSurf: Adaptor3d_HSurface
        	:param thePSurf:
        	:type thePSurf: Adaptor3d_HSurface
        	:param theRefPt:
        	:type theRefPt: IntSurf_PntOn2S
        	:param theIsU:
        	:type theIsU: bool
        	:param theIsoParameter:
        	:type theIsoParameter: float
        	:param theToler:
        	:type theToler: math_Vector
        	:param theInitPoint:
        	:type theInitPoint: math_Vector
        	:param theInfBound:
        	:type theInfBound: math_Vector
        	:param theSupBound:
        	:type theSupBound: math_Vector
        	:param theAddedPoint:
        	:type theAddedPoint: IntSurf_PntOn2S
        	:param theIsReversed: default value is Standard_False
        	:type theIsReversed: bool
        	:rtype: bool
        """
        return _IntPatch.IntPatch_SpecialPoints_AddPointOnUorVIso(*args)

    AddPointOnUorVIso = staticmethod(AddPointOnUorVIso)

    def AddSingularPole(*args) -> "Standard_Boolean":
        """
        * Computes the pole of sphere to add it in the intersection line. Stores the result in theAddedPoint variable (does not add in the line). At that, cone and sphere (with singularity) must be set in theQSurf parameter. By default (if theIsReversed == False), theQSurf is the first surface of the Walking line. If it is not, theIsReversed parameter must be set to True. theIsReqRefCheck is True if and only if 3D-point of theRefPt must be pole or apex for check (e.g. if it is vertex). thePtIso is the reference point for obtaining isoline where must be placed the Apex/Pole. //! ATTENTION!!! theVertex must be initialized before calling the method .
        	:param theQSurf:
        	:type theQSurf: Adaptor3d_HSurface
        	:param thePSurf:
        	:type thePSurf: Adaptor3d_HSurface
        	:param thePtIso:
        	:type thePtIso: IntSurf_PntOn2S
        	:param theVertex:
        	:type theVertex: IntPatch_Point
        	:param theAddedPoint:
        	:type theAddedPoint: IntSurf_PntOn2S
        	:param theIsReversed: default value is Standard_False
        	:type theIsReversed: bool
        	:param theIsReqRefCheck: default value is Standard_False
        	:type theIsReqRefCheck: bool
        	:rtype: bool
        """
        return _IntPatch.IntPatch_SpecialPoints_AddSingularPole(*args)

    AddSingularPole = staticmethod(AddSingularPole)

    def AdjustPointAndVertex(*args) -> "void":
        """
        * Sets theNewPoint parameters in 2D-space the closest to theRefPoint with help of adding/subtracting corresponding periods. theArrPeriods must be filled as follows: {<U-period of 1st surface>, <V-period of 1st surface>, <U-period of 2nd surface>, <V-period of 2nd surface>}. If theVertex != 0 then its parameters will be filled as corresponding parameters of theNewPoint. //! ATTENTION!!! theNewPoint is not only Output parameter. It is Input/Output one. I.e. theNewPoint is reference point together with theRefPt.
        	:param theRefPoint:
        	:type theRefPoint: IntSurf_PntOn2S
        	:param theArrPeriods:
        	:type theArrPeriods: float
        	:param theNewPoint:
        	:type theNewPoint: IntSurf_PntOn2S
        	:param theVertex: default value is 0
        	:type theVertex: IntPatch_Point *
        	:rtype: void
        """
        return _IntPatch.IntPatch_SpecialPoints_AdjustPointAndVertex(*args)

    AdjustPointAndVertex = staticmethod(AdjustPointAndVertex)

    def ContinueAfterSpecialPoint(*args) -> "Standard_Boolean":
        """
        * Special point has already been added in the line. Now, we need in correct prolongation of the line or in start new line. This function returns new point. //! ATTENTION!!! theNewPoint is not only Output parameter. It is Input/Output one. I.e. theNewPoint is reference point together with theRefPt.
        	:param theQSurf:
        	:type theQSurf: Adaptor3d_HSurface
        	:param thePSurf:
        	:type thePSurf: Adaptor3d_HSurface
        	:param theRefPt:
        	:type theRefPt: IntSurf_PntOn2S
        	:param theSPType:
        	:type theSPType: IntPatch_SpecPntType
        	:param theTol2D:
        	:type theTol2D: float
        	:param theNewPoint:
        	:type theNewPoint: IntSurf_PntOn2S
        	:param theIsReversed: default value is Standard_False
        	:type theIsReversed: bool
        	:rtype: bool
        """
        return _IntPatch.IntPatch_SpecialPoints_ContinueAfterSpecialPoint(*args)

    ContinueAfterSpecialPoint = staticmethod(ContinueAfterSpecialPoint)

    __repr__ = _dumps_object


    def __init__(self):
        _IntPatch.IntPatch_SpecialPoints_swiginit(self, _IntPatch.new_IntPatch_SpecialPoints())
    __swig_destroy__ = _IntPatch.delete_IntPatch_SpecialPoints
IntPatch_SpecialPoints_swigregister = _IntPatch.IntPatch_SpecialPoints_swigregister
IntPatch_SpecialPoints_swigregister(IntPatch_SpecialPoints)

def IntPatch_SpecialPoints_AddCrossUVIsoPoint(*args) -> "Standard_Boolean":
    """
    * Adds the point defined as intersection of two isolines (U = 0 and V = 0) on theQSurf in theLine. theRefPt is used to correct adjusting parameters. If theIsReversed is True then theQSurf correspond to the second (otherwise, the first) surface while forming intersection point IntSurf_PntOn2S.
    	:param theQSurf:
    	:type theQSurf: Adaptor3d_HSurface
    	:param thePSurf:
    	:type thePSurf: Adaptor3d_HSurface
    	:param theRefPt:
    	:type theRefPt: IntSurf_PntOn2S
    	:param theTol3d:
    	:type theTol3d: float
    	:param theAddedPoint:
    	:type theAddedPoint: IntSurf_PntOn2S
    	:param theIsReversed: default value is Standard_False
    	:type theIsReversed: bool
    	:rtype: bool
    """
    return _IntPatch.IntPatch_SpecialPoints_AddCrossUVIsoPoint(*args)

def IntPatch_SpecialPoints_AddPointOnUorVIso(*args) -> "Standard_Boolean":
    """
    * Adds the point lain strictly in the isoline U = 0 or V = 0 of theQSurf, in theLine. theRefPt is used to correct adjusting parameters. If theIsReversed is True then theQSurf corresponds to the second (otherwise, the first) surface while forming intersection point IntSurf_PntOn2S. All math_Vector-objects must be filled as follows: [1] - U-parameter of thePSurf; [2] - V-parameter of thePSurf; [3] - U- (if V-isoline is considered) or V-parameter (if U-isoline is considered) of theQSurf.
    	:param theQSurf:
    	:type theQSurf: Adaptor3d_HSurface
    	:param thePSurf:
    	:type thePSurf: Adaptor3d_HSurface
    	:param theRefPt:
    	:type theRefPt: IntSurf_PntOn2S
    	:param theIsU:
    	:type theIsU: bool
    	:param theIsoParameter:
    	:type theIsoParameter: float
    	:param theToler:
    	:type theToler: math_Vector
    	:param theInitPoint:
    	:type theInitPoint: math_Vector
    	:param theInfBound:
    	:type theInfBound: math_Vector
    	:param theSupBound:
    	:type theSupBound: math_Vector
    	:param theAddedPoint:
    	:type theAddedPoint: IntSurf_PntOn2S
    	:param theIsReversed: default value is Standard_False
    	:type theIsReversed: bool
    	:rtype: bool
    """
    return _IntPatch.IntPatch_SpecialPoints_AddPointOnUorVIso(*args)

def IntPatch_SpecialPoints_AddSingularPole(*args) -> "Standard_Boolean":
    """
    * Computes the pole of sphere to add it in the intersection line. Stores the result in theAddedPoint variable (does not add in the line). At that, cone and sphere (with singularity) must be set in theQSurf parameter. By default (if theIsReversed == False), theQSurf is the first surface of the Walking line. If it is not, theIsReversed parameter must be set to True. theIsReqRefCheck is True if and only if 3D-point of theRefPt must be pole or apex for check (e.g. if it is vertex). thePtIso is the reference point for obtaining isoline where must be placed the Apex/Pole. //! ATTENTION!!! theVertex must be initialized before calling the method .
    	:param theQSurf:
    	:type theQSurf: Adaptor3d_HSurface
    	:param thePSurf:
    	:type thePSurf: Adaptor3d_HSurface
    	:param thePtIso:
    	:type thePtIso: IntSurf_PntOn2S
    	:param theVertex:
    	:type theVertex: IntPatch_Point
    	:param theAddedPoint:
    	:type theAddedPoint: IntSurf_PntOn2S
    	:param theIsReversed: default value is Standard_False
    	:type theIsReversed: bool
    	:param theIsReqRefCheck: default value is Standard_False
    	:type theIsReqRefCheck: bool
    	:rtype: bool
    """
    return _IntPatch.IntPatch_SpecialPoints_AddSingularPole(*args)

def IntPatch_SpecialPoints_AdjustPointAndVertex(*args) -> "void":
    """
    * Sets theNewPoint parameters in 2D-space the closest to theRefPoint with help of adding/subtracting corresponding periods. theArrPeriods must be filled as follows: {<U-period of 1st surface>, <V-period of 1st surface>, <U-period of 2nd surface>, <V-period of 2nd surface>}. If theVertex != 0 then its parameters will be filled as corresponding parameters of theNewPoint. //! ATTENTION!!! theNewPoint is not only Output parameter. It is Input/Output one. I.e. theNewPoint is reference point together with theRefPt.
    	:param theRefPoint:
    	:type theRefPoint: IntSurf_PntOn2S
    	:param theArrPeriods:
    	:type theArrPeriods: float
    	:param theNewPoint:
    	:type theNewPoint: IntSurf_PntOn2S
    	:param theVertex: default value is 0
    	:type theVertex: IntPatch_Point *
    	:rtype: void
    """
    return _IntPatch.IntPatch_SpecialPoints_AdjustPointAndVertex(*args)

def IntPatch_SpecialPoints_ContinueAfterSpecialPoint(*args) -> "Standard_Boolean":
    """
    * Special point has already been added in the line. Now, we need in correct prolongation of the line or in start new line. This function returns new point. //! ATTENTION!!! theNewPoint is not only Output parameter. It is Input/Output one. I.e. theNewPoint is reference point together with theRefPt.
    	:param theQSurf:
    	:type theQSurf: Adaptor3d_HSurface
    	:param thePSurf:
    	:type thePSurf: Adaptor3d_HSurface
    	:param theRefPt:
    	:type theRefPt: IntSurf_PntOn2S
    	:param theSPType:
    	:type theSPType: IntPatch_SpecPntType
    	:param theTol2D:
    	:type theTol2D: float
    	:param theNewPoint:
    	:type theNewPoint: IntSurf_PntOn2S
    	:param theIsReversed: default value is Standard_False
    	:type theIsReversed: bool
    	:rtype: bool
    """
    return _IntPatch.IntPatch_SpecialPoints_ContinueAfterSpecialPoint(*args)

class IntPatch_TheIWLineOfTheIWalking(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddIndexPassing(self, *args) -> "void":
        """
        * associer a l 'indice du point sur la ligne l'indice du point passant dans l'iterateur de depart
        	:param Index:
        	:type Index: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddIndexPassing(self, *args)


    def AddPoint(self, *args) -> "void":
        """
        * Add a point in the line.
        	:param P:
        	:type P: IntSurf_PntOn2S
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddPoint(self, *args)


    def AddStatusFirst(self, *args) -> "void":
        """
        :param Closed:
        	:type Closed: bool
        	:param HasFirst:
        	:type HasFirst: bool
        	:rtype: None
        :param Closed:
        	:type Closed: bool
        	:param HasLast:
        	:type HasLast: bool
        	:param Index:
        	:type Index: int
        	:param P:
        	:type P: IntSurf_PathPoint
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirst(self, *args)


    def AddStatusFirstLast(self, *args) -> "void":
        """
        :param Closed:
        	:type Closed: bool
        	:param HasFirst:
        	:type HasFirst: bool
        	:param HasLast:
        	:type HasLast: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirstLast(self, *args)


    def AddStatusLast(self, *args) -> "void":
        """
        :param HasLast:
        	:type HasLast: bool
        	:rtype: None
        :param HasLast:
        	:type HasLast: bool
        	:param Index:
        	:type Index: int
        	:param P:
        	:type P: IntSurf_PathPoint
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusLast(self, *args)


    def Cut(self, *args) -> "void":
        """
        * Cut the line at the point of rank Index.
        	:param Index:
        	:type Index: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Cut(self, *args)


    def FirstPoint(self, *args) -> "IntSurf_PathPoint const &":
        """
        * Returns the first point of the line when it is a marching point. An exception is raised if HasFirstPoint returns False.
        	:rtype: IntSurf_PathPoint
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPoint(self, *args)


    def FirstPointIndex(self, *args) -> "Standard_Integer":
        """
        * Returns the Index of first point of the line when it is a marching point.This index is the index in the PointStartIterator. An exception is raised if HasFirstPoint returns False.
        	:rtype: int
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPointIndex(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the first point of the line is a marching point . when is HasFirstPoint==False ,the line begins on the natural bound of the surface.the line can be too long
        	:rtype: bool
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the end point of the line is a marching point (Point from IntWS). when is HasFirstPoint==False ,the line ends on the natural bound of the surface.the line can be too long.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_HasLastPoint(self, *args)


    def __init__(self, *args):
        """
        :param theAllocator: default value is 0
        	:type theAllocator: IntSurf_Allocator
        	:rtype: None
        """
        _IntPatch.IntPatch_TheIWLineOfTheIWalking_swiginit(self, _IntPatch.new_IntPatch_TheIWLineOfTheIWalking(*args))

    def IsClosed(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line is closed.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsClosed(self, *args)


    def IsTangentAtBegining(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtBegining(self, *args)


    def IsTangentAtEnd(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtEnd(self, *args)


    def LastPoint(self, *args) -> "IntSurf_PathPoint const &":
        """
        * Returns the last point of the line when it is a marching point. An exception is raised if HasLastPoint returns False.
        	:rtype: IntSurf_PathPoint
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPoint(self, *args)


    def LastPointIndex(self, *args) -> "Standard_Integer":
        """
        * Returns the index of last point of the line when it is a marching point.This index is the index in the PointStartIterator. An exception is raised if HasLastPoint returns False.
        	:rtype: int
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPointIndex(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntSurf_LineOn2S > const &":
        """
        * Returns the LineOn2S contained in the walking line.
        	:rtype: opencascade::handle<IntSurf_LineOn2S>
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Line(self, *args)


    def NbPassingPoint(self, *args) -> "Standard_Integer":
        """
        * returns the number of points belonging to Pnts1 which are passing point.
        	:rtype: int
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPassingPoint(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * Returns the number of points of the line (including first point and end point : see HasLastPoint and HasFirstPoint).
        	:rtype: int
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPoints(self, *args)


    def PassingPoint(self, *args) -> "void":
        """
        * returns the index of the point belonging to the line which is associated to the passing point belonging to Pnts1 an exception is raised if Index > NbPassingPoint()
        	:param Index:
        	:type Index: int
        	:param IndexLine:
        	:type IndexLine: int
        	:param IndexPnts:
        	:type IndexPnts: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_PassingPoint(self, *args)


    def Reverse(self, *args) -> "void":
        """
        * reverse the points in the line. Hasfirst, HasLast are kept.
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Reverse(self, *args)


    def SetTangencyAtBegining(self, *args) -> "void":
        """
        :param IsTangent:
        	:type IsTangent: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtBegining(self, *args)


    def SetTangencyAtEnd(self, *args) -> "void":
        """
        :param IsTangent:
        	:type IsTangent: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtEnd(self, *args)


    def SetTangentVector(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:param Index:
        	:type Index: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangentVector(self, *args)


    def TangentVector(self, *args) -> "gp_Vec const":
        """
        :param Index:
        	:type Index: int
        	:rtype: gp_Vec
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_TangentVector(self, *args)


    def Value(self, *args) -> "IntSurf_PntOn2S const &":
        """
        * Returns the point of range Index. If index <= 0 or Index > NbPoints, an exception is raised.
        	:param Index:
        	:type Index: int
        	:rtype: IntSurf_PntOn2S
        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheIWLineOfTheIWalking
IntPatch_TheIWLineOfTheIWalking.AddIndexPassing = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddIndexPassing, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.AddPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.AddStatusFirst = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirst, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.AddStatusFirstLast = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirstLast, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.AddStatusLast = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusLast, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.Cut = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_Cut, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.FirstPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.FirstPointIndex = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPointIndex, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_HasFirstPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_HasLastPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.IsClosed = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_IsClosed, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.IsTangentAtBegining = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtBegining, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.IsTangentAtEnd = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtEnd, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.LastPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.LastPointIndex = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPointIndex, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.Line = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_Line, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.NbPassingPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPassingPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.NbPoints = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPoints, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.PassingPoint = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_PassingPoint, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.Reverse = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_Reverse, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.SetTangencyAtBegining = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtBegining, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.SetTangencyAtEnd = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtEnd, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.SetTangentVector = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangentVector, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.TangentVector = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_TangentVector, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking.Value = new_instancemethod(_IntPatch.IntPatch_TheIWLineOfTheIWalking_Value, None, IntPatch_TheIWLineOfTheIWalking)
IntPatch_TheIWLineOfTheIWalking_swigregister = _IntPatch.IntPatch_TheIWLineOfTheIWalking_swigregister
IntPatch_TheIWLineOfTheIWalking_swigregister(IntPatch_TheIWLineOfTheIWalking)

class IntPatch_TheIWalking(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Deflection is the maximum deflection admitted between two consecutive points on a resulting polyline. Step is the maximum increment admitted between two consecutive points (in 2d space). Epsilon is the tolerance beyond which 2 points are confused. theToFillHoles is the flag defining whether possible holes between resulting curves are filled or not in case of IntPatch walking theToFillHoles is False
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Step:
        	:type Step: float
        	:param theToFillHoles: default value is Standard_False
        	:type theToFillHoles: bool
        	:rtype: None
        """
        _IntPatch.IntPatch_TheIWalking_swiginit(self, _IntPatch.new_IntPatch_TheIWalking(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the calculus was successful.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_TheIWalking_IsDone(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns the number of resulting polylines. An exception is raised if IsDone returns False.
        	:rtype: int
        """
        return _IntPatch.IntPatch_TheIWalking_NbLines(self, *args)


    def NbSinglePnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of points belonging to Pnts on which no line starts or ends. An exception is raised if IsDone returns False.
        	:rtype: int
        """
        return _IntPatch.IntPatch_TheIWalking_NbSinglePnts(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Searches a set of polylines starting on a point of Pnts1 or Pnts2. Each point on a resulting polyline verifies F(u,v)=0
        	:param Pnts1:
        	:type Pnts1: IntSurf_SequenceOfPathPoint
        	:param Pnts2:
        	:type Pnts2: IntSurf_SequenceOfInteriorPoint
        	:param Func:
        	:type Func: IntPatch_TheSurfFunction
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param Reversed: default value is Standard_False
        	:type Reversed: bool
        	:rtype: None
        * Searches a set of polylines starting on a point of Pnts1. Each point on a resulting polyline verifies F(u,v)=0
        	:param Pnts1:
        	:type Pnts1: IntSurf_SequenceOfPathPoint
        	:param Func:
        	:type Func: IntPatch_TheSurfFunction
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param Reversed: default value is Standard_False
        	:type Reversed: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWalking_Perform(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Deflection is the maximum deflection admitted between two consecutive points on a resulting polyline. Step is the maximum increment admitted between two consecutive points (in 2d space). Epsilon is the tolerance beyond which 2 points are confused
        	:param Epsilon:
        	:type Epsilon: float
        	:param Deflection:
        	:type Deflection: float
        	:param Step:
        	:type Step: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheIWalking_SetTolerance(self, *args)


    def SinglePnt(self, *args) -> "IntSurf_PathPoint const &":
        """
        * Returns the point of range Index . An exception is raised if IsDone returns False. An exception is raised if Index<=0 or Index > NbSinglePnts.
        	:param Index:
        	:type Index: int
        	:rtype: IntSurf_PathPoint
        """
        return _IntPatch.IntPatch_TheIWalking_SinglePnt(self, *args)


    def Value(self, *args) -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking > const &":
        """
        * Returns the polyline of range Index. An exception is raised if IsDone is False. An exception is raised if Index<=0 or Index>NbLines.
        	:param Index:
        	:type Index: int
        	:rtype: opencascade::handle<IntPatch_TheIWLineOfTheIWalking>
        """
        return _IntPatch.IntPatch_TheIWalking_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheIWalking
IntPatch_TheIWalking.IsDone = new_instancemethod(_IntPatch.IntPatch_TheIWalking_IsDone, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.NbLines = new_instancemethod(_IntPatch.IntPatch_TheIWalking_NbLines, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.NbSinglePnts = new_instancemethod(_IntPatch.IntPatch_TheIWalking_NbSinglePnts, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.Perform = new_instancemethod(_IntPatch.IntPatch_TheIWalking_Perform, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.SetTolerance = new_instancemethod(_IntPatch.IntPatch_TheIWalking_SetTolerance, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.SinglePnt = new_instancemethod(_IntPatch.IntPatch_TheIWalking_SinglePnt, None, IntPatch_TheIWalking)
IntPatch_TheIWalking.Value = new_instancemethod(_IntPatch.IntPatch_TheIWalking_Value, None, IntPatch_TheIWalking)
IntPatch_TheIWalking_swigregister = _IntPatch.IntPatch_TheIWalking_swigregister
IntPatch_TheIWalking_swigregister(IntPatch_TheIWalking)

class IntPatch_ThePathPointOfTheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Arc(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """:rtype: opencascade::handle<Adaptor2d_HCurve2d>"""
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Arc(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param P:
        	:type P: gp_Pnt
        	:param Tol:
        	:type Tol: float
        	:param V:
        	:type V: Adaptor3d_HVertex
        	:param A:
        	:type A: Adaptor2d_HCurve2d
        	:param Parameter:
        	:type Parameter: float
        	:rtype: None
        :param P:
        	:type P: gp_Pnt
        	:param Tol:
        	:type Tol: float
        	:param A:
        	:type A: Adaptor2d_HCurve2d
        	:param Parameter:
        	:type Parameter: float
        	:rtype: None
        """
        _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_ThePathPointOfTheSOnBounds(*args))

    def IsNew(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_IsNew(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Parameter(self, *args)


    def SetValue(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param Tol:
        	:type Tol: float
        	:param V:
        	:type V: Adaptor3d_HVertex
        	:param A:
        	:type A: Adaptor2d_HCurve2d
        	:param Parameter:
        	:type Parameter: float
        	:rtype: None
        :param P:
        	:type P: gp_Pnt
        	:param Tol:
        	:type Tol: float
        	:param A:
        	:type A: Adaptor2d_HCurve2d
        	:param Parameter:
        	:type Parameter: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_SetValue(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Tolerance(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Value(self, *args)


    def Vertex(self, *args) -> "opencascade::handle< Adaptor3d_HVertex > const &":
        """:rtype: opencascade::handle<Adaptor3d_HVertex>"""
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Vertex(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ThePathPointOfTheSOnBounds
IntPatch_ThePathPointOfTheSOnBounds.Arc = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Arc, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.IsNew = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_IsNew, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.Parameter = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Parameter, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.SetValue = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_SetValue, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.Tolerance = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Tolerance, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.Value = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Value, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds.Vertex = new_instancemethod(_IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Vertex, None, IntPatch_ThePathPointOfTheSOnBounds)
IntPatch_ThePathPointOfTheSOnBounds_swigregister = _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_swigregister
IntPatch_ThePathPointOfTheSOnBounds_swigregister(IntPatch_ThePathPointOfTheSOnBounds)

class IntPatch_TheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AllArcSolution(self, *args) -> "Standard_Boolean":
        """
        * Returns true if all arc of the Arcs are solution (inside the surface). An exception is raised if IsDone returns False.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_TheSOnBounds_AllArcSolution(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        """
        _IntPatch.IntPatch_TheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_TheSOnBounds(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the calculus was successful.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_TheSOnBounds_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * Returns the number of resulting points. An exception is raised if IsDone returns False (NotDone).
        	:rtype: int
        """
        return _IntPatch.IntPatch_TheSOnBounds_NbPoints(self, *args)


    def NbSegments(self, *args) -> "Standard_Integer":
        """
        * Returns the number of the resulting segments. An exception is raised if IsDone returns False (NotDone).
        	:rtype: int
        """
        return _IntPatch.IntPatch_TheSOnBounds_NbSegments(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Algorithm to find the points and parts of curves of Domain (domain of of restriction of a surface) which verify F = 0. TolBoundary defines if a curve is on Q. TolTangency defines if a point is on Q.
        	:param F:
        	:type F: IntPatch_ArcFunction
        	:param Domain:
        	:type Domain: Adaptor3d_TopolTool
        	:param TolBoundary:
        	:type TolBoundary: float
        	:param TolTangency:
        	:type TolTangency: float
        	:param RecheckOnRegularity: default value is Standard_False
        	:type RecheckOnRegularity: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheSOnBounds_Perform(self, *args)


    def Point(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        * Returns the resulting point of range Index. The exception NotDone is raised if IsDone() returns False. The exception OutOfRange is raised if Index <= 0 or Index > NbPoints.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_ThePathPointOfTheSOnBounds
        """
        return _IntPatch.IntPatch_TheSOnBounds_Point(self, *args)


    def Segment(self, *args) -> "IntPatch_TheSegmentOfTheSOnBounds const &":
        """
        * Returns the resulting segment of range Index. The exception NotDone is raised if IsDone() returns False. The exception OutOfRange is raised if Index <= 0 or Index > NbPoints.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_TheSegmentOfTheSOnBounds
        """
        return _IntPatch.IntPatch_TheSOnBounds_Segment(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSOnBounds
IntPatch_TheSOnBounds.AllArcSolution = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_AllArcSolution, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.IsDone = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_IsDone, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.NbPoints = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_NbPoints, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.NbSegments = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_NbSegments, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.Perform = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_Perform, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.Point = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_Point, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds.Segment = new_instancemethod(_IntPatch.IntPatch_TheSOnBounds_Segment, None, IntPatch_TheSOnBounds)
IntPatch_TheSOnBounds_swigregister = _IntPatch.IntPatch_TheSOnBounds_swigregister
IntPatch_TheSOnBounds_swigregister(IntPatch_TheSOnBounds)

class IntPatch_TheSearchInside(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param F:
        	:type F: IntPatch_TheSurfFunction
        	:param Surf:
        	:type Surf: Adaptor3d_HSurface
        	:param T:
        	:type T: Adaptor3d_TopolTool
        	:param Epsilon:
        	:type Epsilon: float
        	:rtype: None
        """
        _IntPatch.IntPatch_TheSearchInside_swiginit(self, _IntPatch.new_IntPatch_TheSearchInside(*args))

    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntPatch.IntPatch_TheSearchInside_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * Returns the number of points. The exception NotDone if raised if IsDone returns False.
        	:rtype: int
        """
        return _IntPatch.IntPatch_TheSearchInside_NbPoints(self, *args)


    def Perform(self, *args) -> "void":
        """
        :param F:
        	:type F: IntPatch_TheSurfFunction
        	:param Surf:
        	:type Surf: Adaptor3d_HSurface
        	:param T:
        	:type T: Adaptor3d_TopolTool
        	:param Epsilon:
        	:type Epsilon: float
        	:rtype: None
        :param F:
        	:type F: IntPatch_TheSurfFunction
        	:param Surf:
        	:type Surf: Adaptor3d_HSurface
        	:param UStart:
        	:type UStart: float
        	:param VStart:
        	:type VStart: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheSearchInside_Perform(self, *args)


    def Value(self, *args) -> "IntSurf_InteriorPoint const &":
        """
        * Returns the point of range Index. The exception NotDone if raised if IsDone returns False. The exception OutOfRange if raised if Index <= 0 or Index > NbPoints.
        	:param Index:
        	:type Index: int
        	:rtype: IntSurf_InteriorPoint
        """
        return _IntPatch.IntPatch_TheSearchInside_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSearchInside
IntPatch_TheSearchInside.IsDone = new_instancemethod(_IntPatch.IntPatch_TheSearchInside_IsDone, None, IntPatch_TheSearchInside)
IntPatch_TheSearchInside.NbPoints = new_instancemethod(_IntPatch.IntPatch_TheSearchInside_NbPoints, None, IntPatch_TheSearchInside)
IntPatch_TheSearchInside.Perform = new_instancemethod(_IntPatch.IntPatch_TheSearchInside_Perform, None, IntPatch_TheSearchInside)
IntPatch_TheSearchInside.Value = new_instancemethod(_IntPatch.IntPatch_TheSearchInside_Value, None, IntPatch_TheSearchInside)
IntPatch_TheSearchInside_swigregister = _IntPatch.IntPatch_TheSearchInside_swigregister
IntPatch_TheSearchInside_swigregister(IntPatch_TheSearchInside)

class IntPatch_TheSegmentOfTheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Curve(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        * Returns the geometric curve on the surface 's domain which is solution.
        	:rtype: opencascade::handle<Adaptor2d_HCurve2d>
        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_Curve(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        * Returns the first point.
        	:rtype: IntPatch_ThePathPointOfTheSOnBounds
        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_FirstPoint(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there is a vertex (ThePathPoint) defining the lowest valid parameter on the arc.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there is a vertex (ThePathPoint) defining the greatest valid parameter on the arc.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasLastPoint(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        """
        _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_swiginit(self, _IntPatch.new_IntPatch_TheSegmentOfTheSOnBounds(*args))

    def LastPoint(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        * Returns the last point.
        	:rtype: IntPatch_ThePathPointOfTheSOnBounds
        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_LastPoint(self, *args)


    def SetLimitPoint(self, *args) -> "void":
        """
        * Defines the first point or the last point, depending on the value of the boolean First.
        	:param V:
        	:type V: IntPatch_ThePathPointOfTheSOnBounds
        	:param First:
        	:type First: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetLimitPoint(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Defines the concerned arc.
        	:param A:
        	:type A: Adaptor2d_HCurve2d
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetValue(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSegmentOfTheSOnBounds
IntPatch_TheSegmentOfTheSOnBounds.Curve = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_Curve, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.FirstPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_FirstPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasFirstPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasLastPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.LastPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_LastPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.SetLimitPoint = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetLimitPoint, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds.SetValue = new_instancemethod(_IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetValue, None, IntPatch_TheSegmentOfTheSOnBounds)
IntPatch_TheSegmentOfTheSOnBounds_swigregister = _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_swigregister
IntPatch_TheSegmentOfTheSOnBounds_swigregister(IntPatch_TheSegmentOfTheSOnBounds)

class IntPatch_TheSurfFunction(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Direction2d(self, *args) -> "gp_Dir2d const":
        """:rtype: gp_Dir2d"""
        return _IntPatch.IntPatch_TheSurfFunction_Direction2d(self, *args)


    def Direction3d(self, *args) -> "gp_Vec const":
        """:rtype: gp_Vec"""
        return _IntPatch.IntPatch_TheSurfFunction_Direction3d(self, *args)


    def ISurface(self, *args) -> "IntSurf_Quadric const &":
        """:rtype: IntSurf_Quadric"""
        return _IntPatch.IntPatch_TheSurfFunction_ISurface(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param PS:
        	:type PS: Adaptor3d_HSurface
        	:param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        :param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        """
        _IntPatch.IntPatch_TheSurfFunction_swiginit(self, _IntPatch.new_IntPatch_TheSurfFunction(*args))

    def IsTangent(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntPatch.IntPatch_TheSurfFunction_IsTangent(self, *args)


    def PSurface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """:rtype: opencascade::handle<Adaptor3d_HSurface>"""
        return _IntPatch.IntPatch_TheSurfFunction_PSurface(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """:rtype: gp_Pnt"""
        return _IntPatch.IntPatch_TheSurfFunction_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_TheSurfFunction_Root(self, *args)


    def Set(self, *args) -> "void":
        """
        :param PS:
        	:type PS: Adaptor3d_HSurface
        	:rtype: None
        :param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheSurfFunction_Set(self, *args)


    def SetImplicitSurface(self, *args) -> "void":
        """
        :param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        """
        return _IntPatch.IntPatch_TheSurfFunction_SetImplicitSurface(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * Returns the value Tol so that if Abs(Func.Root())<Tol the function is considered null.
        	:rtype: float
        """
        return _IntPatch.IntPatch_TheSurfFunction_Tolerance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSurfFunction
IntPatch_TheSurfFunction.Direction2d = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Direction2d, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Direction3d = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Direction3d, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.ISurface = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_ISurface, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.IsTangent = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_IsTangent, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.PSurface = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_PSurface, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Point = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Point, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Root = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Root, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Set = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Set, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.SetImplicitSurface = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_SetImplicitSurface, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction.Tolerance = new_instancemethod(_IntPatch.IntPatch_TheSurfFunction_Tolerance, None, IntPatch_TheSurfFunction)
IntPatch_TheSurfFunction_swigregister = _IntPatch.IntPatch_TheSurfFunction_swigregister
IntPatch_TheSurfFunction_swigregister(IntPatch_TheSurfFunction)

class IntPatch_WLineTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ComputePurgedWLine(*args) -> "opencascade::handle< IntPatch_WLine >":
        """
        * I Removes equal points (leave one of equal points) from theWLine and recompute vertex parameters. //! II Removes point out of borders in case of non periodic surfaces. //! III Removes exceed points using tube criteria: delete 7D point if it lies near to expected lines in 2d and 3d. Each task (2d, 2d, 3d) have its own tolerance and checked separately. //! Returns new WLine or null WLine if the number of the points is less than 2.
        	:param theWLine:
        	:type theWLine: IntPatch_WLine
        	:param theS1:
        	:type theS1: Adaptor3d_HSurface
        	:param theS2:
        	:type theS2: Adaptor3d_HSurface
        	:param theDom1:
        	:type theDom1: Adaptor3d_TopolTool
        	:param theDom2:
        	:type theDom2: Adaptor3d_TopolTool
        	:rtype: opencascade::handle<IntPatch_WLine>
        """
        return _IntPatch.IntPatch_WLineTool_ComputePurgedWLine(*args)

    ComputePurgedWLine = staticmethod(ComputePurgedWLine)

    def ExtendTwoWLines(*args) -> "void":
        """
        * Extends every line from theSlin (if it is possible) to be started/finished in strictly determined point (in the place of joint of two lines). As result, some gaps between two lines will vanish. The Walking lines are supposed (algorithm will do nothing for not-Walking line) to be computed as a result of intersection. Both theS1 and theS2 must be quadrics. Other cases are not supported. theArrPeriods must be filled as follows (every value must not be negative; if the surface is not periodic the period must be equal to 0.0 strictly): {<U-period of 1st surface>, <V-period of 1st surface>, <U-period of 2nd surface>, <V-period of 2nd surface>}. theListOfCriticalPoints must contain 3D-points where joining is disabled.
        	:param theSlin:
        	:type theSlin: IntPatch_SequenceOfLine
        	:param theS1:
        	:type theS1: Adaptor3d_HSurface
        	:param theS2:
        	:type theS2: Adaptor3d_HSurface
        	:param theToler3D:
        	:type theToler3D: float
        	:param theArrPeriods:
        	:type theArrPeriods: float *
        	:param theBoxS1:
        	:type theBoxS1: Bnd_Box2d
        	:param theBoxS2:
        	:type theBoxS2: Bnd_Box2d
        	:param theListOfCriticalPoints:
        	:type theListOfCriticalPoints: NCollection_List<gp_Pnt>
        	:rtype: void
        """
        return _IntPatch.IntPatch_WLineTool_ExtendTwoWLines(*args)

    ExtendTwoWLines = staticmethod(ExtendTwoWLines)

    def JoinWLines(*args) -> "void":
        """
        * Joins all WLines from theSlin to one if it is possible and records the result into theSlin again. Lines will be kept to be split if: a) they are separated (has no common points); b) resulted line (after joining) go through seam-edges or surface boundaries. //! In addition, if points in theSPnt lies at least in one of the line in theSlin, this point will be deleted.
        	:param theSlin:
        	:type theSlin: IntPatch_SequenceOfLine
        	:param theSPnt:
        	:type theSPnt: IntPatch_SequenceOfPoint
        	:param theS1:
        	:type theS1: Adaptor3d_HSurface
        	:param theS2:
        	:type theS2: Adaptor3d_HSurface
        	:param theTol3D:
        	:type theTol3D: float
        	:rtype: void
        """
        return _IntPatch.IntPatch_WLineTool_JoinWLines(*args)

    JoinWLines = staticmethod(JoinWLines)

    __repr__ = _dumps_object


    def __init__(self):
        _IntPatch.IntPatch_WLineTool_swiginit(self, _IntPatch.new_IntPatch_WLineTool())
    __swig_destroy__ = _IntPatch.delete_IntPatch_WLineTool
IntPatch_WLineTool_swigregister = _IntPatch.IntPatch_WLineTool_swigregister
IntPatch_WLineTool_swigregister(IntPatch_WLineTool)

def IntPatch_WLineTool_ComputePurgedWLine(*args) -> "opencascade::handle< IntPatch_WLine >":
    """
    * I Removes equal points (leave one of equal points) from theWLine and recompute vertex parameters. //! II Removes point out of borders in case of non periodic surfaces. //! III Removes exceed points using tube criteria: delete 7D point if it lies near to expected lines in 2d and 3d. Each task (2d, 2d, 3d) have its own tolerance and checked separately. //! Returns new WLine or null WLine if the number of the points is less than 2.
    	:param theWLine:
    	:type theWLine: IntPatch_WLine
    	:param theS1:
    	:type theS1: Adaptor3d_HSurface
    	:param theS2:
    	:type theS2: Adaptor3d_HSurface
    	:param theDom1:
    	:type theDom1: Adaptor3d_TopolTool
    	:param theDom2:
    	:type theDom2: Adaptor3d_TopolTool
    	:rtype: opencascade::handle<IntPatch_WLine>
    """
    return _IntPatch.IntPatch_WLineTool_ComputePurgedWLine(*args)

def IntPatch_WLineTool_ExtendTwoWLines(*args) -> "void":
    """
    * Extends every line from theSlin (if it is possible) to be started/finished in strictly determined point (in the place of joint of two lines). As result, some gaps between two lines will vanish. The Walking lines are supposed (algorithm will do nothing for not-Walking line) to be computed as a result of intersection. Both theS1 and theS2 must be quadrics. Other cases are not supported. theArrPeriods must be filled as follows (every value must not be negative; if the surface is not periodic the period must be equal to 0.0 strictly): {<U-period of 1st surface>, <V-period of 1st surface>, <U-period of 2nd surface>, <V-period of 2nd surface>}. theListOfCriticalPoints must contain 3D-points where joining is disabled.
    	:param theSlin:
    	:type theSlin: IntPatch_SequenceOfLine
    	:param theS1:
    	:type theS1: Adaptor3d_HSurface
    	:param theS2:
    	:type theS2: Adaptor3d_HSurface
    	:param theToler3D:
    	:type theToler3D: float
    	:param theArrPeriods:
    	:type theArrPeriods: float *
    	:param theBoxS1:
    	:type theBoxS1: Bnd_Box2d
    	:param theBoxS2:
    	:type theBoxS2: Bnd_Box2d
    	:param theListOfCriticalPoints:
    	:type theListOfCriticalPoints: NCollection_List<gp_Pnt>
    	:rtype: void
    """
    return _IntPatch.IntPatch_WLineTool_ExtendTwoWLines(*args)

def IntPatch_WLineTool_JoinWLines(*args) -> "void":
    """
    * Joins all WLines from theSlin to one if it is possible and records the result into theSlin again. Lines will be kept to be split if: a) they are separated (has no common points); b) resulted line (after joining) go through seam-edges or surface boundaries. //! In addition, if points in theSPnt lies at least in one of the line in theSlin, this point will be deleted.
    	:param theSlin:
    	:type theSlin: IntPatch_SequenceOfLine
    	:param theSPnt:
    	:type theSPnt: IntPatch_SequenceOfPoint
    	:param theS1:
    	:type theS1: Adaptor3d_HSurface
    	:param theS2:
    	:type theS2: Adaptor3d_HSurface
    	:param theTol3D:
    	:type theTol3D: float
    	:rtype: void
    """
    return _IntPatch.IntPatch_WLineTool_JoinWLines(*args)

class IntPatch_ALine(IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddVertex(self, *args) -> "void":
        """
        * To add a vertex in the list.
        	:param Pnt:
        	:type Pnt: IntPatch_Point
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALine_AddVertex(self, *args)


    def ChangeVertex(self, *args) -> "IntPatch_Point &":
        """
        * Allows modifying the vertex with index theIndex on the line.
        	:param theIndex:
        	:type theIndex: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_ALine_ChangeVertex(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        * Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALine_ComputeVertexParameters(self, *args)


    def Curve(self, *args) -> "IntAna_Curve const &":
        """:rtype: IntAna_Curve"""
        return _IntPatch.IntPatch_ALine_Curve(self, *args)


    def D1(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True when the derivative at parameter U is defined on the analytic intersection line. In that case, Du is the derivative. Returns Standard_False when it is not possible to evaluate the derivative. In both cases, P is the point at parameter U on the intersection.
        	:param U:
        	:type U: float
        	:param P:
        	:type P: gp_Pnt
        	:param Du:
        	:type Du: gp_Vec
        	:rtype: bool
        """
        return _IntPatch.IntPatch_ALine_D1(self, *args)


    def FindParameter(self, *args) -> "void":
        """
        * Tries to find the parameters of the point P on the curve. If the method returns False, the 'projection' is impossible. If the method returns True at least one parameter has been found. theParams is always sorted in ascending order.
        	:param P:
        	:type P: gp_Pnt
        	:param theParams:
        	:type theParams: TColStd_ListOfReal
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALine_FindParameter(self, *args)


    def FirstParameter(self, *args) -> "Standard_Real":
        """
        * Returns the first parameter on the intersection line. If IsIncluded returns True, Value and D1 methods can be call with a parameter equal to FirstParamater. Otherwise, the parameter must be greater than FirstParameter.
        	:param IsIncluded:
        	:type IsIncluded: bool
        	:rtype: float
        """
        return _IntPatch.IntPatch_ALine_FirstParameter(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the FirstPoint. An exception is raised when HasFirstPoint returns False.
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_ALine_FirstPoint(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known First point. This point is given by the method FirstPoint().
        	:rtype: bool
        """
        return _IntPatch.IntPatch_ALine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known Last point. This point is given by the method LastPoint().
        	:rtype: bool
        """
        return _IntPatch.IntPatch_ALine_HasLastPoint(self, *args)


    def __init__(self, *args):
        """
        * Creates an analytic intersection line when the transitions are In or Out.
        	:param C:
        	:type C: IntAna_Curve
        	:param Tang:
        	:type Tang: bool
        	:param Trans1:
        	:type Trans1: IntSurf_TypeTrans
        	:param Trans2:
        	:type Trans2: IntSurf_TypeTrans
        	:rtype: None
        * Creates an analytic intersection line when the transitions are Touch.
        	:param C:
        	:type C: IntAna_Curve
        	:param Tang:
        	:type Tang: bool
        	:param Situ1:
        	:type Situ1: IntSurf_Situation
        	:param Situ2:
        	:type Situ2: IntSurf_Situation
        	:rtype: None
        * Creates an analytic intersection line when the transitions are Undecided.
        	:param C:
        	:type C: IntAna_Curve
        	:param Tang:
        	:type Tang: bool
        	:rtype: None
        """
        _IntPatch.IntPatch_ALine_swiginit(self, _IntPatch.new_IntPatch_ALine(*args))

    def LastParameter(self, *args) -> "Standard_Real":
        """
        * Returns the last parameter on the intersection line. If IsIncluded returns True, Value and D1 methods can be call with a parameter equal to LastParamater. Otherwise, the parameter must be less than LastParameter.
        	:param IsIncluded:
        	:type IsIncluded: bool
        	:rtype: float
        """
        return _IntPatch.IntPatch_ALine_LastParameter(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the LastPoint. An exception is raised when HasLastPoint returns False.
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_ALine_LastPoint(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _IntPatch.IntPatch_ALine_NbVertex(self, *args)


    def Replace(self, *args) -> "void":
        """
        * Replaces the element of range Index in the list of points.
        	:param Index:
        	:type Index: int
        	:param Pnt:
        	:type Pnt: IntPatch_Point
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALine_Replace(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        :param IndFirst:
        	:type IndFirst: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        :param IndLast:
        	:type IndLast: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_ALine_SetLastPoint(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        * Returns the point of parameter U on the analytic intersection line.
        	:param U:
        	:type U: float
        	:rtype: gp_Pnt
        """
        return _IntPatch.IntPatch_ALine_Value(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the vertex of range Index on the line.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_ALine_Vertex(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_ALine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ALine
IntPatch_ALine.AddVertex = new_instancemethod(_IntPatch.IntPatch_ALine_AddVertex, None, IntPatch_ALine)
IntPatch_ALine.ChangeVertex = new_instancemethod(_IntPatch.IntPatch_ALine_ChangeVertex, None, IntPatch_ALine)
IntPatch_ALine.ComputeVertexParameters = new_instancemethod(_IntPatch.IntPatch_ALine_ComputeVertexParameters, None, IntPatch_ALine)
IntPatch_ALine.Curve = new_instancemethod(_IntPatch.IntPatch_ALine_Curve, None, IntPatch_ALine)
IntPatch_ALine.D1 = new_instancemethod(_IntPatch.IntPatch_ALine_D1, None, IntPatch_ALine)
IntPatch_ALine.FindParameter = new_instancemethod(_IntPatch.IntPatch_ALine_FindParameter, None, IntPatch_ALine)
IntPatch_ALine.FirstParameter = new_instancemethod(_IntPatch.IntPatch_ALine_FirstParameter, None, IntPatch_ALine)
IntPatch_ALine.FirstPoint = new_instancemethod(_IntPatch.IntPatch_ALine_FirstPoint, None, IntPatch_ALine)
IntPatch_ALine.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_ALine_HasFirstPoint, None, IntPatch_ALine)
IntPatch_ALine.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_ALine_HasLastPoint, None, IntPatch_ALine)
IntPatch_ALine.LastParameter = new_instancemethod(_IntPatch.IntPatch_ALine_LastParameter, None, IntPatch_ALine)
IntPatch_ALine.LastPoint = new_instancemethod(_IntPatch.IntPatch_ALine_LastPoint, None, IntPatch_ALine)
IntPatch_ALine.NbVertex = new_instancemethod(_IntPatch.IntPatch_ALine_NbVertex, None, IntPatch_ALine)
IntPatch_ALine.Replace = new_instancemethod(_IntPatch.IntPatch_ALine_Replace, None, IntPatch_ALine)
IntPatch_ALine.SetFirstPoint = new_instancemethod(_IntPatch.IntPatch_ALine_SetFirstPoint, None, IntPatch_ALine)
IntPatch_ALine.SetLastPoint = new_instancemethod(_IntPatch.IntPatch_ALine_SetLastPoint, None, IntPatch_ALine)
IntPatch_ALine.Value = new_instancemethod(_IntPatch.IntPatch_ALine_Value, None, IntPatch_ALine)
IntPatch_ALine.Vertex = new_instancemethod(_IntPatch.IntPatch_ALine_Vertex, None, IntPatch_ALine)
IntPatch_ALine_swigregister = _IntPatch.IntPatch_ALine_swigregister
IntPatch_ALine_swigregister(IntPatch_ALine)

class IntPatch_GLine(IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddVertex(self, *args) -> "void":
        """
        * To add a vertex in the list.
        	:param Pnt:
        	:type Pnt: IntPatch_Point
        	:rtype: None
        """
        return _IntPatch.IntPatch_GLine_AddVertex(self, *args)


    def Circle(self, *args) -> "gp_Circ":
        """
        * Returns the Circ from gp corrsponding to the intersection when ArcType returns IntPatch_Circle.
        	:rtype: gp_Circ
        """
        return _IntPatch.IntPatch_GLine_Circle(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        * Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_GLine_ComputeVertexParameters(self, *args)


    def Ellipse(self, *args) -> "gp_Elips":
        """
        * Returns the Elips from gp corrsponding to the intersection when ArcType returns IntPatch_Ellipse.
        	:rtype: gp_Elips
        """
        return _IntPatch.IntPatch_GLine_Ellipse(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the FirstPoint. An exception is raised when HasFirstPoint returns False.
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_GLine_FirstPoint(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known First point. This point is given by the method FirstPoint().
        	:rtype: bool
        """
        return _IntPatch.IntPatch_GLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known Last point. This point is given by the method LastPoint().
        	:rtype: bool
        """
        return _IntPatch.IntPatch_GLine_HasLastPoint(self, *args)


    def Hyperbola(self, *args) -> "gp_Hypr":
        """
        * Returns the Hypr from gp corrsponding to the intersection when ArcType returns IntPatch_Hyperbola.
        	:rtype: gp_Hypr
        """
        return _IntPatch.IntPatch_GLine_Hyperbola(self, *args)


    def __init__(self, *args):
        """
        * Creates a Line as intersection line when the transitions are In or Out.
        	:param L:
        	:type L: gp_Lin
        	:param Tang:
        	:type Tang: bool
        	:param Trans1:
        	:type Trans1: IntSurf_TypeTrans
        	:param Trans2:
        	:type Trans2: IntSurf_TypeTrans
        	:rtype: None
        * Creates a Line as intersection line when the transitions are Touch.
        	:param L:
        	:type L: gp_Lin
        	:param Tang:
        	:type Tang: bool
        	:param Situ1:
        	:type Situ1: IntSurf_Situation
        	:param Situ2:
        	:type Situ2: IntSurf_Situation
        	:rtype: None
        * Creates a Line as intersection line when the transitions are Undecided.
        	:param L:
        	:type L: gp_Lin
        	:param Tang:
        	:type Tang: bool
        	:rtype: None
        * Creates a circle as intersection line when the transitions are In or Out.
        	:param C:
        	:type C: gp_Circ
        	:param Tang:
        	:type Tang: bool
        	:param Trans1:
        	:type Trans1: IntSurf_TypeTrans
        	:param Trans2:
        	:type Trans2: IntSurf_TypeTrans
        	:rtype: None
        * Creates a circle as intersection line when the transitions are Touch.
        	:param C:
        	:type C: gp_Circ
        	:param Tang:
        	:type Tang: bool
        	:param Situ1:
        	:type Situ1: IntSurf_Situation
        	:param Situ2:
        	:type Situ2: IntSurf_Situation
        	:rtype: None
        * Creates a circle as intersection line when the transitions are Undecided.
        	:param C:
        	:type C: gp_Circ
        	:param Tang:
        	:type Tang: bool
        	:rtype: None
        * Creates an ellipse as intersection line when the transitions are In or Out.
        	:param E:
        	:type E: gp_Elips
        	:param Tang:
        	:type Tang: bool
        	:param Trans1:
        	:type Trans1: IntSurf_TypeTrans
        	:param Trans2:
        	:type Trans2: IntSurf_TypeTrans
        	:rtype: None
        * Creates an ellispe as intersection line when the transitions are Touch.
        	:param E:
        	:type E: gp_Elips
        	:param Tang:
        	:type Tang: bool
        	:param Situ1:
        	:type Situ1: IntSurf_Situation
        	:param Situ2:
        	:type Situ2: IntSurf_Situation
        	:rtype: None
        * Creates an ellipse as intersection line when the transitions are Undecided.
        	:param E:
        	:type E: gp_Elips
        	:param Tang:
        	:type Tang: bool
        	:rtype: None
        * Creates a parabola as intersection line when the transitions are In or Out.
        	:param P:
        	:type P: gp_Parab
        	:param Tang:
        	:type Tang: bool
        	:param Trans1:
        	:type Trans1: IntSurf_TypeTrans
        	:param Trans2:
        	:type Trans2: IntSurf_TypeTrans
        	:rtype: None
        * Creates a parabola as intersection line when the transitions are Touch.
        	:param P:
        	:type P: gp_Parab
        	:param Tang:
        	:type Tang: bool
        	:param Situ1:
        	:type Situ1: IntSurf_Situation
        	:param Situ2:
        	:type Situ2: IntSurf_Situation
        	:rtype: None
        * Creates a parabola as intersection line when the transitions are Undecided.
        	:param P:
        	:type P: gp_Parab
        	:param Tang:
        	:type Tang: bool
        	:rtype: None
        * Creates an hyperbola as intersection line when the transitions are In or Out.
        	:param H:
        	:type H: gp_Hypr
        	:param Tang:
        	:type Tang: bool
        	:param Trans1:
        	:type Trans1: IntSurf_TypeTrans
        	:param Trans2:
        	:type Trans2: IntSurf_TypeTrans
        	:rtype: None
        * Creates an hyperbola as intersection line when the transitions are Touch.
        	:param H:
        	:type H: gp_Hypr
        	:param Tang:
        	:type Tang: bool
        	:param Situ1:
        	:type Situ1: IntSurf_Situation
        	:param Situ2:
        	:type Situ2: IntSurf_Situation
        	:rtype: None
        * Creates an hyperbola as intersection line when the transitions are Undecided.
        	:param H:
        	:type H: gp_Hypr
        	:param Tang:
        	:type Tang: bool
        	:rtype: None
        """
        _IntPatch.IntPatch_GLine_swiginit(self, _IntPatch.new_IntPatch_GLine(*args))

    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the LastPoint. An exception is raised when HasLastPoint returns False.
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_GLine_LastPoint(self, *args)


    def Line(self, *args) -> "gp_Lin":
        """
        * Returns the Lin from gp corresponding to the intersection when ArcType returns IntPatch_Line.
        	:rtype: gp_Lin
        """
        return _IntPatch.IntPatch_GLine_Line(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _IntPatch.IntPatch_GLine_NbVertex(self, *args)


    def Parabola(self, *args) -> "gp_Parab":
        """
        * Returns the Parab from gp corrsponding to the intersection when ArcType returns IntPatch_Parabola.
        	:rtype: gp_Parab
        """
        return _IntPatch.IntPatch_GLine_Parabola(self, *args)


    def Replace(self, *args) -> "void":
        """
        * To replace the element of range Index in the list of points.
        	:param Index:
        	:type Index: int
        	:param Pnt:
        	:type Pnt: IntPatch_Point
        	:rtype: None
        """
        return _IntPatch.IntPatch_GLine_Replace(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        :param IndFirst:
        	:type IndFirst: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_GLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        :param IndLast:
        	:type IndLast: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_GLine_SetLastPoint(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the vertex of range Index on the line.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_GLine_Vertex(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_GLine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_GLine
IntPatch_GLine.AddVertex = new_instancemethod(_IntPatch.IntPatch_GLine_AddVertex, None, IntPatch_GLine)
IntPatch_GLine.Circle = new_instancemethod(_IntPatch.IntPatch_GLine_Circle, None, IntPatch_GLine)
IntPatch_GLine.ComputeVertexParameters = new_instancemethod(_IntPatch.IntPatch_GLine_ComputeVertexParameters, None, IntPatch_GLine)
IntPatch_GLine.Ellipse = new_instancemethod(_IntPatch.IntPatch_GLine_Ellipse, None, IntPatch_GLine)
IntPatch_GLine.FirstPoint = new_instancemethod(_IntPatch.IntPatch_GLine_FirstPoint, None, IntPatch_GLine)
IntPatch_GLine.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_GLine_HasFirstPoint, None, IntPatch_GLine)
IntPatch_GLine.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_GLine_HasLastPoint, None, IntPatch_GLine)
IntPatch_GLine.Hyperbola = new_instancemethod(_IntPatch.IntPatch_GLine_Hyperbola, None, IntPatch_GLine)
IntPatch_GLine.LastPoint = new_instancemethod(_IntPatch.IntPatch_GLine_LastPoint, None, IntPatch_GLine)
IntPatch_GLine.Line = new_instancemethod(_IntPatch.IntPatch_GLine_Line, None, IntPatch_GLine)
IntPatch_GLine.NbVertex = new_instancemethod(_IntPatch.IntPatch_GLine_NbVertex, None, IntPatch_GLine)
IntPatch_GLine.Parabola = new_instancemethod(_IntPatch.IntPatch_GLine_Parabola, None, IntPatch_GLine)
IntPatch_GLine.Replace = new_instancemethod(_IntPatch.IntPatch_GLine_Replace, None, IntPatch_GLine)
IntPatch_GLine.SetFirstPoint = new_instancemethod(_IntPatch.IntPatch_GLine_SetFirstPoint, None, IntPatch_GLine)
IntPatch_GLine.SetLastPoint = new_instancemethod(_IntPatch.IntPatch_GLine_SetLastPoint, None, IntPatch_GLine)
IntPatch_GLine.Vertex = new_instancemethod(_IntPatch.IntPatch_GLine_Vertex, None, IntPatch_GLine)
IntPatch_GLine_swigregister = _IntPatch.IntPatch_GLine_swigregister
IntPatch_GLine_swigregister(IntPatch_GLine)

class IntPatch_PointLine(IntPatch_Line):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddVertex(self, *args) -> "void":
        """
        * Adds a vertex in the list. If theIsPrepend == True the new vertex will be added before the first element of vertices sequence. Otherwise, to the end of the sequence
        	:param Pnt:
        	:type Pnt: IntPatch_Point
        	:param theIsPrepend: default value is Standard_False
        	:type theIsPrepend: bool
        	:rtype: void
        """
        return _IntPatch.IntPatch_PointLine_AddVertex(self, *args)


    def ChangeVertex(self, *args) -> "IntPatch_Point &":
        """
        * Returns the vertex of range Index on the line.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_PointLine_ChangeVertex(self, *args)


    def ClearVertexes(self, *args) -> "void":
        """
        * Removes vertices from the line
        	:rtype: void
        """
        return _IntPatch.IntPatch_PointLine_ClearVertexes(self, *args)


    def CurvatureRadiusOfIntersLine(*args) -> "Standard_Real":
        """
        * Returns the radius of curvature of the intersection line in given point. Returns negative value if computation is not possible.
        	:param theS1:
        	:type theS1: Adaptor3d_HSurface
        	:param theS2:
        	:type theS2: Adaptor3d_HSurface
        	:param theUVPoint:
        	:type theUVPoint: IntSurf_PntOn2S
        	:rtype: float
        """
        return _IntPatch.IntPatch_PointLine_CurvatureRadiusOfIntersLine(*args)

    CurvatureRadiusOfIntersLine = staticmethod(CurvatureRadiusOfIntersLine)

    def Curve(self, *args) -> "opencascade::handle< IntSurf_LineOn2S >":
        """
        * Returns set of intersection points
        	:rtype: opencascade::handle<IntSurf_LineOn2S>
        """
        return _IntPatch.IntPatch_PointLine_Curve(self, *args)


    def IsOutBox(self, *args) -> "Standard_Boolean":
        """
        * Returns True if P is out of the box built from 3D-points.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: bool
        """
        return _IntPatch.IntPatch_PointLine_IsOutBox(self, *args)


    def IsOutSurf1Box(self, *args) -> "Standard_Boolean":
        """
        * Returns True if P1 is out of the box built from the points on 1st surface
        	:param P1:
        	:type P1: gp_Pnt2d
        	:rtype: bool
        """
        return _IntPatch.IntPatch_PointLine_IsOutSurf1Box(self, *args)


    def IsOutSurf2Box(self, *args) -> "Standard_Boolean":
        """
        * Returns True if P2 is out of the box built from the points on 2nd surface
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: bool
        """
        return _IntPatch.IntPatch_PointLine_IsOutSurf2Box(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intersection points.
        	:rtype: int
        """
        return _IntPatch.IntPatch_PointLine_NbPnts(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """
        * Returns number of vertices (IntPatch_Point) of the line
        	:rtype: int
        """
        return _IntPatch.IntPatch_PointLine_NbVertex(self, *args)


    def Point(self, *args) -> "IntSurf_PntOn2S const &":
        """
        * Returns the intersection point of range Index.
        	:param Index:
        	:type Index: int
        	:rtype: IntSurf_PntOn2S
        """
        return _IntPatch.IntPatch_PointLine_Point(self, *args)


    def RemoveVertex(self, *args) -> "void":
        """
        * Removes single vertex from the line
        	:param theIndex:
        	:type theIndex: int
        	:rtype: void
        """
        return _IntPatch.IntPatch_PointLine_RemoveVertex(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the vertex of range Index on the line.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_PointLine_Vertex(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_PointLine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PointLine
IntPatch_PointLine.AddVertex = new_instancemethod(_IntPatch.IntPatch_PointLine_AddVertex, None, IntPatch_PointLine)
IntPatch_PointLine.ChangeVertex = new_instancemethod(_IntPatch.IntPatch_PointLine_ChangeVertex, None, IntPatch_PointLine)
IntPatch_PointLine.ClearVertexes = new_instancemethod(_IntPatch.IntPatch_PointLine_ClearVertexes, None, IntPatch_PointLine)
IntPatch_PointLine.Curve = new_instancemethod(_IntPatch.IntPatch_PointLine_Curve, None, IntPatch_PointLine)
IntPatch_PointLine.IsOutBox = new_instancemethod(_IntPatch.IntPatch_PointLine_IsOutBox, None, IntPatch_PointLine)
IntPatch_PointLine.IsOutSurf1Box = new_instancemethod(_IntPatch.IntPatch_PointLine_IsOutSurf1Box, None, IntPatch_PointLine)
IntPatch_PointLine.IsOutSurf2Box = new_instancemethod(_IntPatch.IntPatch_PointLine_IsOutSurf2Box, None, IntPatch_PointLine)
IntPatch_PointLine.NbPnts = new_instancemethod(_IntPatch.IntPatch_PointLine_NbPnts, None, IntPatch_PointLine)
IntPatch_PointLine.NbVertex = new_instancemethod(_IntPatch.IntPatch_PointLine_NbVertex, None, IntPatch_PointLine)
IntPatch_PointLine.Point = new_instancemethod(_IntPatch.IntPatch_PointLine_Point, None, IntPatch_PointLine)
IntPatch_PointLine.RemoveVertex = new_instancemethod(_IntPatch.IntPatch_PointLine_RemoveVertex, None, IntPatch_PointLine)
IntPatch_PointLine.Vertex = new_instancemethod(_IntPatch.IntPatch_PointLine_Vertex, None, IntPatch_PointLine)
IntPatch_PointLine_swigregister = _IntPatch.IntPatch_PointLine_swigregister
IntPatch_PointLine_swigregister(IntPatch_PointLine)

def IntPatch_PointLine_CurvatureRadiusOfIntersLine(*args) -> "Standard_Real":
    """
    * Returns the radius of curvature of the intersection line in given point. Returns negative value if computation is not possible.
    	:param theS1:
    	:type theS1: Adaptor3d_HSurface
    	:param theS2:
    	:type theS2: Adaptor3d_HSurface
    	:param theUVPoint:
    	:type theUVPoint: IntSurf_PntOn2S
    	:rtype: float
    """
    return _IntPatch.IntPatch_PointLine_CurvatureRadiusOfIntersLine(*args)

class IntPatch_PolyArc(IntPatch_Polygo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates the polygon of the arc A on the surface S. The arc is limited by the parameters Pfirst and Plast. None of these parameters can be infinite.
        	:param A:
        	:type A: Adaptor2d_HCurve2d
        	:param NbSample:
        	:type NbSample: int
        	:param Pfirst:
        	:type Pfirst: float
        	:param Plast:
        	:type Plast: float
        	:param BoxOtherPolygon:
        	:type BoxOtherPolygon: Bnd_Box2d
        	:rtype: None
        """
        _IntPatch.IntPatch_PolyArc_swiginit(self, _IntPatch.new_IntPatch_PolyArc(*args))

    def Parameter(self, *args) -> "Standard_Real":
        """
        :param Index:
        	:type Index: int
        	:rtype: float
        """
        return _IntPatch.IntPatch_PolyArc_Parameter(self, *args)


    def SetOffset(self, *args) -> "void":
        """
        :param OffsetX:
        	:type OffsetX: float
        	:param OffsetY:
        	:type OffsetY: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_PolyArc_SetOffset(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyArc
IntPatch_PolyArc.Parameter = new_instancemethod(_IntPatch.IntPatch_PolyArc_Parameter, None, IntPatch_PolyArc)
IntPatch_PolyArc.SetOffset = new_instancemethod(_IntPatch.IntPatch_PolyArc_SetOffset, None, IntPatch_PolyArc)
IntPatch_PolyArc_swigregister = _IntPatch.IntPatch_PolyArc_swigregister
IntPatch_PolyArc_swigregister(IntPatch_PolyArc)

class IntPatch_PolyLine(IntPatch_Polygo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :rtype: None
        :param InitDefle:
        	:type InitDefle: float
        	:rtype: None
        """
        _IntPatch.IntPatch_PolyLine_swiginit(self, _IntPatch.new_IntPatch_PolyLine(*args))

    def ResetError(self, *args) -> "void":
        """:rtype: None"""
        return _IntPatch.IntPatch_PolyLine_ResetError(self, *args)


    def SetRLine(self, *args) -> "void":
        """
        :param OnFirst:
        	:type OnFirst: bool
        	:param Line:
        	:type Line: IntPatch_RLine
        	:rtype: None
        """
        return _IntPatch.IntPatch_PolyLine_SetRLine(self, *args)


    def SetWLine(self, *args) -> "void":
        """
        :param OnFirst:
        	:type OnFirst: bool
        	:param Line:
        	:type Line: IntPatch_WLine
        	:rtype: None
        """
        return _IntPatch.IntPatch_PolyLine_SetWLine(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyLine
IntPatch_PolyLine.ResetError = new_instancemethod(_IntPatch.IntPatch_PolyLine_ResetError, None, IntPatch_PolyLine)
IntPatch_PolyLine.SetRLine = new_instancemethod(_IntPatch.IntPatch_PolyLine_SetRLine, None, IntPatch_PolyLine)
IntPatch_PolyLine.SetWLine = new_instancemethod(_IntPatch.IntPatch_PolyLine_SetWLine, None, IntPatch_PolyLine)
IntPatch_PolyLine_swigregister = _IntPatch.IntPatch_PolyLine_swigregister
IntPatch_PolyLine_swigregister(IntPatch_PolyLine)

class IntPatch_RLine(IntPatch_PointLine):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        :param L:
        	:type L: IntSurf_LineOn2S
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_Add(self, *args)


    def ArcOnS1(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        * Returns the concerned arc.
        	:rtype: opencascade::handle<Adaptor2d_HCurve2d>
        """
        return _IntPatch.IntPatch_RLine_ArcOnS1(self, *args)


    def ArcOnS2(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        * Returns the concerned arc.
        	:rtype: opencascade::handle<Adaptor2d_HCurve2d>
        """
        return _IntPatch.IntPatch_RLine_ArcOnS2(self, *args)


    def ChangeVertex(self, *args) -> "IntPatch_Point &":
        """
        * Returns the vertex of range Index on the line.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_RLine_ChangeVertex(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        * Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_ComputeVertexParameters(self, *args)


    def Dump(self, *args) -> "void":
        """
        * if (theMode == 0) then prints the information about WLine if (theMode == 1) then prints the list of 3d-points if (theMode == 2) then prints the list of 2d-points on the 1st surface Otherwise, prints list of 2d-points on the 2nd surface
        	:param theMode:
        	:type theMode: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_Dump(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the FirstPoint. An exception is raised when HasFirstPoint returns False.
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_RLine_FirstPoint(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known First point. This point is given by the method FirstPoint().
        	:rtype: bool
        """
        return _IntPatch.IntPatch_RLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known Last point. This point is given by the method LastPoint().
        	:rtype: bool
        """
        return _IntPatch.IntPatch_RLine_HasLastPoint(self, *args)


    def HasPolygon(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntPatch.IntPatch_RLine_HasPolygon(self, *args)


    def __init__(self, *args):
        """
        * Creates a restriction as an intersection line when the transitions are In or Out.
        	:param Tang:
        	:type Tang: bool
        	:param Trans1:
        	:type Trans1: IntSurf_TypeTrans
        	:param Trans2:
        	:type Trans2: IntSurf_TypeTrans
        	:rtype: None
        * Creates a restriction as an intersection line when the transitions are Touch.
        	:param Tang:
        	:type Tang: bool
        	:param Situ1:
        	:type Situ1: IntSurf_Situation
        	:param Situ2:
        	:type Situ2: IntSurf_Situation
        	:rtype: None
        * Creates a restriction as an intersection line when the transitions are Undecided.
        	:param Tang:
        	:type Tang: bool
        	:rtype: None
        """
        _IntPatch.IntPatch_RLine_swiginit(self, _IntPatch.new_IntPatch_RLine(*args))

    def IsArcOnS1(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is on the domain of the first patch. Returns False if the intersection is on the domain of the second patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_RLine_IsArcOnS1(self, *args)


    def IsArcOnS2(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the intersection is on the domain of the first patch. Returns False if the intersection is on the domain of the second patch.
        	:rtype: bool
        """
        return _IntPatch.IntPatch_RLine_IsArcOnS2(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the IntPoint corresponding to the LastPoint. An exception is raised when HasLastPoint returns False.
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_RLine_LastPoint(self, *args)


    def ParamOnS1(self, *args) -> "void":
        """
        :param p1:
        	:type p1: float
        	:param p2:
        	:type p2: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_ParamOnS1(self, *args)


    def ParamOnS2(self, *args) -> "void":
        """
        :param p1:
        	:type p1: float
        	:param p2:
        	:type p2: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_ParamOnS2(self, *args)


    def Replace(self, *args) -> "void":
        """
        * Replaces the element of range Index in the list of points.
        	:param Index:
        	:type Index: int
        	:param Pnt:
        	:type Pnt: IntPatch_Point
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_Replace(self, *args)


    def SetArcOnS1(self, *args) -> "void":
        """
        :param A:
        	:type A: Adaptor2d_HCurve2d
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_SetArcOnS1(self, *args)


    def SetArcOnS2(self, *args) -> "void":
        """
        :param A:
        	:type A: Adaptor2d_HCurve2d
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_SetArcOnS2(self, *args)


    def SetCurve(self, *args) -> "void":
        """
        :param theNewCurve:
        	:type theNewCurve: IntSurf_LineOn2S
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_SetCurve(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        :param IndFirst:
        	:type IndFirst: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        :param IndLast:
        	:type IndLast: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_SetLastPoint(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        * Set the Point of index <Index> in the LineOn2S
        	:param Index:
        	:type Index: int
        	:param Pnt:
        	:type Pnt: IntPatch_Point
        	:rtype: None
        """
        return _IntPatch.IntPatch_RLine_SetPoint(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_RLine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_RLine
IntPatch_RLine.Add = new_instancemethod(_IntPatch.IntPatch_RLine_Add, None, IntPatch_RLine)
IntPatch_RLine.ArcOnS1 = new_instancemethod(_IntPatch.IntPatch_RLine_ArcOnS1, None, IntPatch_RLine)
IntPatch_RLine.ArcOnS2 = new_instancemethod(_IntPatch.IntPatch_RLine_ArcOnS2, None, IntPatch_RLine)
IntPatch_RLine.ChangeVertex = new_instancemethod(_IntPatch.IntPatch_RLine_ChangeVertex, None, IntPatch_RLine)
IntPatch_RLine.ComputeVertexParameters = new_instancemethod(_IntPatch.IntPatch_RLine_ComputeVertexParameters, None, IntPatch_RLine)
IntPatch_RLine.Dump = new_instancemethod(_IntPatch.IntPatch_RLine_Dump, None, IntPatch_RLine)
IntPatch_RLine.FirstPoint = new_instancemethod(_IntPatch.IntPatch_RLine_FirstPoint, None, IntPatch_RLine)
IntPatch_RLine.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_RLine_HasFirstPoint, None, IntPatch_RLine)
IntPatch_RLine.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_RLine_HasLastPoint, None, IntPatch_RLine)
IntPatch_RLine.HasPolygon = new_instancemethod(_IntPatch.IntPatch_RLine_HasPolygon, None, IntPatch_RLine)
IntPatch_RLine.IsArcOnS1 = new_instancemethod(_IntPatch.IntPatch_RLine_IsArcOnS1, None, IntPatch_RLine)
IntPatch_RLine.IsArcOnS2 = new_instancemethod(_IntPatch.IntPatch_RLine_IsArcOnS2, None, IntPatch_RLine)
IntPatch_RLine.LastPoint = new_instancemethod(_IntPatch.IntPatch_RLine_LastPoint, None, IntPatch_RLine)
IntPatch_RLine.ParamOnS1 = new_instancemethod(_IntPatch.IntPatch_RLine_ParamOnS1, None, IntPatch_RLine)
IntPatch_RLine.ParamOnS2 = new_instancemethod(_IntPatch.IntPatch_RLine_ParamOnS2, None, IntPatch_RLine)
IntPatch_RLine.Replace = new_instancemethod(_IntPatch.IntPatch_RLine_Replace, None, IntPatch_RLine)
IntPatch_RLine.SetArcOnS1 = new_instancemethod(_IntPatch.IntPatch_RLine_SetArcOnS1, None, IntPatch_RLine)
IntPatch_RLine.SetArcOnS2 = new_instancemethod(_IntPatch.IntPatch_RLine_SetArcOnS2, None, IntPatch_RLine)
IntPatch_RLine.SetCurve = new_instancemethod(_IntPatch.IntPatch_RLine_SetCurve, None, IntPatch_RLine)
IntPatch_RLine.SetFirstPoint = new_instancemethod(_IntPatch.IntPatch_RLine_SetFirstPoint, None, IntPatch_RLine)
IntPatch_RLine.SetLastPoint = new_instancemethod(_IntPatch.IntPatch_RLine_SetLastPoint, None, IntPatch_RLine)
IntPatch_RLine.SetPoint = new_instancemethod(_IntPatch.IntPatch_RLine_SetPoint, None, IntPatch_RLine)
IntPatch_RLine_swigregister = _IntPatch.IntPatch_RLine_swigregister
IntPatch_RLine_swigregister(IntPatch_RLine)

class IntPatch_WLine(IntPatch_PointLine):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    IntPatch_WLUnknown = _IntPatch.IntPatch_WLine_IntPatch_WLUnknown
    IntPatch_WLImpImp = _IntPatch.IntPatch_WLine_IntPatch_WLImpImp
    IntPatch_WLImpPrm = _IntPatch.IntPatch_WLine_IntPatch_WLImpPrm
    IntPatch_WLPrmPrm = _IntPatch.IntPatch_WLine_IntPatch_WLPrmPrm

    def ChangeVertex(self, *args) -> "IntPatch_Point &":
        """
        * Returns the vertex of range Index on the line.
        	:param Index:
        	:type Index: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_WLine_ChangeVertex(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        * Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_ComputeVertexParameters(self, *args)


    def Dump(self, *args) -> "void":
        """
        * if (theMode == 0) then prints the information about WLine if (theMode == 1) then prints the list of 3d-points if (theMode == 2) then prints the list of 2d-points on the 1st surface Otherwise, prints list of 2d-points on the 2nd surface
        	:param theMode:
        	:type theMode: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_Dump(self, *args)


    def EnablePurging(self, *args) -> "void":
        """
        * Allows or forbids purging of existing WLine
        	:param theIsEnabled:
        	:type theIsEnabled: bool
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_EnablePurging(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the Point corresponding to the FirstPoint.
        	:rtype: IntPatch_Point
        * Returns the Point corresponding to the FirstPoint. Indfirst is the index of the first in the list of vertices.
        	:param Indfirst:
        	:type Indfirst: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_WLine_FirstPoint(self, *args)


    def GetArcOnS1(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """:rtype: opencascade::handle<Adaptor2d_HCurve2d>"""
        return _IntPatch.IntPatch_WLine_GetArcOnS1(self, *args)


    def GetArcOnS2(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """:rtype: opencascade::handle<Adaptor2d_HCurve2d>"""
        return _IntPatch.IntPatch_WLine_GetArcOnS2(self, *args)


    def GetCreatingWay(self, *args) -> "IntPatch_WLine::IntPatch_WLType":
        """
        * Returns the way of <*this> creation.
        	:rtype: IntPatch_WLType
        """
        return _IntPatch.IntPatch_WLine_GetCreatingWay(self, *args)


    def HasArcOnS1(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntPatch.IntPatch_WLine_HasArcOnS1(self, *args)


    def HasArcOnS2(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _IntPatch.IntPatch_WLine_HasArcOnS2(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known First point. This point is given by the method FirstPoint().
        	:rtype: bool
        """
        return _IntPatch.IntPatch_WLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the line has a known Last point. This point is given by the method LastPoint().
        	:rtype: bool
        """
        return _IntPatch.IntPatch_WLine_HasLastPoint(self, *args)


    def InsertVertexBefore(self, *args) -> "void":
        """
        :param theIndex:
        	:type theIndex: int
        	:param thePnt:
        	:type thePnt: IntPatch_Point
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_InsertVertexBefore(self, *args)


    def __init__(self, *args):
        """
        * Creates a WLine as an intersection when the transitions are In or Out.
        	:param Line:
        	:type Line: IntSurf_LineOn2S
        	:param Tang:
        	:type Tang: bool
        	:param Trans1:
        	:type Trans1: IntSurf_TypeTrans
        	:param Trans2:
        	:type Trans2: IntSurf_TypeTrans
        	:rtype: None
        * Creates a WLine as an intersection when the transitions are Touch.
        	:param Line:
        	:type Line: IntSurf_LineOn2S
        	:param Tang:
        	:type Tang: bool
        	:param Situ1:
        	:type Situ1: IntSurf_Situation
        	:param Situ2:
        	:type Situ2: IntSurf_Situation
        	:rtype: None
        * Creates a WLine as an intersection when the transitions are Undecided.
        	:param Line:
        	:type Line: IntSurf_LineOn2S
        	:param Tang:
        	:type Tang: bool
        	:rtype: None
        """
        _IntPatch.IntPatch_WLine_swiginit(self, _IntPatch.new_IntPatch_WLine(*args))

    def IsPurgingAllowed(self, *args) -> "Standard_Boolean":
        """
        * Returns True if purging is allowed or forbidden for existing WLine
        	:rtype: bool
        """
        return _IntPatch.IntPatch_WLine_IsPurgingAllowed(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        * Returns the Point corresponding to the LastPoint.
        	:rtype: IntPatch_Point
        * Returns the Point corresponding to the LastPoint. Indlast is the index of the last in the list of vertices.
        	:param Indlast:
        	:type Indlast: int
        	:rtype: IntPatch_Point
        """
        return _IntPatch.IntPatch_WLine_LastPoint(self, *args)


    def Replace(self, *args) -> "void":
        """
        * Replaces the element of range Index in the list of points. The exception OutOfRange is raised when Index <= 0 or Index > NbVertex.
        	:param Index:
        	:type Index: int
        	:param Pnt:
        	:type Pnt: IntPatch_Point
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_Replace(self, *args)


    def SetArcOnS1(self, *args) -> "void":
        """
        :param A:
        	:type A: Adaptor2d_HCurve2d
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_SetArcOnS1(self, *args)


    def SetArcOnS2(self, *args) -> "void":
        """
        :param A:
        	:type A: Adaptor2d_HCurve2d
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_SetArcOnS2(self, *args)


    def SetCreatingWayInfo(self, *args) -> "void":
        """
        * Sets the info about the way of <*this> creation.
        	:param theAlgo:
        	:type theAlgo: IntPatch_WLType
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_SetCreatingWayInfo(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        :param IndFirst:
        	:type IndFirst: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        :param IndLast:
        	:type IndLast: int
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_SetLastPoint(self, *args)


    def SetPeriod(self, *args) -> "void":
        """
        :param pu1:
        	:type pu1: float
        	:param pv1:
        	:type pv1: float
        	:param pu2:
        	:type pu2: float
        	:param pv2:
        	:type pv2: float
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_SetPeriod(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        * Set the Point of index <Index> in the LineOn2S
        	:param Index:
        	:type Index: int
        	:param Pnt:
        	:type Pnt: IntPatch_Point
        	:rtype: None
        """
        return _IntPatch.IntPatch_WLine_SetPoint(self, *args)


    def U1Period(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_WLine_U1Period(self, *args)


    def U2Period(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_WLine_U2Period(self, *args)


    def V1Period(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_WLine_V1Period(self, *args)


    def V2Period(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _IntPatch.IntPatch_WLine_V2Period(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_WLine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_WLine
IntPatch_WLine.ChangeVertex = new_instancemethod(_IntPatch.IntPatch_WLine_ChangeVertex, None, IntPatch_WLine)
IntPatch_WLine.ComputeVertexParameters = new_instancemethod(_IntPatch.IntPatch_WLine_ComputeVertexParameters, None, IntPatch_WLine)
IntPatch_WLine.Dump = new_instancemethod(_IntPatch.IntPatch_WLine_Dump, None, IntPatch_WLine)
IntPatch_WLine.EnablePurging = new_instancemethod(_IntPatch.IntPatch_WLine_EnablePurging, None, IntPatch_WLine)
IntPatch_WLine.FirstPoint = new_instancemethod(_IntPatch.IntPatch_WLine_FirstPoint, None, IntPatch_WLine)
IntPatch_WLine.GetArcOnS1 = new_instancemethod(_IntPatch.IntPatch_WLine_GetArcOnS1, None, IntPatch_WLine)
IntPatch_WLine.GetArcOnS2 = new_instancemethod(_IntPatch.IntPatch_WLine_GetArcOnS2, None, IntPatch_WLine)
IntPatch_WLine.GetCreatingWay = new_instancemethod(_IntPatch.IntPatch_WLine_GetCreatingWay, None, IntPatch_WLine)
IntPatch_WLine.HasArcOnS1 = new_instancemethod(_IntPatch.IntPatch_WLine_HasArcOnS1, None, IntPatch_WLine)
IntPatch_WLine.HasArcOnS2 = new_instancemethod(_IntPatch.IntPatch_WLine_HasArcOnS2, None, IntPatch_WLine)
IntPatch_WLine.HasFirstPoint = new_instancemethod(_IntPatch.IntPatch_WLine_HasFirstPoint, None, IntPatch_WLine)
IntPatch_WLine.HasLastPoint = new_instancemethod(_IntPatch.IntPatch_WLine_HasLastPoint, None, IntPatch_WLine)
IntPatch_WLine.InsertVertexBefore = new_instancemethod(_IntPatch.IntPatch_WLine_InsertVertexBefore, None, IntPatch_WLine)
IntPatch_WLine.IsPurgingAllowed = new_instancemethod(_IntPatch.IntPatch_WLine_IsPurgingAllowed, None, IntPatch_WLine)
IntPatch_WLine.LastPoint = new_instancemethod(_IntPatch.IntPatch_WLine_LastPoint, None, IntPatch_WLine)
IntPatch_WLine.Replace = new_instancemethod(_IntPatch.IntPatch_WLine_Replace, None, IntPatch_WLine)
IntPatch_WLine.SetArcOnS1 = new_instancemethod(_IntPatch.IntPatch_WLine_SetArcOnS1, None, IntPatch_WLine)
IntPatch_WLine.SetArcOnS2 = new_instancemethod(_IntPatch.IntPatch_WLine_SetArcOnS2, None, IntPatch_WLine)
IntPatch_WLine.SetCreatingWayInfo = new_instancemethod(_IntPatch.IntPatch_WLine_SetCreatingWayInfo, None, IntPatch_WLine)
IntPatch_WLine.SetFirstPoint = new_instancemethod(_IntPatch.IntPatch_WLine_SetFirstPoint, None, IntPatch_WLine)
IntPatch_WLine.SetLastPoint = new_instancemethod(_IntPatch.IntPatch_WLine_SetLastPoint, None, IntPatch_WLine)
IntPatch_WLine.SetPeriod = new_instancemethod(_IntPatch.IntPatch_WLine_SetPeriod, None, IntPatch_WLine)
IntPatch_WLine.SetPoint = new_instancemethod(_IntPatch.IntPatch_WLine_SetPoint, None, IntPatch_WLine)
IntPatch_WLine.U1Period = new_instancemethod(_IntPatch.IntPatch_WLine_U1Period, None, IntPatch_WLine)
IntPatch_WLine.U2Period = new_instancemethod(_IntPatch.IntPatch_WLine_U2Period, None, IntPatch_WLine)
IntPatch_WLine.V1Period = new_instancemethod(_IntPatch.IntPatch_WLine_V1Period, None, IntPatch_WLine)
IntPatch_WLine.V2Period = new_instancemethod(_IntPatch.IntPatch_WLine_V2Period, None, IntPatch_WLine)
IntPatch_WLine_swigregister = _IntPatch.IntPatch_WLine_swigregister
IntPatch_WLine_swigregister(IntPatch_WLine)



