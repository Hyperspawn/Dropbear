# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Interface module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_interface.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Interface.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Interface')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Interface')
    _Interface = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Interface', [dirname(__file__)])
        except ImportError:
            import _Interface
            return _Interface
        try:
            _mod = imp.load_module('_Interface', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Interface = swig_import_helper()
    del swig_import_helper
else:
    import _Interface
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Interface.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Interface.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Interface.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Interface.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Interface.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Interface.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Interface.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Interface.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Interface.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Interface.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Interface.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Interface.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Interface.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Interface.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Interface.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Interface.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Interface.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Interface.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _Interface.process_exception(error, method_name, class_name)
process_exception = _Interface.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TCollection
import OCC.Core.TColStd
import OCC.Core.Message
import OCC.Core.MoniTool
import OCC.Core.TopoDS
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.OSD
Interface_ParamMisc = _Interface.Interface_ParamMisc
Interface_ParamInteger = _Interface.Interface_ParamInteger
Interface_ParamReal = _Interface.Interface_ParamReal
Interface_ParamIdent = _Interface.Interface_ParamIdent
Interface_ParamVoid = _Interface.Interface_ParamVoid
Interface_ParamText = _Interface.Interface_ParamText
Interface_ParamEnum = _Interface.Interface_ParamEnum
Interface_ParamLogical = _Interface.Interface_ParamLogical
Interface_ParamSub = _Interface.Interface_ParamSub
Interface_ParamHexa = _Interface.Interface_ParamHexa
Interface_ParamBinary = _Interface.Interface_ParamBinary
Interface_StateOK = _Interface.Interface_StateOK
Interface_LoadWarning = _Interface.Interface_LoadWarning
Interface_LoadFail = _Interface.Interface_LoadFail
Interface_DataWarning = _Interface.Interface_DataWarning
Interface_DataFail = _Interface.Interface_DataFail
Interface_StateUnloaded = _Interface.Interface_StateUnloaded
Interface_StateUnknown = _Interface.Interface_StateUnknown
Interface_CheckOK = _Interface.Interface_CheckOK
Interface_CheckWarning = _Interface.Interface_CheckWarning
Interface_CheckFail = _Interface.Interface_CheckFail
Interface_CheckAny = _Interface.Interface_CheckAny
Interface_CheckMessage = _Interface.Interface_CheckMessage
Interface_CheckNoFail = _Interface.Interface_CheckNoFail

def Handle_Interface_Check_Create() -> "opencascade::handle< Interface_Check >":
    return _Interface.Handle_Interface_Check_Create()
Handle_Interface_Check_Create = _Interface.Handle_Interface_Check_Create

def Handle_Interface_Check_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_Check >":
    return _Interface.Handle_Interface_Check_DownCast(t)
Handle_Interface_Check_DownCast = _Interface.Handle_Interface_Check_DownCast

def Handle_Interface_Check_IsNull(t: 'opencascade::handle< Interface_Check > const &') -> "bool":
    return _Interface.Handle_Interface_Check_IsNull(t)
Handle_Interface_Check_IsNull = _Interface.Handle_Interface_Check_IsNull

def Handle_Interface_CopyControl_Create() -> "opencascade::handle< Interface_CopyControl >":
    return _Interface.Handle_Interface_CopyControl_Create()
Handle_Interface_CopyControl_Create = _Interface.Handle_Interface_CopyControl_Create

def Handle_Interface_CopyControl_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_CopyControl >":
    return _Interface.Handle_Interface_CopyControl_DownCast(t)
Handle_Interface_CopyControl_DownCast = _Interface.Handle_Interface_CopyControl_DownCast

def Handle_Interface_CopyControl_IsNull(t: 'opencascade::handle< Interface_CopyControl > const &') -> "bool":
    return _Interface.Handle_Interface_CopyControl_IsNull(t)
Handle_Interface_CopyControl_IsNull = _Interface.Handle_Interface_CopyControl_IsNull

def Handle_Interface_EntityCluster_Create() -> "opencascade::handle< Interface_EntityCluster >":
    return _Interface.Handle_Interface_EntityCluster_Create()
Handle_Interface_EntityCluster_Create = _Interface.Handle_Interface_EntityCluster_Create

def Handle_Interface_EntityCluster_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_EntityCluster >":
    return _Interface.Handle_Interface_EntityCluster_DownCast(t)
Handle_Interface_EntityCluster_DownCast = _Interface.Handle_Interface_EntityCluster_DownCast

def Handle_Interface_EntityCluster_IsNull(t: 'opencascade::handle< Interface_EntityCluster > const &') -> "bool":
    return _Interface.Handle_Interface_EntityCluster_IsNull(t)
Handle_Interface_EntityCluster_IsNull = _Interface.Handle_Interface_EntityCluster_IsNull

def Handle_Interface_FileReaderData_Create() -> "opencascade::handle< Interface_FileReaderData >":
    return _Interface.Handle_Interface_FileReaderData_Create()
Handle_Interface_FileReaderData_Create = _Interface.Handle_Interface_FileReaderData_Create

def Handle_Interface_FileReaderData_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_FileReaderData >":
    return _Interface.Handle_Interface_FileReaderData_DownCast(t)
Handle_Interface_FileReaderData_DownCast = _Interface.Handle_Interface_FileReaderData_DownCast

def Handle_Interface_FileReaderData_IsNull(t: 'opencascade::handle< Interface_FileReaderData > const &') -> "bool":
    return _Interface.Handle_Interface_FileReaderData_IsNull(t)
Handle_Interface_FileReaderData_IsNull = _Interface.Handle_Interface_FileReaderData_IsNull

def Handle_Interface_GTool_Create() -> "opencascade::handle< Interface_GTool >":
    return _Interface.Handle_Interface_GTool_Create()
Handle_Interface_GTool_Create = _Interface.Handle_Interface_GTool_Create

def Handle_Interface_GTool_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_GTool >":
    return _Interface.Handle_Interface_GTool_DownCast(t)
Handle_Interface_GTool_DownCast = _Interface.Handle_Interface_GTool_DownCast

def Handle_Interface_GTool_IsNull(t: 'opencascade::handle< Interface_GTool > const &') -> "bool":
    return _Interface.Handle_Interface_GTool_IsNull(t)
Handle_Interface_GTool_IsNull = _Interface.Handle_Interface_GTool_IsNull

def Handle_Interface_GeneralModule_Create() -> "opencascade::handle< Interface_GeneralModule >":
    return _Interface.Handle_Interface_GeneralModule_Create()
Handle_Interface_GeneralModule_Create = _Interface.Handle_Interface_GeneralModule_Create

def Handle_Interface_GeneralModule_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_GeneralModule >":
    return _Interface.Handle_Interface_GeneralModule_DownCast(t)
Handle_Interface_GeneralModule_DownCast = _Interface.Handle_Interface_GeneralModule_DownCast

def Handle_Interface_GeneralModule_IsNull(t: 'opencascade::handle< Interface_GeneralModule > const &') -> "bool":
    return _Interface.Handle_Interface_GeneralModule_IsNull(t)
Handle_Interface_GeneralModule_IsNull = _Interface.Handle_Interface_GeneralModule_IsNull

def Handle_Interface_GlobalNodeOfGeneralLib_Create() -> "opencascade::handle< Interface_GlobalNodeOfGeneralLib >":
    return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Create()
Handle_Interface_GlobalNodeOfGeneralLib_Create = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Create

def Handle_Interface_GlobalNodeOfGeneralLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_GlobalNodeOfGeneralLib >":
    return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_DownCast(t)
Handle_Interface_GlobalNodeOfGeneralLib_DownCast = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_DownCast

def Handle_Interface_GlobalNodeOfGeneralLib_IsNull(t: 'opencascade::handle< Interface_GlobalNodeOfGeneralLib > const &') -> "bool":
    return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_IsNull(t)
Handle_Interface_GlobalNodeOfGeneralLib_IsNull = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_IsNull

def Handle_Interface_GlobalNodeOfReaderLib_Create() -> "opencascade::handle< Interface_GlobalNodeOfReaderLib >":
    return _Interface.Handle_Interface_GlobalNodeOfReaderLib_Create()
Handle_Interface_GlobalNodeOfReaderLib_Create = _Interface.Handle_Interface_GlobalNodeOfReaderLib_Create

def Handle_Interface_GlobalNodeOfReaderLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_GlobalNodeOfReaderLib >":
    return _Interface.Handle_Interface_GlobalNodeOfReaderLib_DownCast(t)
Handle_Interface_GlobalNodeOfReaderLib_DownCast = _Interface.Handle_Interface_GlobalNodeOfReaderLib_DownCast

def Handle_Interface_GlobalNodeOfReaderLib_IsNull(t: 'opencascade::handle< Interface_GlobalNodeOfReaderLib > const &') -> "bool":
    return _Interface.Handle_Interface_GlobalNodeOfReaderLib_IsNull(t)
Handle_Interface_GlobalNodeOfReaderLib_IsNull = _Interface.Handle_Interface_GlobalNodeOfReaderLib_IsNull

def Handle_Interface_HGraph_Create() -> "opencascade::handle< Interface_HGraph >":
    return _Interface.Handle_Interface_HGraph_Create()
Handle_Interface_HGraph_Create = _Interface.Handle_Interface_HGraph_Create

def Handle_Interface_HGraph_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_HGraph >":
    return _Interface.Handle_Interface_HGraph_DownCast(t)
Handle_Interface_HGraph_DownCast = _Interface.Handle_Interface_HGraph_DownCast

def Handle_Interface_HGraph_IsNull(t: 'opencascade::handle< Interface_HGraph > const &') -> "bool":
    return _Interface.Handle_Interface_HGraph_IsNull(t)
Handle_Interface_HGraph_IsNull = _Interface.Handle_Interface_HGraph_IsNull

def Handle_Interface_IntVal_Create() -> "opencascade::handle< Interface_IntVal >":
    return _Interface.Handle_Interface_IntVal_Create()
Handle_Interface_IntVal_Create = _Interface.Handle_Interface_IntVal_Create

def Handle_Interface_IntVal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_IntVal >":
    return _Interface.Handle_Interface_IntVal_DownCast(t)
Handle_Interface_IntVal_DownCast = _Interface.Handle_Interface_IntVal_DownCast

def Handle_Interface_IntVal_IsNull(t: 'opencascade::handle< Interface_IntVal > const &') -> "bool":
    return _Interface.Handle_Interface_IntVal_IsNull(t)
Handle_Interface_IntVal_IsNull = _Interface.Handle_Interface_IntVal_IsNull

def Handle_Interface_InterfaceModel_Create() -> "opencascade::handle< Interface_InterfaceModel >":
    return _Interface.Handle_Interface_InterfaceModel_Create()
Handle_Interface_InterfaceModel_Create = _Interface.Handle_Interface_InterfaceModel_Create

def Handle_Interface_InterfaceModel_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_InterfaceModel >":
    return _Interface.Handle_Interface_InterfaceModel_DownCast(t)
Handle_Interface_InterfaceModel_DownCast = _Interface.Handle_Interface_InterfaceModel_DownCast

def Handle_Interface_InterfaceModel_IsNull(t: 'opencascade::handle< Interface_InterfaceModel > const &') -> "bool":
    return _Interface.Handle_Interface_InterfaceModel_IsNull(t)
Handle_Interface_InterfaceModel_IsNull = _Interface.Handle_Interface_InterfaceModel_IsNull

def Handle_Interface_NodeOfGeneralLib_Create() -> "opencascade::handle< Interface_NodeOfGeneralLib >":
    return _Interface.Handle_Interface_NodeOfGeneralLib_Create()
Handle_Interface_NodeOfGeneralLib_Create = _Interface.Handle_Interface_NodeOfGeneralLib_Create

def Handle_Interface_NodeOfGeneralLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_NodeOfGeneralLib >":
    return _Interface.Handle_Interface_NodeOfGeneralLib_DownCast(t)
Handle_Interface_NodeOfGeneralLib_DownCast = _Interface.Handle_Interface_NodeOfGeneralLib_DownCast

def Handle_Interface_NodeOfGeneralLib_IsNull(t: 'opencascade::handle< Interface_NodeOfGeneralLib > const &') -> "bool":
    return _Interface.Handle_Interface_NodeOfGeneralLib_IsNull(t)
Handle_Interface_NodeOfGeneralLib_IsNull = _Interface.Handle_Interface_NodeOfGeneralLib_IsNull

def Handle_Interface_NodeOfReaderLib_Create() -> "opencascade::handle< Interface_NodeOfReaderLib >":
    return _Interface.Handle_Interface_NodeOfReaderLib_Create()
Handle_Interface_NodeOfReaderLib_Create = _Interface.Handle_Interface_NodeOfReaderLib_Create

def Handle_Interface_NodeOfReaderLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_NodeOfReaderLib >":
    return _Interface.Handle_Interface_NodeOfReaderLib_DownCast(t)
Handle_Interface_NodeOfReaderLib_DownCast = _Interface.Handle_Interface_NodeOfReaderLib_DownCast

def Handle_Interface_NodeOfReaderLib_IsNull(t: 'opencascade::handle< Interface_NodeOfReaderLib > const &') -> "bool":
    return _Interface.Handle_Interface_NodeOfReaderLib_IsNull(t)
Handle_Interface_NodeOfReaderLib_IsNull = _Interface.Handle_Interface_NodeOfReaderLib_IsNull

def Handle_Interface_ParamList_Create() -> "opencascade::handle< Interface_ParamList >":
    return _Interface.Handle_Interface_ParamList_Create()
Handle_Interface_ParamList_Create = _Interface.Handle_Interface_ParamList_Create

def Handle_Interface_ParamList_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_ParamList >":
    return _Interface.Handle_Interface_ParamList_DownCast(t)
Handle_Interface_ParamList_DownCast = _Interface.Handle_Interface_ParamList_DownCast

def Handle_Interface_ParamList_IsNull(t: 'opencascade::handle< Interface_ParamList > const &') -> "bool":
    return _Interface.Handle_Interface_ParamList_IsNull(t)
Handle_Interface_ParamList_IsNull = _Interface.Handle_Interface_ParamList_IsNull

def Handle_Interface_ParamSet_Create() -> "opencascade::handle< Interface_ParamSet >":
    return _Interface.Handle_Interface_ParamSet_Create()
Handle_Interface_ParamSet_Create = _Interface.Handle_Interface_ParamSet_Create

def Handle_Interface_ParamSet_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_ParamSet >":
    return _Interface.Handle_Interface_ParamSet_DownCast(t)
Handle_Interface_ParamSet_DownCast = _Interface.Handle_Interface_ParamSet_DownCast

def Handle_Interface_ParamSet_IsNull(t: 'opencascade::handle< Interface_ParamSet > const &') -> "bool":
    return _Interface.Handle_Interface_ParamSet_IsNull(t)
Handle_Interface_ParamSet_IsNull = _Interface.Handle_Interface_ParamSet_IsNull

def Handle_Interface_Protocol_Create() -> "opencascade::handle< Interface_Protocol >":
    return _Interface.Handle_Interface_Protocol_Create()
Handle_Interface_Protocol_Create = _Interface.Handle_Interface_Protocol_Create

def Handle_Interface_Protocol_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_Protocol >":
    return _Interface.Handle_Interface_Protocol_DownCast(t)
Handle_Interface_Protocol_DownCast = _Interface.Handle_Interface_Protocol_DownCast

def Handle_Interface_Protocol_IsNull(t: 'opencascade::handle< Interface_Protocol > const &') -> "bool":
    return _Interface.Handle_Interface_Protocol_IsNull(t)
Handle_Interface_Protocol_IsNull = _Interface.Handle_Interface_Protocol_IsNull

def Handle_Interface_ReaderModule_Create() -> "opencascade::handle< Interface_ReaderModule >":
    return _Interface.Handle_Interface_ReaderModule_Create()
Handle_Interface_ReaderModule_Create = _Interface.Handle_Interface_ReaderModule_Create

def Handle_Interface_ReaderModule_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_ReaderModule >":
    return _Interface.Handle_Interface_ReaderModule_DownCast(t)
Handle_Interface_ReaderModule_DownCast = _Interface.Handle_Interface_ReaderModule_DownCast

def Handle_Interface_ReaderModule_IsNull(t: 'opencascade::handle< Interface_ReaderModule > const &') -> "bool":
    return _Interface.Handle_Interface_ReaderModule_IsNull(t)
Handle_Interface_ReaderModule_IsNull = _Interface.Handle_Interface_ReaderModule_IsNull

def Handle_Interface_ReportEntity_Create() -> "opencascade::handle< Interface_ReportEntity >":
    return _Interface.Handle_Interface_ReportEntity_Create()
Handle_Interface_ReportEntity_Create = _Interface.Handle_Interface_ReportEntity_Create

def Handle_Interface_ReportEntity_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_ReportEntity >":
    return _Interface.Handle_Interface_ReportEntity_DownCast(t)
Handle_Interface_ReportEntity_DownCast = _Interface.Handle_Interface_ReportEntity_DownCast

def Handle_Interface_ReportEntity_IsNull(t: 'opencascade::handle< Interface_ReportEntity > const &') -> "bool":
    return _Interface.Handle_Interface_ReportEntity_IsNull(t)
Handle_Interface_ReportEntity_IsNull = _Interface.Handle_Interface_ReportEntity_IsNull

def Handle_Interface_SignLabel_Create() -> "opencascade::handle< Interface_SignLabel >":
    return _Interface.Handle_Interface_SignLabel_Create()
Handle_Interface_SignLabel_Create = _Interface.Handle_Interface_SignLabel_Create

def Handle_Interface_SignLabel_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_SignLabel >":
    return _Interface.Handle_Interface_SignLabel_DownCast(t)
Handle_Interface_SignLabel_DownCast = _Interface.Handle_Interface_SignLabel_DownCast

def Handle_Interface_SignLabel_IsNull(t: 'opencascade::handle< Interface_SignLabel > const &') -> "bool":
    return _Interface.Handle_Interface_SignLabel_IsNull(t)
Handle_Interface_SignLabel_IsNull = _Interface.Handle_Interface_SignLabel_IsNull

def Handle_Interface_SignType_Create() -> "opencascade::handle< Interface_SignType >":
    return _Interface.Handle_Interface_SignType_Create()
Handle_Interface_SignType_Create = _Interface.Handle_Interface_SignType_Create

def Handle_Interface_SignType_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_SignType >":
    return _Interface.Handle_Interface_SignType_DownCast(t)
Handle_Interface_SignType_DownCast = _Interface.Handle_Interface_SignType_DownCast

def Handle_Interface_SignType_IsNull(t: 'opencascade::handle< Interface_SignType > const &') -> "bool":
    return _Interface.Handle_Interface_SignType_IsNull(t)
Handle_Interface_SignType_IsNull = _Interface.Handle_Interface_SignType_IsNull

def Handle_Interface_TypedValue_Create() -> "opencascade::handle< Interface_TypedValue >":
    return _Interface.Handle_Interface_TypedValue_Create()
Handle_Interface_TypedValue_Create = _Interface.Handle_Interface_TypedValue_Create

def Handle_Interface_TypedValue_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_TypedValue >":
    return _Interface.Handle_Interface_TypedValue_DownCast(t)
Handle_Interface_TypedValue_DownCast = _Interface.Handle_Interface_TypedValue_DownCast

def Handle_Interface_TypedValue_IsNull(t: 'opencascade::handle< Interface_TypedValue > const &') -> "bool":
    return _Interface.Handle_Interface_TypedValue_IsNull(t)
Handle_Interface_TypedValue_IsNull = _Interface.Handle_Interface_TypedValue_IsNull

def Handle_Interface_UndefinedContent_Create() -> "opencascade::handle< Interface_UndefinedContent >":
    return _Interface.Handle_Interface_UndefinedContent_Create()
Handle_Interface_UndefinedContent_Create = _Interface.Handle_Interface_UndefinedContent_Create

def Handle_Interface_UndefinedContent_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_UndefinedContent >":
    return _Interface.Handle_Interface_UndefinedContent_DownCast(t)
Handle_Interface_UndefinedContent_DownCast = _Interface.Handle_Interface_UndefinedContent_DownCast

def Handle_Interface_UndefinedContent_IsNull(t: 'opencascade::handle< Interface_UndefinedContent > const &') -> "bool":
    return _Interface.Handle_Interface_UndefinedContent_IsNull(t)
Handle_Interface_UndefinedContent_IsNull = _Interface.Handle_Interface_UndefinedContent_IsNull

def Handle_Interface_CopyMap_Create() -> "opencascade::handle< Interface_CopyMap >":
    return _Interface.Handle_Interface_CopyMap_Create()
Handle_Interface_CopyMap_Create = _Interface.Handle_Interface_CopyMap_Create

def Handle_Interface_CopyMap_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_CopyMap >":
    return _Interface.Handle_Interface_CopyMap_DownCast(t)
Handle_Interface_CopyMap_DownCast = _Interface.Handle_Interface_CopyMap_DownCast

def Handle_Interface_CopyMap_IsNull(t: 'opencascade::handle< Interface_CopyMap > const &') -> "bool":
    return _Interface.Handle_Interface_CopyMap_IsNull(t)
Handle_Interface_CopyMap_IsNull = _Interface.Handle_Interface_CopyMap_IsNull

def Handle_Interface_Static_Create() -> "opencascade::handle< Interface_Static >":
    return _Interface.Handle_Interface_Static_Create()
Handle_Interface_Static_Create = _Interface.Handle_Interface_Static_Create

def Handle_Interface_Static_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_Static >":
    return _Interface.Handle_Interface_Static_DownCast(t)
Handle_Interface_Static_DownCast = _Interface.Handle_Interface_Static_DownCast

def Handle_Interface_Static_IsNull(t: 'opencascade::handle< Interface_Static > const &') -> "bool":
    return _Interface.Handle_Interface_Static_IsNull(t)
Handle_Interface_Static_IsNull = _Interface.Handle_Interface_Static_IsNull

def Handle_Interface_HArray1OfHAsciiString_Create() -> "opencascade::handle< Interface_HArray1OfHAsciiString >":
    return _Interface.Handle_Interface_HArray1OfHAsciiString_Create()
Handle_Interface_HArray1OfHAsciiString_Create = _Interface.Handle_Interface_HArray1OfHAsciiString_Create

def Handle_Interface_HArray1OfHAsciiString_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_HArray1OfHAsciiString >":
    return _Interface.Handle_Interface_HArray1OfHAsciiString_DownCast(t)
Handle_Interface_HArray1OfHAsciiString_DownCast = _Interface.Handle_Interface_HArray1OfHAsciiString_DownCast

def Handle_Interface_HArray1OfHAsciiString_IsNull(t: 'opencascade::handle< Interface_HArray1OfHAsciiString > const &') -> "bool":
    return _Interface.Handle_Interface_HArray1OfHAsciiString_IsNull(t)
Handle_Interface_HArray1OfHAsciiString_IsNull = _Interface.Handle_Interface_HArray1OfHAsciiString_IsNull

def Handle_Interface_HSequenceOfCheck_Create() -> "opencascade::handle< Interface_HSequenceOfCheck >":
    return _Interface.Handle_Interface_HSequenceOfCheck_Create()
Handle_Interface_HSequenceOfCheck_Create = _Interface.Handle_Interface_HSequenceOfCheck_Create

def Handle_Interface_HSequenceOfCheck_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_HSequenceOfCheck >":
    return _Interface.Handle_Interface_HSequenceOfCheck_DownCast(t)
Handle_Interface_HSequenceOfCheck_DownCast = _Interface.Handle_Interface_HSequenceOfCheck_DownCast

def Handle_Interface_HSequenceOfCheck_IsNull(t: 'opencascade::handle< Interface_HSequenceOfCheck > const &') -> "bool":
    return _Interface.Handle_Interface_HSequenceOfCheck_IsNull(t)
Handle_Interface_HSequenceOfCheck_IsNull = _Interface.Handle_Interface_HSequenceOfCheck_IsNull
class Interface_VectorOfFileParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Interface.Interface_VectorOfFileParameter_swiginit(self, _Interface.new_Interface_VectorOfFileParameter(*args))
    __swig_destroy__ = _Interface.delete_Interface_VectorOfFileParameter
Interface_VectorOfFileParameter.begin = new_instancemethod(_Interface.Interface_VectorOfFileParameter_begin, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.end = new_instancemethod(_Interface.Interface_VectorOfFileParameter_end, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.cbegin = new_instancemethod(_Interface.Interface_VectorOfFileParameter_cbegin, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.cend = new_instancemethod(_Interface.Interface_VectorOfFileParameter_cend, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Length = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Length, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Size = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Size, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Lower = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Lower, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Upper = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Upper, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.IsEmpty = new_instancemethod(_Interface.Interface_VectorOfFileParameter_IsEmpty, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Assign = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Assign, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Set = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Set, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Append = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Append, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Appended = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Appended, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Value = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Value, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.First = new_instancemethod(_Interface.Interface_VectorOfFileParameter_First, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.ChangeFirst = new_instancemethod(_Interface.Interface_VectorOfFileParameter_ChangeFirst, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.Last = new_instancemethod(_Interface.Interface_VectorOfFileParameter_Last, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.ChangeLast = new_instancemethod(_Interface.Interface_VectorOfFileParameter_ChangeLast, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.__call__ = new_instancemethod(_Interface.Interface_VectorOfFileParameter___call__, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.ChangeValue = new_instancemethod(_Interface.Interface_VectorOfFileParameter_ChangeValue, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter.SetValue = new_instancemethod(_Interface.Interface_VectorOfFileParameter_SetValue, None, Interface_VectorOfFileParameter)
Interface_VectorOfFileParameter_swigregister = _Interface.Interface_VectorOfFileParameter_swigregister
Interface_VectorOfFileParameter_swigregister(Interface_VectorOfFileParameter)

class Interface_Array1OfFileParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Interface.Interface_Array1OfFileParameter_swiginit(self, _Interface.new_Interface_Array1OfFileParameter(*args))
    __swig_destroy__ = _Interface.delete_Interface_Array1OfFileParameter

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

Interface_Array1OfFileParameter.begin = new_instancemethod(_Interface.Interface_Array1OfFileParameter_begin, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.end = new_instancemethod(_Interface.Interface_Array1OfFileParameter_end, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.cbegin = new_instancemethod(_Interface.Interface_Array1OfFileParameter_cbegin, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.cend = new_instancemethod(_Interface.Interface_Array1OfFileParameter_cend, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Init = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Init, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Size = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Size, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Length = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Length, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.IsEmpty = new_instancemethod(_Interface.Interface_Array1OfFileParameter_IsEmpty, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Lower = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Lower, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Upper = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Upper, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.IsDeletable = new_instancemethod(_Interface.Interface_Array1OfFileParameter_IsDeletable, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.IsAllocated = new_instancemethod(_Interface.Interface_Array1OfFileParameter_IsAllocated, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Assign = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Assign, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Move = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Move, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Set = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Set, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.First = new_instancemethod(_Interface.Interface_Array1OfFileParameter_First, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.ChangeFirst = new_instancemethod(_Interface.Interface_Array1OfFileParameter_ChangeFirst, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Last = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Last, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.ChangeLast = new_instancemethod(_Interface.Interface_Array1OfFileParameter_ChangeLast, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Value = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Value, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.ChangeValue = new_instancemethod(_Interface.Interface_Array1OfFileParameter_ChangeValue, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.__call__ = new_instancemethod(_Interface.Interface_Array1OfFileParameter___call__, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.SetValue = new_instancemethod(_Interface.Interface_Array1OfFileParameter_SetValue, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter.Resize = new_instancemethod(_Interface.Interface_Array1OfFileParameter_Resize, None, Interface_Array1OfFileParameter)
Interface_Array1OfFileParameter_swigregister = _Interface.Interface_Array1OfFileParameter_swigregister
Interface_Array1OfFileParameter_swigregister(Interface_Array1OfFileParameter)

class Interface_Array1OfHAsciiString(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Interface.Interface_Array1OfHAsciiString_swiginit(self, _Interface.new_Interface_Array1OfHAsciiString(*args))
    __swig_destroy__ = _Interface.delete_Interface_Array1OfHAsciiString

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

Interface_Array1OfHAsciiString.begin = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_begin, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.end = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_end, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.cbegin = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_cbegin, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.cend = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_cend, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Init = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Init, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Size = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Size, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Length = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Length, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.IsEmpty = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_IsEmpty, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Lower = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Lower, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Upper = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Upper, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.IsDeletable = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_IsDeletable, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.IsAllocated = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_IsAllocated, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Assign = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Assign, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Move = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Move, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Set = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Set, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.First = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_First, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.ChangeFirst = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_ChangeFirst, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Last = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Last, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.ChangeLast = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_ChangeLast, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Value = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Value, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.ChangeValue = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_ChangeValue, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.__call__ = new_instancemethod(_Interface.Interface_Array1OfHAsciiString___call__, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.SetValue = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_SetValue, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString.Resize = new_instancemethod(_Interface.Interface_Array1OfHAsciiString_Resize, None, Interface_Array1OfHAsciiString)
Interface_Array1OfHAsciiString_swigregister = _Interface.Interface_Array1OfHAsciiString_swigregister
Interface_Array1OfHAsciiString_swigregister(Interface_Array1OfHAsciiString)

class Interface_SequenceOfCheck(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Interface.Interface_SequenceOfCheck_swiginit(self, _Interface.new_Interface_SequenceOfCheck(*args))
    delNode = staticmethod(_Interface.Interface_SequenceOfCheck_delNode)
    __swig_destroy__ = _Interface.delete_Interface_SequenceOfCheck
Interface_SequenceOfCheck.begin = new_instancemethod(_Interface.Interface_SequenceOfCheck_begin, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.end = new_instancemethod(_Interface.Interface_SequenceOfCheck_end, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.cbegin = new_instancemethod(_Interface.Interface_SequenceOfCheck_cbegin, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.cend = new_instancemethod(_Interface.Interface_SequenceOfCheck_cend, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Size = new_instancemethod(_Interface.Interface_SequenceOfCheck_Size, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Length = new_instancemethod(_Interface.Interface_SequenceOfCheck_Length, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Lower = new_instancemethod(_Interface.Interface_SequenceOfCheck_Lower, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Upper = new_instancemethod(_Interface.Interface_SequenceOfCheck_Upper, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.IsEmpty = new_instancemethod(_Interface.Interface_SequenceOfCheck_IsEmpty, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Reverse = new_instancemethod(_Interface.Interface_SequenceOfCheck_Reverse, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Exchange = new_instancemethod(_Interface.Interface_SequenceOfCheck_Exchange, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Clear = new_instancemethod(_Interface.Interface_SequenceOfCheck_Clear, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Assign = new_instancemethod(_Interface.Interface_SequenceOfCheck_Assign, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Set = new_instancemethod(_Interface.Interface_SequenceOfCheck_Set, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Remove = new_instancemethod(_Interface.Interface_SequenceOfCheck_Remove, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Append = new_instancemethod(_Interface.Interface_SequenceOfCheck_Append, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Prepend = new_instancemethod(_Interface.Interface_SequenceOfCheck_Prepend, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.InsertBefore = new_instancemethod(_Interface.Interface_SequenceOfCheck_InsertBefore, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.InsertAfter = new_instancemethod(_Interface.Interface_SequenceOfCheck_InsertAfter, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Split = new_instancemethod(_Interface.Interface_SequenceOfCheck_Split, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.First = new_instancemethod(_Interface.Interface_SequenceOfCheck_First, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.ChangeFirst = new_instancemethod(_Interface.Interface_SequenceOfCheck_ChangeFirst, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Last = new_instancemethod(_Interface.Interface_SequenceOfCheck_Last, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.ChangeLast = new_instancemethod(_Interface.Interface_SequenceOfCheck_ChangeLast, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.Value = new_instancemethod(_Interface.Interface_SequenceOfCheck_Value, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.ChangeValue = new_instancemethod(_Interface.Interface_SequenceOfCheck_ChangeValue, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.__call__ = new_instancemethod(_Interface.Interface_SequenceOfCheck___call__, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck.SetValue = new_instancemethod(_Interface.Interface_SequenceOfCheck_SetValue, None, Interface_SequenceOfCheck)
Interface_SequenceOfCheck_swigregister = _Interface.Interface_SequenceOfCheck_swigregister
Interface_SequenceOfCheck_swigregister(Interface_SequenceOfCheck)

def Interface_SequenceOfCheck_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _Interface.Interface_SequenceOfCheck_delNode(theNode, theAl)
Interface_SequenceOfCheck_delNode = _Interface.Interface_SequenceOfCheck_delNode

class Interface_DataMapOfTransientInteger(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Interface.Interface_DataMapOfTransientInteger_swiginit(self, _Interface.new_Interface_DataMapOfTransientInteger(*args))
    __swig_destroy__ = _Interface.delete_Interface_DataMapOfTransientInteger
Interface_DataMapOfTransientInteger.begin = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_begin, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.end = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_end, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.cbegin = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_cbegin, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.cend = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_cend, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.Exchange = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_Exchange, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.Assign = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_Assign, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.Set = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_Set, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.ReSize = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_ReSize, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.Bind = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_Bind, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.Bound = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_Bound, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.IsBound = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_IsBound, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.UnBind = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_UnBind, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.Seek = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_Seek, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.Find = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_Find, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.ChangeSeek = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_ChangeSeek, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.ChangeFind = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_ChangeFind, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.__call__ = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger___call__, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.Clear = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_Clear, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger.Size = new_instancemethod(_Interface.Interface_DataMapOfTransientInteger_Size, None, Interface_DataMapOfTransientInteger)
Interface_DataMapOfTransientInteger_swigregister = _Interface.Interface_DataMapOfTransientInteger_swigregister
Interface_DataMapOfTransientInteger_swigregister(Interface_DataMapOfTransientInteger)

class Interface_IndexedMapOfAsciiString(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Interface.Interface_IndexedMapOfAsciiString_swiginit(self, _Interface.new_Interface_IndexedMapOfAsciiString(*args))
    __swig_destroy__ = _Interface.delete_Interface_IndexedMapOfAsciiString
Interface_IndexedMapOfAsciiString.cbegin = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_cbegin, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.cend = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_cend, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.Exchange = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_Exchange, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.Assign = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_Assign, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.Set = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_Set, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.ReSize = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_ReSize, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.Add = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_Add, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.Contains = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_Contains, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.Substitute = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_Substitute, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.Swap = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_Swap, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.RemoveLast = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_RemoveLast, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.RemoveFromIndex = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_RemoveFromIndex, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.RemoveKey = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_RemoveKey, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.FindKey = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_FindKey, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.__call__ = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString___call__, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.FindIndex = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_FindIndex, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.Clear = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_Clear, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString.Size = new_instancemethod(_Interface.Interface_IndexedMapOfAsciiString_Size, None, Interface_IndexedMapOfAsciiString)
Interface_IndexedMapOfAsciiString_swigregister = _Interface.Interface_IndexedMapOfAsciiString_swigregister
Interface_IndexedMapOfAsciiString_swigregister(Interface_IndexedMapOfAsciiString)

class Interface_BitMap(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddFlag(self, *args) -> "Standard_Integer":
        """
        * Adds a flag, a name can be attached to it Returns its flag number Makes required reservation
        	:param name: default value is 
        	:type name: char *
        	:rtype: int
        """
        return _Interface.Interface_BitMap_AddFlag(self, *args)


    def AddSomeFlags(self, *args) -> "Standard_Integer":
        """
        * Adds several flags (<more>) with no name Returns the number of last added flag
        	:param more:
        	:type more: int
        	:rtype: int
        """
        return _Interface.Interface_BitMap_AddSomeFlags(self, *args)


    def CFalse(self, *args) -> "Standard_Boolean":
        """
        * Returns the former value for a flag and sets it to False (before : value returned; after : False)
        	:param item:
        	:type item: int
        	:param flag: default value is 0
        	:type flag: int
        	:rtype: bool
        """
        return _Interface.Interface_BitMap_CFalse(self, *args)


    def CTrue(self, *args) -> "Standard_Boolean":
        """
        * Returns the former value for a flag and sets it to True (before : value returned; after : True)
        	:param item:
        	:type item: int
        	:param flag: default value is 0
        	:type flag: int
        	:rtype: bool
        """
        return _Interface.Interface_BitMap_CTrue(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clear all field of bit map
        	:rtype: None
        """
        return _Interface.Interface_BitMap_Clear(self, *args)


    def FlagName(self, *args) -> "char const *":
        """
        * Returns the name recorded for a flag, or an empty string
        	:param num:
        	:type num: int
        	:rtype: char *
        """
        return _Interface.Interface_BitMap_FlagName(self, *args)


    def FlagNumber(self, *args) -> "Standard_Integer":
        """
        * Returns the number or a flag given its name, or zero
        	:param name:
        	:type name: char *
        	:rtype: int
        """
        return _Interface.Interface_BitMap_FlagNumber(self, *args)


    def Init(self, *args) -> "void":
        """
        * Initialises all the values of Flag Number <flag> to a given value <val>
        	:param val:
        	:type val: bool
        	:param flag: default value is 0
        	:type flag: int
        	:rtype: None
        """
        return _Interface.Interface_BitMap_Init(self, *args)


    def Initialize(self, *args) -> "void":
        """
        * Initialize empty bit by <nbitems> items One flag is defined, n0 0 <resflags> prepares allocation for <resflags> more flags Flags values start at false
        	:param nbitems:
        	:type nbitems: int
        	:param resflags: default value is 0
        	:type resflags: int
        	:rtype: None
        * Initialize a BitMap from another one
        	:param other:
        	:type other: Interface_BitMap
        	:param copied: default value is Standard_False
        	:type copied: bool
        	:rtype: None
        """
        return _Interface.Interface_BitMap_Initialize(self, *args)


    def __init__(self, *args):
        """
        * Creates a empty BitMap
        	:rtype: None
        * Creates a BitMap for <nbitems> items One flag is defined, n0 0 <resflags> prepares allocation for <resflags> more flags Flags values start at false
        	:param nbitems:
        	:type nbitems: int
        	:param resflags: default value is 0
        	:type resflags: int
        	:rtype: None
        * Creates a BitMap from another one if <copied> is True, copies data else, data are not copied, only the header object is
        	:param other:
        	:type other: Interface_BitMap
        	:param copied: default value is Standard_False
        	:type copied: bool
        	:rtype: None
        """
        _Interface.Interface_BitMap_swiginit(self, _Interface.new_Interface_BitMap(*args))

    def Internals(self, *args) -> "void":
        """
        * Returns internal values, used for copying Flags values start at false
        	:param nbitems:
        	:type nbitems: int
        	:param nbwords:
        	:type nbwords: int
        	:param nbflags:
        	:type nbflags: int
        	:param flags:
        	:type flags: TColStd_HArray1OfInteger
        	:param names:
        	:type names: TColStd_HSequenceOfAsciiString
        	:rtype: None
        """
        return _Interface.Interface_BitMap_Internals(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        * Returns the count of items (i.e. the length of the bitmap)
        	:rtype: int
        """
        return _Interface.Interface_BitMap_Length(self, *args)


    def NbFlags(self, *args) -> "Standard_Integer":
        """
        * Returns the count of flags (flag 0 not included)
        	:rtype: int
        """
        return _Interface.Interface_BitMap_NbFlags(self, *args)


    def RemoveFlag(self, *args) -> "Standard_Boolean":
        """
        * Removes a flag given its number. Returns True if done, false if num is out of range
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_BitMap_RemoveFlag(self, *args)


    def Reservate(self, *args) -> "void":
        """
        * Reservates for a count of more flags
        	:param moreflags:
        	:type moreflags: int
        	:rtype: None
        """
        return _Interface.Interface_BitMap_Reservate(self, *args)


    def SetFalse(self, *args) -> "void":
        """
        * Sets a flag to False
        	:param item:
        	:type item: int
        	:param flag: default value is 0
        	:type flag: int
        	:rtype: None
        """
        return _Interface.Interface_BitMap_SetFalse(self, *args)


    def SetFlagName(self, *args) -> "Standard_Boolean":
        """
        * Sets a name for a flag, given its number name can be empty (to erase the name of a flag) Returns True if done, false if : num is out of range, or name non-empty already set to another flag
        	:param num:
        	:type num: int
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _Interface.Interface_BitMap_SetFlagName(self, *args)


    def SetLength(self, *args) -> "void":
        """
        * Sets for a new count of items, which can be either less or greater than the former one For new items, their flags start at false
        	:param nbitems:
        	:type nbitems: int
        	:rtype: None
        """
        return _Interface.Interface_BitMap_SetLength(self, *args)


    def SetTrue(self, *args) -> "void":
        """
        * Sets a flag to True
        	:param item:
        	:type item: int
        	:param flag: default value is 0
        	:type flag: int
        	:rtype: None
        """
        return _Interface.Interface_BitMap_SetTrue(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Sets a new value for a flag
        	:param item:
        	:type item: int
        	:param val:
        	:type val: bool
        	:param flag: default value is 0
        	:type flag: int
        	:rtype: None
        """
        return _Interface.Interface_BitMap_SetValue(self, *args)


    def Value(self, *args) -> "Standard_Boolean":
        """
        * Returns the value (true/false) of a flag, from : - the number of the item - the flag number, by default 0
        	:param item:
        	:type item: int
        	:param flag: default value is 0
        	:type flag: int
        	:rtype: bool
        """
        return _Interface.Interface_BitMap_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_BitMap
Interface_BitMap.AddFlag = new_instancemethod(_Interface.Interface_BitMap_AddFlag, None, Interface_BitMap)
Interface_BitMap.AddSomeFlags = new_instancemethod(_Interface.Interface_BitMap_AddSomeFlags, None, Interface_BitMap)
Interface_BitMap.CFalse = new_instancemethod(_Interface.Interface_BitMap_CFalse, None, Interface_BitMap)
Interface_BitMap.CTrue = new_instancemethod(_Interface.Interface_BitMap_CTrue, None, Interface_BitMap)
Interface_BitMap.Clear = new_instancemethod(_Interface.Interface_BitMap_Clear, None, Interface_BitMap)
Interface_BitMap.FlagName = new_instancemethod(_Interface.Interface_BitMap_FlagName, None, Interface_BitMap)
Interface_BitMap.FlagNumber = new_instancemethod(_Interface.Interface_BitMap_FlagNumber, None, Interface_BitMap)
Interface_BitMap.Init = new_instancemethod(_Interface.Interface_BitMap_Init, None, Interface_BitMap)
Interface_BitMap.Initialize = new_instancemethod(_Interface.Interface_BitMap_Initialize, None, Interface_BitMap)
Interface_BitMap.Internals = new_instancemethod(_Interface.Interface_BitMap_Internals, None, Interface_BitMap)
Interface_BitMap.Length = new_instancemethod(_Interface.Interface_BitMap_Length, None, Interface_BitMap)
Interface_BitMap.NbFlags = new_instancemethod(_Interface.Interface_BitMap_NbFlags, None, Interface_BitMap)
Interface_BitMap.RemoveFlag = new_instancemethod(_Interface.Interface_BitMap_RemoveFlag, None, Interface_BitMap)
Interface_BitMap.Reservate = new_instancemethod(_Interface.Interface_BitMap_Reservate, None, Interface_BitMap)
Interface_BitMap.SetFalse = new_instancemethod(_Interface.Interface_BitMap_SetFalse, None, Interface_BitMap)
Interface_BitMap.SetFlagName = new_instancemethod(_Interface.Interface_BitMap_SetFlagName, None, Interface_BitMap)
Interface_BitMap.SetLength = new_instancemethod(_Interface.Interface_BitMap_SetLength, None, Interface_BitMap)
Interface_BitMap.SetTrue = new_instancemethod(_Interface.Interface_BitMap_SetTrue, None, Interface_BitMap)
Interface_BitMap.SetValue = new_instancemethod(_Interface.Interface_BitMap_SetValue, None, Interface_BitMap)
Interface_BitMap.Value = new_instancemethod(_Interface.Interface_BitMap_Value, None, Interface_BitMap)
Interface_BitMap_swigregister = _Interface.Interface_BitMap_swigregister
Interface_BitMap_swigregister(Interface_BitMap)

class Interface_Category(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddCategory(*args) -> "Standard_Integer":
        """
        * Records a new Category defined by its names, produces a number New if not yet recorded
        	:param theName:
        	:type theName: char *
        	:rtype: int
        """
        return _Interface.Interface_Category_AddCategory(*args)

    AddCategory = staticmethod(AddCategory)

    def CatNum(self, *args) -> "Standard_Integer":
        """
        * Determines the Category Number for an entity in its context, by using general service CategoryNumber
        	:param theEnt:
        	:type theEnt: Standard_Transient
        	:param theShares:
        	:type theShares: Interface_ShareTool
        	:rtype: int
        """
        return _Interface.Interface_Category_CatNum(self, *args)


    def ClearNums(self, *args) -> "void":
        """
        * Clears the recorded list of category numbers for a Model
        	:rtype: None
        """
        return _Interface.Interface_Category_ClearNums(self, *args)


    def Compute(self, *args) -> "void":
        """
        * Computes the Category Number for each entity and records it, in an array (ent.number -> category number) Hence, it can be queried by the method Num. The Model itself is not recorded, this method is intended to be used in a wider context (which detains also a Graph, etc)
        	:param theModel:
        	:type theModel: Interface_InterfaceModel
        	:param theShares:
        	:type theShares: Interface_ShareTool
        	:rtype: None
        """
        return _Interface.Interface_Category_Compute(self, *args)


    def Init(*args) -> "void":
        """
        * Default initialisation (protected against several calls : passes only once)
        	:rtype: void
        """
        return _Interface.Interface_Category_Init(*args)

    Init = staticmethod(Init)

    def __init__(self, *args):
        """
        * Creates a Category, with no protocol yet
        	:rtype: None
        * Creates a Category with a given protocol
        	:param theProtocol:
        	:type theProtocol: Interface_Protocol
        	:rtype: None
        * Creates a Category with a given GTool
        	:param theGTool:
        	:type theGTool: Interface_GTool
        	:rtype: None
        """
        _Interface.Interface_Category_swiginit(self, _Interface.new_Interface_Category(*args))

    def Name(*args) -> "char const *":
        """
        * Returns the name of a category, according to its number
        	:param theNum:
        	:type theNum: int
        	:rtype: char *
        """
        return _Interface.Interface_Category_Name(*args)

    Name = staticmethod(Name)

    def NbCategories(*args) -> "Standard_Integer":
        """
        * Returns the count of recorded categories
        	:rtype: int
        """
        return _Interface.Interface_Category_NbCategories(*args)

    NbCategories = staticmethod(NbCategories)

    def Num(self, *args) -> "Standard_Integer":
        """
        * Returns the category number recorded for an entity number Returns 0 if out of range
        	:param theNumEnt:
        	:type theNumEnt: int
        	:rtype: int
        """
        return _Interface.Interface_Category_Num(self, *args)


    def Number(*args) -> "Standard_Integer":
        """
        * Returns the number of a category, according to its name
        	:param theName:
        	:type theName: char *
        	:rtype: int
        """
        return _Interface.Interface_Category_Number(*args)

    Number = staticmethod(Number)

    def SetProtocol(self, *args) -> "void":
        """
        * Sets/Changes Protocol
        	:param theProtocol:
        	:type theProtocol: Interface_Protocol
        	:rtype: None
        """
        return _Interface.Interface_Category_SetProtocol(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Category
Interface_Category.CatNum = new_instancemethod(_Interface.Interface_Category_CatNum, None, Interface_Category)
Interface_Category.ClearNums = new_instancemethod(_Interface.Interface_Category_ClearNums, None, Interface_Category)
Interface_Category.Compute = new_instancemethod(_Interface.Interface_Category_Compute, None, Interface_Category)
Interface_Category.Num = new_instancemethod(_Interface.Interface_Category_Num, None, Interface_Category)
Interface_Category.SetProtocol = new_instancemethod(_Interface.Interface_Category_SetProtocol, None, Interface_Category)
Interface_Category_swigregister = _Interface.Interface_Category_swigregister
Interface_Category_swigregister(Interface_Category)

def Interface_Category_AddCategory(*args) -> "Standard_Integer":
    """
    * Records a new Category defined by its names, produces a number New if not yet recorded
    	:param theName:
    	:type theName: char *
    	:rtype: int
    """
    return _Interface.Interface_Category_AddCategory(*args)

def Interface_Category_Init(*args) -> "void":
    """
    * Default initialisation (protected against several calls : passes only once)
    	:rtype: void
    """
    return _Interface.Interface_Category_Init(*args)

def Interface_Category_Name(*args) -> "char const *":
    """
    * Returns the name of a category, according to its number
    	:param theNum:
    	:type theNum: int
    	:rtype: char *
    """
    return _Interface.Interface_Category_Name(*args)

def Interface_Category_NbCategories(*args) -> "Standard_Integer":
    """
    * Returns the count of recorded categories
    	:rtype: int
    """
    return _Interface.Interface_Category_NbCategories(*args)

def Interface_Category_Number(*args) -> "Standard_Integer":
    """
    * Returns the number of a category, according to its name
    	:param theName:
    	:type theName: char *
    	:rtype: int
    """
    return _Interface.Interface_Category_Number(*args)

class Interface_Check(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddFail(self, *args) -> "void":
        """
        * Records a new Fail message
        	:param amess:
        	:type amess: TCollection_HAsciiString
        	:rtype: None
        * Records a new Fail message under two forms : final,original
        	:param amess:
        	:type amess: TCollection_HAsciiString
        	:param orig:
        	:type orig: TCollection_HAsciiString
        	:rtype: None
        * Records a new Fail message given as 'error text' directly If <orig> is given, a distinct original form is recorded else (D), the original form equates <amess>
        	:param amess:
        	:type amess: char *
        	:param orig: default value is 
        	:type orig: char *
        	:rtype: None
        * Records a new Fail from the definition of a Msg (Original+Value)
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Interface.Interface_Check_AddFail(self, *args)


    def AddWarning(self, *args) -> "void":
        """
        * Records a new Warning message
        	:param amess:
        	:type amess: TCollection_HAsciiString
        	:rtype: None
        * Records a new Warning message under two forms : final,original
        	:param amess:
        	:type amess: TCollection_HAsciiString
        	:param orig:
        	:type orig: TCollection_HAsciiString
        	:rtype: None
        * Records a Warning message given as 'warning message' directly If <orig> is given, a distinct original form is recorded else (D), the original form equates <amess>
        	:param amess:
        	:type amess: char *
        	:param orig: default value is 
        	:type orig: char *
        	:rtype: None
        * Records a new Warning from the definition of a Msg (Original+Value)
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Interface.Interface_Check_AddWarning(self, *args)


    def CFail(self, *args) -> "char const *":
        """
        * Same as above, but returns a CString (to be printed ...) Final form by default, Original form if <final> is False
        	:param num:
        	:type num: int
        	:param final: default value is Standard_True
        	:type final: bool
        	:rtype: char *
        """
        return _Interface.Interface_Check_CFail(self, *args)


    def CInfoMsg(self, *args) -> "char const *":
        """
        * Same as above, but returns a CString (to be printed ...) Final form by default, Original form if <final> is False
        	:param num:
        	:type num: int
        	:param final: default value is Standard_True
        	:type final: bool
        	:rtype: char *
        """
        return _Interface.Interface_Check_CInfoMsg(self, *args)


    def CWarning(self, *args) -> "char const *":
        """
        * Same as above, but returns a CString (to be printed ...) Final form by default, Original form if <final> is False
        	:param num:
        	:type num: int
        	:param final: default value is Standard_True
        	:type final: bool
        	:rtype: char *
        """
        return _Interface.Interface_Check_CWarning(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears a check, in order to receive informations from transfer (Messages and Entity)
        	:rtype: None
        """
        return _Interface.Interface_Check_Clear(self, *args)


    def ClearFails(self, *args) -> "void":
        """
        * Clears the Fail Messages (for instance to keep only Warnings)
        	:rtype: None
        """
        return _Interface.Interface_Check_ClearFails(self, *args)


    def ClearInfoMsgs(self, *args) -> "void":
        """
        * Clears the Info Messages
        	:rtype: None
        """
        return _Interface.Interface_Check_ClearInfoMsgs(self, *args)


    def ClearWarnings(self, *args) -> "void":
        """
        * Clears the Warning Messages (for instance to keep only Fails)
        	:rtype: None
        """
        return _Interface.Interface_Check_ClearWarnings(self, *args)


    def Complies(self, *args) -> "Standard_Boolean":
        """
        * Tells if Check Status complies with a given one (i.e. also status for query)
        	:param status:
        	:type status: Interface_CheckStatus
        	:rtype: bool
        * Tells if a message is brought by a Check, as follows : <incl> = 0 : <mess> exactly matches one of the messages <incl> < 0 : <mess> is contained by one of the messages <incl> > 0 : <mess> contains one of the messages For <status> : for CheckWarning and CheckFail, considers only resp. Warning or Check messages. for CheckAny, considers all other values are ignored (answer will be false)
        	:param mess:
        	:type mess: TCollection_HAsciiString
        	:param incl:
        	:type incl: int
        	:param status:
        	:type status: Interface_CheckStatus
        	:rtype: bool
        """
        return _Interface.Interface_Check_Complies(self, *args)


    def Entity(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the entity on which the Check has been defined
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_Check_Entity(self, *args)


    def Fail(self, *args) -> "opencascade::handle< TCollection_HAsciiString > const &":
        """
        * Returns Fail Message as a String Final form by default, Original form if <final> is False
        	:param num:
        	:type num: int
        	:param final: default value is Standard_True
        	:type final: bool
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _Interface.Interface_Check_Fail(self, *args)


    def Fails(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        * Returns the list of Fails, for a frontal-engine logic Final forms by default, Original forms if <final> is False Can be empty
        	:param final: default value is Standard_True
        	:type final: bool
        	:rtype: opencascade::handle<TColStd_HSequenceOfHAsciiString>
        """
        return _Interface.Interface_Check_Fails(self, *args)


    def GetAsWarning(self, *args) -> "void":
        """
        * Copies messages converted into Warning messages If failsonly is true, only Fails are taken, and converted else, Warnings are taken too. Does not regard Entity Used to keep Fail messages as Warning, after a recovery
        	:param other:
        	:type other: Interface_Check
        	:param failsonly:
        	:type failsonly: bool
        	:rtype: None
        """
        return _Interface.Interface_Check_GetAsWarning(self, *args)


    def GetEntity(self, *args) -> "void":
        """
        * same as SetEntity (old form kept for compatibility) Warning : Does nothing if Entity field is not yet clear
        	:param anentity:
        	:type anentity: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_Check_GetEntity(self, *args)


    def GetMessages(self, *args) -> "void":
        """
        * Copies messages stored in another Check, cumulating Does not regard other's Entity. Used to cumulate messages
        	:param other:
        	:type other: Interface_Check
        	:rtype: None
        """
        return _Interface.Interface_Check_GetMessages(self, *args)


    def HasEntity(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a Check is devoted to an entity; else, it is global (for InterfaceModel's storing of global error messages)
        	:rtype: bool
        """
        return _Interface.Interface_Check_HasEntity(self, *args)


    def HasFailed(self, *args) -> "Standard_Boolean":
        """
        * Returns True if Check brings at least one Fail Message
        	:rtype: bool
        """
        return _Interface.Interface_Check_HasFailed(self, *args)


    def HasWarnings(self, *args) -> "Standard_Boolean":
        """
        * Returns True if Check brings at least one Warning Message
        	:rtype: bool
        """
        return _Interface.Interface_Check_HasWarnings(self, *args)


    def InfoMsg(self, *args) -> "opencascade::handle< TCollection_HAsciiString > const &":
        """
        * Returns information message as a String
        	:param num:
        	:type num: int
        	:param final: default value is Standard_True
        	:type final: bool
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _Interface.Interface_Check_InfoMsg(self, *args)


    def InfoMsgs(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        * Returns the list of Info Msg, for a frontal-engine logic Final forms by default, Original forms if <final> is False Can be empty
        	:param final: default value is Standard_True
        	:type final: bool
        	:rtype: opencascade::handle<TColStd_HSequenceOfHAsciiString>
        """
        return _Interface.Interface_Check_InfoMsgs(self, *args)


    def __init__(self, *args):
        """
        * Allows definition of a Sequence. Used also for Global Check of an InterfaceModel (which stores global messages for file)
        	:rtype: None
        * Defines a Check on an Entity
        	:param anentity:
        	:type anentity: Standard_Transient
        	:rtype: None
        """
        _Interface.Interface_Check_swiginit(self, _Interface.new_Interface_Check(*args))

    def Mend(self, *args) -> "Standard_Boolean":
        """
        * Mends messages, according <pref> and <num> According to <num>, works on the whole list of Fails if = 0(D) or only one Fail message, given its rank If <pref> is empty, converts Fail(s) to Warning(s) Else, does the conversion but prefixes the new Warning(s) but <pref> followed by a semi-column Some reserved values of <pref> are : 'FM' : standard prefix 'Mended' (can be translated) 'CF' : clears Fail(s) 'CW' : clears Warning(s) : here, <num> refers to Warning list 'CA' : clears all messages : here, <num> is ignored
        	:param pref:
        	:type pref: char *
        	:param num: default value is 0
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_Check_Mend(self, *args)


    def NbFails(self, *args) -> "Standard_Integer":
        """
        * Returns count of recorded Fails
        	:rtype: int
        """
        return _Interface.Interface_Check_NbFails(self, *args)


    def NbInfoMsgs(self, *args) -> "Standard_Integer":
        """
        * Returns the count of recorded information messages
        	:rtype: int
        """
        return _Interface.Interface_Check_NbInfoMsgs(self, *args)


    def NbWarnings(self, *args) -> "Standard_Integer":
        """
        * Returns count of recorded Warning messages
        	:rtype: int
        """
        return _Interface.Interface_Check_NbWarnings(self, *args)


    def Print(self, *args) -> "void":
        """
        * Prints the messages of the check to an Messenger <level> = 1 : only fails <level> = 2 : fails and warnings <level> = 3 : all (fails, warnings, info msg) <final> : if positive (D) prints final values of messages if negative, prints originals if null, prints both forms
        	:param S:
        	:type S: Message_Messenger
        	:param level:
        	:type level: int
        	:param final: default value is 1
        	:type final: int
        	:rtype: None
        """
        return _Interface.Interface_Check_Print(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        * Removes the messages which comply with <mess>, as follows : <incl> = 0 : <mess> exactly matches one of the messages <incl> < 0 : <mess> is contained by one of the messages <incl> > 0 : <mess> contains one of the messages For <status> : for CheckWarning and CheckFail, considers only resp. Warning or Check messages. for CheckAny, considers all other values are ignored (nothing is done) Returns True if at least one message has been removed, False else
        	:param mess:
        	:type mess: TCollection_HAsciiString
        	:param incl:
        	:type incl: int
        	:param status:
        	:type status: Interface_CheckStatus
        	:rtype: bool
        """
        return _Interface.Interface_Check_Remove(self, *args)


    def SendFail(self, *args) -> "void":
        """
        * New name for AddFail (Msg)
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Interface.Interface_Check_SendFail(self, *args)


    def SendMsg(self, *args) -> "void":
        """
        * Records an information message This does not change the status of the Check
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Interface.Interface_Check_SendMsg(self, *args)


    def SendWarning(self, *args) -> "void":
        """
        * New name for AddWarning
        	:param amsg:
        	:type amsg: Message_Msg
        	:rtype: None
        """
        return _Interface.Interface_Check_SendWarning(self, *args)


    def SetEntity(self, *args) -> "void":
        """
        * Receives an entity result of a Transfer
        	:param anentity:
        	:type anentity: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_Check_SetEntity(self, *args)


    def Status(self, *args) -> "Interface_CheckStatus":
        """
        * Returns the Check Status : OK, Warning or Fail
        	:rtype: Interface_CheckStatus
        """
        return _Interface.Interface_Check_Status(self, *args)


    def Trace(self, *args) -> "void":
        """
        * Prints the messages of the check to the default trace file By default, according to the default standard level Else, according level (see method Print)
        	:param level: default value is -1
        	:type level: int
        	:param final: default value is 1
        	:type final: int
        	:rtype: None
        """
        return _Interface.Interface_Check_Trace(self, *args)


    def Warning(self, *args) -> "opencascade::handle< TCollection_HAsciiString > const &":
        """
        * Returns Warning message as a String Final form by default, Original form if <final> is False
        	:param num:
        	:type num: int
        	:param final: default value is Standard_True
        	:type final: bool
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _Interface.Interface_Check_Warning(self, *args)


    def Warnings(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        * Returns the list of Warnings, for a frontal-engine logic Final forms by default, Original forms if <final> is False Can be empty
        	:param final: default value is Standard_True
        	:type final: bool
        	:rtype: opencascade::handle<TColStd_HSequenceOfHAsciiString>
        """
        return _Interface.Interface_Check_Warnings(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_Check_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Check
Interface_Check.AddFail = new_instancemethod(_Interface.Interface_Check_AddFail, None, Interface_Check)
Interface_Check.AddWarning = new_instancemethod(_Interface.Interface_Check_AddWarning, None, Interface_Check)
Interface_Check.CFail = new_instancemethod(_Interface.Interface_Check_CFail, None, Interface_Check)
Interface_Check.CInfoMsg = new_instancemethod(_Interface.Interface_Check_CInfoMsg, None, Interface_Check)
Interface_Check.CWarning = new_instancemethod(_Interface.Interface_Check_CWarning, None, Interface_Check)
Interface_Check.Clear = new_instancemethod(_Interface.Interface_Check_Clear, None, Interface_Check)
Interface_Check.ClearFails = new_instancemethod(_Interface.Interface_Check_ClearFails, None, Interface_Check)
Interface_Check.ClearInfoMsgs = new_instancemethod(_Interface.Interface_Check_ClearInfoMsgs, None, Interface_Check)
Interface_Check.ClearWarnings = new_instancemethod(_Interface.Interface_Check_ClearWarnings, None, Interface_Check)
Interface_Check.Complies = new_instancemethod(_Interface.Interface_Check_Complies, None, Interface_Check)
Interface_Check.Entity = new_instancemethod(_Interface.Interface_Check_Entity, None, Interface_Check)
Interface_Check.Fail = new_instancemethod(_Interface.Interface_Check_Fail, None, Interface_Check)
Interface_Check.Fails = new_instancemethod(_Interface.Interface_Check_Fails, None, Interface_Check)
Interface_Check.GetAsWarning = new_instancemethod(_Interface.Interface_Check_GetAsWarning, None, Interface_Check)
Interface_Check.GetEntity = new_instancemethod(_Interface.Interface_Check_GetEntity, None, Interface_Check)
Interface_Check.GetMessages = new_instancemethod(_Interface.Interface_Check_GetMessages, None, Interface_Check)
Interface_Check.HasEntity = new_instancemethod(_Interface.Interface_Check_HasEntity, None, Interface_Check)
Interface_Check.HasFailed = new_instancemethod(_Interface.Interface_Check_HasFailed, None, Interface_Check)
Interface_Check.HasWarnings = new_instancemethod(_Interface.Interface_Check_HasWarnings, None, Interface_Check)
Interface_Check.InfoMsg = new_instancemethod(_Interface.Interface_Check_InfoMsg, None, Interface_Check)
Interface_Check.InfoMsgs = new_instancemethod(_Interface.Interface_Check_InfoMsgs, None, Interface_Check)
Interface_Check.Mend = new_instancemethod(_Interface.Interface_Check_Mend, None, Interface_Check)
Interface_Check.NbFails = new_instancemethod(_Interface.Interface_Check_NbFails, None, Interface_Check)
Interface_Check.NbInfoMsgs = new_instancemethod(_Interface.Interface_Check_NbInfoMsgs, None, Interface_Check)
Interface_Check.NbWarnings = new_instancemethod(_Interface.Interface_Check_NbWarnings, None, Interface_Check)
Interface_Check.Print = new_instancemethod(_Interface.Interface_Check_Print, None, Interface_Check)
Interface_Check.Remove = new_instancemethod(_Interface.Interface_Check_Remove, None, Interface_Check)
Interface_Check.SendFail = new_instancemethod(_Interface.Interface_Check_SendFail, None, Interface_Check)
Interface_Check.SendMsg = new_instancemethod(_Interface.Interface_Check_SendMsg, None, Interface_Check)
Interface_Check.SendWarning = new_instancemethod(_Interface.Interface_Check_SendWarning, None, Interface_Check)
Interface_Check.SetEntity = new_instancemethod(_Interface.Interface_Check_SetEntity, None, Interface_Check)
Interface_Check.Status = new_instancemethod(_Interface.Interface_Check_Status, None, Interface_Check)
Interface_Check.Trace = new_instancemethod(_Interface.Interface_Check_Trace, None, Interface_Check)
Interface_Check.Warning = new_instancemethod(_Interface.Interface_Check_Warning, None, Interface_Check)
Interface_Check.Warnings = new_instancemethod(_Interface.Interface_Check_Warnings, None, Interface_Check)
Interface_Check_swigregister = _Interface.Interface_Check_swigregister
Interface_Check_swigregister(Interface_Check)

class Interface_CheckIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a Check to the list to be iterated This Check is Accompanied by Entity Number in the Model (0 for Global Check or Entity unknown in the Model), if 0 and Model is recorded in <self>, it is computed
        	:param ach:
        	:type ach: Interface_Check
        	:param num: default value is 0
        	:type num: int
        	:rtype: None
        """
        return _Interface.Interface_CheckIterator_Add(self, *args)


    def CCheck(self, *args) -> "opencascade::handle< Interface_Check > &":
        """
        * Returns the Check bound to an Entity Number (0 : Global) in order to be consulted or completed on the spot I.e. returns the Check if is already exists, or adds it then returns the new empty Check
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Interface_Check>
        * Returns the Check bound to an Entity, in order to be consulted or completed on the spot I.e. returns the Check if is already exists, or adds it then returns the new empty Check
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Interface.Interface_CheckIterator_CCheck(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        * Returns the Check which was attached to an Entity given its Number in the Model. <num>=0 is for the Global Check. If no Check was recorded for this Number, returns an empty Check. Remark : Works apart from the iteration methods (no interference)
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Interface_Check>
        * Returns the Check attached to an Entity If no Check was recorded for this Entity, returns an empty Check. Remark : Works apart from the iteration methods (no interference)
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Interface.Interface_CheckIterator_Check(self, *args)


    def Checkeds(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the list of entities concerned by a Check Only fails if <failsonly> is True, else all non-empty checks If <global> is true, adds the model for a global check Else, global check is ignored
        	:param failsonly:
        	:type failsonly: bool
        	:param global:
        	:type global: bool
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _Interface.Interface_CheckIterator_Checkeds(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears the list of checks
        	:rtype: None
        """
        return _Interface.Interface_CheckIterator_Clear(self, *args)


    def Complies(self, *args) -> "Standard_Boolean":
        """
        * Tells if this check list complies with a given status : OK (i.e. empty), Warning (at least one Warning, but no Fail), Fail (at least one), Message (not OK), NoFail, Any
        	:param status:
        	:type status: Interface_CheckStatus
        	:rtype: bool
        """
        return _Interface.Interface_CheckIterator_Complies(self, *args)


    def Destroy(self, *args) -> "void":
        """
        * Clears data of iteration
        	:rtype: None
        """
        return _Interface.Interface_CheckIterator_Destroy(self, *args)


    def Extract(self, *args) -> "Interface_CheckIterator":
        """
        * Returns a CheckIterator which contains the checks which comply with a given status Each check is added completely (no split Warning/Fail)
        	:param status:
        	:type status: Interface_CheckStatus
        	:rtype: Interface_CheckIterator
        * Returns a CheckIterator which contains the check which comply with a message, plus some conditions as follows : <incl> = 0 : <mess> exactly matches one of the messages <incl> < 0 : <mess> is contained by one of the messages <incl> > 0 : <mess> contains one of the messages For <status> : for CheckWarning and CheckFail, considers only resp. Warning or Check messages. for CheckAny, considers all other values are ignored (answer will be false) Each Check which complies is entirely taken
        	:param mess:
        	:type mess: char *
        	:param incl:
        	:type incl: int
        	:param status:
        	:type status: Interface_CheckStatus
        	:rtype: Interface_CheckIterator
        """
        return _Interface.Interface_CheckIterator_Extract(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty CheckIterator
        	:rtype: None
        * Creates a CheckIterator with a name (displayed by Print as a title)
        	:param name:
        	:type name: char *
        	:rtype: None
        """
        _Interface.Interface_CheckIterator_swiginit(self, _Interface.new_Interface_CheckIterator(*args))

    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns True if : no Fail has been recorded if <failsonly> is True, no Check at all if <failsonly> is False
        	:param failsonly:
        	:type failsonly: bool
        	:rtype: bool
        """
        return _Interface.Interface_CheckIterator_IsEmpty(self, *args)


    def Merge(self, *args) -> "void":
        """
        * Merges another CheckIterator into <self>, i.e. adds each of its Checks. Content of <other> remains unchanged. Takes also the Model but not the Name
        	:param other:
        	:type other: Interface_CheckIterator
        	:rtype: None
        """
        return _Interface.Interface_CheckIterator_Merge(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the stored model (can be a null handle)
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_CheckIterator_Model(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there are more Checks to get
        	:rtype: bool
        """
        return _Interface.Interface_CheckIterator_More(self, *args)


    def Name(self, *args) -> "char const *":
        """
        * Returns the recorded name (can be empty)
        	:rtype: char *
        """
        return _Interface.Interface_CheckIterator_Name(self, *args)


    def Next(self, *args) -> "void":
        """
        * Sets Iteration to next Item
        	:rtype: None
        """
        return _Interface.Interface_CheckIterator_Next(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        * Returns Number of Entity for the Check currently iterated or 0 for GlobalCheck
        	:rtype: int
        """
        return _Interface.Interface_CheckIterator_Number(self, *args)


    def Print(self, *args) -> "void":
        """
        * Prints the list of Checks with their attached Numbers If <failsonly> is True, prints only Fail messages If <failsonly> is False, prints all messages If <final> = 0 (D), prints also original messages if different If <final> < 0, prints only original messages If <final> > 0, prints only final messages It uses the recorded Model if it is defined Remark : Works apart from the iteration methods (no interference)
        	:param S:
        	:type S: Message_Messenger
        	:param failsonly:
        	:type failsonly: bool
        	:param final: default value is 0
        	:type final: int
        	:rtype: None
        * Works as Print without a model, but for entities which have no attached number (Number not positive), tries to compute this Number from <model> and displays 'original' or 'computed'
        	:param S:
        	:type S: Message_Messenger
        	:param model:
        	:type model: Interface_InterfaceModel
        	:param failsonly:
        	:type failsonly: bool
        	:param final: default value is 0
        	:type final: int
        	:rtype: None
        """
        return _Interface.Interface_CheckIterator_Print(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        * Removes the messages of all Checks, under these conditions : <incl> = 0 : <mess> exactly matches one of the messages <incl> < 0 : <mess> is contained by one of the messages <incl> > 0 : <mess> contains one of the messages For <status> : for CheckWarning and CheckFail, considers only resp. Warning or Check messages. for CheckAny, considers all other values are ignored (nothing is done) Returns True if at least one message has been removed, False else
        	:param mess:
        	:type mess: char *
        	:param incl:
        	:type incl: int
        	:param status:
        	:type status: Interface_CheckStatus
        	:rtype: bool
        """
        return _Interface.Interface_CheckIterator_Remove(self, *args)


    def SetModel(self, *args) -> "void":
        """
        * Defines a Model, used to locate entities (not required, if it is absent, entities are simply less documented)
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: None
        """
        return _Interface.Interface_CheckIterator_SetModel(self, *args)


    def SetName(self, *args) -> "void":
        """
        * Sets / Changes the name
        	:param name:
        	:type name: char *
        	:rtype: None
        """
        return _Interface.Interface_CheckIterator_SetName(self, *args)


    def Start(self, *args) -> "void":
        """
        * Starts Iteration. Thus, it is possible to restart it Remark : an iteration may be done with a const Iterator While its content is modified (through a pointer), this allows to give it as a const argument to a function
        	:rtype: None
        """
        return _Interface.Interface_CheckIterator_Start(self, *args)


    def Status(self, *args) -> "Interface_CheckStatus":
        """
        * Returns worst status among : OK, Warning, Fail
        	:rtype: Interface_CheckStatus
        """
        return _Interface.Interface_CheckIterator_Status(self, *args)


    def Value(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        * Returns Check currently Iterated It brings all other informations (status, messages, ...) The Number of the Entity in the Model is given by Number below
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Interface.Interface_CheckIterator_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CheckIterator
Interface_CheckIterator.Add = new_instancemethod(_Interface.Interface_CheckIterator_Add, None, Interface_CheckIterator)
Interface_CheckIterator.CCheck = new_instancemethod(_Interface.Interface_CheckIterator_CCheck, None, Interface_CheckIterator)
Interface_CheckIterator.Check = new_instancemethod(_Interface.Interface_CheckIterator_Check, None, Interface_CheckIterator)
Interface_CheckIterator.Checkeds = new_instancemethod(_Interface.Interface_CheckIterator_Checkeds, None, Interface_CheckIterator)
Interface_CheckIterator.Clear = new_instancemethod(_Interface.Interface_CheckIterator_Clear, None, Interface_CheckIterator)
Interface_CheckIterator.Complies = new_instancemethod(_Interface.Interface_CheckIterator_Complies, None, Interface_CheckIterator)
Interface_CheckIterator.Destroy = new_instancemethod(_Interface.Interface_CheckIterator_Destroy, None, Interface_CheckIterator)
Interface_CheckIterator.Extract = new_instancemethod(_Interface.Interface_CheckIterator_Extract, None, Interface_CheckIterator)
Interface_CheckIterator.IsEmpty = new_instancemethod(_Interface.Interface_CheckIterator_IsEmpty, None, Interface_CheckIterator)
Interface_CheckIterator.Merge = new_instancemethod(_Interface.Interface_CheckIterator_Merge, None, Interface_CheckIterator)
Interface_CheckIterator.Model = new_instancemethod(_Interface.Interface_CheckIterator_Model, None, Interface_CheckIterator)
Interface_CheckIterator.More = new_instancemethod(_Interface.Interface_CheckIterator_More, None, Interface_CheckIterator)
Interface_CheckIterator.Name = new_instancemethod(_Interface.Interface_CheckIterator_Name, None, Interface_CheckIterator)
Interface_CheckIterator.Next = new_instancemethod(_Interface.Interface_CheckIterator_Next, None, Interface_CheckIterator)
Interface_CheckIterator.Number = new_instancemethod(_Interface.Interface_CheckIterator_Number, None, Interface_CheckIterator)
Interface_CheckIterator.Print = new_instancemethod(_Interface.Interface_CheckIterator_Print, None, Interface_CheckIterator)
Interface_CheckIterator.Remove = new_instancemethod(_Interface.Interface_CheckIterator_Remove, None, Interface_CheckIterator)
Interface_CheckIterator.SetModel = new_instancemethod(_Interface.Interface_CheckIterator_SetModel, None, Interface_CheckIterator)
Interface_CheckIterator.SetName = new_instancemethod(_Interface.Interface_CheckIterator_SetName, None, Interface_CheckIterator)
Interface_CheckIterator.Start = new_instancemethod(_Interface.Interface_CheckIterator_Start, None, Interface_CheckIterator)
Interface_CheckIterator.Status = new_instancemethod(_Interface.Interface_CheckIterator_Status, None, Interface_CheckIterator)
Interface_CheckIterator.Value = new_instancemethod(_Interface.Interface_CheckIterator_Value, None, Interface_CheckIterator)
Interface_CheckIterator_swigregister = _Interface.Interface_CheckIterator_swigregister
Interface_CheckIterator_swigregister(Interface_CheckIterator)

class Interface_CheckTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AnalyseCheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns list of errors dectected at Analyse time (syntactic) (note that GlobalCheck is not in this list)
        	:rtype: Interface_CheckIterator
        """
        return _Interface.Interface_CheckTool_AnalyseCheckList(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check >":
        """
        * Returns the Check associated to an Entity identified by its Number in a Model.
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Interface.Interface_CheckTool_Check(self, *args)


    def CheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns list of all Errors detected Note that presence of Unknown Entities is not an error Cumulates : GlobalCheck if error + AnalyseCheckList + VerifyCheckList
        	:rtype: Interface_CheckIterator
        """
        return _Interface.Interface_CheckTool_CheckList(self, *args)


    def CheckSuccess(self, *args) -> "void":
        """
        * Checks if any Error has been detected (CheckList not empty) Returns normally if none, raises exception if some exists. It reuses the last computations from other checking methods, unless the argument <resest> is given True
        	:param reset: default value is Standard_False
        	:type reset: bool
        	:rtype: None
        """
        return _Interface.Interface_CheckTool_CheckSuccess(self, *args)


    def CompleteCheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns list of all 'remarkable' informations, which include : - GlobalCheck, if not empty - Error Checks, for all Errors (Verify + Analyse) - also Corrected Entities - and Unknown Entities : for those, each Unknown Entity is associated to an empty Check (it is neither an Error nor a Correction, but a remarkable information)
        	:rtype: Interface_CheckIterator
        """
        return _Interface.Interface_CheckTool_CompleteCheckList(self, *args)


    def FillCheck(self, *args) -> "void":
        """
        * Fills as required a Check with the Error and Warning messages produced by Checking a given Entity. For an Erroneous or Corrected Entity : Check build at Analyse time; else, Check computed for Entity (Verify integrity), can use a Graph as required to control context
        	:param ent:
        	:type ent: Standard_Transient
        	:param sh:
        	:type sh: Interface_ShareTool
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: None
        """
        return _Interface.Interface_CheckTool_FillCheck(self, *args)


    def __init__(self, *args):
        """
        * Creates a CheckTool, by calling the General Service Library and Modules, selected through a Protocol, to work on a Model Moreover, Protocol recognizes Unknown Entities
        	:param model:
        	:type model: Interface_InterfaceModel
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:rtype: None
        * Creates a CheckTool, by calling the General Service Library and Modules, selected through a Protocol, to work on a Model Protocol and so on are taken from the Model (its GTool)
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: None
        * Creates a CheckTool from a Graph. The Graph contains a Model which designates a Protocol: they are used to create ShareTool
        	:param graph:
        	:type graph: Interface_Graph
        	:rtype: None
        :param hgraph:
        	:type hgraph: Interface_HGraph
        	:rtype: None
        """
        _Interface.Interface_CheckTool_swiginit(self, _Interface.new_Interface_CheckTool(*args))

    def Print(self, *args) -> "void":
        """
        * Utility method which Prints the content of a Check
        	:param ach:
        	:type ach: Interface_Check
        	:param S:
        	:type S: Message_Messenger
        	:rtype: None
        * Simply Lists all the Checks and the Content (messages) and the Entity, if there is, of each Check (if all Checks are OK, nothing is Printed)
        	:param list:
        	:type list: Interface_CheckIterator
        	:param S:
        	:type S: Message_Messenger
        	:rtype: None
        """
        return _Interface.Interface_CheckTool_Print(self, *args)


    def UnknownEntities(self, *args) -> "Interface_EntityIterator":
        """
        * Returns list of Unknown Entities Note that Error and Erroneous Entities are not considered as Unknown
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_CheckTool_UnknownEntities(self, *args)


    def VerifyCheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns list of integrity constraints errors (semantic) (note that GlobalCheck is not in this list)
        	:rtype: Interface_CheckIterator
        """
        return _Interface.Interface_CheckTool_VerifyCheckList(self, *args)


    def WarningCheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns list of Corrections (includes GlobalCheck if corrected)
        	:rtype: Interface_CheckIterator
        """
        return _Interface.Interface_CheckTool_WarningCheckList(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CheckTool
Interface_CheckTool.AnalyseCheckList = new_instancemethod(_Interface.Interface_CheckTool_AnalyseCheckList, None, Interface_CheckTool)
Interface_CheckTool.Check = new_instancemethod(_Interface.Interface_CheckTool_Check, None, Interface_CheckTool)
Interface_CheckTool.CheckList = new_instancemethod(_Interface.Interface_CheckTool_CheckList, None, Interface_CheckTool)
Interface_CheckTool.CheckSuccess = new_instancemethod(_Interface.Interface_CheckTool_CheckSuccess, None, Interface_CheckTool)
Interface_CheckTool.CompleteCheckList = new_instancemethod(_Interface.Interface_CheckTool_CompleteCheckList, None, Interface_CheckTool)
Interface_CheckTool.FillCheck = new_instancemethod(_Interface.Interface_CheckTool_FillCheck, None, Interface_CheckTool)
Interface_CheckTool.Print = new_instancemethod(_Interface.Interface_CheckTool_Print, None, Interface_CheckTool)
Interface_CheckTool.UnknownEntities = new_instancemethod(_Interface.Interface_CheckTool_UnknownEntities, None, Interface_CheckTool)
Interface_CheckTool.VerifyCheckList = new_instancemethod(_Interface.Interface_CheckTool_VerifyCheckList, None, Interface_CheckTool)
Interface_CheckTool.WarningCheckList = new_instancemethod(_Interface.Interface_CheckTool_WarningCheckList, None, Interface_CheckTool)
Interface_CheckTool_swigregister = _Interface.Interface_CheckTool_swigregister
Interface_CheckTool_swigregister(Interface_CheckTool)

class Interface_CopyControl(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Bind(self, *args) -> "void":
        """
        * Bind a Result to a Starting Entity identified by its Number
        	:param ent:
        	:type ent: Standard_Transient
        	:param res:
        	:type res: Standard_Transient
        	:rtype: void
        """
        return _Interface.Interface_CopyControl_Bind(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears List of Copy Results. Gets Ready to begin another Copy Process.
        	:rtype: void
        """
        return _Interface.Interface_CopyControl_Clear(self, *args)


    def Search(self, *args) -> "Standard_Boolean":
        """
        * Searches for the Result bound to a Startingf Entity identified by its Number. If Found, returns True and fills <res> Else, returns False and nullifies <res>
        	:param ent:
        	:type ent: Standard_Transient
        	:param res:
        	:type res: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_CopyControl_Search(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_CopyControl_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CopyControl
Interface_CopyControl.Bind = new_instancemethod(_Interface.Interface_CopyControl_Bind, None, Interface_CopyControl)
Interface_CopyControl.Clear = new_instancemethod(_Interface.Interface_CopyControl_Clear, None, Interface_CopyControl)
Interface_CopyControl.Search = new_instancemethod(_Interface.Interface_CopyControl_Search, None, Interface_CopyControl)
Interface_CopyControl_swigregister = _Interface.Interface_CopyControl_swigregister
Interface_CopyControl_swigregister(Interface_CopyControl)

class Interface_CopyTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bind(self, *args) -> "void":
        """
        * Defines a Result for the Transfer of a Starting object. Used by method Transferred (which performs a normal Copy), but can also be called to enforce a result : in the latter case, the enforced result must be compatible with the other Transfers which are performed
        	:param ent:
        	:type ent: Standard_Transient
        	:param res:
        	:type res: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_CopyTool_Bind(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears Transfer List. Gets Ready to begin another Transfer
        	:rtype: void
        """
        return _Interface.Interface_CopyTool_Clear(self, *args)


    def ClearLastFlags(self, *args) -> "void":
        """
        * Clears LastFlags only. This allows to know what Entities are copied after its call (see method LastCopiedAfter). It can be used when copies are done by increments, which must be distinghished. ClearLastFlags is also called by Clear.
        	:rtype: None
        """
        return _Interface.Interface_CopyTool_ClearLastFlags(self, *args)


    def CompleteResult(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the complete list of copied Entities If <withreports> is given True, the entities which were reported in the Starting Model are replaced in the list by the copied ReportEntities
        	:param withreports: default value is Standard_False
        	:type withreports: bool
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_CopyTool_CompleteResult(self, *args)


    def Control(self, *args) -> "opencascade::handle< Interface_CopyControl >":
        """
        * Returns the object used for Control
        	:rtype: opencascade::handle<Interface_CopyControl>
        """
        return _Interface.Interface_CopyTool_Control(self, *args)


    def Copy(self, *args) -> "Standard_Boolean":
        """
        * Creates the CounterPart of an Entity (by ShallowCopy), Binds it, then Copies the content of the former Entity to the other one (same Type), by call to the General Service Library It may command the Copy of Referenced Entities Then, its returns True. //! If <mapped> is True, the Map is used to store the Result Else, the Result is simply produced : it can be used to Copy internal sub-parts of Entities, which are not intended to be shared (Strings, Arrays, etc...) If <errstat> is True, this means that the Entity is recorded in the Model as Erroneous : in this case, the General Service for Deep Copy is not called (this could be dangerous) : hence the Counter-Part is produced but empty, it can be referenced. //! This method does nothing and returns False if the Protocol does not recognize <ent>. It basically makes a Deep Copy without changing the Types. It can be redefined for special uses.
        	:param entfrom:
        	:type entfrom: Standard_Transient
        	:param entto:
        	:type entto: Standard_Transient
        	:param mapped:
        	:type mapped: bool
        	:param errstat:
        	:type errstat: bool
        	:rtype: bool
        """
        return _Interface.Interface_CopyTool_Copy(self, *args)


    def FillModel(self, *args) -> "void":
        """
        * Fills a Model with the result of the transfer (TransferList) Commands copy of Header too, and calls RenewImpliedRefs
        	:param bmodel:
        	:type bmodel: Interface_InterfaceModel
        	:rtype: None
        """
        return _Interface.Interface_CopyTool_FillModel(self, *args)


    def __init__(self, *args):
        """
        * Creates a CopyTool adapted to work from a Model. Works with a General Service Library, given as an argument
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param lib:
        	:type lib: Interface_GeneralLib
        	:rtype: None
        * Same as above, but Library is defined through a Protocol
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:rtype: None
        * Same as above, but works with the Active Protocol
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        """
        _Interface.Interface_CopyTool_swiginit(self, _Interface.new_Interface_CopyTool(*args))

    def LastCopiedAfter(self, *args) -> "Standard_Integer":
        """
        * Returns an copied Entity and its Result which were operated after last call to ClearLastFlags. It returns the first 'Last Copied Entity' which Number follows <numfrom>, Zero if none. It is used in a loop as follow : Integer num = 0; while ( (num = CopyTool.LastCopiedAfter(num,ent,res)) ) { .. Process Starting <ent> and its Result <res> }
        	:param numfrom:
        	:type numfrom: int
        	:param ent:
        	:type ent: Standard_Transient
        	:param res:
        	:type res: Standard_Transient
        	:rtype: int
        """
        return _Interface.Interface_CopyTool_LastCopiedAfter(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the Model on which the CopyTool works
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_CopyTool_Model(self, *args)


    def RenewImpliedRefs(self, *args) -> "void":
        """
        * Renews the Implied References. These References do not involve Copying of referenced Entities. For such a Reference, if the Entity which defines it AND the referenced Entity are both copied, then this Reference is renewed. Else it is deleted in the copied Entities. Remark : this concerns only some specific references, such as 'back pointers'.
        	:rtype: None
        """
        return _Interface.Interface_CopyTool_RenewImpliedRefs(self, *args)


    def RootResult(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of Root copied Entities (those which were asked for copy by the user of CopyTool, not by copying another Entity)
        	:param withreports: default value is Standard_False
        	:type withreports: bool
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_CopyTool_RootResult(self, *args)


    def Search(self, *args) -> "Standard_Boolean":
        """
        * Search for the result of a Starting Object (i.e. an Entity) Returns True if a Result is Bound (and fills 'result') Returns False if no result is Bound
        	:param ent:
        	:type ent: Standard_Transient
        	:param res:
        	:type res: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_CopyTool_Search(self, *args)


    def SetControl(self, *args) -> "void":
        """
        * Changes the Map of Result for another one. This allows to work with a more sophisticated Mapping Control than the Standard one which is CopyMap (e.g. TransferProcess from Transfer)
        	:param othermap:
        	:type othermap: Interface_CopyControl
        	:rtype: None
        """
        return _Interface.Interface_CopyTool_SetControl(self, *args)


    def TransferEntity(self, *args) -> "void":
        """
        * Transfers one Entity and records result into the Transfer List Calls method Transferred
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_CopyTool_TransferEntity(self, *args)


    def Transferred(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Transfers one Entity, if not yet bound to a result Remark : For an Entity which is reported in the Starting Model, the ReportEntity will also be copied with its Content if it has one (at least ShallowCopy; Complete Copy if the Protocol recognizes the Content : see method Copy)
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_CopyTool_Transferred(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CopyTool
Interface_CopyTool.Bind = new_instancemethod(_Interface.Interface_CopyTool_Bind, None, Interface_CopyTool)
Interface_CopyTool.Clear = new_instancemethod(_Interface.Interface_CopyTool_Clear, None, Interface_CopyTool)
Interface_CopyTool.ClearLastFlags = new_instancemethod(_Interface.Interface_CopyTool_ClearLastFlags, None, Interface_CopyTool)
Interface_CopyTool.CompleteResult = new_instancemethod(_Interface.Interface_CopyTool_CompleteResult, None, Interface_CopyTool)
Interface_CopyTool.Control = new_instancemethod(_Interface.Interface_CopyTool_Control, None, Interface_CopyTool)
Interface_CopyTool.Copy = new_instancemethod(_Interface.Interface_CopyTool_Copy, None, Interface_CopyTool)
Interface_CopyTool.FillModel = new_instancemethod(_Interface.Interface_CopyTool_FillModel, None, Interface_CopyTool)
Interface_CopyTool.LastCopiedAfter = new_instancemethod(_Interface.Interface_CopyTool_LastCopiedAfter, None, Interface_CopyTool)
Interface_CopyTool.Model = new_instancemethod(_Interface.Interface_CopyTool_Model, None, Interface_CopyTool)
Interface_CopyTool.RenewImpliedRefs = new_instancemethod(_Interface.Interface_CopyTool_RenewImpliedRefs, None, Interface_CopyTool)
Interface_CopyTool.RootResult = new_instancemethod(_Interface.Interface_CopyTool_RootResult, None, Interface_CopyTool)
Interface_CopyTool.Search = new_instancemethod(_Interface.Interface_CopyTool_Search, None, Interface_CopyTool)
Interface_CopyTool.SetControl = new_instancemethod(_Interface.Interface_CopyTool_SetControl, None, Interface_CopyTool)
Interface_CopyTool.TransferEntity = new_instancemethod(_Interface.Interface_CopyTool_TransferEntity, None, Interface_CopyTool)
Interface_CopyTool.Transferred = new_instancemethod(_Interface.Interface_CopyTool_Transferred, None, Interface_CopyTool)
Interface_CopyTool_swigregister = _Interface.Interface_CopyTool_swigregister
Interface_CopyTool_swigregister(Interface_CopyTool)

class Interface_EntityCluster(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Append(self, *args) -> "void":
        """
        * Appends an Entity to the Cluster. If it is not full, adds the entity directly inside itself. Else, transmits to its Next and Creates it if it does not yet exist
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_EntityCluster_Append(self, *args)


    def FillIterator(self, *args) -> "void":
        """
        * Fills an Iterator with designated Entities (includes Next)
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:rtype: None
        """
        return _Interface.Interface_EntityCluster_FillIterator(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty, non-chained, EntityCluster
        	:rtype: None
        * Creates a non-chained EntityCluster, filled with one Entity
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        * Creates an empty EntityCluster, chained with another one (that is, put BEFORE this other one in the list)
        	:param ec:
        	:type ec: Interface_EntityCluster
        	:rtype: None
        * Creates an EntityCluster, filled with a first Entity, and chained to another EntityCluster (BEFORE it, as above)
        	:param ant:
        	:type ant: Standard_Transient
        	:param ec:
        	:type ec: Interface_EntityCluster
        	:rtype: None
        """
        _Interface.Interface_EntityCluster_swiginit(self, _Interface.new_Interface_EntityCluster(*args))

    def NbEntities(self, *args) -> "Standard_Integer":
        """
        * Returns total count of Entities (including Next)
        	:rtype: int
        """
        return _Interface.Interface_EntityCluster_NbEntities(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        * Removes an Entity from the Cluster. If it is not found, calls its Next one to do so. Returns True if it becomes itself empty, False else (thus, a Cluster which becomes empty is deleted from the list)
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        * Removes an Entity from the Cluster, given its rank. If <num> is greater than NbLocal, calls its Next with (num - NbLocal), Returns True if it becomes itself empty, False else
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_EntityCluster_Remove(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Changes an Entity given its rank.
        	:param num:
        	:type num: int
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_EntityCluster_SetValue(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the Entity identified by its rank in the list (including Next)
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_EntityCluster_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_EntityCluster_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_EntityCluster
Interface_EntityCluster.Append = new_instancemethod(_Interface.Interface_EntityCluster_Append, None, Interface_EntityCluster)
Interface_EntityCluster.FillIterator = new_instancemethod(_Interface.Interface_EntityCluster_FillIterator, None, Interface_EntityCluster)
Interface_EntityCluster.NbEntities = new_instancemethod(_Interface.Interface_EntityCluster_NbEntities, None, Interface_EntityCluster)
Interface_EntityCluster.Remove = new_instancemethod(_Interface.Interface_EntityCluster_Remove, None, Interface_EntityCluster)
Interface_EntityCluster.SetValue = new_instancemethod(_Interface.Interface_EntityCluster_SetValue, None, Interface_EntityCluster)
Interface_EntityCluster.Value = new_instancemethod(_Interface.Interface_EntityCluster_Value, None, Interface_EntityCluster)
Interface_EntityCluster_swigregister = _Interface.Interface_EntityCluster_swigregister
Interface_EntityCluster_swigregister(Interface_EntityCluster)

class Interface_EntityIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddItem(self, *args) -> "void":
        """
        * Adds to the iteration list a defined entity
        	:param anentity:
        	:type anentity: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_EntityIterator_AddItem(self, *args)


    def AddList(self, *args) -> "void":
        """
        * Gets a list of entities and adds its to the iteration list
        	:param list:
        	:type list: TColStd_HSequenceOfTransient
        	:rtype: None
        """
        return _Interface.Interface_EntityIterator_AddList(self, *args)


    def Content(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the content of the Iterator, accessed through a Handle to be used by a frontal-engine logic Returns an empty Sequence if the Iterator is empty Calls Start if not yet done
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _Interface.Interface_EntityIterator_Content(self, *args)


    def Destroy(self, *args) -> "void":
        """
        * Clears data of iteration
        	:rtype: None
        """
        return _Interface.Interface_EntityIterator_Destroy(self, *args)


    def GetOneItem(self, *args) -> "void":
        """
        * same as AddItem (kept for compatibility)
        	:param anentity:
        	:type anentity: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_EntityIterator_GetOneItem(self, *args)


    def __init__(self, *args):
        """
        * Defines an empty iterator (see AddList & AddItem)
        	:rtype: None
        * Defines an iterator on a list, directly i.e. without copying it
        	:param list:
        	:type list: TColStd_HSequenceOfTransient
        	:rtype: None
        """
        _Interface.Interface_EntityIterator_swiginit(self, _Interface.new_Interface_EntityIterator(*args))

    def More(self, *args) -> "Standard_Boolean":
        """
        * Says if there are other entities (vertices) to iterate the first time, calls Start
        	:rtype: bool
        """
        return _Interface.Interface_EntityIterator_More(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        * Returns count of entities which will be iterated on Calls Start if not yet done
        	:rtype: int
        """
        return _Interface.Interface_EntityIterator_NbEntities(self, *args)


    def NbTyped(self, *args) -> "Standard_Integer":
        """
        * Returns count of entities of a given type (kind of)
        	:param type:
        	:type type: Standard_Type
        	:rtype: int
        """
        return _Interface.Interface_EntityIterator_NbTyped(self, *args)


    def Next(self, *args) -> "void":
        """
        * Sets iteration to the next entity (vertex) to give
        	:rtype: None
        """
        return _Interface.Interface_EntityIterator_Next(self, *args)


    def SelectType(self, *args) -> "void":
        """
        * Selects entities with are Kind of a given type, keep only them (is keep is True) or reject only them (if keep is False)
        	:param atype:
        	:type atype: Standard_Type
        	:param keep:
        	:type keep: bool
        	:rtype: None
        """
        return _Interface.Interface_EntityIterator_SelectType(self, *args)


    def Start(self, *args) -> "void":
        """
        * Allows re-iteration (useless for the first iteration)
        	:rtype: void
        """
        return _Interface.Interface_EntityIterator_Start(self, *args)


    def Typed(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of entities of a given type (kind of)
        	:param type:
        	:type type: Standard_Type
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_EntityIterator_Typed(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the current Entity iterated, to be used by Interface tools
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_EntityIterator_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_EntityIterator
Interface_EntityIterator.AddItem = new_instancemethod(_Interface.Interface_EntityIterator_AddItem, None, Interface_EntityIterator)
Interface_EntityIterator.AddList = new_instancemethod(_Interface.Interface_EntityIterator_AddList, None, Interface_EntityIterator)
Interface_EntityIterator.Content = new_instancemethod(_Interface.Interface_EntityIterator_Content, None, Interface_EntityIterator)
Interface_EntityIterator.Destroy = new_instancemethod(_Interface.Interface_EntityIterator_Destroy, None, Interface_EntityIterator)
Interface_EntityIterator.GetOneItem = new_instancemethod(_Interface.Interface_EntityIterator_GetOneItem, None, Interface_EntityIterator)
Interface_EntityIterator.More = new_instancemethod(_Interface.Interface_EntityIterator_More, None, Interface_EntityIterator)
Interface_EntityIterator.NbEntities = new_instancemethod(_Interface.Interface_EntityIterator_NbEntities, None, Interface_EntityIterator)
Interface_EntityIterator.NbTyped = new_instancemethod(_Interface.Interface_EntityIterator_NbTyped, None, Interface_EntityIterator)
Interface_EntityIterator.Next = new_instancemethod(_Interface.Interface_EntityIterator_Next, None, Interface_EntityIterator)
Interface_EntityIterator.SelectType = new_instancemethod(_Interface.Interface_EntityIterator_SelectType, None, Interface_EntityIterator)
Interface_EntityIterator.Start = new_instancemethod(_Interface.Interface_EntityIterator_Start, None, Interface_EntityIterator)
Interface_EntityIterator.Typed = new_instancemethod(_Interface.Interface_EntityIterator_Typed, None, Interface_EntityIterator)
Interface_EntityIterator.Value = new_instancemethod(_Interface.Interface_EntityIterator_Value, None, Interface_EntityIterator)
Interface_EntityIterator_swigregister = _Interface.Interface_EntityIterator_swigregister
Interface_EntityIterator_swigregister(Interface_EntityIterator)

class Interface_EntityList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds an Entity to the list, that is, with NO REGARD about the order (faster than Append if count becomes greater than 10)
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_EntityList_Add(self, *args)


    def Append(self, *args) -> "void":
        """
        * Appends an Entity, that is to the END of the list (keeps order, but works slowerly than Add, see below)
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_EntityList_Append(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears the List
        	:rtype: None
        """
        return _Interface.Interface_EntityList_Clear(self, *args)


    def FillIterator(self, *args) -> "void":
        """
        * fills an Iterator with the content of the list (normal way to consult a list which has been filled with Add)
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:rtype: None
        """
        return _Interface.Interface_EntityList_FillIterator(self, *args)


    def __init__(self, *args):
        """
        * Creates a List as beeing empty
        	:rtype: None
        """
        _Interface.Interface_EntityList_swiginit(self, _Interface.new_Interface_EntityList(*args))

    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the list is empty
        	:rtype: bool
        """
        return _Interface.Interface_EntityList_IsEmpty(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        * Returns count of recorded Entities
        	:rtype: int
        """
        return _Interface.Interface_EntityList_NbEntities(self, *args)


    def NbTypedEntities(self, *args) -> "Standard_Integer":
        """
        * Returns count of Entities of a given Type (0 : none)
        	:param atype:
        	:type atype: Standard_Type
        	:rtype: int
        """
        return _Interface.Interface_EntityList_NbTypedEntities(self, *args)


    def Remove(self, *args) -> "void":
        """
        * Removes an Entity from the list, if it is there
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        * Removes an Entity from the list, given its rank
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _Interface.Interface_EntityList_Remove(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Returns an Item given its number. Beware about the way the list was filled (see above, Add and Append)
        	:param num:
        	:type num: int
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_EntityList_SetValue(self, *args)


    def TypedEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns the Entity which is of a given type. If num = 0 (D), there must be ONE AND ONLY ONE If num > 0, returns the num-th entity of this type
        	:param atype:
        	:type atype: Standard_Type
        	:param num: default value is 0
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_EntityList_TypedEntity(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns an Item given its number. Beware about the way the list was filled (see above, Add and Append)
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_EntityList_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_EntityList
Interface_EntityList.Add = new_instancemethod(_Interface.Interface_EntityList_Add, None, Interface_EntityList)
Interface_EntityList.Append = new_instancemethod(_Interface.Interface_EntityList_Append, None, Interface_EntityList)
Interface_EntityList.Clear = new_instancemethod(_Interface.Interface_EntityList_Clear, None, Interface_EntityList)
Interface_EntityList.FillIterator = new_instancemethod(_Interface.Interface_EntityList_FillIterator, None, Interface_EntityList)
Interface_EntityList.IsEmpty = new_instancemethod(_Interface.Interface_EntityList_IsEmpty, None, Interface_EntityList)
Interface_EntityList.NbEntities = new_instancemethod(_Interface.Interface_EntityList_NbEntities, None, Interface_EntityList)
Interface_EntityList.NbTypedEntities = new_instancemethod(_Interface.Interface_EntityList_NbTypedEntities, None, Interface_EntityList)
Interface_EntityList.Remove = new_instancemethod(_Interface.Interface_EntityList_Remove, None, Interface_EntityList)
Interface_EntityList.SetValue = new_instancemethod(_Interface.Interface_EntityList_SetValue, None, Interface_EntityList)
Interface_EntityList.TypedEntity = new_instancemethod(_Interface.Interface_EntityList_TypedEntity, None, Interface_EntityList)
Interface_EntityList.Value = new_instancemethod(_Interface.Interface_EntityList_Value, None, Interface_EntityList)
Interface_EntityList_swigregister = _Interface.Interface_EntityList_swigregister
Interface_EntityList_swigregister(Interface_EntityList)

class Interface_FileParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CValue(self, *args) -> "char const *":
        """
        * Same as above, but as a CString (for immediate exploitation) was C++ : return const
        	:rtype: char *
        """
        return _Interface.Interface_FileParameter_CValue(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears stored data : frees memory taken for the String Value
        	:rtype: None
        """
        return _Interface.Interface_FileParameter_Clear(self, *args)


    def Destroy(self, *args) -> "void":
        """
        * Destructor. Does nothing because Memory is managed by ParamSet
        	:rtype: None
        """
        return _Interface.Interface_FileParameter_Destroy(self, *args)


    def EntityNumber(self, *args) -> "Standard_Integer":
        """
        * Returns value set by SetEntityNumber
        	:rtype: int
        """
        return _Interface.Interface_FileParameter_EntityNumber(self, *args)


    def Init(self, *args) -> "void":
        """
        * Fills fields (with Entity Number set to zero)
        	:param val:
        	:type val: TCollection_AsciiString
        	:param typ:
        	:type typ: Interface_ParamType
        	:rtype: None
        * Same as above, but builds the Value from a CString
        	:param val:
        	:type val: char *
        	:param typ:
        	:type typ: Interface_ParamType
        	:rtype: None
        """
        return _Interface.Interface_FileParameter_Init(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _Interface.Interface_FileParameter_swiginit(self, _Interface.new_Interface_FileParameter(*args))

    def ParamType(self, *args) -> "Interface_ParamType":
        """
        * Returns the type of the parameter
        	:rtype: Interface_ParamType
        """
        return _Interface.Interface_FileParameter_ParamType(self, *args)


    def SetEntityNumber(self, *args) -> "void":
        """
        * Allows to set a reference to an Entity in a numbered list
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _Interface.Interface_FileParameter_SetEntityNumber(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_FileParameter
Interface_FileParameter.CValue = new_instancemethod(_Interface.Interface_FileParameter_CValue, None, Interface_FileParameter)
Interface_FileParameter.Clear = new_instancemethod(_Interface.Interface_FileParameter_Clear, None, Interface_FileParameter)
Interface_FileParameter.Destroy = new_instancemethod(_Interface.Interface_FileParameter_Destroy, None, Interface_FileParameter)
Interface_FileParameter.EntityNumber = new_instancemethod(_Interface.Interface_FileParameter_EntityNumber, None, Interface_FileParameter)
Interface_FileParameter.Init = new_instancemethod(_Interface.Interface_FileParameter_Init, None, Interface_FileParameter)
Interface_FileParameter.ParamType = new_instancemethod(_Interface.Interface_FileParameter_ParamType, None, Interface_FileParameter)
Interface_FileParameter.SetEntityNumber = new_instancemethod(_Interface.Interface_FileParameter_SetEntityNumber, None, Interface_FileParameter)
Interface_FileParameter_swigregister = _Interface.Interface_FileParameter_swigregister
Interface_FileParameter_swigregister(Interface_FileParameter)

class Interface_FileReaderData(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddParam(self, *args) -> "void":
        """
        * Adds a parameter to record no 'num' and fills its fields (EntityNumber is optional) Warning : <aval> is assumed to be memory-managed elsewhere : it is NOT copied. This gives a best speed : strings remain stored in pages of characters
        	:param num:
        	:type num: int
        	:param aval:
        	:type aval: char *
        	:param atype:
        	:type atype: Interface_ParamType
        	:param nument: default value is 0
        	:type nument: int
        	:rtype: None
        * Same as above, but gets a AsciiString from TCollection Remark that the content of the AsciiString is locally copied (because its content is most often lost after using)
        	:param num:
        	:type num: int
        	:param aval:
        	:type aval: TCollection_AsciiString
        	:param atype:
        	:type atype: Interface_ParamType
        	:param nument: default value is 0
        	:type nument: int
        	:rtype: None
        * Same as above, but gets a complete FileParameter Warning : Content of <FP> is NOT copied : its original address and space in memory are assumed to be managed elsewhere (see ParamSet)
        	:param num:
        	:type num: int
        	:param FP:
        	:type FP: Interface_FileParameter
        	:rtype: None
        """
        return _Interface.Interface_FileReaderData_AddParam(self, *args)


    def BindEntity(self, *args) -> "void":
        """
        * Binds an entity to a record
        	:param num:
        	:type num: int
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_FileReaderData_BindEntity(self, *args)


    def BoundEntity(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the entity bound to a record, set by SetEntities
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_FileReaderData_BoundEntity(self, *args)


    def ChangeParam(self, *args) -> "Interface_FileParameter &":
        """
        * Same as above, but in order to be modified on place
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:rtype: Interface_FileParameter
        """
        return _Interface.Interface_FileReaderData_ChangeParam(self, *args)


    def Destroy(self, *args) -> "void":
        """
        * Destructor (waiting for memory management)
        	:rtype: None
        """
        return _Interface.Interface_FileReaderData_Destroy(self, *args)


    def Fastof(*args) -> "Standard_Real":
        """
        * Same spec.s as standard <atof> but 5 times faster
        	:param str:
        	:type str: char *
        	:rtype: float
        """
        return _Interface.Interface_FileReaderData_Fastof(*args)

    Fastof = staticmethod(Fastof)

    def FindNextRecord(self, *args) -> "Standard_Integer":
        """
        * Determines the record number defining an Entity following a given record number. Specific to each sub-class of FileReaderData. Returning zero means no record found
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _Interface.Interface_FileReaderData_FindNextRecord(self, *args)


    def InitParams(self, *args) -> "void":
        """
        * attaches an empty ParamList to a Record
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _Interface.Interface_FileReaderData_InitParams(self, *args)


    def IsErrorLoad(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the status 'Error Load' has been set (to True or False)
        	:rtype: bool
        """
        return _Interface.Interface_FileReaderData_IsErrorLoad(self, *args)


    def IsParamDefined(self, *args) -> "Standard_Boolean":
        """
        * Returns True if parameter 'nump' of record 'num' is defined (it is not if its type is ParamVoid)
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:rtype: bool
        """
        return _Interface.Interface_FileReaderData_IsParamDefined(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        * Returns the count of entities. Depending of each norm, records can be Entities or SubParts (SubList in STEP, SubGroup in SET ...). NbEntities counts only Entities, not Subs Used for memory reservation in InterfaceModel Default implementation uses FindNextRecord Can be redefined into a more performant way
        	:rtype: int
        """
        return _Interface.Interface_FileReaderData_NbEntities(self, *args)


    def NbParams(self, *args) -> "Standard_Integer":
        """
        * Returns count of parameters attached to record 'num' If <num> = 0, returns the total recorded count of parameters
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _Interface.Interface_FileReaderData_NbParams(self, *args)


    def NbRecords(self, *args) -> "Standard_Integer":
        """
        * Returns the count of registered records That is, value given for Initialization (can be redefined)
        	:rtype: int
        """
        return _Interface.Interface_FileReaderData_NbRecords(self, *args)


    def Param(self, *args) -> "Interface_FileParameter const &":
        """
        * Returns parameter 'nump' of record 'num', as a complete FileParameter
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:rtype: Interface_FileParameter
        """
        return _Interface.Interface_FileReaderData_Param(self, *args)


    def ParamCValue(self, *args) -> "char const *":
        """
        * Same as above, but as a CString was C++ : return const
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:rtype: char *
        """
        return _Interface.Interface_FileReaderData_ParamCValue(self, *args)


    def ParamEntity(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the StepEntity referenced by a parameter Error if none
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_FileReaderData_ParamEntity(self, *args)


    def ParamFirstRank(self, *args) -> "Standard_Integer":
        """
        * Returns the absolute rank of the beginning of a record (its lsit is from ParamFirstRank+1 to ParamFirstRank+NbParams)
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _Interface.Interface_FileReaderData_ParamFirstRank(self, *args)


    def ParamNumber(self, *args) -> "Standard_Integer":
        """
        * Returns record number of an entity referenced by a parameter of type Ident; 0 if no EntityNumber has been determined Note that it is used to reference Entities but also Sublists (sublists are not objects, but internal descriptions)
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:rtype: int
        """
        return _Interface.Interface_FileReaderData_ParamNumber(self, *args)


    def ParamType(self, *args) -> "Interface_ParamType":
        """
        * Returns type of parameter 'nump' of record 'num' Returns literal value of parameter 'nump' of record 'num' was C++ : return const &
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:rtype: Interface_ParamType
        """
        return _Interface.Interface_FileReaderData_ParamType(self, *args)


    def Params(self, *args) -> "opencascade::handle< Interface_ParamList >":
        """
        * Returns the complete ParamList of a record (read only) num = 0 to return the whole param list for the file
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Interface_ParamList>
        """
        return _Interface.Interface_FileReaderData_Params(self, *args)


    def ResetErrorLoad(self, *args) -> "Standard_Boolean":
        """
        * Returns the former value of status 'Error Load' then resets it Used to read the status then ensure it is reset
        	:rtype: bool
        """
        return _Interface.Interface_FileReaderData_ResetErrorLoad(self, *args)


    def SetErrorLoad(self, *args) -> "void":
        """
        * Sets the status 'Error Load' on, to overside check fails <val> True : declares unloaded <val> False : declares loaded If not called before loading (see FileReaderTool), check fails give the status IsErrorLoad says if SetErrorLoad has been called by user ResetErrorLoad resets it (called by FileReaderTool) This allows to specify that the currently loaded entity remains unloaded (because of syntactic fail)
        	:param val:
        	:type val: bool
        	:rtype: None
        """
        return _Interface.Interface_FileReaderData_SetErrorLoad(self, *args)


    def SetParam(self, *args) -> "void":
        """
        * Sets a new value for a parameter of a record, given by : num : record number; nump : parameter number in the record
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param FP:
        	:type FP: Interface_FileParameter
        	:rtype: None
        """
        return _Interface.Interface_FileReaderData_SetParam(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_FileReaderData_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_FileReaderData
Interface_FileReaderData.AddParam = new_instancemethod(_Interface.Interface_FileReaderData_AddParam, None, Interface_FileReaderData)
Interface_FileReaderData.BindEntity = new_instancemethod(_Interface.Interface_FileReaderData_BindEntity, None, Interface_FileReaderData)
Interface_FileReaderData.BoundEntity = new_instancemethod(_Interface.Interface_FileReaderData_BoundEntity, None, Interface_FileReaderData)
Interface_FileReaderData.ChangeParam = new_instancemethod(_Interface.Interface_FileReaderData_ChangeParam, None, Interface_FileReaderData)
Interface_FileReaderData.Destroy = new_instancemethod(_Interface.Interface_FileReaderData_Destroy, None, Interface_FileReaderData)
Interface_FileReaderData.FindNextRecord = new_instancemethod(_Interface.Interface_FileReaderData_FindNextRecord, None, Interface_FileReaderData)
Interface_FileReaderData.InitParams = new_instancemethod(_Interface.Interface_FileReaderData_InitParams, None, Interface_FileReaderData)
Interface_FileReaderData.IsErrorLoad = new_instancemethod(_Interface.Interface_FileReaderData_IsErrorLoad, None, Interface_FileReaderData)
Interface_FileReaderData.IsParamDefined = new_instancemethod(_Interface.Interface_FileReaderData_IsParamDefined, None, Interface_FileReaderData)
Interface_FileReaderData.NbEntities = new_instancemethod(_Interface.Interface_FileReaderData_NbEntities, None, Interface_FileReaderData)
Interface_FileReaderData.NbParams = new_instancemethod(_Interface.Interface_FileReaderData_NbParams, None, Interface_FileReaderData)
Interface_FileReaderData.NbRecords = new_instancemethod(_Interface.Interface_FileReaderData_NbRecords, None, Interface_FileReaderData)
Interface_FileReaderData.Param = new_instancemethod(_Interface.Interface_FileReaderData_Param, None, Interface_FileReaderData)
Interface_FileReaderData.ParamCValue = new_instancemethod(_Interface.Interface_FileReaderData_ParamCValue, None, Interface_FileReaderData)
Interface_FileReaderData.ParamEntity = new_instancemethod(_Interface.Interface_FileReaderData_ParamEntity, None, Interface_FileReaderData)
Interface_FileReaderData.ParamFirstRank = new_instancemethod(_Interface.Interface_FileReaderData_ParamFirstRank, None, Interface_FileReaderData)
Interface_FileReaderData.ParamNumber = new_instancemethod(_Interface.Interface_FileReaderData_ParamNumber, None, Interface_FileReaderData)
Interface_FileReaderData.ParamType = new_instancemethod(_Interface.Interface_FileReaderData_ParamType, None, Interface_FileReaderData)
Interface_FileReaderData.Params = new_instancemethod(_Interface.Interface_FileReaderData_Params, None, Interface_FileReaderData)
Interface_FileReaderData.ResetErrorLoad = new_instancemethod(_Interface.Interface_FileReaderData_ResetErrorLoad, None, Interface_FileReaderData)
Interface_FileReaderData.SetErrorLoad = new_instancemethod(_Interface.Interface_FileReaderData_SetErrorLoad, None, Interface_FileReaderData)
Interface_FileReaderData.SetParam = new_instancemethod(_Interface.Interface_FileReaderData_SetParam, None, Interface_FileReaderData)
Interface_FileReaderData_swigregister = _Interface.Interface_FileReaderData_swigregister
Interface_FileReaderData_swigregister(Interface_FileReaderData)

def Interface_FileReaderData_Fastof(*args) -> "Standard_Real":
    """
    * Same spec.s as standard <atof> but 5 times faster
    	:param str:
    	:type str: char *
    	:rtype: float
    """
    return _Interface.Interface_FileReaderData_Fastof(*args)

class Interface_FileReaderTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AnalyseRecord(self, *args) -> "Standard_Boolean":
        """
        * Fills an Entity, given record no; specific to each Interface, called by AnalyseFile from InterfaceModel (which manages its calling arguments) To work, each Interface can define a method in its proper Transient class, like this (given as an example) : AnalyseRecord (me : mutable; FR : in out FileReaderTool; num : Integer; acheck : in out Check) returns Boolean; and call it from AnalyseRecord //! Returned Value : True if the entity could be loaded, False else (in case of syntactic fail)
        	:param num:
        	:type num: int
        	:param anent:
        	:type anent: Standard_Transient
        	:param acheck:
        	:type acheck: Interface_Check
        	:rtype: bool
        """
        return _Interface.Interface_FileReaderTool_AnalyseRecord(self, *args)


    def BeginRead(self, *args) -> "void":
        """
        * Fills model's header; each Interface defines for its Model its own file header; this method fills it from FileReaderTool.+ It is called by AnalyseFile from InterfaceModel
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: void
        """
        return _Interface.Interface_FileReaderTool_BeginRead(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clear filelds
        	:rtype: None
        """
        return _Interface.Interface_FileReaderTool_Clear(self, *args)


    def Data(self, *args) -> "opencascade::handle< Interface_FileReaderData >":
        """
        * Returns the FileReaderData which is used to work
        	:rtype: opencascade::handle<Interface_FileReaderData>
        """
        return _Interface.Interface_FileReaderTool_Data(self, *args)


    def EndRead(self, *args) -> "void":
        """
        * Ends file reading after reading all the entities default is doing nothing; redefinable as necessary
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: void
        """
        return _Interface.Interface_FileReaderTool_EndRead(self, *args)


    def LoadModel(self, *args) -> "void":
        """
        * Reads and fills Entities from the FileReaderData set by SetData to an InterfaceModel. It enchains required operations, the specific ones correspond to deferred methods (below) to be defined for each Norm. It manages also error recovery and trace. Remark : it calls SetModel. It Can raise any error which can occur during a load operation, unless Error Handling is set. This method can also be redefined if judged necessary.
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        """
        return _Interface.Interface_FileReaderTool_LoadModel(self, *args)


    def LoadedEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Reads, Fills and Returns one Entity read from a Record of the FileReaderData. This Method manages also case of Fail or Warning, by producing a ReportEntyty plus , for a Fail, a literal Content (as an UnknownEntity). Performs also Trace
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_FileReaderTool_LoadedEntity(self, *args)


    def Messenger(self, *args) -> "opencascade::handle< Message_Messenger >":
        """
        * Returns Messenger used for outputting messages. The returned object is guaranteed to be non-null; default is Message::Messenger().
        	:rtype: opencascade::handle<Message_Messenger>
        """
        return _Interface.Interface_FileReaderTool_Messenger(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the stored Model
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_FileReaderTool_Model(self, *args)


    def NewModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Creates an empty Model of the norm. Uses Protocol to do it
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_FileReaderTool_NewModel(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        * Returns the Protocol given at creation time
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_FileReaderTool_Protocol(self, *args)


    def Recognize(self, *args) -> "Standard_Boolean":
        """
        * Recognizes a record, given its number. Specific to each Interface; called by SetEntities. It can call the basic method RecognizeByLib. Returns False if recognition has failed, True else. <ach> has not to be filled if simply Recognition has failed : it must record true error messages : RecognizeByLib can generate error messages if NewRead is called //! Note that it works thru a Recognizer (method Evaluate) which has to be memorized before starting
        	:param num:
        	:type num: int
        	:param ach:
        	:type ach: Interface_Check
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_FileReaderTool_Recognize(self, *args)


    def RecognizeByLib(self, *args) -> "Standard_Boolean":
        """
        * Recognizes a record with the help of Libraries. Can be used to implement the method Recognize. <rlib> is used to find Protocol and CaseNumber to apply <glib> performs the creation (by service NewVoid, or NewRead if NewVoid gave no result) <ach> is a check, which is transmitted to NewRead if it is called, gives a result but which is false <ent> is the result Returns False if recognition has failed, True else
        	:param num:
        	:type num: int
        	:param glib:
        	:type glib: Interface_GeneralLib
        	:param rlib:
        	:type rlib: Interface_ReaderLib
        	:param ach:
        	:type ach: Interface_Check
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_FileReaderTool_RecognizeByLib(self, *args)


    def SetData(self, *args) -> "void":
        """
        * Sets Data to a FileReaderData. Works with a Protocol
        	:param reader:
        	:type reader: Interface_FileReaderData
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:rtype: None
        """
        return _Interface.Interface_FileReaderTool_SetData(self, *args)


    def SetEntities(self, *args) -> "void":
        """
        * Fills records with empty entities; once done, each entity can ask the FileReaderTool for any entity referenced through an identifier. Calls Recognize which is specific to each specific type of FileReaderTool
        	:rtype: None
        """
        return _Interface.Interface_FileReaderTool_SetEntities(self, *args)


    def SetMessenger(self, *args) -> "void":
        """
        * Sets Messenger used for outputting messages
        	:param messenger:
        	:type messenger: Message_Messenger
        	:rtype: None
        """
        return _Interface.Interface_FileReaderTool_SetMessenger(self, *args)


    def SetModel(self, *args) -> "void":
        """
        * Stores a Model. Used when the Model has been loaded
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        """
        return _Interface.Interface_FileReaderTool_SetModel(self, *args)


    def SetTraceLevel(self, *args) -> "void":
        """
        * Sets trace level used for outputting messages - 0: no trace at all - 1: errors - 2: errors and warnings - 3: all messages Default is 1 : Errors traced
        	:param tracelev:
        	:type tracelev: int
        	:rtype: None
        """
        return _Interface.Interface_FileReaderTool_SetTraceLevel(self, *args)


    def TraceLevel(self, *args) -> "Standard_Integer":
        """
        * Returns trace level used for outputting messages.
        	:rtype: int
        """
        return _Interface.Interface_FileReaderTool_TraceLevel(self, *args)


    def UnknownEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Provides an unknown entity, specific to the Interface called by SetEntities when Recognize has failed (Unknown alone) or by LoadModel when an Entity has caused a Fail on reading (to keep at least its literal description) Uses Protocol to do it
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_FileReaderTool_UnknownEntity(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_FileReaderTool
Interface_FileReaderTool.AnalyseRecord = new_instancemethod(_Interface.Interface_FileReaderTool_AnalyseRecord, None, Interface_FileReaderTool)
Interface_FileReaderTool.BeginRead = new_instancemethod(_Interface.Interface_FileReaderTool_BeginRead, None, Interface_FileReaderTool)
Interface_FileReaderTool.Clear = new_instancemethod(_Interface.Interface_FileReaderTool_Clear, None, Interface_FileReaderTool)
Interface_FileReaderTool.Data = new_instancemethod(_Interface.Interface_FileReaderTool_Data, None, Interface_FileReaderTool)
Interface_FileReaderTool.EndRead = new_instancemethod(_Interface.Interface_FileReaderTool_EndRead, None, Interface_FileReaderTool)
Interface_FileReaderTool.LoadModel = new_instancemethod(_Interface.Interface_FileReaderTool_LoadModel, None, Interface_FileReaderTool)
Interface_FileReaderTool.LoadedEntity = new_instancemethod(_Interface.Interface_FileReaderTool_LoadedEntity, None, Interface_FileReaderTool)
Interface_FileReaderTool.Messenger = new_instancemethod(_Interface.Interface_FileReaderTool_Messenger, None, Interface_FileReaderTool)
Interface_FileReaderTool.Model = new_instancemethod(_Interface.Interface_FileReaderTool_Model, None, Interface_FileReaderTool)
Interface_FileReaderTool.NewModel = new_instancemethod(_Interface.Interface_FileReaderTool_NewModel, None, Interface_FileReaderTool)
Interface_FileReaderTool.Protocol = new_instancemethod(_Interface.Interface_FileReaderTool_Protocol, None, Interface_FileReaderTool)
Interface_FileReaderTool.Recognize = new_instancemethod(_Interface.Interface_FileReaderTool_Recognize, None, Interface_FileReaderTool)
Interface_FileReaderTool.RecognizeByLib = new_instancemethod(_Interface.Interface_FileReaderTool_RecognizeByLib, None, Interface_FileReaderTool)
Interface_FileReaderTool.SetData = new_instancemethod(_Interface.Interface_FileReaderTool_SetData, None, Interface_FileReaderTool)
Interface_FileReaderTool.SetEntities = new_instancemethod(_Interface.Interface_FileReaderTool_SetEntities, None, Interface_FileReaderTool)
Interface_FileReaderTool.SetMessenger = new_instancemethod(_Interface.Interface_FileReaderTool_SetMessenger, None, Interface_FileReaderTool)
Interface_FileReaderTool.SetModel = new_instancemethod(_Interface.Interface_FileReaderTool_SetModel, None, Interface_FileReaderTool)
Interface_FileReaderTool.SetTraceLevel = new_instancemethod(_Interface.Interface_FileReaderTool_SetTraceLevel, None, Interface_FileReaderTool)
Interface_FileReaderTool.TraceLevel = new_instancemethod(_Interface.Interface_FileReaderTool_TraceLevel, None, Interface_FileReaderTool)
Interface_FileReaderTool.UnknownEntity = new_instancemethod(_Interface.Interface_FileReaderTool_UnknownEntity, None, Interface_FileReaderTool)
Interface_FileReaderTool_swigregister = _Interface.Interface_FileReaderTool_swigregister
Interface_FileReaderTool_swigregister(Interface_FileReaderTool)

class Interface_FloatWriter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Convert(*args) -> "Standard_Integer":
        """
        * This class method converts a Real Value to a string, given options given as arguments. It can be called independantly. Warning : even if declared in, content of <text> will be modified
        	:param val:
        	:type val: float
        	:param text:
        	:type text: char *
        	:param zerosup:
        	:type zerosup: bool
        	:param Range1:
        	:type Range1: float
        	:param Range2:
        	:type Range2: float
        	:param mainform:
        	:type mainform: char *
        	:param rangeform:
        	:type rangeform: char *
        	:rtype: int
        """
        return _Interface.Interface_FloatWriter_Convert(*args)

    Convert = staticmethod(Convert)

    def FormatForRange(self, *args) -> "char const *":
        """
        * Returns the format for range, if set Meaningful only if <range> from Options is True was C++ : return const
        	:rtype: char *
        """
        return _Interface.Interface_FloatWriter_FormatForRange(self, *args)


    def __init__(self, *args):
        """
        * Creates a FloatWriter ready to work, with default options - - zero suppress option is set - main format is set to '%E' - secondary format is set to '%f' for values between 0.1 and 1000. in absolute values If <chars> is given (and positive), it will produce options to produce this count of characters : '%<chars>f','%<chars>%E'
        	:param chars: default value is 0
        	:type chars: int
        	:rtype: None
        """
        _Interface.Interface_FloatWriter_swiginit(self, _Interface.new_Interface_FloatWriter(*args))

    def MainFormat(self, *args) -> "char const *":
        """
        * Returns the main format was C++ : return const
        	:rtype: char *
        """
        return _Interface.Interface_FloatWriter_MainFormat(self, *args)


    def Options(self, *args) -> "void":
        """
        * Returns active options : <zerosup> is the option ZeroSuppress, <range> is True if a range is set, False else R1,R2 give the range (if it is set)
        	:param zerosup:
        	:type zerosup: bool
        	:param range:
        	:type range: bool
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:rtype: None
        """
        return _Interface.Interface_FloatWriter_Options(self, *args)


    def SetDefaults(self, *args) -> "void":
        """
        * Sets again options to the defaults given by Create
        	:param chars: default value is 0
        	:type chars: int
        	:rtype: None
        """
        return _Interface.Interface_FloatWriter_SetDefaults(self, *args)


    def SetFormat(self, *args) -> "void":
        """
        * Sets a specific Format for Sending Reals (main format) (Default from Creation is '%E') If <reset> is given True (default), this call clears effects of former calls to SetFormatForRange and SetZeroSuppress
        	:param form:
        	:type form: char *
        	:param reset: default value is Standard_True
        	:type reset: bool
        	:rtype: None
        """
        return _Interface.Interface_FloatWriter_SetFormat(self, *args)


    def SetFormatForRange(self, *args) -> "void":
        """
        * Sets a secondary Format for Real, to be applied between R1 and R2 (in absolute values). A Call to SetRealForm cancels this secondary form if <reset> is True. (Default from Creation is '%f' between 0.1 and 1000.) Warning : if the condition (0. <= R1 < R2) is not fulfilled, this secondary form is canceled.
        	:param form:
        	:type form: char *
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:rtype: None
        """
        return _Interface.Interface_FloatWriter_SetFormatForRange(self, *args)


    def SetZeroSuppress(self, *args) -> "void":
        """
        * Sets Sending Real Parameters to suppress trailing Zeros and Null Exponant ('E+00'), if <mode> is given True, Resets this mode if <mode> is False (in addition to Real Forms) A call to SetRealFrom resets this mode to False ig <reset> is given True (Default from Creation is True)
        	:param mode:
        	:type mode: bool
        	:rtype: None
        """
        return _Interface.Interface_FloatWriter_SetZeroSuppress(self, *args)


    def Write(self, *args) -> "Standard_Integer":
        """
        * Writes a Real value <val> to a string <text> by using the options. Returns the useful Length of produced string. It calls the class method Convert. Warning : <text> is assumed to be wide enough (20-30 is correct) And, even if declared in, its content will be modified
        	:param val:
        	:type val: float
        	:param text:
        	:type text: char *
        	:rtype: int
        """
        return _Interface.Interface_FloatWriter_Write(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_FloatWriter
Interface_FloatWriter.FormatForRange = new_instancemethod(_Interface.Interface_FloatWriter_FormatForRange, None, Interface_FloatWriter)
Interface_FloatWriter.MainFormat = new_instancemethod(_Interface.Interface_FloatWriter_MainFormat, None, Interface_FloatWriter)
Interface_FloatWriter.Options = new_instancemethod(_Interface.Interface_FloatWriter_Options, None, Interface_FloatWriter)
Interface_FloatWriter.SetDefaults = new_instancemethod(_Interface.Interface_FloatWriter_SetDefaults, None, Interface_FloatWriter)
Interface_FloatWriter.SetFormat = new_instancemethod(_Interface.Interface_FloatWriter_SetFormat, None, Interface_FloatWriter)
Interface_FloatWriter.SetFormatForRange = new_instancemethod(_Interface.Interface_FloatWriter_SetFormatForRange, None, Interface_FloatWriter)
Interface_FloatWriter.SetZeroSuppress = new_instancemethod(_Interface.Interface_FloatWriter_SetZeroSuppress, None, Interface_FloatWriter)
Interface_FloatWriter.Write = new_instancemethod(_Interface.Interface_FloatWriter_Write, None, Interface_FloatWriter)
Interface_FloatWriter_swigregister = _Interface.Interface_FloatWriter_swigregister
Interface_FloatWriter_swigregister(Interface_FloatWriter)

def Interface_FloatWriter_Convert(*args) -> "Standard_Integer":
    """
    * This class method converts a Real Value to a string, given options given as arguments. It can be called independantly. Warning : even if declared in, content of <text> will be modified
    	:param val:
    	:type val: float
    	:param text:
    	:type text: char *
    	:param zerosup:
    	:type zerosup: bool
    	:param Range1:
    	:type Range1: float
    	:param Range2:
    	:type Range2: float
    	:param mainform:
    	:type mainform: char *
    	:param rangeform:
    	:type rangeform: char *
    	:rtype: int
    """
    return _Interface.Interface_FloatWriter_Convert(*args)

class Interface_GTool(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ClearEntities(self, *args) -> "void":
        """
        * Clears the maps which record, for each already recorded entity its Module and Case Number
        	:rtype: None
        """
        return _Interface.Interface_GTool_ClearEntities(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty, not set, GTool
        	:rtype: None
        * Creates a GTool from a Protocol Optional starting count of entities
        	:param proto:
        	:type proto: Interface_Protocol
        	:param nbent: default value is 0
        	:type nbent: int
        	:rtype: None
        """
        _Interface.Interface_GTool_swiginit(self, _Interface.new_Interface_GTool(*args))

    def Lib(self, *args) -> "Interface_GeneralLib &":
        """
        * Returns the GeneralLib itself
        	:rtype: Interface_GeneralLib
        """
        return _Interface.Interface_GTool_Lib(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        * Returns the Protocol. Warning : it can be Null
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_GTool_Protocol(self, *args)


    def Reservate(self, *args) -> "void":
        """
        * Reservates maps for a count of entities <enforce> False : minimum count <enforce> True : clears former reservations Does not clear the maps
        	:param nb:
        	:type nb: int
        	:param enforce: default value is Standard_False
        	:type enforce: bool
        	:rtype: None
        """
        return _Interface.Interface_GTool_Reservate(self, *args)


    def Select(self, *args) -> "Standard_Boolean":
        """
        * Selects for an entity, its Module and Case Number It is optimised : once done for each entity, the result is mapped and the GeneralLib is not longer queried <enforce> True overpasses this optimisation
        	:param ent:
        	:type ent: Standard_Transient
        	:param gmod:
        	:type gmod: Interface_GeneralModule
        	:param CN:
        	:type CN: int
        	:param enforce: default value is Standard_False
        	:type enforce: bool
        	:rtype: bool
        """
        return _Interface.Interface_GTool_Select(self, *args)


    def SetProtocol(self, *args) -> "void":
        """
        * Sets a new Protocol if <enforce> is False and the new Protocol equates the old one then nothing is done
        	:param proto:
        	:type proto: Interface_Protocol
        	:param enforce: default value is Standard_False
        	:type enforce: bool
        	:rtype: None
        """
        return _Interface.Interface_GTool_SetProtocol(self, *args)


    def SetSignType(self, *args) -> "void":
        """
        * Sets a new SignType
        	:param sign:
        	:type sign: Interface_SignType
        	:rtype: None
        """
        return _Interface.Interface_GTool_SetSignType(self, *args)


    def SignName(self, *args) -> "char const *":
        """
        * Returns the Name of the SignType, or 'Class Name'
        	:rtype: char *
        """
        return _Interface.Interface_GTool_SignName(self, *args)


    def SignType(self, *args) -> "opencascade::handle< Interface_SignType >":
        """
        * Returns the SignType. Can be null
        	:rtype: opencascade::handle<Interface_SignType>
        """
        return _Interface.Interface_GTool_SignType(self, *args)


    def SignValue(self, *args) -> "char const *":
        """
        * Returns the Signature for a Transient Object in a Model It calls SignType to do that If SignType is not defined, return ClassName of <ent>
        	:param ent:
        	:type ent: Standard_Transient
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: char *
        """
        return _Interface.Interface_GTool_SignValue(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_GTool_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GTool
Interface_GTool.ClearEntities = new_instancemethod(_Interface.Interface_GTool_ClearEntities, None, Interface_GTool)
Interface_GTool.Lib = new_instancemethod(_Interface.Interface_GTool_Lib, None, Interface_GTool)
Interface_GTool.Protocol = new_instancemethod(_Interface.Interface_GTool_Protocol, None, Interface_GTool)
Interface_GTool.Reservate = new_instancemethod(_Interface.Interface_GTool_Reservate, None, Interface_GTool)
Interface_GTool.Select = new_instancemethod(_Interface.Interface_GTool_Select, None, Interface_GTool)
Interface_GTool.SetProtocol = new_instancemethod(_Interface.Interface_GTool_SetProtocol, None, Interface_GTool)
Interface_GTool.SetSignType = new_instancemethod(_Interface.Interface_GTool_SetSignType, None, Interface_GTool)
Interface_GTool.SignName = new_instancemethod(_Interface.Interface_GTool_SignName, None, Interface_GTool)
Interface_GTool.SignType = new_instancemethod(_Interface.Interface_GTool_SignType, None, Interface_GTool)
Interface_GTool.SignValue = new_instancemethod(_Interface.Interface_GTool_SignValue, None, Interface_GTool)
Interface_GTool_swigregister = _Interface.Interface_GTool_swigregister
Interface_GTool_swigregister(Interface_GTool)

class Interface_GeneralLib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddProtocol(self, *args) -> "void":
        """
        * Adds a couple (Module-Protocol) to the Library, given the class of a Protocol. Takes Resources into account. (if <aprotocol> is not of type TheProtocol, it is not added)
        	:param aprotocol:
        	:type aprotocol: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_GeneralLib_AddProtocol(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears the list of Modules of a library (can be used to redefine the order of Modules before action : Clear then refill the Library by calls to AddProtocol)
        	:rtype: None
        """
        return _Interface.Interface_GeneralLib_Clear(self, *args)


    def __init__(self, *args):
        """
        * Creates a Library which complies with a Protocol, that is : Same class (criterium IsInstance) This creation gets the Modules from the global set, those which are bound to the given Protocol and its Resources
        	:param aprotocol:
        	:type aprotocol: Interface_Protocol
        	:rtype: None
        * Creates an empty Library : it will later by filled by method AddProtocol
        	:rtype: None
        """
        _Interface.Interface_GeneralLib_swiginit(self, _Interface.new_Interface_GeneralLib(*args))

    def Module(self, *args) -> "opencascade::handle< Interface_GeneralModule > const &":
        """
        * Returns the current Module in the Iteration
        	:rtype: opencascade::handle<Interface_GeneralModule>
        """
        return _Interface.Interface_GeneralLib_Module(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there are more Modules to iterate on
        	:rtype: bool
        """
        return _Interface.Interface_GeneralLib_More(self, *args)


    def Next(self, *args) -> "void":
        """
        * Iterates by getting the next Module in the list If there is none, the exception will be raised by Value
        	:rtype: None
        """
        return _Interface.Interface_GeneralLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        * Returns the current Protocol in the Iteration
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_GeneralLib_Protocol(self, *args)


    def Select(self, *args) -> "Standard_Boolean":
        """
        * Selects a Module from the Library, given an Object. Returns True if Select has succeeded, False else. Also Returns (as arguments) the selected Module and the Case Number determined by the associated Protocol. If Select has failed, <module> is Null Handle and CN is zero. (Select can work on any criterium, such as Object DynamicType)
        	:param obj:
        	:type obj: Standard_Transient
        	:param module:
        	:type module: Interface_GeneralModule
        	:param CN:
        	:type CN: int
        	:rtype: bool
        """
        return _Interface.Interface_GeneralLib_Select(self, *args)


    def SetComplete(self, *args) -> "void":
        """
        * Sets a library to be defined with the complete Global list (all the couples Protocol/Modules recorded in it)
        	:rtype: None
        """
        return _Interface.Interface_GeneralLib_SetComplete(self, *args)


    def SetGlobal(*args) -> "void":
        """
        * Adds a couple (Module-Protocol) into the global definition set for this class of Library.
        	:param amodule:
        	:type amodule: Interface_GeneralModule
        	:param aprotocol:
        	:type aprotocol: Interface_Protocol
        	:rtype: void
        """
        return _Interface.Interface_GeneralLib_SetGlobal(*args)

    SetGlobal = staticmethod(SetGlobal)

    def Start(self, *args) -> "void":
        """
        * Starts Iteration on the Modules (sets it on the first one)
        	:rtype: None
        """
        return _Interface.Interface_GeneralLib_Start(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GeneralLib
Interface_GeneralLib.AddProtocol = new_instancemethod(_Interface.Interface_GeneralLib_AddProtocol, None, Interface_GeneralLib)
Interface_GeneralLib.Clear = new_instancemethod(_Interface.Interface_GeneralLib_Clear, None, Interface_GeneralLib)
Interface_GeneralLib.Module = new_instancemethod(_Interface.Interface_GeneralLib_Module, None, Interface_GeneralLib)
Interface_GeneralLib.More = new_instancemethod(_Interface.Interface_GeneralLib_More, None, Interface_GeneralLib)
Interface_GeneralLib.Next = new_instancemethod(_Interface.Interface_GeneralLib_Next, None, Interface_GeneralLib)
Interface_GeneralLib.Protocol = new_instancemethod(_Interface.Interface_GeneralLib_Protocol, None, Interface_GeneralLib)
Interface_GeneralLib.Select = new_instancemethod(_Interface.Interface_GeneralLib_Select, None, Interface_GeneralLib)
Interface_GeneralLib.SetComplete = new_instancemethod(_Interface.Interface_GeneralLib_SetComplete, None, Interface_GeneralLib)
Interface_GeneralLib.Start = new_instancemethod(_Interface.Interface_GeneralLib_Start, None, Interface_GeneralLib)
Interface_GeneralLib_swigregister = _Interface.Interface_GeneralLib_swigregister
Interface_GeneralLib_swigregister(Interface_GeneralLib)

def Interface_GeneralLib_SetGlobal(*args) -> "void":
    """
    * Adds a couple (Module-Protocol) into the global definition set for this class of Library.
    	:param amodule:
    	:type amodule: Interface_GeneralModule
    	:param aprotocol:
    	:type aprotocol: Interface_Protocol
    	:rtype: void
    """
    return _Interface.Interface_GeneralLib_SetGlobal(*args)

class Interface_GeneralModule(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CanCopy(self, *args) -> "Standard_Boolean":
        """
        * Specific answer to the question 'is Copy properly implemented' Remark that it should be in phase with the implementation of NewVoid+CopyCase/NewCopyCase Default returns always False, can be redefined
        	:param CN:
        	:type CN: int
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_GeneralModule_CanCopy(self, *args)


    def CategoryNumber(self, *args) -> "Standard_Integer":
        """
        * Returns a category number which characterizes an entity Category Numbers are managed by the class Category <shares> can be used to evaluate this number in the context Default returns 0 which means 'unspecified'
        	:param CN:
        	:type CN: int
        	:param ent:
        	:type ent: Standard_Transient
        	:param shares:
        	:type shares: Interface_ShareTool
        	:rtype: int
        """
        return _Interface.Interface_GeneralModule_CategoryNumber(self, *args)


    def CheckCase(self, *args) -> "void":
        """
        * Specific Checking of an Entity <ent> Can check context queried through a ShareTool, as required
        	:param CN:
        	:type CN: int
        	:param ent:
        	:type ent: Standard_Transient
        	:param shares:
        	:type shares: Interface_ShareTool
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: void
        """
        return _Interface.Interface_GeneralModule_CheckCase(self, *args)


    def CopyCase(self, *args) -> "void":
        """
        * Specific Copy ('Deep') from <entfrom> to <entto> (same type) by using a CopyTool which provides its working Map. Use method Transferred from CopyTool to work
        	:param CN:
        	:type CN: int
        	:param entfrom:
        	:type entfrom: Standard_Transient
        	:param entto:
        	:type entto: Standard_Transient
        	:param TC:
        	:type TC: Interface_CopyTool
        	:rtype: void
        """
        return _Interface.Interface_GeneralModule_CopyCase(self, *args)


    def Dispatch(self, *args) -> "Standard_Boolean":
        """
        * Dispatches an entity Returns True if it works by copy, False if it just duplicates the starting Handle //! Dispatching means producing a new entity, image of the starting one, in order to be put into a new Model, this Model being itself the result of a dispatch from an original Model //! According to the cases, dispatch can either * just return <entto> as equating <entfrom> -> the new model designates the starting entity : it is lighter, but the dispatched entity being shared might not be modified for dispatch * copy <entfrom> to <entto> by calling NewVoid+CopyCase (two steps) or NewCopiedCase (1) -> the dispatched entity is a COPY, hence it can be modified //! The provided default just duplicates the handle without copying, then returns False. Can be redefined
        	:param CN:
        	:type CN: int
        	:param entfrom:
        	:type entfrom: Standard_Transient
        	:param entto:
        	:type entto: Standard_Transient
        	:param TC:
        	:type TC: Interface_CopyTool
        	:rtype: bool
        """
        return _Interface.Interface_GeneralModule_Dispatch(self, *args)


    def FillShared(self, *args) -> "void":
        """
        * Specific filling of the list of Entities shared by an Entity <ent>, according a Case Number <CN> (formerly computed by CaseNum), considered in the context of a Model <model> Default calls FillSharedCase (i.e., ignores the model) Can be redefined to use the model for working
        	:param model:
        	:type model: Interface_InterfaceModel
        	:param CN:
        	:type CN: int
        	:param ent:
        	:type ent: Standard_Transient
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:rtype: void
        """
        return _Interface.Interface_GeneralModule_FillShared(self, *args)


    def FillSharedCase(self, *args) -> "void":
        """
        * Specific filling of the list of Entities shared by an Entity <ent>, according a Case Number <CN> (formerly computed by CaseNum). Can use the internal utility method Share, below
        	:param CN:
        	:type CN: int
        	:param ent:
        	:type ent: Standard_Transient
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:rtype: void
        """
        return _Interface.Interface_GeneralModule_FillSharedCase(self, *args)


    def ListImplied(self, *args) -> "void":
        """
        * List the Implied References of <ent> considered in the context of a Model <model> : i.e. the Entities which are Referenced while not considered as Shared (not copied if <ent> is, references not renewed by CopyCase but by ImpliedCase, only if referenced Entities have been Copied too) FillShared + ListImplied give the complete list of References Default calls ListImpliedCase (i.e. ignores the model) Can be redefined to use the model for working
        	:param model:
        	:type model: Interface_InterfaceModel
        	:param CN:
        	:type CN: int
        	:param ent:
        	:type ent: Standard_Transient
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:rtype: void
        """
        return _Interface.Interface_GeneralModule_ListImplied(self, *args)


    def ListImpliedCase(self, *args) -> "void":
        """
        * List the Implied References of <ent> (see above) are Referenced while not considered as Shared (not copied if <ent> is, references not renewed by CopyCase but by ImpliedCase, only if referenced Entities have been Copied too) FillSharedCase + ListImpliedCase give the complete list of Referenced Entities The provided default method does nothing (Implied References are specific of a little amount of Entity Classes).
        	:param CN:
        	:type CN: int
        	:param ent:
        	:type ent: Standard_Transient
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:rtype: void
        """
        return _Interface.Interface_GeneralModule_ListImpliedCase(self, *args)


    def Name(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        * Determines if an entity brings a Name (or widerly, if a Name can be attached to it, through the ShareTool By default, returns a Null opencascade::handle<nonamecanbeproduced> Can be redefined //! Warning : While this string may be edited on the spot, if it is a read field, the returned value must be copied before.
        	:param CN:
        	:type CN: int
        	:param ent:
        	:type ent: Standard_Transient
        	:param shares:
        	:type shares: Interface_ShareTool
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _Interface.Interface_GeneralModule_Name(self, *args)


    def NewCopiedCase(self, *args) -> "Standard_Boolean":
        """
        * Specific operator (create+copy) defaulted to do nothing. It can be redefined : When it is not possible to work in two steps (NewVoid then CopyCase). This can occur when there is no default constructor : hence the result <entto> must be created with an effective definition. Remark : if NewCopiedCase is defined, CopyCase has nothing to do Returns True if it has produced something, false else
        	:param CN:
        	:type CN: int
        	:param entfrom:
        	:type entfrom: Standard_Transient
        	:param entto:
        	:type entto: Standard_Transient
        	:param TC:
        	:type TC: Interface_CopyTool
        	:rtype: bool
        """
        return _Interface.Interface_GeneralModule_NewCopiedCase(self, *args)


    def NewVoid(self, *args) -> "Standard_Boolean":
        """
        * Creates a new void entity <entto> according to a Case Number This entity remains to be filled, by reading from a file or by copying from another entity of same type (see CopyCase)
        	:param CN:
        	:type CN: int
        	:param entto:
        	:type entto: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_GeneralModule_NewVoid(self, *args)


    def RenewImpliedCase(self, *args) -> "void":
        """
        * Specific Copying of Implied References A Default is provided which does nothing (must current case !) Already copied references (by CopyFrom) must remain unchanged Use method Search from CopyTool to work
        	:param CN:
        	:type CN: int
        	:param entfrom:
        	:type entfrom: Standard_Transient
        	:param entto:
        	:type entto: Standard_Transient
        	:param TC:
        	:type TC: Interface_CopyTool
        	:rtype: void
        """
        return _Interface.Interface_GeneralModule_RenewImpliedCase(self, *args)


    def Share(self, *args) -> "void":
        """
        * Adds an Entity to a Shared List (uses GetOneItem on <iter>)
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:param shared:
        	:type shared: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_GeneralModule_Share(self, *args)


    def WhenDeleteCase(self, *args) -> "void":
        """
        * Prepares an entity to be deleted. What does it mean : Basically, any class of entity may define its own destructor By default, it does nothing but calling destructors on fields With the Memory Manager, it is useless to call destructor, it is done automatically when the Handle is nullified(cleared) BUT this is ineffective in looping structures (whatever these are 'Implied' references or not). //! THUS : if no loop may appear in definitions, a class which inherits from TShared is correctly managed by automatic way BUT if there can be loops (or simply back pointers), they must be broken, for instance by clearing fields of one of the nodes The default does nothing, to be redefined if a loop can occur (Implied generally requires WhenDelete, but other cases can occur) //! Warning : <dispatched> tells if the entity to be deleted has been produced by Dispatch or not. Hence WhenDelete must be in coherence with Dispatch Dispatch can either copy or not. If it copies the entity, this one should be deleted If it doesnt (i.e. duplicates the handle) nothing to do //! If <dispatch> is False, normal deletion is to be performed
        	:param CN:
        	:type CN: int
        	:param ent:
        	:type ent: Standard_Transient
        	:param dispatched:
        	:type dispatched: bool
        	:rtype: void
        """
        return _Interface.Interface_GeneralModule_WhenDeleteCase(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_GeneralModule_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GeneralModule
Interface_GeneralModule.CanCopy = new_instancemethod(_Interface.Interface_GeneralModule_CanCopy, None, Interface_GeneralModule)
Interface_GeneralModule.CategoryNumber = new_instancemethod(_Interface.Interface_GeneralModule_CategoryNumber, None, Interface_GeneralModule)
Interface_GeneralModule.CheckCase = new_instancemethod(_Interface.Interface_GeneralModule_CheckCase, None, Interface_GeneralModule)
Interface_GeneralModule.CopyCase = new_instancemethod(_Interface.Interface_GeneralModule_CopyCase, None, Interface_GeneralModule)
Interface_GeneralModule.Dispatch = new_instancemethod(_Interface.Interface_GeneralModule_Dispatch, None, Interface_GeneralModule)
Interface_GeneralModule.FillShared = new_instancemethod(_Interface.Interface_GeneralModule_FillShared, None, Interface_GeneralModule)
Interface_GeneralModule.FillSharedCase = new_instancemethod(_Interface.Interface_GeneralModule_FillSharedCase, None, Interface_GeneralModule)
Interface_GeneralModule.ListImplied = new_instancemethod(_Interface.Interface_GeneralModule_ListImplied, None, Interface_GeneralModule)
Interface_GeneralModule.ListImpliedCase = new_instancemethod(_Interface.Interface_GeneralModule_ListImpliedCase, None, Interface_GeneralModule)
Interface_GeneralModule.Name = new_instancemethod(_Interface.Interface_GeneralModule_Name, None, Interface_GeneralModule)
Interface_GeneralModule.NewCopiedCase = new_instancemethod(_Interface.Interface_GeneralModule_NewCopiedCase, None, Interface_GeneralModule)
Interface_GeneralModule.NewVoid = new_instancemethod(_Interface.Interface_GeneralModule_NewVoid, None, Interface_GeneralModule)
Interface_GeneralModule.RenewImpliedCase = new_instancemethod(_Interface.Interface_GeneralModule_RenewImpliedCase, None, Interface_GeneralModule)
Interface_GeneralModule.Share = new_instancemethod(_Interface.Interface_GeneralModule_Share, None, Interface_GeneralModule)
Interface_GeneralModule.WhenDeleteCase = new_instancemethod(_Interface.Interface_GeneralModule_WhenDeleteCase, None, Interface_GeneralModule)
Interface_GeneralModule_swigregister = _Interface.Interface_GeneralModule_swigregister
Interface_GeneralModule_swigregister(Interface_GeneralModule)

class Interface_GlobalNodeOfGeneralLib(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a Module bound with a Protocol to the list : does nothing if already in the list, THAT IS, Same Type (exact match) and Same State (that is, IsEqual is not required) Once added, stores its attached Protocol in correspondance
        	:param amodule:
        	:type amodule: Interface_GeneralModule
        	:param aprotocol:
        	:type aprotocol: Interface_Protocol
        	:rtype: None
        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_Add(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty GlobalNode, with no Next
        	:rtype: None
        """
        _Interface.Interface_GlobalNodeOfGeneralLib_swiginit(self, _Interface.new_Interface_GlobalNodeOfGeneralLib(*args))

    def Module(self, *args) -> "opencascade::handle< Interface_GeneralModule > const &":
        """
        * Returns the Module stored in a given GlobalNode
        	:rtype: opencascade::handle<Interface_GeneralModule>
        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< Interface_GlobalNodeOfGeneralLib > const &":
        """
        * Returns the Next GlobalNode. If none is defined, returned value is a Null Handle
        	:rtype: opencascade::handle<Interface_GlobalNodeOfGeneralLib>
        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        * Returns the attached Protocol stored in a given GlobalNode
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_Protocol(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_GlobalNodeOfGeneralLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GlobalNodeOfGeneralLib
Interface_GlobalNodeOfGeneralLib.Add = new_instancemethod(_Interface.Interface_GlobalNodeOfGeneralLib_Add, None, Interface_GlobalNodeOfGeneralLib)
Interface_GlobalNodeOfGeneralLib.Module = new_instancemethod(_Interface.Interface_GlobalNodeOfGeneralLib_Module, None, Interface_GlobalNodeOfGeneralLib)
Interface_GlobalNodeOfGeneralLib.Next = new_instancemethod(_Interface.Interface_GlobalNodeOfGeneralLib_Next, None, Interface_GlobalNodeOfGeneralLib)
Interface_GlobalNodeOfGeneralLib.Protocol = new_instancemethod(_Interface.Interface_GlobalNodeOfGeneralLib_Protocol, None, Interface_GlobalNodeOfGeneralLib)
Interface_GlobalNodeOfGeneralLib_swigregister = _Interface.Interface_GlobalNodeOfGeneralLib_swigregister
Interface_GlobalNodeOfGeneralLib_swigregister(Interface_GlobalNodeOfGeneralLib)

class Interface_GlobalNodeOfReaderLib(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a Module bound with a Protocol to the list : does nothing if already in the list, THAT IS, Same Type (exact match) and Same State (that is, IsEqual is not required) Once added, stores its attached Protocol in correspondance
        	:param amodule:
        	:type amodule: Interface_ReaderModule
        	:param aprotocol:
        	:type aprotocol: Interface_Protocol
        	:rtype: None
        """
        return _Interface.Interface_GlobalNodeOfReaderLib_Add(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty GlobalNode, with no Next
        	:rtype: None
        """
        _Interface.Interface_GlobalNodeOfReaderLib_swiginit(self, _Interface.new_Interface_GlobalNodeOfReaderLib(*args))

    def Module(self, *args) -> "opencascade::handle< Interface_ReaderModule > const &":
        """
        * Returns the Module stored in a given GlobalNode
        	:rtype: opencascade::handle<Interface_ReaderModule>
        """
        return _Interface.Interface_GlobalNodeOfReaderLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< Interface_GlobalNodeOfReaderLib > const &":
        """
        * Returns the Next GlobalNode. If none is defined, returned value is a Null Handle
        	:rtype: opencascade::handle<Interface_GlobalNodeOfReaderLib>
        """
        return _Interface.Interface_GlobalNodeOfReaderLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        * Returns the attached Protocol stored in a given GlobalNode
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_GlobalNodeOfReaderLib_Protocol(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_GlobalNodeOfReaderLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GlobalNodeOfReaderLib
Interface_GlobalNodeOfReaderLib.Add = new_instancemethod(_Interface.Interface_GlobalNodeOfReaderLib_Add, None, Interface_GlobalNodeOfReaderLib)
Interface_GlobalNodeOfReaderLib.Module = new_instancemethod(_Interface.Interface_GlobalNodeOfReaderLib_Module, None, Interface_GlobalNodeOfReaderLib)
Interface_GlobalNodeOfReaderLib.Next = new_instancemethod(_Interface.Interface_GlobalNodeOfReaderLib_Next, None, Interface_GlobalNodeOfReaderLib)
Interface_GlobalNodeOfReaderLib.Protocol = new_instancemethod(_Interface.Interface_GlobalNodeOfReaderLib_Protocol, None, Interface_GlobalNodeOfReaderLib)
Interface_GlobalNodeOfReaderLib_swigregister = _Interface.Interface_GlobalNodeOfReaderLib_swigregister
Interface_GlobalNodeOfReaderLib_swigregister(Interface_GlobalNodeOfReaderLib)

class Interface_Graph(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BitMap(self, *args) -> "Interface_BitMap const &":
        """
        * Returns the Bit Map in order to read or edit flag values
        	:rtype: Interface_BitMap
        """
        return _Interface.Interface_Graph_BitMap(self, *args)


    def CBitMap(self, *args) -> "Interface_BitMap &":
        """
        * Returns the Bit Map in order to edit it (add new flags)
        	:rtype: Interface_BitMap
        """
        return _Interface.Interface_Graph_CBitMap(self, *args)


    def ChangeStatus(self, *args) -> "void":
        """
        * Changes all status which value is oldstat to new value newstat
        	:param oldstat:
        	:type oldstat: int
        	:param newstat:
        	:type newstat: int
        	:rtype: None
        """
        return _Interface.Interface_Graph_ChangeStatus(self, *args)


    def Entity(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns mapped Entity given its no (if it is present)
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_Graph_Entity(self, *args)


    def EntityNumber(self, *args) -> "Standard_Integer":
        """
        * Returns the Number of the entity in the Map, computed at creation time (Entities loaded from the Model) Returns 0 if <ent> not contained by Model used to create <self> (that is, <ent> is unknown from <self>)
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: int
        """
        return _Interface.Interface_Graph_EntityNumber(self, *args)


    def GetFromEntity(self, *args) -> "void":
        """
        * Gets an Entity, plus its shared ones (at every level) if 'shared' is True. New items are set to status 'newstat' Items already present in graph remain unchanged Of course, redefinitions of Shared lists are taken into account if there are some
        	:param ent:
        	:type ent: Standard_Transient
        	:param shared:
        	:type shared: bool
        	:param newstat: default value is 0
        	:type newstat: int
        	:rtype: None
        * Gets an Entity, plus its shared ones (at every level) if 'shared' is True. New items are set to status 'newstat'. Items already present in graph are processed as follows : - if they already have status 'newstat', they remain unchanged - if they have another status, this one is modified : if cumul is True, to former status + overlapstat (cumul) if cumul is False, to overlapstat (enforce)
        	:param ent:
        	:type ent: Standard_Transient
        	:param shared:
        	:type shared: bool
        	:param newstat:
        	:type newstat: int
        	:param overlapstat:
        	:type overlapstat: int
        	:param cumul:
        	:type cumul: bool
        	:rtype: None
        """
        return _Interface.Interface_Graph_GetFromEntity(self, *args)


    def GetFromGraph(self, *args) -> "void":
        """
        * Gets all present items from another graph
        	:param agraph:
        	:type agraph: Interface_Graph
        	:rtype: None
        * Gets items from another graph which have a specific Status
        	:param agraph:
        	:type agraph: Interface_Graph
        	:param stat:
        	:type stat: int
        	:rtype: None
        """
        return _Interface.Interface_Graph_GetFromGraph(self, *args)


    def GetFromIter(self, *args) -> "void":
        """
        * Gets Entities given by an EntityIterator. Entities which were not yet present in the graph are mapped with status 'newstat' Entities already present remain unchanged
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:param newstat:
        	:type newstat: int
        	:rtype: None
        * Gets Entities given by an EntityIterator and distinguishes those already present in the Graph : - new entities added to the Graph with status 'newstst' - entities already present with status = 'newstat' remain unchanged - entities already present with status different form 'newstat' have their status modified : if cumul is True, to former status + overlapstat (cumul) if cumul is False, to overlapstat (enforce) (Note : works as GetEntity, shared = False, for each entity)
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:param newstat:
        	:type newstat: int
        	:param overlapstat:
        	:type overlapstat: int
        	:param cumul:
        	:type cumul: bool
        	:rtype: None
        """
        return _Interface.Interface_Graph_GetFromIter(self, *args)


    def GetFromModel(self, *args) -> "void":
        """
        * Loads Graph with all Entities contained in the Model
        	:rtype: None
        """
        return _Interface.Interface_Graph_GetFromModel(self, *args)


    def GetShareds(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the sequence of Entities Shared by an Entity
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _Interface.Interface_Graph_GetShareds(self, *args)


    def GetSharings(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        * Returns the sequence of Entities Sharings by an Entity
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<TColStd_HSequenceOfTransient>
        """
        return _Interface.Interface_Graph_GetSharings(self, *args)


    def HasShareErrors(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <ent> or the list of entities shared by <ent> (not redefined) contains items unknown from this Graph Remark : apart from the status HasShareError, these items are ignored
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_Graph_HasShareErrors(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty graph, ready to receive Entities from amodel Note that this way of Creation allows <self> to verify that Entities to work with are contained in <amodel> Basic Shared and Sharing lists are obtained from a General Services Library, given directly as an argument
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param lib:
        	:type lib: Interface_GeneralLib
        	:param theModeStats: default value is Standard_True
        	:type theModeStats: bool
        	:rtype: None
        * Same as above, but the Library is defined through a Protocol
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:param theModeStats: default value is Standard_True
        	:type theModeStats: bool
        	:rtype: None
        * Same as above, but the Library is defined through a Protocol
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param gtool:
        	:type gtool: Interface_GTool
        	:param theModeStats: default value is Standard_True
        	:type theModeStats: bool
        	:rtype: None
        * Same a above but works with the Protocol recorded in the Model
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param theModeStats: default value is Standard_True
        	:type theModeStats: bool
        	:rtype: None
        * Creates a Graph from another one, getting all its data Remark that status are copied from <agraph>, but the other lists (sharing/shared) are copied only if <copied> = True
        	:param agraph:
        	:type agraph: Interface_Graph
        	:param copied: default value is Standard_False
        	:type copied: bool
        	:rtype: None
        """
        _Interface.Interface_Graph_swiginit(self, _Interface.new_Interface_Graph(*args))

    def IsPresent(self, *args) -> "Standard_Boolean":
        """
        * Returns True if an Entity is noted as present in the graph (See methods Get... which determine this status) Returns False if <num> is out of range too
        	:param num:
        	:type num: int
        	:rtype: bool
        * Same as above but directly on an Entity <ent> : if it is not contained in the Model, returns False. Else calls IsPresent(num) with <num> given by EntityNumber
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_Graph_IsPresent(self, *args)


    def ModeStat(self, *args) -> "Standard_Boolean":
        """
        * Returns mode resposible for computation of statuses;
        	:rtype: bool
        """
        return _Interface.Interface_Graph_ModeStat(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel > const &":
        """
        * Returns the Model with which this Graph was created
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_Graph_Model(self, *args)


    def Name(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        * Determines the name attached to an entity, by using the general service Name in GeneralModule Returns a null handle if no name could be computed or if the entity is not in the model
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _Interface.Interface_Graph_Name(self, *args)


    def NbStatuses(self, *args) -> "Standard_Integer":
        """
        * Returns size of array of statuses
        	:rtype: int
        """
        return _Interface.Interface_Graph_NbStatuses(self, *args)


    def RemoveItem(self, *args) -> "void":
        """
        * Clears Entity and sets Status to 0, for a numero
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _Interface.Interface_Graph_RemoveItem(self, *args)


    def RemoveStatus(self, *args) -> "void":
        """
        * Removes all items of which status has a given value stat
        	:param stat:
        	:type stat: int
        	:rtype: None
        """
        return _Interface.Interface_Graph_RemoveStatus(self, *args)


    def Reset(self, *args) -> "void":
        """
        * Erases data, making graph ready to rebegin from void (also resets Shared lists redefinitions)
        	:rtype: None
        """
        return _Interface.Interface_Graph_Reset(self, *args)


    def ResetStatus(self, *args) -> "void":
        """
        * Erases Status (Values and Flags of Presence), making graph ready to rebegin from void. Does not concerns Shared lists
        	:rtype: None
        """
        return _Interface.Interface_Graph_ResetStatus(self, *args)


    def RootEntities(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the Entities which are not Shared (their Sharing List is empty) in the Model
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_Graph_RootEntities(self, *args)


    def SetStatus(self, *args) -> "void":
        """
        * Modifies Status associated to a numero
        	:param num:
        	:type num: int
        	:param stat:
        	:type stat: int
        	:rtype: None
        """
        return _Interface.Interface_Graph_SetStatus(self, *args)


    def Shareds(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of Entities Shared by an Entity, as recorded by the Graph. That is, by default Basic Shared List, else it can be redefined by methods SetShare, SetNoShare ... see below
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_Graph_Shareds(self, *args)


    def SharingTable(self, *args) -> "opencascade::handle< TColStd_HArray1OfListOfInteger > const &":
        """
        * Returns the Table of Sharing lists. Used to Create another Graph from <self>
        	:rtype: opencascade::handle<TColStd_HArray1OfListOfInteger>
        """
        return _Interface.Interface_Graph_SharingTable(self, *args)


    def Sharings(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of Entities which Share an Entity, computed from the Basic or Redefined Shared Lists
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_Graph_Sharings(self, *args)


    def Size(self, *args) -> "Standard_Integer":
        """
        * Returns size (max nb of entities, i.e. Model's nb of entities)
        	:rtype: int
        """
        return _Interface.Interface_Graph_Size(self, *args)


    def Status(self, *args) -> "Standard_Integer":
        """
        * Returns Status associated to a numero (only to read it)
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _Interface.Interface_Graph_Status(self, *args)


    def TypedSharings(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of sharings entities, AT ANY LEVEL, which are kind of a given type. A sharing entity kind of this type ends the exploration of its branch
        	:param ent:
        	:type ent: Standard_Transient
        	:param type:
        	:type type: Standard_Type
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_Graph_TypedSharings(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Graph
Interface_Graph.BitMap = new_instancemethod(_Interface.Interface_Graph_BitMap, None, Interface_Graph)
Interface_Graph.CBitMap = new_instancemethod(_Interface.Interface_Graph_CBitMap, None, Interface_Graph)
Interface_Graph.ChangeStatus = new_instancemethod(_Interface.Interface_Graph_ChangeStatus, None, Interface_Graph)
Interface_Graph.Entity = new_instancemethod(_Interface.Interface_Graph_Entity, None, Interface_Graph)
Interface_Graph.EntityNumber = new_instancemethod(_Interface.Interface_Graph_EntityNumber, None, Interface_Graph)
Interface_Graph.GetFromEntity = new_instancemethod(_Interface.Interface_Graph_GetFromEntity, None, Interface_Graph)
Interface_Graph.GetFromGraph = new_instancemethod(_Interface.Interface_Graph_GetFromGraph, None, Interface_Graph)
Interface_Graph.GetFromIter = new_instancemethod(_Interface.Interface_Graph_GetFromIter, None, Interface_Graph)
Interface_Graph.GetFromModel = new_instancemethod(_Interface.Interface_Graph_GetFromModel, None, Interface_Graph)
Interface_Graph.GetShareds = new_instancemethod(_Interface.Interface_Graph_GetShareds, None, Interface_Graph)
Interface_Graph.GetSharings = new_instancemethod(_Interface.Interface_Graph_GetSharings, None, Interface_Graph)
Interface_Graph.HasShareErrors = new_instancemethod(_Interface.Interface_Graph_HasShareErrors, None, Interface_Graph)
Interface_Graph.IsPresent = new_instancemethod(_Interface.Interface_Graph_IsPresent, None, Interface_Graph)
Interface_Graph.ModeStat = new_instancemethod(_Interface.Interface_Graph_ModeStat, None, Interface_Graph)
Interface_Graph.Model = new_instancemethod(_Interface.Interface_Graph_Model, None, Interface_Graph)
Interface_Graph.Name = new_instancemethod(_Interface.Interface_Graph_Name, None, Interface_Graph)
Interface_Graph.NbStatuses = new_instancemethod(_Interface.Interface_Graph_NbStatuses, None, Interface_Graph)
Interface_Graph.RemoveItem = new_instancemethod(_Interface.Interface_Graph_RemoveItem, None, Interface_Graph)
Interface_Graph.RemoveStatus = new_instancemethod(_Interface.Interface_Graph_RemoveStatus, None, Interface_Graph)
Interface_Graph.Reset = new_instancemethod(_Interface.Interface_Graph_Reset, None, Interface_Graph)
Interface_Graph.ResetStatus = new_instancemethod(_Interface.Interface_Graph_ResetStatus, None, Interface_Graph)
Interface_Graph.RootEntities = new_instancemethod(_Interface.Interface_Graph_RootEntities, None, Interface_Graph)
Interface_Graph.SetStatus = new_instancemethod(_Interface.Interface_Graph_SetStatus, None, Interface_Graph)
Interface_Graph.Shareds = new_instancemethod(_Interface.Interface_Graph_Shareds, None, Interface_Graph)
Interface_Graph.SharingTable = new_instancemethod(_Interface.Interface_Graph_SharingTable, None, Interface_Graph)
Interface_Graph.Sharings = new_instancemethod(_Interface.Interface_Graph_Sharings, None, Interface_Graph)
Interface_Graph.Size = new_instancemethod(_Interface.Interface_Graph_Size, None, Interface_Graph)
Interface_Graph.Status = new_instancemethod(_Interface.Interface_Graph_Status, None, Interface_Graph)
Interface_Graph.TypedSharings = new_instancemethod(_Interface.Interface_Graph_TypedSharings, None, Interface_Graph)
Interface_Graph_swigregister = _Interface.Interface_Graph_swigregister
Interface_Graph_swigregister(Interface_Graph)

class Interface_HGraph(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CGraph(self, *args) -> "Interface_Graph &":
        """
        * Same as above, but for Read-Write Operations Then, The Graph will be modified in the HGraph itself
        	:rtype: Interface_Graph
        """
        return _Interface.Interface_HGraph_CGraph(self, *args)


    def Graph(self, *args) -> "Interface_Graph const &":
        """
        * Returns the Graph contained in <self>, for Read Only Operations Remark that it is returns as 'const &' Getting it in a new variable instead of a reference would be a pitty, because all the graph's content would be duplicated
        	:rtype: Interface_Graph
        """
        return _Interface.Interface_HGraph_Graph(self, *args)


    def __init__(self, *args):
        """
        * Creates an HGraph directly from a Graph. Remark that the starting Graph is duplicated
        	:param agraph:
        	:type agraph: Interface_Graph
        	:rtype: None
        * Creates an HGraph with a Graph created from <amodel> and <lib>
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param lib:
        	:type lib: Interface_GeneralLib
        	:param theModeStats: default value is Standard_True
        	:type theModeStats: bool
        	:rtype: None
        * Creates an HGraph with a graph itself created from <amodel> and <protocol>
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:param theModeStats: default value is Standard_True
        	:type theModeStats: bool
        	:rtype: None
        * Creates an HGraph with a graph itself created from <amodel> and <protocol>
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param gtool:
        	:type gtool: Interface_GTool
        	:param theModeStats: default value is Standard_True
        	:type theModeStats: bool
        	:rtype: None
        * Same a above, but works with the GTool in the model
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param theModeStats: default value is Standard_True
        	:type theModeStats: bool
        	:rtype: None
        """
        _Interface.Interface_HGraph_swiginit(self, _Interface.new_Interface_HGraph(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Interface_HGraph_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_HGraph
Interface_HGraph.CGraph = new_instancemethod(_Interface.Interface_HGraph_CGraph, None, Interface_HGraph)
Interface_HGraph.Graph = new_instancemethod(_Interface.Interface_HGraph_Graph, None, Interface_HGraph)
Interface_HGraph_swigregister = _Interface.Interface_HGraph_swigregister
Interface_HGraph_swigregister(Interface_HGraph)

class Interface_IntList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a reference (as an integer value, an entity number) to the current entity number. Zero is ignored
        	:param ref:
        	:type ref: int
        	:rtype: None
        """
        return _Interface.Interface_IntList_Add(self, *args)


    def AdjustSize(self, *args) -> "void":
        """
        * Resizes lists to exact sizes. For list of refs, a positive margin can be added.
        	:param margin: default value is 0
        	:type margin: int
        	:rtype: None
        """
        return _Interface.Interface_IntList_AdjustSize(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears all data, hence each entity number has an empty list
        	:rtype: None
        """
        return _Interface.Interface_IntList_Clear(self, *args)


    def Initialize(self, *args) -> "void":
        """
        * Initialize IntList by number of entities.
        	:param nbe:
        	:type nbe: int
        	:rtype: None
        """
        return _Interface.Interface_IntList_Initialize(self, *args)


    def __init__(self, *args):
        """
        * Creates empty IntList.
        	:rtype: None
        * Creates an IntList for <nbe> entities
        	:param nbe:
        	:type nbe: int
        	:rtype: None
        * Creates an IntList from another one. if <copied> is True, copies data else, data are not copied, only the header object is
        	:param other:
        	:type other: Interface_IntList
        	:param copied:
        	:type copied: bool
        	:rtype: None
        """
        _Interface.Interface_IntList_swiginit(self, _Interface.new_Interface_IntList(*args))

    def Internals(self, *args) -> "void":
        """
        * Returns internal values, used for copying
        	:param nbrefs:
        	:type nbrefs: int
        	:param ents:
        	:type ents: TColStd_HArray1OfInteger
        	:param refs:
        	:type refs: TColStd_HArray1OfInteger
        	:rtype: None
        """
        return _Interface.Interface_IntList_Internals(self, *args)


    def IsRedefined(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the list for a number (default is taken as current) is 'redefined' (usefull for empty list)
        	:param num: default value is 0
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_IntList_IsRedefined(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        * Returns the count of refs attached to current entity number
        	:rtype: int
        """
        return _Interface.Interface_IntList_Length(self, *args)


    def List(self, *args) -> "Interface_IntList":
        """
        * Returns an IntList, identical to <self> but set to a specified entity Number By default, not copied (in order to be read) Specified <copied> to produce another list and edit it
        	:param number:
        	:type number: int
        	:param copied: default value is Standard_False
        	:type copied: bool
        	:rtype: Interface_IntList
        """
        return _Interface.Interface_IntList_List(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        * Returns count of entities to be aknowledged
        	:rtype: int
        """
        return _Interface.Interface_IntList_NbEntities(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        * Returns the current entity number
        	:rtype: int
        """
        return _Interface.Interface_IntList_Number(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        * Removes an item in the list for current number, given its rank Returns True if done, False else
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_IntList_Remove(self, *args)


    def Reservate(self, *args) -> "void":
        """
        * Makes a reservation for <count> references to be later attached to the current entity. If required, it increases the size of array used to store refs. Remark that if count is less than two, it does nothing (because immediate storing)
        	:param count:
        	:type count: int
        	:rtype: None
        """
        return _Interface.Interface_IntList_Reservate(self, *args)


    def SetNbEntities(self, *args) -> "void":
        """
        * Changes the count of entities (ignored if decreased)
        	:param nbe:
        	:type nbe: int
        	:rtype: None
        """
        return _Interface.Interface_IntList_SetNbEntities(self, *args)


    def SetNumber(self, *args) -> "void":
        """
        * Sets an entity number as current (for read and fill)
        	:param number:
        	:type number: int
        	:rtype: None
        """
        return _Interface.Interface_IntList_SetNumber(self, *args)


    def SetRedefined(self, *args) -> "void":
        """
        * Sets current entity list to be redefined or not This is used in a Graph for redefinition list : it can be disable (no redefinition, i.e. list is cleared), or enabled (starts as empty). The original list has not to be 'redefined'
        	:param mode:
        	:type mode: bool
        	:rtype: None
        """
        return _Interface.Interface_IntList_SetRedefined(self, *args)


    def Value(self, *args) -> "Standard_Integer":
        """
        * Returns a reference number in the list for current number, according to its rank
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _Interface.Interface_IntList_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_IntList
Interface_IntList.Add = new_instancemethod(_Interface.Interface_IntList_Add, None, Interface_IntList)
Interface_IntList.AdjustSize = new_instancemethod(_Interface.Interface_IntList_AdjustSize, None, Interface_IntList)
Interface_IntList.Clear = new_instancemethod(_Interface.Interface_IntList_Clear, None, Interface_IntList)
Interface_IntList.Initialize = new_instancemethod(_Interface.Interface_IntList_Initialize, None, Interface_IntList)
Interface_IntList.Internals = new_instancemethod(_Interface.Interface_IntList_Internals, None, Interface_IntList)
Interface_IntList.IsRedefined = new_instancemethod(_Interface.Interface_IntList_IsRedefined, None, Interface_IntList)
Interface_IntList.Length = new_instancemethod(_Interface.Interface_IntList_Length, None, Interface_IntList)
Interface_IntList.List = new_instancemethod(_Interface.Interface_IntList_List, None, Interface_IntList)
Interface_IntList.NbEntities = new_instancemethod(_Interface.Interface_IntList_NbEntities, None, Interface_IntList)
Interface_IntList.Number = new_instancemethod(_Interface.Interface_IntList_Number, None, Interface_IntList)
Interface_IntList.Remove = new_instancemethod(_Interface.Interface_IntList_Remove, None, Interface_IntList)
Interface_IntList.Reservate = new_instancemethod(_Interface.Interface_IntList_Reservate, None, Interface_IntList)
Interface_IntList.SetNbEntities = new_instancemethod(_Interface.Interface_IntList_SetNbEntities, None, Interface_IntList)
Interface_IntList.SetNumber = new_instancemethod(_Interface.Interface_IntList_SetNumber, None, Interface_IntList)
Interface_IntList.SetRedefined = new_instancemethod(_Interface.Interface_IntList_SetRedefined, None, Interface_IntList)
Interface_IntList.Value = new_instancemethod(_Interface.Interface_IntList_Value, None, Interface_IntList)
Interface_IntList_swigregister = _Interface.Interface_IntList_swigregister
Interface_IntList_swigregister(Interface_IntList)

class Interface_IntVal(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetCValue(self) -> "Standard_Integer":
        """GetCValue(Interface_IntVal self) -> Standard_Integer"""
        return _Interface.Interface_IntVal_GetCValue(self)


    def SetCValue(self, value: 'Standard_Integer') -> "void":
        """SetCValue(Interface_IntVal self, Standard_Integer value)"""
        return _Interface.Interface_IntVal_SetCValue(self, value)


    def __init__(self, *args):
        """:rtype: None"""
        _Interface.Interface_IntVal_swiginit(self, _Interface.new_Interface_IntVal(*args))

    def Value(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _Interface.Interface_IntVal_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_IntVal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_IntVal
Interface_IntVal.GetCValue = new_instancemethod(_Interface.Interface_IntVal_GetCValue, None, Interface_IntVal)
Interface_IntVal.SetCValue = new_instancemethod(_Interface.Interface_IntVal_SetCValue, None, Interface_IntVal)
Interface_IntVal.Value = new_instancemethod(_Interface.Interface_IntVal_Value, None, Interface_IntVal)
Interface_IntVal_swigregister = _Interface.Interface_IntVal_swigregister
Interface_IntVal_swigregister(Interface_IntVal)

class Interface_InterfaceModel(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddEntity(self, *args) -> "void":
        """
        * Internal method for adding an Entity. Used by file reading (defined by each Interface) and Transfer tools. It adds the entity required to be added, not its refs : see AddWithRefs. If <anentity> is a ReportEntity, it is added to the list of Reports, its Concerned Entity (Erroneous or Corrected, else Unknown) is added to the list of Entities. That is, the ReportEntity must be created before Adding
        	:param anentity:
        	:type anentity: Standard_Transient
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_AddEntity(self, *args)


    def AddReportEntity(self, *args) -> "Standard_Boolean":
        """
        * Adds a ReportEntity as such. Returns False if the concerned entity is not recorded in the Model Else, adds it into, either the main report list or the list for semantic checks, then returns True
        	:param rep:
        	:type rep: Interface_ReportEntity
        	:param semantic: default value is Standard_False
        	:type semantic: bool
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_AddReportEntity(self, *args)


    def AddWithRefs(self, *args) -> "void":
        """
        * Adds to the Model, an Entity with all its References, as they are defined by General Services FillShared and ListImplied. Process is recursive (any sub-levels) if <level> = 0 (Default) Else, adds sub-entities until the required sub-level. Especially, if <level> = 1, adds immediate subs and that's all //! If <listall> is False (Default), an entity (<anentity> itself or one of its subs at any level) which is already recorded in the Model is not analysed, only the newly added ones are. If <listall> is True, all items are analysed (this allows to ensure the consistency of an adding made by steps)
        	:param anent:
        	:type anent: Standard_Transient
        	:param proto:
        	:type proto: Interface_Protocol
        	:param level: default value is 0
        	:type level: int
        	:param listall: default value is Standard_False
        	:type listall: bool
        	:rtype: None
        * Same as above, but works with the Protocol of the Model
        	:param anent:
        	:type anent: Standard_Transient
        	:param level: default value is 0
        	:type level: int
        	:param listall: default value is Standard_False
        	:type listall: bool
        	:rtype: None
        * Same as above, but works with an already created GeneralLib
        	:param anent:
        	:type anent: Standard_Transient
        	:param lib:
        	:type lib: Interface_GeneralLib
        	:param level: default value is 0
        	:type level: int
        	:param listall: default value is Standard_False
        	:type listall: bool
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_AddWithRefs(self, *args)


    def CategoryNumber(self, *args) -> "Standard_Integer":
        """
        * Returns the recorded category number for a given entity number 0 if none was defined for this entity
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _Interface.Interface_InterfaceModel_CategoryNumber(self, *args)


    def ChangeOrder(self, *args) -> "void":
        """
        * Changes the Numbers of some Entities : <oldnum> is moved to <newnum>, same for <count> entities. Thus : 1,2 ... newnum-1 newnum ... oldnum .. oldnum+count oldnum+count+1 .. gives 1,2 ... newnum-1 oldnum .. oldnum+count newnum ... oldnum+count+1 (can be seen as a circular permutation)
        	:param oldnum:
        	:type oldnum: int
        	:param newnum:
        	:type newnum: int
        	:param count: default value is 1
        	:type count: int
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_ChangeOrder(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        * Returns the check attached to an entity, designated by its Number. 0 for global check <semantic> True : recorded semantic check <semantic> False : recorded syntactic check (see ReportEntity) If no check is recorded for <num>, returns an empty Check
        	:param num:
        	:type num: int
        	:param syntactic:
        	:type syntactic: bool
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Interface.Interface_InterfaceModel_Check(self, *args)


    def ClassName(*args) -> "char const *":
        """
        * From a CDL Type Name, returns the Class part (package dropped) WARNING : buffered, to be immediately copied or printed
        	:param typnam:
        	:type typnam: char *
        	:rtype: char *
        """
        return _Interface.Interface_InterfaceModel_ClassName(*args)

    ClassName = staticmethod(ClassName)

    def Clear(self, *args) -> "void":
        """
        * Erases contained data; used when a Model is copied to others : the new copied ones begin from clear Clear calls specific method ClearHeader (see below)
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_Clear(self, *args)


    def ClearEntities(self, *args) -> "void":
        """
        * Clears the entities; uses the general service WhenDelete, in addition to the standard Memory Manager; can be redefined
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_ClearEntities(self, *args)


    def ClearHeader(self, *args) -> "void":
        """
        * Clears Model's header : specific to each norm
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_ClearHeader(self, *args)


    def ClearLabels(self, *args) -> "void":
        """
        * Erases informations about labels, if any : specific to each norm
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_ClearLabels(self, *args)


    def ClearReportEntity(self, *args) -> "Standard_Boolean":
        """
        * Removes the ReportEntity attached to Entity <num>. Returns True if done, False if no ReportEntity was attached to <num>. Warning : the caller must assume that this clearing is meaningfull
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_ClearReportEntity(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a Model contains an Entity (for a ReportEntity, looks for the ReportEntity itself AND its Concerned Entity)
        	:param anentity:
        	:type anentity: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_Contains(self, *args)


    def Destroy(self, *args) -> "void":
        """
        * Clears the list of entities (service WhenDelete)
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_Destroy(self, *args)


    def GetDispatchStatus(self) -> "Standard_Boolean":
        """GetDispatchStatus(Interface_InterfaceModel self) -> Standard_Boolean"""
        return _Interface.Interface_InterfaceModel_GetDispatchStatus(self)


    def SetDispatchStatus(self, value: 'Standard_Boolean') -> "void":
        """SetDispatchStatus(Interface_InterfaceModel self, Standard_Boolean value)"""
        return _Interface.Interface_InterfaceModel_SetDispatchStatus(self, value)


    def DumpHeader(self, *args) -> "void":
        """
        * Dumps Header in a short, easy to read, form, onto a Stream <level> allows to print more or less parts of the header, if necessary. 0 for basic print
        	:param S:
        	:type S: Message_Messenger
        	:param level: default value is 0
        	:type level: int
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_DumpHeader(self, *args)


    def Entities(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of all Entities, as an Iterator on Entities (the Entities themselves, not the Reports)
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_InterfaceModel_Entities(self, *args)


    def EntityState(self, *args) -> "Interface_DataState":
        """
        * Returns the State of an entity, given its number
        	:param num:
        	:type num: int
        	:rtype: Interface_DataState
        """
        return _Interface.Interface_InterfaceModel_EntityState(self, *args)


    def FillIterator(self, *args) -> "void":
        """
        * Allows an EntityIterator to get a list of Entities
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_FillIterator(self, *args)


    def FillSemanticChecks(self, *args) -> "void":
        """
        * Fills the list of semantic checks. This list is computed (by CheckTool). Hence, it can be stored in the model for later queries <clear> True (D) : new list replaces <clear> False : new list is cumulated
        	:param checks:
        	:type checks: Interface_CheckIterator
        	:param clear: default value is Standard_True
        	:type clear: bool
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_FillSemanticChecks(self, *args)


    def GTool(self, *args) -> "opencascade::handle< Interface_GTool >":
        """
        * Returns the GTool, set by SetProtocol or by SetGTool
        	:rtype: opencascade::handle<Interface_GTool>
        """
        return _Interface.Interface_InterfaceModel_GTool(self, *args)


    def GetFromAnother(self, *args) -> "void":
        """
        * Gets header (data specific of a defined Interface) from another InterfaceModel; called from TransferCopy
        	:param other:
        	:type other: Interface_InterfaceModel
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_GetFromAnother(self, *args)


    def GetFromTransfer(self, *args) -> "void":
        """
        * Gets contents from an EntityIterator, prepared by a Transfer tool (e.g TransferCopy). Starts from clear
        	:param aniter:
        	:type aniter: Interface_EntityIterator
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_GetFromTransfer(self, *args)


    def GlobalCheck(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        * Returns the GlobalCheck, which memorizes messages global to the file (not specific to an Entity), especially Header
        	:param syntactic: default value is Standard_True
        	:type syntactic: bool
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Interface.Interface_InterfaceModel_GlobalCheck(self, *args)


    def HasSemanticChecks(self, *args) -> "Standard_Boolean":
        """
        * Returns True if semantic checks have been filled
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_HasSemanticChecks(self, *args)


    def HasTemplate(*args) -> "Standard_Boolean":
        """
        * Returns true if a template is attached to a given name
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_HasTemplate(*args)

    HasTemplate = staticmethod(HasTemplate)

    def IsErrorEntity(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <num> identifies an Error Entity : in this case, a ReportEntity brings Fail Messages and possibly an 'undefined' Content, see IsRedefinedEntity
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_IsErrorEntity(self, *args)


    def IsRedefinedContent(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <num> identifies an Entity which content is redefined through a ReportEntity (i.e. with literal data only) This happens when an entity is syntactically erroneous in the way that its basic content remains empty. For more details (such as content itself), see ReportEntity
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_IsRedefinedContent(self, *args)


    def IsReportEntity(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <num> identifies a ReportEntity in the Model Hence, ReportEntity can be called. //! By default, queries main report, if <semantic> is True, it queries report for semantic check //! Remember that a Report Entity can be defined for an Unknown Entity, or a Corrected or Erroneous (at read time) Entity. The ReportEntity is defined before call to method AddEntity.
        	:param num:
        	:type num: int
        	:param semantic: default value is Standard_False
        	:type semantic: bool
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_IsReportEntity(self, *args)


    def IsUnknownEntity(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <num> identifies an Unknown Entity : in this case, a ReportEntity with no Check Messages designates it.
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_IsUnknownEntity(self, *args)


    def ListTemplates(*args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        * Returns the complete list of names attached to template models
        	:rtype: opencascade::handle<TColStd_HSequenceOfHAsciiString>
        """
        return _Interface.Interface_InterfaceModel_ListTemplates(*args)

    ListTemplates = staticmethod(ListTemplates)

    def NbEntities(self, *args) -> "Standard_Integer":
        """
        * Returns count of contained Entities
        	:rtype: int
        """
        return _Interface.Interface_InterfaceModel_NbEntities(self, *args)


    def NbTypes(self, *args) -> "Standard_Integer":
        """
        * Returns the count of DISTINCT types under which an entity may be processed. Defined by the Protocol, which gives default as 1 (dynamic Type).
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: int
        """
        return _Interface.Interface_InterfaceModel_NbTypes(self, *args)


    def NewEmptyModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns a New Empty Model, same type as <self> (whatever its Type); called to Copy parts a Model into other ones, then followed by a call to GetFromAnother (Header) then filling with specified Entities, themselves copied
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_InterfaceModel_NewEmptyModel(self, *args)


    def NextNumberForLabel(self, *args) -> "Standard_Integer":
        """
        * Searches a label which matches with one entity. Begins from <lastnum>+1 (default:1) and scans the entities until <NbEntities>. For the first which matches <label>, this method returns its Number. Returns 0 if nothing found Can be called recursively (labels are not specified as unique) <exact> : if True (default), exact match is required else, checks the END of entity label //! This method is virtual, hence it can be redefined for a more efficient search (if exact is true).
        	:param label:
        	:type label: char *
        	:param lastnum: default value is 0
        	:type lastnum: int
        	:param exact: default value is Standard_True
        	:type exact: bool
        	:rtype: int
        """
        return _Interface.Interface_InterfaceModel_NextNumberForLabel(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        * Returns the Number of an Entity in the Model if it contains it. Else returns 0. For a ReportEntity, looks at Concerned Entity. Returns the Directory entry Number of an Entity in the Model if it contains it. Else returns 0. For a ReportEntity, looks at Concerned Entity.
        	:param anentity:
        	:type anentity: Standard_Transient
        	:rtype: int
        """
        return _Interface.Interface_InterfaceModel_Number(self, *args)


    def Print(self, *args) -> "void":
        """
        * Prints identification of a given entity in <self>, in order to be printed in a list or phrase <mode> < 0 : prints only its number <mode> = 1 : just calls PrintLabel <mode> = 0 (D) : prints its number plus '/' plus PrintLabel If <ent> == <self>, simply prints 'Global' If <ent> is unknown, prints '/its type'
        	:param ent:
        	:type ent: Standard_Transient
        	:param s:
        	:type s: Message_Messenger
        	:param mode: default value is 0
        	:type mode: int
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_Print(self, *args)


    def PrintLabel(self, *args) -> "void":
        """
        * Prints label specific to each norm, for a given entity. Must only print label itself, in order to be included in a phrase. Can call the result of StringLabel, but not obliged.
        	:param ent:
        	:type ent: Standard_Transient
        	:param S:
        	:type S: Message_Messenger
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_PrintLabel(self, *args)


    def PrintToLog(self, *args) -> "void":
        """
        * Prints label specific to each norm in log format, for a given entity. By default, just calls PrintLabel, can be redefined
        	:param ent:
        	:type ent: Standard_Transient
        	:param S:
        	:type S: Message_Messenger
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_PrintToLog(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        * Returns the Protocol which has been set by SetProtocol, or AddWithRefs with Protocol
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_InterfaceModel_Protocol(self, *args)


    def Redefineds(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of ReportEntities which redefine data (generally, if concerned entity is 'Error', a literal content is added to it : this is a 'redefined entity'
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_InterfaceModel_Redefineds(self, *args)


    def ReplaceEntity(self, *args) -> "void":
        """
        * Replace Entity with Number=nument on other entity - 'anent'
        	:param nument:
        	:type nument: int
        	:param anent:
        	:type anent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_ReplaceEntity(self, *args)


    def ReportEntity(self, *args) -> "opencascade::handle< Interface_ReportEntity >":
        """
        * Returns a ReportEntity identified by its number in the Model, or a Null Handle If <num> does not identify a ReportEntity. //! By default, queries main report, if <semantic> is True, it queries report for semantic check
        	:param num:
        	:type num: int
        	:param semantic: default value is Standard_False
        	:type semantic: bool
        	:rtype: opencascade::handle<Interface_ReportEntity>
        """
        return _Interface.Interface_InterfaceModel_ReportEntity(self, *args)


    def Reports(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the list of all ReportEntities, i.e. data about Entities read with Error or Warning informations (each item has to be casted to Report Entity then it can be queried for Concerned Entity, Content, Check ...) By default, returns the main reports, is <semantic> is True it returns the list for sematic checks
        	:param semantic: default value is Standard_False
        	:type semantic: bool
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_InterfaceModel_Reports(self, *args)


    def Reservate(self, *args) -> "void":
        """
        * Does a reservation for the List of Entities (for optimized storage management). If it is not called, storage management can be less efficient. <nbent> is the expected count of Entities to store
        	:param nbent:
        	:type nbent: int
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_Reservate(self, *args)


    def ReverseOrders(self, *args) -> "void":
        """
        * Reverses the Numbers of the Entities, between <after> and the total count of Entities. Thus, the entities : 1,2 ... after, after+1 ... nb-1, nb become numbered as : 1,2 ... after, nb, nb-1 ... after+1 By default (after = 0) the whole list of Entities is reversed
        	:param after: default value is 0
        	:type after: int
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_ReverseOrders(self, *args)


    def SetCategoryNumber(self, *args) -> "Standard_Boolean":
        """
        * Records a category number for an entity number Returns True when done, False if <num> is out of range
        	:param num:
        	:type num: int
        	:param val:
        	:type val: int
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_SetCategoryNumber(self, *args)


    def SetGTool(self, *args) -> "void":
        """
        * Sets a GTool for this model, which already defines a Protocol
        	:param gtool:
        	:type gtool: Interface_GTool
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_SetGTool(self, *args)


    def SetGlobalCheck(self, *args) -> "void":
        """
        * Allows to modify GlobalCheck, after getting then completing it Remark : it is SYNTACTIC check. Semantics, see FillChecks
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_SetGlobalCheck(self, *args)


    def SetProtocol(self, *args) -> "void":
        """
        * Sets a Protocol for this Model It is also set by a call to AddWithRefs with Protocol It is used for : DumpHeader (as required), ClearEntities ...
        	:param proto:
        	:type proto: Interface_Protocol
        	:rtype: None
        """
        return _Interface.Interface_InterfaceModel_SetProtocol(self, *args)


    def SetReportEntity(self, *args) -> "Standard_Boolean":
        """
        * Sets or Replaces a ReportEntity for the Entity <num>. Returns True if Report is replaced, False if it has been replaced Warning : the caller must assume that this setting is meaningfull
        	:param num:
        	:type num: int
        	:param rep:
        	:type rep: Interface_ReportEntity
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_SetReportEntity(self, *args)


    def SetTemplate(*args) -> "Standard_Boolean":
        """
        * Records a new template model with a name. If the name was already recorded, the corresponding template is replaced by the new one. Then, WARNING : test HasTemplate to avoid surprises
        	:param name:
        	:type name: char *
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: bool
        """
        return _Interface.Interface_InterfaceModel_SetTemplate(*args)

    SetTemplate = staticmethod(SetTemplate)

    def StringLabel(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        * Returns a string with the label attached to a given entity. Warning : While this string may be edited on the spot, if it is a read field, the returned value must be copied before.
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _Interface.Interface_InterfaceModel_StringLabel(self, *args)


    def Template(*args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the template model attached to a name, or a Null Handle
        	:param name:
        	:type name: char *
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_InterfaceModel_Template(*args)

    Template = staticmethod(Template)

    def Type(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns a type, given its rank : defined by the Protocol (by default, the first one)
        	:param ent:
        	:type ent: Standard_Transient
        	:param num: default value is 1
        	:type num: int
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _Interface.Interface_InterfaceModel_Type(self, *args)


    def TypeName(self, *args) -> "char const *":
        """
        * Returns the type name of an entity, from the list of types (one or more ...) <complete> True (D) gives the complete type, else packages are removed WARNING : buffered, to be immediately copied or printed
        	:param ent:
        	:type ent: Standard_Transient
        	:param complete: default value is Standard_True
        	:type complete: bool
        	:rtype: char *
        """
        return _Interface.Interface_InterfaceModel_TypeName(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns an Entity identified by its number in the Model Each sub-class of InterfaceModel can define its own method Entity to return its specific class of Entity (e.g. for VDA, VDAModel returns a VDAEntity), working by calling Value Remark : For a Reported Entity, (Erroneous, Corrected, Unknown), this method returns this Reported Entity. See ReportEntity for other questions.
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_InterfaceModel_Value(self, *args)


    def VerifyCheck(self, *args) -> "void":
        """
        * Minimum Semantic Global Check on data in model (header) Can only check basic Data. See also GlobalCheck from Protocol for a check which takes the Graph into account Default does nothing, can be redefined
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: void
        """
        return _Interface.Interface_InterfaceModel_VerifyCheck(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_InterfaceModel_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_InterfaceModel
Interface_InterfaceModel.AddEntity = new_instancemethod(_Interface.Interface_InterfaceModel_AddEntity, None, Interface_InterfaceModel)
Interface_InterfaceModel.AddReportEntity = new_instancemethod(_Interface.Interface_InterfaceModel_AddReportEntity, None, Interface_InterfaceModel)
Interface_InterfaceModel.AddWithRefs = new_instancemethod(_Interface.Interface_InterfaceModel_AddWithRefs, None, Interface_InterfaceModel)
Interface_InterfaceModel.CategoryNumber = new_instancemethod(_Interface.Interface_InterfaceModel_CategoryNumber, None, Interface_InterfaceModel)
Interface_InterfaceModel.ChangeOrder = new_instancemethod(_Interface.Interface_InterfaceModel_ChangeOrder, None, Interface_InterfaceModel)
Interface_InterfaceModel.Check = new_instancemethod(_Interface.Interface_InterfaceModel_Check, None, Interface_InterfaceModel)
Interface_InterfaceModel.Clear = new_instancemethod(_Interface.Interface_InterfaceModel_Clear, None, Interface_InterfaceModel)
Interface_InterfaceModel.ClearEntities = new_instancemethod(_Interface.Interface_InterfaceModel_ClearEntities, None, Interface_InterfaceModel)
Interface_InterfaceModel.ClearHeader = new_instancemethod(_Interface.Interface_InterfaceModel_ClearHeader, None, Interface_InterfaceModel)
Interface_InterfaceModel.ClearLabels = new_instancemethod(_Interface.Interface_InterfaceModel_ClearLabels, None, Interface_InterfaceModel)
Interface_InterfaceModel.ClearReportEntity = new_instancemethod(_Interface.Interface_InterfaceModel_ClearReportEntity, None, Interface_InterfaceModel)
Interface_InterfaceModel.Contains = new_instancemethod(_Interface.Interface_InterfaceModel_Contains, None, Interface_InterfaceModel)
Interface_InterfaceModel.Destroy = new_instancemethod(_Interface.Interface_InterfaceModel_Destroy, None, Interface_InterfaceModel)
Interface_InterfaceModel.GetDispatchStatus = new_instancemethod(_Interface.Interface_InterfaceModel_GetDispatchStatus, None, Interface_InterfaceModel)
Interface_InterfaceModel.SetDispatchStatus = new_instancemethod(_Interface.Interface_InterfaceModel_SetDispatchStatus, None, Interface_InterfaceModel)
Interface_InterfaceModel.DumpHeader = new_instancemethod(_Interface.Interface_InterfaceModel_DumpHeader, None, Interface_InterfaceModel)
Interface_InterfaceModel.Entities = new_instancemethod(_Interface.Interface_InterfaceModel_Entities, None, Interface_InterfaceModel)
Interface_InterfaceModel.EntityState = new_instancemethod(_Interface.Interface_InterfaceModel_EntityState, None, Interface_InterfaceModel)
Interface_InterfaceModel.FillIterator = new_instancemethod(_Interface.Interface_InterfaceModel_FillIterator, None, Interface_InterfaceModel)
Interface_InterfaceModel.FillSemanticChecks = new_instancemethod(_Interface.Interface_InterfaceModel_FillSemanticChecks, None, Interface_InterfaceModel)
Interface_InterfaceModel.GTool = new_instancemethod(_Interface.Interface_InterfaceModel_GTool, None, Interface_InterfaceModel)
Interface_InterfaceModel.GetFromAnother = new_instancemethod(_Interface.Interface_InterfaceModel_GetFromAnother, None, Interface_InterfaceModel)
Interface_InterfaceModel.GetFromTransfer = new_instancemethod(_Interface.Interface_InterfaceModel_GetFromTransfer, None, Interface_InterfaceModel)
Interface_InterfaceModel.GlobalCheck = new_instancemethod(_Interface.Interface_InterfaceModel_GlobalCheck, None, Interface_InterfaceModel)
Interface_InterfaceModel.HasSemanticChecks = new_instancemethod(_Interface.Interface_InterfaceModel_HasSemanticChecks, None, Interface_InterfaceModel)
Interface_InterfaceModel.IsErrorEntity = new_instancemethod(_Interface.Interface_InterfaceModel_IsErrorEntity, None, Interface_InterfaceModel)
Interface_InterfaceModel.IsRedefinedContent = new_instancemethod(_Interface.Interface_InterfaceModel_IsRedefinedContent, None, Interface_InterfaceModel)
Interface_InterfaceModel.IsReportEntity = new_instancemethod(_Interface.Interface_InterfaceModel_IsReportEntity, None, Interface_InterfaceModel)
Interface_InterfaceModel.IsUnknownEntity = new_instancemethod(_Interface.Interface_InterfaceModel_IsUnknownEntity, None, Interface_InterfaceModel)
Interface_InterfaceModel.NbEntities = new_instancemethod(_Interface.Interface_InterfaceModel_NbEntities, None, Interface_InterfaceModel)
Interface_InterfaceModel.NbTypes = new_instancemethod(_Interface.Interface_InterfaceModel_NbTypes, None, Interface_InterfaceModel)
Interface_InterfaceModel.NewEmptyModel = new_instancemethod(_Interface.Interface_InterfaceModel_NewEmptyModel, None, Interface_InterfaceModel)
Interface_InterfaceModel.NextNumberForLabel = new_instancemethod(_Interface.Interface_InterfaceModel_NextNumberForLabel, None, Interface_InterfaceModel)
Interface_InterfaceModel.Number = new_instancemethod(_Interface.Interface_InterfaceModel_Number, None, Interface_InterfaceModel)
Interface_InterfaceModel.Print = new_instancemethod(_Interface.Interface_InterfaceModel_Print, None, Interface_InterfaceModel)
Interface_InterfaceModel.PrintLabel = new_instancemethod(_Interface.Interface_InterfaceModel_PrintLabel, None, Interface_InterfaceModel)
Interface_InterfaceModel.PrintToLog = new_instancemethod(_Interface.Interface_InterfaceModel_PrintToLog, None, Interface_InterfaceModel)
Interface_InterfaceModel.Protocol = new_instancemethod(_Interface.Interface_InterfaceModel_Protocol, None, Interface_InterfaceModel)
Interface_InterfaceModel.Redefineds = new_instancemethod(_Interface.Interface_InterfaceModel_Redefineds, None, Interface_InterfaceModel)
Interface_InterfaceModel.ReplaceEntity = new_instancemethod(_Interface.Interface_InterfaceModel_ReplaceEntity, None, Interface_InterfaceModel)
Interface_InterfaceModel.ReportEntity = new_instancemethod(_Interface.Interface_InterfaceModel_ReportEntity, None, Interface_InterfaceModel)
Interface_InterfaceModel.Reports = new_instancemethod(_Interface.Interface_InterfaceModel_Reports, None, Interface_InterfaceModel)
Interface_InterfaceModel.Reservate = new_instancemethod(_Interface.Interface_InterfaceModel_Reservate, None, Interface_InterfaceModel)
Interface_InterfaceModel.ReverseOrders = new_instancemethod(_Interface.Interface_InterfaceModel_ReverseOrders, None, Interface_InterfaceModel)
Interface_InterfaceModel.SetCategoryNumber = new_instancemethod(_Interface.Interface_InterfaceModel_SetCategoryNumber, None, Interface_InterfaceModel)
Interface_InterfaceModel.SetGTool = new_instancemethod(_Interface.Interface_InterfaceModel_SetGTool, None, Interface_InterfaceModel)
Interface_InterfaceModel.SetGlobalCheck = new_instancemethod(_Interface.Interface_InterfaceModel_SetGlobalCheck, None, Interface_InterfaceModel)
Interface_InterfaceModel.SetProtocol = new_instancemethod(_Interface.Interface_InterfaceModel_SetProtocol, None, Interface_InterfaceModel)
Interface_InterfaceModel.SetReportEntity = new_instancemethod(_Interface.Interface_InterfaceModel_SetReportEntity, None, Interface_InterfaceModel)
Interface_InterfaceModel.StringLabel = new_instancemethod(_Interface.Interface_InterfaceModel_StringLabel, None, Interface_InterfaceModel)
Interface_InterfaceModel.Type = new_instancemethod(_Interface.Interface_InterfaceModel_Type, None, Interface_InterfaceModel)
Interface_InterfaceModel.TypeName = new_instancemethod(_Interface.Interface_InterfaceModel_TypeName, None, Interface_InterfaceModel)
Interface_InterfaceModel.Value = new_instancemethod(_Interface.Interface_InterfaceModel_Value, None, Interface_InterfaceModel)
Interface_InterfaceModel.VerifyCheck = new_instancemethod(_Interface.Interface_InterfaceModel_VerifyCheck, None, Interface_InterfaceModel)
Interface_InterfaceModel_swigregister = _Interface.Interface_InterfaceModel_swigregister
Interface_InterfaceModel_swigregister(Interface_InterfaceModel)

def Interface_InterfaceModel_ClassName(*args) -> "char const *":
    """
    * From a CDL Type Name, returns the Class part (package dropped) WARNING : buffered, to be immediately copied or printed
    	:param typnam:
    	:type typnam: char *
    	:rtype: char *
    """
    return _Interface.Interface_InterfaceModel_ClassName(*args)

def Interface_InterfaceModel_HasTemplate(*args) -> "Standard_Boolean":
    """
    * Returns true if a template is attached to a given name
    	:param name:
    	:type name: char *
    	:rtype: bool
    """
    return _Interface.Interface_InterfaceModel_HasTemplate(*args)

def Interface_InterfaceModel_ListTemplates(*args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
    """
    * Returns the complete list of names attached to template models
    	:rtype: opencascade::handle<TColStd_HSequenceOfHAsciiString>
    """
    return _Interface.Interface_InterfaceModel_ListTemplates(*args)

def Interface_InterfaceModel_SetTemplate(*args) -> "Standard_Boolean":
    """
    * Records a new template model with a name. If the name was already recorded, the corresponding template is replaced by the new one. Then, WARNING : test HasTemplate to avoid surprises
    	:param name:
    	:type name: char *
    	:param model:
    	:type model: Interface_InterfaceModel
    	:rtype: bool
    """
    return _Interface.Interface_InterfaceModel_SetTemplate(*args)

def Interface_InterfaceModel_Template(*args) -> "opencascade::handle< Interface_InterfaceModel >":
    """
    * Returns the template model attached to a name, or a Null Handle
    	:param name:
    	:type name: char *
    	:rtype: opencascade::handle<Interface_InterfaceModel>
    """
    return _Interface.Interface_InterfaceModel_Template(*args)

class Interface_LineBuffer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a text as a CString. Its Length is evaluated from the text (by C function strlen)
        	:param text:
        	:type text: char *
        	:rtype: None
        * Adds a text as a CString. Its length is given as <lntext>
        	:param text:
        	:type text: char *
        	:param lntext:
        	:type lntext: int
        	:rtype: None
        * Adds a text as a AsciiString from TCollection
        	:param text:
        	:type text: TCollection_AsciiString
        	:rtype: None
        * Adds a text made of only ONE Character
        	:param text:
        	:type text: Standard_Character
        	:rtype: None
        """
        return _Interface.Interface_LineBuffer_Add(self, *args)


    def CanGet(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there is room enough to add <more> characters Else, it is required to Dump the Buffer before refilling it <more> is recorded to manage SetKeep status
        	:param more:
        	:type more: int
        	:rtype: bool
        """
        return _Interface.Interface_LineBuffer_CanGet(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears completely the LineBuffer
        	:rtype: None
        """
        return _Interface.Interface_LineBuffer_Clear(self, *args)


    def Content(self, *args) -> "char const *":
        """
        * Returns the Content of the LineBuffer
        	:rtype: char *
        """
        return _Interface.Interface_LineBuffer_Content(self, *args)


    def FreezeInitial(self, *args) -> "void":
        """
        * Inhibits effect of SetInitial until the next Move (i.e. Keep) Then Prepare will not insert initial blanks, but further ones will. This allows to cancel initial blanks on an internal Split A call to SetInitial has no effect on this until Move
        	:rtype: None
        """
        return _Interface.Interface_LineBuffer_FreezeInitial(self, *args)


    def __init__(self, *args):
        """
        * Creates a LineBuffer with an absolute maximum size (Default value is only to satisfy compiler requirement)
        	:param size: default value is 10
        	:type size: int
        	:rtype: None
        """
        _Interface.Interface_LineBuffer_swiginit(self, _Interface.new_Interface_LineBuffer(*args))

    def Length(self, *args) -> "Standard_Integer":
        """
        * Returns the Length of the LineBuffer
        	:rtype: int
        """
        return _Interface.Interface_LineBuffer_Length(self, *args)


    def Move(self, *args) -> "void":
        """
        * Fills a AsciiString <str> with the Content of the Line Buffer, then Clears the LineBuffer
        	:param str:
        	:type str: TCollection_AsciiString
        	:rtype: None
        * Same as above, but <str> is known through a Handle
        	:param str:
        	:type str: TCollection_HAsciiString
        	:rtype: None
        """
        return _Interface.Interface_LineBuffer_Move(self, *args)


    def Moved(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        * Same as above, but generates the HAsciiString
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _Interface.Interface_LineBuffer_Moved(self, *args)


    def SetInitial(self, *args) -> "void":
        """
        * Sets an Initial reservation for Blank characters (this reservation is counted in the size of the current Line)
        	:param initial:
        	:type initial: int
        	:rtype: None
        """
        return _Interface.Interface_LineBuffer_SetInitial(self, *args)


    def SetKeep(self, *args) -> "void":
        """
        * Sets a Keep Status at current Length. It means that at next Move, the new line will begin by characters between Keep + 1 and current Length
        	:rtype: None
        """
        return _Interface.Interface_LineBuffer_SetKeep(self, *args)


    def SetMax(self, *args) -> "void":
        """
        * Changes Maximum allowed size of Buffer. If <max> is Zero, Maximum size is set to the initial size.
        	:param max:
        	:type max: int
        	:rtype: None
        """
        return _Interface.Interface_LineBuffer_SetMax(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_LineBuffer
Interface_LineBuffer.Add = new_instancemethod(_Interface.Interface_LineBuffer_Add, None, Interface_LineBuffer)
Interface_LineBuffer.CanGet = new_instancemethod(_Interface.Interface_LineBuffer_CanGet, None, Interface_LineBuffer)
Interface_LineBuffer.Clear = new_instancemethod(_Interface.Interface_LineBuffer_Clear, None, Interface_LineBuffer)
Interface_LineBuffer.Content = new_instancemethod(_Interface.Interface_LineBuffer_Content, None, Interface_LineBuffer)
Interface_LineBuffer.FreezeInitial = new_instancemethod(_Interface.Interface_LineBuffer_FreezeInitial, None, Interface_LineBuffer)
Interface_LineBuffer.Length = new_instancemethod(_Interface.Interface_LineBuffer_Length, None, Interface_LineBuffer)
Interface_LineBuffer.Move = new_instancemethod(_Interface.Interface_LineBuffer_Move, None, Interface_LineBuffer)
Interface_LineBuffer.Moved = new_instancemethod(_Interface.Interface_LineBuffer_Moved, None, Interface_LineBuffer)
Interface_LineBuffer.SetInitial = new_instancemethod(_Interface.Interface_LineBuffer_SetInitial, None, Interface_LineBuffer)
Interface_LineBuffer.SetKeep = new_instancemethod(_Interface.Interface_LineBuffer_SetKeep, None, Interface_LineBuffer)
Interface_LineBuffer.SetMax = new_instancemethod(_Interface.Interface_LineBuffer_SetMax, None, Interface_LineBuffer)
Interface_LineBuffer_swigregister = _Interface.Interface_LineBuffer_swigregister
Interface_LineBuffer_swigregister(Interface_LineBuffer)

class Interface_MSG(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Blanks(*args) -> "char const *":
        """
        * Returns a blank string, of length between 0 and <max>, to fill the printing of a numeric value <val>, i.e. : If val < 10 , max-1 blanks If val between 10 and 99, max-2 blanks ... etc...
        	:param val:
        	:type val: int
        	:param max:
        	:type max: int
        	:rtype: char *
        * Returns a blank string, to complete a given string <val> up to <max> characters : If strlen(val) is 0, max blanks If strlen(val) is 5, max-5 blanks etc...
        	:param val:
        	:type val: char *
        	:param max:
        	:type max: int
        	:rtype: char *
        * Returns a blank string of <count> blanks (mini 0, maxi 76)
        	:param count:
        	:type count: int
        	:rtype: char *
        """
        return _Interface.Interface_MSG_Blanks(*args)

    Blanks = staticmethod(Blanks)

    def CDate(*args) -> "Standard_Integer":
        """
        * Returns a value about comparison of two dates 0 : equal. <0 text1 anterior. >0 text1 posterior
        	:param text1:
        	:type text1: char *
        	:param text2:
        	:type text2: char *
        	:rtype: int
        """
        return _Interface.Interface_MSG_CDate(*args)

    CDate = staticmethod(CDate)

    def Destroy(self, *args) -> "void":
        """
        * Optimised destructor (applies for additional forms of Create)
        	:rtype: None
        """
        return _Interface.Interface_MSG_Destroy(self, *args)


    def __init__(self, *args):
        """
        * A MSG is created to write a 'functional code' in conjunction with operator () attached to Value Then, to have a translated message, write in C++ : //! Interface_MSG('...mykey...') which returns a CString See also some help which follow
        	:param key:
        	:type key: char *
        	:rtype: None
        * Translates a message which contains one integer variable It is just a help which avoid the following : char mess[100]; sprintf(mess,Interface_MSG('code'),ival); then AddFail(mess); replaced by AddFail (Interface_MSG('code',ival)); //! The basic message is intended to be in C-sprintf format, with one %d form in it
        	:param key:
        	:type key: char *
        	:param i1:
        	:type i1: int
        	:rtype: None
        * Translates a message which contains two integer variables As for one integer, it is just a writing help //! The basic message is intended to be in C-sprintf format with two %d forms in it
        	:param key:
        	:type key: char *
        	:param i1:
        	:type i1: int
        	:param i2:
        	:type i2: int
        	:rtype: None
        * Translates a message which contains one real variable <intervals> if set, commands the variable to be rounded to an interval (see below, method Intervals) As for one integer, it is just a writing help //! The basic message is intended to be in C-sprintf format with one %f form (or equivalent : %e etc) in it
        	:param key:
        	:type key: char *
        	:param r1:
        	:type r1: float
        	:param intervals: default value is -1
        	:type intervals: int
        	:rtype: None
        * Translates a message which contains one string variable As for one integer, it is just a writing help //! The basic message is intended to be in C-sprintf format with one %s form in it
        	:param key:
        	:type key: char *
        	:param str:
        	:type str: char *
        	:rtype: None
        * Translates a message which contains one integer and one string variables As for one integer, it is just a writing help Used for instance to say 'Param n0.<ival> i.e. <str> is not..' //! The basic message is intended to be in C-sprintf format with one %d then one %s forms in it
        	:param key:
        	:type key: char *
        	:param ival:
        	:type ival: int
        	:param str:
        	:type str: char *
        	:rtype: None
        """
        _Interface.Interface_MSG_swiginit(self, _Interface.new_Interface_MSG(*args))

    def Intervalled(*args) -> "Standard_Real":
        """
        * Returns an 'intervalled' value from a starting real <val> : i.e. a value which is rounded on an interval limit Interval limits are defined to be in a coarsely 'geometric' progression (two successive intervals are inside a limit ratio) //! <order> gives the count of desired intervals in a range <1-10> <upper> False, returns the first lower interval (D) <upper> True, returns the first upper interval Values of Intervals according <order> : 0,1 : 1 10 100 ... 2 : 1 3 10 30 100 ... 3(D): 1 2 5 10 20 50 100 ... 4 : 1 2 3 6 10 20 30 60 100 ... 6 : 1 1.5 2 3 5 7 10 15 20 ... 10 : 1 1.2 1.5 2 2.5 3 4 5 6 8 10 12 15 20 25 ...
        	:param val:
        	:type val: float
        	:param order: default value is 3
        	:type order: int
        	:param upper: default value is Standard_False
        	:type upper: bool
        	:rtype: float
        """
        return _Interface.Interface_MSG_Intervalled(*args)

    Intervalled = staticmethod(Intervalled)

    def IsKey(*args) -> "Standard_Boolean":
        """
        * Returns True if a given message is surely a key (according to the form adopted for keys) (before activating messages, answer is false)
        	:param mess:
        	:type mess: char *
        	:rtype: bool
        """
        return _Interface.Interface_MSG_IsKey(*args)

    IsKey = staticmethod(IsKey)

    def NDate(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &":
        """
        * Decodes a date to numeric integer values Returns True if OK, False if text does not fit with required format. Incomplete forms are allowed (for instance, for only YYYY-MM-DD, hour is zero)
        	:param text:
        	:type text: char *
        	:param yy:
        	:type yy: int
        	:param mm:
        	:type mm: int
        	:param dd:
        	:type dd: int
        	:param hh:
        	:type hh: int
        	:param mn:
        	:type mn: int
        	:param ss:
        	:type ss: int
        	:rtype: bool
        """
        return _Interface.Interface_MSG_NDate(*args)

    NDate = staticmethod(NDate)

    def Print(*args) -> "void":
        """
        * Prints a String on an Output Stream, as follows : Accompagned with blanks, to give up to <max> charis at all, justified according just : -1 (D) : left 0 : center 1 : right Maximum 76 characters
        	:param S:
        	:type S: Standard_OStream
        	:param val:
        	:type val: char *
        	:param max:
        	:type max: int
        	:param just: default value is -1
        	:type just: int
        	:rtype: void
        """
        return _Interface.Interface_MSG_Print(*args)

    Print = staticmethod(Print)

    def PrintTraceToString(self) -> "std::string":
        """PrintTraceToString(Interface_MSG self) -> std::string"""
        return _Interface.Interface_MSG_PrintTraceToString(self)


    def ReadFromString(self, src: 'std::string') -> "void":
        """ReadFromString(Interface_MSG self, std::string src)"""
        return _Interface.Interface_MSG_ReadFromString(self, src)


    def Read(*args) -> "Standard_Integer":
        """
        * Reads a list of messages from a file defined by its name
        	:param file:
        	:type file: char *
        	:rtype: int
        """
        return _Interface.Interface_MSG_Read(*args)

    Read = staticmethod(Read)

    def Record(*args) -> "void":
        """
        * Fills the dictionary with a couple (key-item) If a key is already recorded, it is possible to : - keep the last definition, and activate the trace system
        	:param key:
        	:type key: char *
        	:param item:
        	:type item: char *
        	:rtype: void
        """
        return _Interface.Interface_MSG_Record(*args)

    Record = staticmethod(Record)

    def SetMode(*args) -> "void":
        """
        * Sets the main modes for MSG : - if <running> is True, translation works normally - if <running> is False, translated item equate keys - if <raising> is True, errors (from Record or Translate) cause MSG to raise an exception - if <raising> is False, MSG runs without exception, then see also Trace Modes above
        	:param running:
        	:type running: bool
        	:param raising:
        	:type raising: bool
        	:rtype: void
        """
        return _Interface.Interface_MSG_SetMode(*args)

    SetMode = staticmethod(SetMode)

    def SetTrace(*args) -> "void":
        """
        * Sets the trace system to work when activated, as follow : - if <toprint> is True, print immediately on standard output - if <torecord> is True, record it for further print
        	:param toprint:
        	:type toprint: bool
        	:param torecord:
        	:type torecord: bool
        	:rtype: void
        """
        return _Interface.Interface_MSG_SetTrace(*args)

    SetTrace = staticmethod(SetTrace)

    def TDate(*args) -> "void":
        """
        * Codes a date as a text, from its numeric value (-> seconds) : YYYY-MM-DD:HH-MN-SS fixed format, completed by leading zeros Another format can be provided, as follows : C:%d ... C like format, preceeded by C: S:... format to call system (not yet implemented)
        	:param text:
        	:type text: char *
        	:param yy:
        	:type yy: int
        	:param mm:
        	:type mm: int
        	:param dd:
        	:type dd: int
        	:param hh:
        	:type hh: int
        	:param mn:
        	:type mn: int
        	:param ss:
        	:type ss: int
        	:param format: default value is 
        	:type format: char *
        	:rtype: void
        """
        return _Interface.Interface_MSG_TDate(*args)

    TDate = staticmethod(TDate)

    def Translated(*args) -> "char const *":
        """
        * Returns the item recorded for a key. Returns the key itself if : - it is not recorded (then, the trace system is activated) - MSG has been required to be hung on
        	:param key:
        	:type key: char *
        	:rtype: char *
        """
        return _Interface.Interface_MSG_Translated(*args)

    Translated = staticmethod(Translated)

    def Value(self, *args) -> "char const *":
        """
        * Returns the translated message, in a functional form with operator () was C++ : return const
        	:rtype: char *
        """
        return _Interface.Interface_MSG_Value(self, *args)


    def Write(*args) -> "Standard_Integer":
        """
        * Writes the list of messages recorded to be translated, to a stream. Writes all the list (Default) or only keys which begin by <rootkey>. Returns the count of written messages
        	:param S:
        	:type S: Standard_OStream
        	:param rootkey: default value is 
        	:type rootkey: char *
        	:rtype: int
        """
        return _Interface.Interface_MSG_Write(*args)

    Write = staticmethod(Write)

    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_MSG
Interface_MSG.Destroy = new_instancemethod(_Interface.Interface_MSG_Destroy, None, Interface_MSG)
Interface_MSG.PrintTraceToString = new_instancemethod(_Interface.Interface_MSG_PrintTraceToString, None, Interface_MSG)
Interface_MSG.ReadFromString = new_instancemethod(_Interface.Interface_MSG_ReadFromString, None, Interface_MSG)
Interface_MSG.Value = new_instancemethod(_Interface.Interface_MSG_Value, None, Interface_MSG)
Interface_MSG_swigregister = _Interface.Interface_MSG_swigregister
Interface_MSG_swigregister(Interface_MSG)

def Interface_MSG_Blanks(*args) -> "char const *":
    """
    * Returns a blank string, of length between 0 and <max>, to fill the printing of a numeric value <val>, i.e. : If val < 10 , max-1 blanks If val between 10 and 99, max-2 blanks ... etc...
    	:param val:
    	:type val: int
    	:param max:
    	:type max: int
    	:rtype: char *
    * Returns a blank string, to complete a given string <val> up to <max> characters : If strlen(val) is 0, max blanks If strlen(val) is 5, max-5 blanks etc...
    	:param val:
    	:type val: char *
    	:param max:
    	:type max: int
    	:rtype: char *
    * Returns a blank string of <count> blanks (mini 0, maxi 76)
    	:param count:
    	:type count: int
    	:rtype: char *
    """
    return _Interface.Interface_MSG_Blanks(*args)

def Interface_MSG_CDate(*args) -> "Standard_Integer":
    """
    * Returns a value about comparison of two dates 0 : equal. <0 text1 anterior. >0 text1 posterior
    	:param text1:
    	:type text1: char *
    	:param text2:
    	:type text2: char *
    	:rtype: int
    """
    return _Interface.Interface_MSG_CDate(*args)

def Interface_MSG_Intervalled(*args) -> "Standard_Real":
    """
    * Returns an 'intervalled' value from a starting real <val> : i.e. a value which is rounded on an interval limit Interval limits are defined to be in a coarsely 'geometric' progression (two successive intervals are inside a limit ratio) //! <order> gives the count of desired intervals in a range <1-10> <upper> False, returns the first lower interval (D) <upper> True, returns the first upper interval Values of Intervals according <order> : 0,1 : 1 10 100 ... 2 : 1 3 10 30 100 ... 3(D): 1 2 5 10 20 50 100 ... 4 : 1 2 3 6 10 20 30 60 100 ... 6 : 1 1.5 2 3 5 7 10 15 20 ... 10 : 1 1.2 1.5 2 2.5 3 4 5 6 8 10 12 15 20 25 ...
    	:param val:
    	:type val: float
    	:param order: default value is 3
    	:type order: int
    	:param upper: default value is Standard_False
    	:type upper: bool
    	:rtype: float
    """
    return _Interface.Interface_MSG_Intervalled(*args)

def Interface_MSG_IsKey(*args) -> "Standard_Boolean":
    """
    * Returns True if a given message is surely a key (according to the form adopted for keys) (before activating messages, answer is false)
    	:param mess:
    	:type mess: char *
    	:rtype: bool
    """
    return _Interface.Interface_MSG_IsKey(*args)

def Interface_MSG_NDate(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &":
    """
    * Decodes a date to numeric integer values Returns True if OK, False if text does not fit with required format. Incomplete forms are allowed (for instance, for only YYYY-MM-DD, hour is zero)
    	:param text:
    	:type text: char *
    	:param yy:
    	:type yy: int
    	:param mm:
    	:type mm: int
    	:param dd:
    	:type dd: int
    	:param hh:
    	:type hh: int
    	:param mn:
    	:type mn: int
    	:param ss:
    	:type ss: int
    	:rtype: bool
    """
    return _Interface.Interface_MSG_NDate(*args)

def Interface_MSG_Print(*args) -> "void":
    """
    * Prints a String on an Output Stream, as follows : Accompagned with blanks, to give up to <max> charis at all, justified according just : -1 (D) : left 0 : center 1 : right Maximum 76 characters
    	:param S:
    	:type S: Standard_OStream
    	:param val:
    	:type val: char *
    	:param max:
    	:type max: int
    	:param just: default value is -1
    	:type just: int
    	:rtype: void
    """
    return _Interface.Interface_MSG_Print(*args)

def Interface_MSG_Read(*args) -> "Standard_Integer":
    """
    * Reads a list of messages from a file defined by its name
    	:param file:
    	:type file: char *
    	:rtype: int
    """
    return _Interface.Interface_MSG_Read(*args)

def Interface_MSG_Record(*args) -> "void":
    """
    * Fills the dictionary with a couple (key-item) If a key is already recorded, it is possible to : - keep the last definition, and activate the trace system
    	:param key:
    	:type key: char *
    	:param item:
    	:type item: char *
    	:rtype: void
    """
    return _Interface.Interface_MSG_Record(*args)

def Interface_MSG_SetMode(*args) -> "void":
    """
    * Sets the main modes for MSG : - if <running> is True, translation works normally - if <running> is False, translated item equate keys - if <raising> is True, errors (from Record or Translate) cause MSG to raise an exception - if <raising> is False, MSG runs without exception, then see also Trace Modes above
    	:param running:
    	:type running: bool
    	:param raising:
    	:type raising: bool
    	:rtype: void
    """
    return _Interface.Interface_MSG_SetMode(*args)

def Interface_MSG_SetTrace(*args) -> "void":
    """
    * Sets the trace system to work when activated, as follow : - if <toprint> is True, print immediately on standard output - if <torecord> is True, record it for further print
    	:param toprint:
    	:type toprint: bool
    	:param torecord:
    	:type torecord: bool
    	:rtype: void
    """
    return _Interface.Interface_MSG_SetTrace(*args)

def Interface_MSG_TDate(*args) -> "void":
    """
    * Codes a date as a text, from its numeric value (-> seconds) : YYYY-MM-DD:HH-MN-SS fixed format, completed by leading zeros Another format can be provided, as follows : C:%d ... C like format, preceeded by C: S:... format to call system (not yet implemented)
    	:param text:
    	:type text: char *
    	:param yy:
    	:type yy: int
    	:param mm:
    	:type mm: int
    	:param dd:
    	:type dd: int
    	:param hh:
    	:type hh: int
    	:param mn:
    	:type mn: int
    	:param ss:
    	:type ss: int
    	:param format: default value is 
    	:type format: char *
    	:rtype: void
    """
    return _Interface.Interface_MSG_TDate(*args)

def Interface_MSG_Translated(*args) -> "char const *":
    """
    * Returns the item recorded for a key. Returns the key itself if : - it is not recorded (then, the trace system is activated) - MSG has been required to be hung on
    	:param key:
    	:type key: char *
    	:rtype: char *
    """
    return _Interface.Interface_MSG_Translated(*args)

def Interface_MSG_Write(*args) -> "Standard_Integer":
    """
    * Writes the list of messages recorded to be translated, to a stream. Writes all the list (Default) or only keys which begin by <rootkey>. Returns the count of written messages
    	:param S:
    	:type S: Standard_OStream
    	:param rootkey: default value is 
    	:type rootkey: char *
    	:rtype: int
    """
    return _Interface.Interface_MSG_Write(*args)

class Interface_MapAsciiStringHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args) -> "Standard_Integer":
        """
        * Computes a hash code for the given ASCII string, in the range [1, theUpperBound] @param theAsciiString the ASCII string which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
        	:param theAsciiString:
        	:type theAsciiString: TCollection_AsciiString
        	:param theUpperBound:
        	:type theUpperBound: int
        	:rtype: int
        """
        return _Interface.Interface_MapAsciiStringHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        :param K1:
        	:type K1: TCollection_AsciiString
        	:param K2:
        	:type K2: TCollection_AsciiString
        	:rtype: bool
        """
        return _Interface.Interface_MapAsciiStringHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object


    def __init__(self):
        _Interface.Interface_MapAsciiStringHasher_swiginit(self, _Interface.new_Interface_MapAsciiStringHasher())
    __swig_destroy__ = _Interface.delete_Interface_MapAsciiStringHasher
Interface_MapAsciiStringHasher_swigregister = _Interface.Interface_MapAsciiStringHasher_swigregister
Interface_MapAsciiStringHasher_swigregister(Interface_MapAsciiStringHasher)

def Interface_MapAsciiStringHasher_HashCode(*args) -> "Standard_Integer":
    """
    * Computes a hash code for the given ASCII string, in the range [1, theUpperBound] @param theAsciiString the ASCII string which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
    	:param theAsciiString:
    	:type theAsciiString: TCollection_AsciiString
    	:param theUpperBound:
    	:type theUpperBound: int
    	:rtype: int
    """
    return _Interface.Interface_MapAsciiStringHasher_HashCode(*args)

def Interface_MapAsciiStringHasher_IsEqual(*args) -> "Standard_Boolean":
    """
    :param K1:
    	:type K1: TCollection_AsciiString
    	:param K2:
    	:type K2: TCollection_AsciiString
    	:rtype: bool
    """
    return _Interface.Interface_MapAsciiStringHasher_IsEqual(*args)

class Interface_NodeOfGeneralLib(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddNode(self, *args) -> "void":
        """
        * Adds a couple (Module,Protocol), that is, stores it into itself if not yet done, else creates a Next Node to do it
        	:param anode:
        	:type anode: Interface_GlobalNodeOfGeneralLib
        	:rtype: None
        """
        return _Interface.Interface_NodeOfGeneralLib_AddNode(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty Node, with no Next
        	:rtype: None
        """
        _Interface.Interface_NodeOfGeneralLib_swiginit(self, _Interface.new_Interface_NodeOfGeneralLib(*args))

    def Module(self, *args) -> "opencascade::handle< Interface_GeneralModule > const &":
        """
        * Returns the Module designated by a precise Node
        	:rtype: opencascade::handle<Interface_GeneralModule>
        """
        return _Interface.Interface_NodeOfGeneralLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< Interface_NodeOfGeneralLib > const &":
        """
        * Returns the Next Node. If none was defined, returned value is a Null Handle
        	:rtype: opencascade::handle<Interface_NodeOfGeneralLib>
        """
        return _Interface.Interface_NodeOfGeneralLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        * Returns the Protocol designated by a precise Node
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_NodeOfGeneralLib_Protocol(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_NodeOfGeneralLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_NodeOfGeneralLib
Interface_NodeOfGeneralLib.AddNode = new_instancemethod(_Interface.Interface_NodeOfGeneralLib_AddNode, None, Interface_NodeOfGeneralLib)
Interface_NodeOfGeneralLib.Module = new_instancemethod(_Interface.Interface_NodeOfGeneralLib_Module, None, Interface_NodeOfGeneralLib)
Interface_NodeOfGeneralLib.Next = new_instancemethod(_Interface.Interface_NodeOfGeneralLib_Next, None, Interface_NodeOfGeneralLib)
Interface_NodeOfGeneralLib.Protocol = new_instancemethod(_Interface.Interface_NodeOfGeneralLib_Protocol, None, Interface_NodeOfGeneralLib)
Interface_NodeOfGeneralLib_swigregister = _Interface.Interface_NodeOfGeneralLib_swigregister
Interface_NodeOfGeneralLib_swigregister(Interface_NodeOfGeneralLib)

class Interface_NodeOfReaderLib(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddNode(self, *args) -> "void":
        """
        * Adds a couple (Module,Protocol), that is, stores it into itself if not yet done, else creates a Next Node to do it
        	:param anode:
        	:type anode: Interface_GlobalNodeOfReaderLib
        	:rtype: None
        """
        return _Interface.Interface_NodeOfReaderLib_AddNode(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty Node, with no Next
        	:rtype: None
        """
        _Interface.Interface_NodeOfReaderLib_swiginit(self, _Interface.new_Interface_NodeOfReaderLib(*args))

    def Module(self, *args) -> "opencascade::handle< Interface_ReaderModule > const &":
        """
        * Returns the Module designated by a precise Node
        	:rtype: opencascade::handle<Interface_ReaderModule>
        """
        return _Interface.Interface_NodeOfReaderLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< Interface_NodeOfReaderLib > const &":
        """
        * Returns the Next Node. If none was defined, returned value is a Null Handle
        	:rtype: opencascade::handle<Interface_NodeOfReaderLib>
        """
        return _Interface.Interface_NodeOfReaderLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        * Returns the Protocol designated by a precise Node
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_NodeOfReaderLib_Protocol(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_NodeOfReaderLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_NodeOfReaderLib
Interface_NodeOfReaderLib.AddNode = new_instancemethod(_Interface.Interface_NodeOfReaderLib_AddNode, None, Interface_NodeOfReaderLib)
Interface_NodeOfReaderLib.Module = new_instancemethod(_Interface.Interface_NodeOfReaderLib_Module, None, Interface_NodeOfReaderLib)
Interface_NodeOfReaderLib.Next = new_instancemethod(_Interface.Interface_NodeOfReaderLib_Next, None, Interface_NodeOfReaderLib)
Interface_NodeOfReaderLib.Protocol = new_instancemethod(_Interface.Interface_NodeOfReaderLib_Protocol, None, Interface_NodeOfReaderLib)
Interface_NodeOfReaderLib_swigregister = _Interface.Interface_NodeOfReaderLib_swigregister
Interface_NodeOfReaderLib_swigregister(Interface_NodeOfReaderLib)

class Interface_ParamList(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ChangeValue(self, *args) -> "Interface_FileParameter &":
        """
        * return the value of the <Index>th element of the array.
        	:param Index:
        	:type Index: int
        	:rtype: Interface_FileParameter
        """
        return _Interface.Interface_ParamList_ChangeValue(self, *args)


    def Clear(self, *args) -> "void":
        """:rtype: None"""
        return _Interface.Interface_ParamList_Clear(self, *args)


    def __init__(self, *args):
        """
        * Creates an vector with size of memmory blok equal to theIncrement
        	:param theIncrement: default value is 256
        	:type theIncrement: int
        	:rtype: None
        """
        _Interface.Interface_ParamList_swiginit(self, _Interface.new_Interface_ParamList(*args))

    def Length(self, *args) -> "Standard_Integer":
        """
        * Returns the number of elements of <self>.
        	:rtype: int
        """
        return _Interface.Interface_ParamList_Length(self, *args)


    def Lower(self, *args) -> "Standard_Integer":
        """
        * Returns the lower bound. Warning
        	:rtype: int
        """
        return _Interface.Interface_ParamList_Lower(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Assigns the value <Value> to the <Index>-th item of this array.
        	:param Index:
        	:type Index: int
        	:param Value:
        	:type Value: Interface_FileParameter
        	:rtype: None
        """
        return _Interface.Interface_ParamList_SetValue(self, *args)


    def Upper(self, *args) -> "Standard_Integer":
        """
        * Returns the upper bound. Warning
        	:rtype: int
        """
        return _Interface.Interface_ParamList_Upper(self, *args)


    def Value(self, *args) -> "Interface_FileParameter const &":
        """
        * Return the value of the <Index>th element of the array.
        	:param Index:
        	:type Index: int
        	:rtype: Interface_FileParameter
        """
        return _Interface.Interface_ParamList_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_ParamList_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ParamList
Interface_ParamList.ChangeValue = new_instancemethod(_Interface.Interface_ParamList_ChangeValue, None, Interface_ParamList)
Interface_ParamList.Clear = new_instancemethod(_Interface.Interface_ParamList_Clear, None, Interface_ParamList)
Interface_ParamList.Length = new_instancemethod(_Interface.Interface_ParamList_Length, None, Interface_ParamList)
Interface_ParamList.Lower = new_instancemethod(_Interface.Interface_ParamList_Lower, None, Interface_ParamList)
Interface_ParamList.SetValue = new_instancemethod(_Interface.Interface_ParamList_SetValue, None, Interface_ParamList)
Interface_ParamList.Upper = new_instancemethod(_Interface.Interface_ParamList_Upper, None, Interface_ParamList)
Interface_ParamList.Value = new_instancemethod(_Interface.Interface_ParamList_Value, None, Interface_ParamList)
Interface_ParamList_swigregister = _Interface.Interface_ParamList_swigregister
Interface_ParamList_swigregister(Interface_ParamList)

class Interface_ParamSet(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Append(self, *args) -> "Standard_Integer":
        """
        * Adds a parameter defined as its Value (CString and length) and Type. Optionnal EntityNumber (for FileReaderData) can be given Allows a better memory management than Appending a complete FileParameter If <lnval> < 0, <val> is assumed to be managed elsewhere : its adress is stored as such. Else, <val> is copied in a locally (quickly) managed Page of Characters Returns new count of recorded Parameters
        	:param val:
        	:type val: char *
        	:param lnval:
        	:type lnval: int
        	:param typ:
        	:type typ: Interface_ParamType
        	:param nument:
        	:type nument: int
        	:rtype: int
        * Adds a parameter at the end of the ParamSet (transparent about reservation and 'Next') Returns new count of recorded Parameters
        	:param FP:
        	:type FP: Interface_FileParameter
        	:rtype: int
        """
        return _Interface.Interface_ParamSet_Append(self, *args)


    def ChangeParam(self, *args) -> "Interface_FileParameter &":
        """
        * Same as above, but in order to be modified on place
        	:param num:
        	:type num: int
        	:rtype: Interface_FileParameter
        """
        return _Interface.Interface_ParamSet_ChangeParam(self, *args)


    def Destroy(self, *args) -> "void":
        """
        * Destructor (waiting for transparent memory management)
        	:rtype: None
        """
        return _Interface.Interface_ParamSet_Destroy(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty ParamSet, beginning at number 'nst' and of initial reservation 'nres' : the 'nres' first parameters which follow 'ndeb' (included) will be put in an Array (a ParamList). The remainders are set in Next(s) ParamSet(s)
        	:param nres:
        	:type nres: int
        	:param nst: default value is 1
        	:type nst: int
        	:rtype: None
        """
        _Interface.Interface_ParamSet_swiginit(self, _Interface.new_Interface_ParamSet(*args))

    def NbParams(self, *args) -> "Standard_Integer":
        """
        * Returns the total count of parameters (including nexts)
        	:rtype: int
        """
        return _Interface.Interface_ParamSet_NbParams(self, *args)


    def Param(self, *args) -> "Interface_FileParameter const &":
        """
        * Returns a parameter identified by its number
        	:param num:
        	:type num: int
        	:rtype: Interface_FileParameter
        """
        return _Interface.Interface_ParamSet_Param(self, *args)


    def Params(self, *args) -> "opencascade::handle< Interface_ParamList >":
        """
        * Builds and returns the sub-list correspinding to parameters, from 'num' included, with count 'nb' If <num> and <nb> are zero, returns the whole list
        	:param num:
        	:type num: int
        	:param nb:
        	:type nb: int
        	:rtype: opencascade::handle<Interface_ParamList>
        """
        return _Interface.Interface_ParamSet_Params(self, *args)


    def SetParam(self, *args) -> "void":
        """
        * Changes a parameter identified by its number
        	:param num:
        	:type num: int
        	:param FP:
        	:type FP: Interface_FileParameter
        	:rtype: None
        """
        return _Interface.Interface_ParamSet_SetParam(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_ParamSet_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ParamSet
Interface_ParamSet.Append = new_instancemethod(_Interface.Interface_ParamSet_Append, None, Interface_ParamSet)
Interface_ParamSet.ChangeParam = new_instancemethod(_Interface.Interface_ParamSet_ChangeParam, None, Interface_ParamSet)
Interface_ParamSet.Destroy = new_instancemethod(_Interface.Interface_ParamSet_Destroy, None, Interface_ParamSet)
Interface_ParamSet.NbParams = new_instancemethod(_Interface.Interface_ParamSet_NbParams, None, Interface_ParamSet)
Interface_ParamSet.Param = new_instancemethod(_Interface.Interface_ParamSet_Param, None, Interface_ParamSet)
Interface_ParamSet.Params = new_instancemethod(_Interface.Interface_ParamSet_Params, None, Interface_ParamSet)
Interface_ParamSet.SetParam = new_instancemethod(_Interface.Interface_ParamSet_SetParam, None, Interface_ParamSet)
Interface_ParamSet_swigregister = _Interface.Interface_ParamSet_swigregister
Interface_ParamSet_swigregister(Interface_ParamSet)

class Interface_Protocol(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Active(*args) -> "opencascade::handle< Interface_Protocol >":
        """
        * Returns the Active Protocol, if defined (else, returns a Null Handle, which means 'no defined active protocol')
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_Protocol_Active(*args)

    Active = staticmethod(Active)

    def CaseNumber(self, *args) -> "Standard_Integer":
        """
        * Returns a unique positive CaseNumber for each Recognized Object. By default, recognition is based on Type(1) By default, calls the following one which is deferred.
        	:param obj:
        	:type obj: Standard_Transient
        	:rtype: int
        """
        return _Interface.Interface_Protocol_CaseNumber(self, *args)


    def ClearActive(*args) -> "void":
        """
        * Erases the Active Protocol (hence it becomes undefined)
        	:rtype: void
        """
        return _Interface.Interface_Protocol_ClearActive(*args)

    ClearActive = staticmethod(ClearActive)

    def GlobalCheck(self, *args) -> "Standard_Boolean":
        """
        * Evaluates a Global Check for a model (with its Graph) Returns True when done, False if data in model do not apply //! Very specific of each norm, i.e. of each protocol : the uppest level Protocol assumes it, it can call GlobalCheck of its ressources only if it is necessary //! Default does nothing, can be redefined
        	:param G:
        	:type G: Interface_Graph
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: bool
        """
        return _Interface.Interface_Protocol_GlobalCheck(self, *args)


    def IsDynamicType(self, *args) -> "Standard_Boolean":
        """
        * Returns True if type of <obj> is that defined from CDL This is the default but it may change according implementation
        	:param obj:
        	:type obj: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_Protocol_IsDynamicType(self, *args)


    def IsSuitableModel(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <model> is a Model of the considered Norm
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: bool
        """
        return _Interface.Interface_Protocol_IsSuitableModel(self, *args)


    def IsUnknownEntity(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <ent> is an Unknown Entity for the Norm, i.e. same Type as them created by method UnknownEntity (for an Entity out of the Norm, answer can be unpredicable)
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_Protocol_IsUnknownEntity(self, *args)


    def NbResources(self, *args) -> "Standard_Integer":
        """
        * Returns count of Protocol used as Resources (level one)
        	:rtype: int
        """
        return _Interface.Interface_Protocol_NbResources(self, *args)


    def NbTypes(self, *args) -> "Standard_Integer":
        """
        * Returns the count of DISTINCT types under which an entity may be processed. Each one is candidate to be recognized by TypeNumber, <obj> is then processed according it By default, returns 1 (the DynamicType)
        	:param obj:
        	:type obj: Standard_Transient
        	:rtype: int
        """
        return _Interface.Interface_Protocol_NbTypes(self, *args)


    def NewModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Creates an empty Model of the considered Norm
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_Protocol_NewModel(self, *args)


    def Resource(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        * Returns a Resource, given its rank (between 1 and NbResources)
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_Protocol_Resource(self, *args)


    def SetActive(*args) -> "void":
        """
        * Sets a given Protocol to be the Active one (for the users of Active, see just above). Applies to every sub-type of Protocol
        	:param aprotocol:
        	:type aprotocol: Interface_Protocol
        	:rtype: void
        """
        return _Interface.Interface_Protocol_SetActive(*args)

    SetActive = staticmethod(SetActive)

    def Type(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns a type under which <obj> can be recognized and processed, according its rank in its definition list (see NbTypes). By default, returns DynamicType
        	:param obj:
        	:type obj: Standard_Transient
        	:param nt: default value is 1
        	:type nt: int
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _Interface.Interface_Protocol_Type(self, *args)


    def TypeNumber(self, *args) -> "Standard_Integer":
        """
        * Returns a unique positive CaseNumber for each Recognized Type, Returns Zero for '<type> not recognized'
        	:param atype:
        	:type atype: Standard_Type
        	:rtype: int
        """
        return _Interface.Interface_Protocol_TypeNumber(self, *args)


    def UnknownEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Creates a new Unknown Entity for the considered Norm
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_Protocol_UnknownEntity(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_Protocol_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Protocol
Interface_Protocol.CaseNumber = new_instancemethod(_Interface.Interface_Protocol_CaseNumber, None, Interface_Protocol)
Interface_Protocol.GlobalCheck = new_instancemethod(_Interface.Interface_Protocol_GlobalCheck, None, Interface_Protocol)
Interface_Protocol.IsDynamicType = new_instancemethod(_Interface.Interface_Protocol_IsDynamicType, None, Interface_Protocol)
Interface_Protocol.IsSuitableModel = new_instancemethod(_Interface.Interface_Protocol_IsSuitableModel, None, Interface_Protocol)
Interface_Protocol.IsUnknownEntity = new_instancemethod(_Interface.Interface_Protocol_IsUnknownEntity, None, Interface_Protocol)
Interface_Protocol.NbResources = new_instancemethod(_Interface.Interface_Protocol_NbResources, None, Interface_Protocol)
Interface_Protocol.NbTypes = new_instancemethod(_Interface.Interface_Protocol_NbTypes, None, Interface_Protocol)
Interface_Protocol.NewModel = new_instancemethod(_Interface.Interface_Protocol_NewModel, None, Interface_Protocol)
Interface_Protocol.Resource = new_instancemethod(_Interface.Interface_Protocol_Resource, None, Interface_Protocol)
Interface_Protocol.Type = new_instancemethod(_Interface.Interface_Protocol_Type, None, Interface_Protocol)
Interface_Protocol.TypeNumber = new_instancemethod(_Interface.Interface_Protocol_TypeNumber, None, Interface_Protocol)
Interface_Protocol.UnknownEntity = new_instancemethod(_Interface.Interface_Protocol_UnknownEntity, None, Interface_Protocol)
Interface_Protocol_swigregister = _Interface.Interface_Protocol_swigregister
Interface_Protocol_swigregister(Interface_Protocol)

def Interface_Protocol_Active(*args) -> "opencascade::handle< Interface_Protocol >":
    """
    * Returns the Active Protocol, if defined (else, returns a Null Handle, which means 'no defined active protocol')
    	:rtype: opencascade::handle<Interface_Protocol>
    """
    return _Interface.Interface_Protocol_Active(*args)

def Interface_Protocol_ClearActive(*args) -> "void":
    """
    * Erases the Active Protocol (hence it becomes undefined)
    	:rtype: void
    """
    return _Interface.Interface_Protocol_ClearActive(*args)

def Interface_Protocol_SetActive(*args) -> "void":
    """
    * Sets a given Protocol to be the Active one (for the users of Active, see just above). Applies to every sub-type of Protocol
    	:param aprotocol:
    	:type aprotocol: Interface_Protocol
    	:rtype: void
    """
    return _Interface.Interface_Protocol_SetActive(*args)

class Interface_ReaderLib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddProtocol(self, *args) -> "void":
        """
        * Adds a couple (Module-Protocol) to the Library, given the class of a Protocol. Takes Resources into account. (if <aprotocol> is not of type TheProtocol, it is not added)
        	:param aprotocol:
        	:type aprotocol: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_ReaderLib_AddProtocol(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears the list of Modules of a library (can be used to redefine the order of Modules before action : Clear then refill the Library by calls to AddProtocol)
        	:rtype: None
        """
        return _Interface.Interface_ReaderLib_Clear(self, *args)


    def __init__(self, *args):
        """
        * Creates a Library which complies with a Protocol, that is : Same class (criterium IsInstance) This creation gets the Modules from the global set, those which are bound to the given Protocol and its Resources
        	:param aprotocol:
        	:type aprotocol: Interface_Protocol
        	:rtype: None
        * Creates an empty Library : it will later by filled by method AddProtocol
        	:rtype: None
        """
        _Interface.Interface_ReaderLib_swiginit(self, _Interface.new_Interface_ReaderLib(*args))

    def Module(self, *args) -> "opencascade::handle< Interface_ReaderModule > const &":
        """
        * Returns the current Module in the Iteration
        	:rtype: opencascade::handle<Interface_ReaderModule>
        """
        return _Interface.Interface_ReaderLib_Module(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there are more Modules to iterate on
        	:rtype: bool
        """
        return _Interface.Interface_ReaderLib_More(self, *args)


    def Next(self, *args) -> "void":
        """
        * Iterates by getting the next Module in the list If there is none, the exception will be raised by Value
        	:rtype: None
        """
        return _Interface.Interface_ReaderLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        * Returns the current Protocol in the Iteration
        	:rtype: opencascade::handle<Interface_Protocol>
        """
        return _Interface.Interface_ReaderLib_Protocol(self, *args)


    def Select(self, *args) -> "Standard_Boolean":
        """
        * Selects a Module from the Library, given an Object. Returns True if Select has succeeded, False else. Also Returns (as arguments) the selected Module and the Case Number determined by the associated Protocol. If Select has failed, <module> is Null Handle and CN is zero. (Select can work on any criterium, such as Object DynamicType)
        	:param obj:
        	:type obj: Standard_Transient
        	:param module:
        	:type module: Interface_ReaderModule
        	:param CN:
        	:type CN: int
        	:rtype: bool
        """
        return _Interface.Interface_ReaderLib_Select(self, *args)


    def SetComplete(self, *args) -> "void":
        """
        * Sets a library to be defined with the complete Global list (all the couples Protocol/Modules recorded in it)
        	:rtype: None
        """
        return _Interface.Interface_ReaderLib_SetComplete(self, *args)


    def SetGlobal(*args) -> "void":
        """
        * Adds a couple (Module-Protocol) into the global definition set for this class of Library.
        	:param amodule:
        	:type amodule: Interface_ReaderModule
        	:param aprotocol:
        	:type aprotocol: Interface_Protocol
        	:rtype: void
        """
        return _Interface.Interface_ReaderLib_SetGlobal(*args)

    SetGlobal = staticmethod(SetGlobal)

    def Start(self, *args) -> "void":
        """
        * Starts Iteration on the Modules (sets it on the first one)
        	:rtype: None
        """
        return _Interface.Interface_ReaderLib_Start(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ReaderLib
Interface_ReaderLib.AddProtocol = new_instancemethod(_Interface.Interface_ReaderLib_AddProtocol, None, Interface_ReaderLib)
Interface_ReaderLib.Clear = new_instancemethod(_Interface.Interface_ReaderLib_Clear, None, Interface_ReaderLib)
Interface_ReaderLib.Module = new_instancemethod(_Interface.Interface_ReaderLib_Module, None, Interface_ReaderLib)
Interface_ReaderLib.More = new_instancemethod(_Interface.Interface_ReaderLib_More, None, Interface_ReaderLib)
Interface_ReaderLib.Next = new_instancemethod(_Interface.Interface_ReaderLib_Next, None, Interface_ReaderLib)
Interface_ReaderLib.Protocol = new_instancemethod(_Interface.Interface_ReaderLib_Protocol, None, Interface_ReaderLib)
Interface_ReaderLib.Select = new_instancemethod(_Interface.Interface_ReaderLib_Select, None, Interface_ReaderLib)
Interface_ReaderLib.SetComplete = new_instancemethod(_Interface.Interface_ReaderLib_SetComplete, None, Interface_ReaderLib)
Interface_ReaderLib.Start = new_instancemethod(_Interface.Interface_ReaderLib_Start, None, Interface_ReaderLib)
Interface_ReaderLib_swigregister = _Interface.Interface_ReaderLib_swigregister
Interface_ReaderLib_swigregister(Interface_ReaderLib)

def Interface_ReaderLib_SetGlobal(*args) -> "void":
    """
    * Adds a couple (Module-Protocol) into the global definition set for this class of Library.
    	:param amodule:
    	:type amodule: Interface_ReaderModule
    	:param aprotocol:
    	:type aprotocol: Interface_Protocol
    	:rtype: void
    """
    return _Interface.Interface_ReaderLib_SetGlobal(*args)

class Interface_ReaderModule(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CaseNum(self, *args) -> "Standard_Integer":
        """
        * Translates the type of record <num> in <data> to a positive Case Number. If Recognition fails, must return 0
        	:param data:
        	:type data: Interface_FileReaderData
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _Interface.Interface_ReaderModule_CaseNum(self, *args)


    def NewRead(self, *args) -> "Standard_Boolean":
        """
        * Specific operator (create+read) defaulted to do nothing. It can be redefined when it is not possible to work in two steps (NewVoid then Read). This occurs when no default constructor is defined : hence the result <ent> must be created with an effective definition from the reader. Remark : if NewRead is defined, Copy has nothing to do. //! Returns True if it has produced something, false else. If nothing was produced, <ach> should be filled : it will be treated as 'Unrecognized case' by reader tool.
        	:param casenum:
        	:type casenum: int
        	:param data:
        	:type data: Interface_FileReaderData
        	:param num:
        	:type num: int
        	:param ach:
        	:type ach: Interface_Check
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_ReaderModule_NewRead(self, *args)


    def Read(self, *args) -> "void":
        """
        * Performs the effective loading from <data>, record <num>, to the Entity <ent> formerly created In case of Error or Warning, fills <ach> with messages Remark that the Case Number comes from translating a record
        	:param casenum:
        	:type casenum: int
        	:param data:
        	:type data: Interface_FileReaderData
        	:param num:
        	:type num: int
        	:param ach:
        	:type ach: Interface_Check
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: void
        """
        return _Interface.Interface_ReaderModule_Read(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_ReaderModule_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ReaderModule
Interface_ReaderModule.CaseNum = new_instancemethod(_Interface.Interface_ReaderModule_CaseNum, None, Interface_ReaderModule)
Interface_ReaderModule.NewRead = new_instancemethod(_Interface.Interface_ReaderModule_NewRead, None, Interface_ReaderModule)
Interface_ReaderModule.Read = new_instancemethod(_Interface.Interface_ReaderModule_Read, None, Interface_ReaderModule)
Interface_ReaderModule_swigregister = _Interface.Interface_ReaderModule_swigregister
Interface_ReaderModule_swigregister(Interface_ReaderModule)

class Interface_ReportEntity(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CCheck(self, *args) -> "opencascade::handle< Interface_Check > &":
        """
        * Returns the stored Check in order to change it
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Interface.Interface_ReportEntity_CCheck(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        * Returns the stored Check
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _Interface.Interface_ReportEntity_Check(self, *args)


    def Concerned(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns the stored Concerned Entity. It equates the Content in the case of an Unknown Entity
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_ReportEntity_Concerned(self, *args)


    def Content(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns the stored Content, or a Null Handle Remark that it must be an 'Unknown Entity' suitable for the norm of the containing Model
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_ReportEntity_Content(self, *args)


    def HasContent(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a Content is stored (it can equate Concerned)
        	:rtype: bool
        """
        return _Interface.Interface_ReportEntity_HasContent(self, *args)


    def HasNewContent(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a Content is stored AND differs from Concerned (i.e. redefines content) : used when Concerned could not be loaded
        	:rtype: bool
        """
        return _Interface.Interface_ReportEntity_HasNewContent(self, *args)


    def __init__(self, *args):
        """
        * Creates a ReportEntity for an Unknown Entity : Check is empty, and Concerned equates Content (i.e. the Unknown Entity)
        	:param unknown:
        	:type unknown: Standard_Transient
        	:rtype: None
        * Creates a ReportEntity with its features : - <acheck> is the Check to be memorised - <concerned> is the Entity to which the Check is bound Later, a Content can be set : it is required for an Error
        	:param acheck:
        	:type acheck: Interface_Check
        	:param concerned:
        	:type concerned: Standard_Transient
        	:rtype: None
        """
        _Interface.Interface_ReportEntity_swiginit(self, _Interface.new_Interface_ReportEntity(*args))

    def IsError(self, *args) -> "Standard_Boolean":
        """
        * Returns True for an Error Entity, i.e. if the Check brings at least one Fail message
        	:rtype: bool
        """
        return _Interface.Interface_ReportEntity_IsError(self, *args)


    def IsUnknown(self, *args) -> "Standard_Boolean":
        """
        * Returns True for an Unknown Entity, i,e. if the Check is empty and Concerned equates Content
        	:rtype: bool
        """
        return _Interface.Interface_ReportEntity_IsUnknown(self, *args)


    def SetContent(self, *args) -> "void":
        """
        * Sets a Content : it brings non interpreted data which belong to the Concerned Entity. It can be empty then loaded later. Remark that for an Unknown Entity, Content is set by Create.
        	:param content:
        	:type content: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_ReportEntity_SetContent(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_ReportEntity_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ReportEntity
Interface_ReportEntity.CCheck = new_instancemethod(_Interface.Interface_ReportEntity_CCheck, None, Interface_ReportEntity)
Interface_ReportEntity.Check = new_instancemethod(_Interface.Interface_ReportEntity_Check, None, Interface_ReportEntity)
Interface_ReportEntity.Concerned = new_instancemethod(_Interface.Interface_ReportEntity_Concerned, None, Interface_ReportEntity)
Interface_ReportEntity.Content = new_instancemethod(_Interface.Interface_ReportEntity_Content, None, Interface_ReportEntity)
Interface_ReportEntity.HasContent = new_instancemethod(_Interface.Interface_ReportEntity_HasContent, None, Interface_ReportEntity)
Interface_ReportEntity.HasNewContent = new_instancemethod(_Interface.Interface_ReportEntity_HasNewContent, None, Interface_ReportEntity)
Interface_ReportEntity.IsError = new_instancemethod(_Interface.Interface_ReportEntity_IsError, None, Interface_ReportEntity)
Interface_ReportEntity.IsUnknown = new_instancemethod(_Interface.Interface_ReportEntity_IsUnknown, None, Interface_ReportEntity)
Interface_ReportEntity.SetContent = new_instancemethod(_Interface.Interface_ReportEntity_SetContent, None, Interface_ReportEntity)
Interface_ReportEntity_swigregister = _Interface.Interface_ReportEntity_swigregister
Interface_ReportEntity_swigregister(Interface_ReportEntity)

class Interface_STAT(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddPhase(self, *args) -> "void":
        """
        * Adds a new phase to the description. The first one after Create replaces the default unique one
        	:param weight:
        	:type weight: float
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _Interface.Interface_STAT_AddPhase(self, *args)


    def AddStep(self, *args) -> "void":
        """
        * Adds a new step for the last added phase, the default unique one if no AddPhase has already been added Warning : AddStep before the first AddPhase are cancelled
        	:param weight: default value is 1
        	:type weight: float
        	:rtype: None
        """
        return _Interface.Interface_STAT_AddStep(self, *args)


    def Description(self, *args) -> "void":
        """
        * Returns global description (cumulated weights of all phases, count of phases,1 for default, and title)
        	:param nbphases:
        	:type nbphases: int
        	:param total:
        	:type total: float
        	:param title:
        	:type title: char *
        	:rtype: None
        """
        return _Interface.Interface_STAT_Description(self, *args)


    def End(*args) -> "void":
        """
        * Commands to declare the process ended (hence, advancement is forced to 100 %)
        	:rtype: void
        """
        return _Interface.Interface_STAT_End(*args)

    End = staticmethod(End)

    def __init__(self, *args):
        """
        * Creates a STAT form. At start, one default phase is defined, with one default step. Then, it suffises to start with a count of items (and cycles if several) then record items, to have a queryable report.
        	:param title: default value is 
        	:type title: char *
        	:rtype: None
        * used when starting
        	:param other:
        	:type other: Interface_STAT
        	:rtype: None
        """
        _Interface.Interface_STAT_swiginit(self, _Interface.new_Interface_STAT(*args))

    def Internals(self, *args) -> "void":
        """
        * Returns fields in once, without copying them, used for copy when starting
        	:param tit:
        	:type tit: TCollection_HAsciiString
        	:param total:
        	:type total: float
        	:param phn:
        	:type phn: TColStd_HSequenceOfAsciiString
        	:param phw:
        	:type phw: TColStd_HSequenceOfReal
        	:param phdeb:
        	:type phdeb: TColStd_HSequenceOfInteger
        	:param phfin:
        	:type phfin: TColStd_HSequenceOfInteger
        	:param stw:
        	:type stw: TColStd_HSequenceOfReal
        	:rtype: None
        """
        return _Interface.Interface_STAT_Internals(self, *args)


    def NextCycle(*args) -> "void":
        """
        * Commands to resume the preceeding cycle and start a new one, with a count of items Ignored if count of cycles is already passed Then, first step is started (or default one) NextItem can be called for the first step, or NextStep to pass to the next one
        	:param items:
        	:type items: int
        	:rtype: void
        """
        return _Interface.Interface_STAT_NextCycle(*args)

    NextCycle = staticmethod(NextCycle)

    def NextItem(*args) -> "void":
        """
        * Commands to add an item in the current step of the current cycle of the current phase By default, one item per call, can be overpassed Ignored if count of items of this cycle is already passed
        	:param nbitems: default value is 1
        	:type nbitems: int
        	:rtype: void
        """
        return _Interface.Interface_STAT_NextItem(*args)

    NextItem = staticmethod(NextItem)

    def NextPhase(*args) -> "void":
        """
        * Commands to resume the preceeding phase and start a new one <items> and <cycles> as for Start, but for this new phase Ignored if count of phases is already passed If <cycles> is more than one, the first Cycle must then be started by NextCycle (NextStep/NextItem are ignored). If it is one, NextItem/NextStep can then be called
        	:param items:
        	:type items: int
        	:param cycles: default value is 1
        	:type cycles: int
        	:rtype: void
        """
        return _Interface.Interface_STAT_NextPhase(*args)

    NextPhase = staticmethod(NextPhase)

    def NextStep(*args) -> "void":
        """
        * Commands to resume the preceeding step of the cycle Ignored if count of steps is already passed NextItem can be called for this step, NextStep passes to next
        	:rtype: void
        """
        return _Interface.Interface_STAT_NextStep(*args)

    NextStep = staticmethod(NextStep)

    def Percent(*args) -> "Standard_Integer":
        """
        * Returns the advancement as a percentage : <phase> True : inside the current phase <phase> False (D) : relative to the whole process
        	:param phase: default value is Standard_False
        	:type phase: bool
        	:rtype: int
        """
        return _Interface.Interface_STAT_Percent(*args)

    Percent = staticmethod(Percent)

    def Phase(self, *args) -> "void":
        """
        * Returns description of a phase, given its rank (n0 for first step, count of steps, default gives one; weight, name)
        	:param num:
        	:type num: int
        	:param n0step:
        	:type n0step: int
        	:param nbstep:
        	:type nbstep: int
        	:param weight:
        	:type weight: float
        	:param name:
        	:type name: char *
        	:rtype: None
        """
        return _Interface.Interface_STAT_Phase(self, *args)


    def SetPhase(*args) -> "void":
        """
        * Changes the parameters of the phase to start To be used before first counting (i.e. just after NextPhase) Can be used by an operator which has to reajust counts on run
        	:param items:
        	:type items: int
        	:param cycles: default value is 1
        	:type cycles: int
        	:rtype: void
        """
        return _Interface.Interface_STAT_SetPhase(*args)

    SetPhase = staticmethod(SetPhase)

    def Start(self, *args) -> "void":
        """
        * Starts a STAT on its first phase (or its default one) <items> gives the total count of items, <cycles> the count of cycles If <cycles> is more than one, the first Cycle must then be started by NextCycle (NextStep/NextItem are ignored). If it is one, NextItem/NextStep can then be called
        	:param items:
        	:type items: int
        	:param cycles: default value is 1
        	:type cycles: int
        	:rtype: None
        """
        return _Interface.Interface_STAT_Start(self, *args)


    def StartCount(*args) -> "void":
        """
        * Starts a default STAT, with no phase, no step, ready to just count items. <items> gives the total count of items Hence, NextItem is available to directly count
        	:param items:
        	:type items: int
        	:param title: default value is 
        	:type title: char *
        	:rtype: void
        """
        return _Interface.Interface_STAT_StartCount(*args)

    StartCount = staticmethod(StartCount)

    def Step(self, *args) -> "Standard_Real":
        """
        * Returns weight of a Step, related to the cumul given for the phase. <num> is given by <n0step> + i, i between 1 and <nbsteps> (default gives n0step < 0 then weight is one)
        	:param num:
        	:type num: int
        	:rtype: float
        """
        return _Interface.Interface_STAT_Step(self, *args)


    def Where(*args) -> "char const *":
        """
        * Returns an identification of the STAT : <phase> True (D) : the name of the current phase <phase> False : the title of the current STAT
        	:param phase: default value is Standard_True
        	:type phase: bool
        	:rtype: char *
        """
        return _Interface.Interface_STAT_Where(*args)

    Where = staticmethod(Where)

    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_STAT
Interface_STAT.AddPhase = new_instancemethod(_Interface.Interface_STAT_AddPhase, None, Interface_STAT)
Interface_STAT.AddStep = new_instancemethod(_Interface.Interface_STAT_AddStep, None, Interface_STAT)
Interface_STAT.Description = new_instancemethod(_Interface.Interface_STAT_Description, None, Interface_STAT)
Interface_STAT.Internals = new_instancemethod(_Interface.Interface_STAT_Internals, None, Interface_STAT)
Interface_STAT.Phase = new_instancemethod(_Interface.Interface_STAT_Phase, None, Interface_STAT)
Interface_STAT.Start = new_instancemethod(_Interface.Interface_STAT_Start, None, Interface_STAT)
Interface_STAT.Step = new_instancemethod(_Interface.Interface_STAT_Step, None, Interface_STAT)
Interface_STAT_swigregister = _Interface.Interface_STAT_swigregister
Interface_STAT_swigregister(Interface_STAT)

def Interface_STAT_End(*args) -> "void":
    """
    * Commands to declare the process ended (hence, advancement is forced to 100 %)
    	:rtype: void
    """
    return _Interface.Interface_STAT_End(*args)

def Interface_STAT_NextCycle(*args) -> "void":
    """
    * Commands to resume the preceeding cycle and start a new one, with a count of items Ignored if count of cycles is already passed Then, first step is started (or default one) NextItem can be called for the first step, or NextStep to pass to the next one
    	:param items:
    	:type items: int
    	:rtype: void
    """
    return _Interface.Interface_STAT_NextCycle(*args)

def Interface_STAT_NextItem(*args) -> "void":
    """
    * Commands to add an item in the current step of the current cycle of the current phase By default, one item per call, can be overpassed Ignored if count of items of this cycle is already passed
    	:param nbitems: default value is 1
    	:type nbitems: int
    	:rtype: void
    """
    return _Interface.Interface_STAT_NextItem(*args)

def Interface_STAT_NextPhase(*args) -> "void":
    """
    * Commands to resume the preceeding phase and start a new one <items> and <cycles> as for Start, but for this new phase Ignored if count of phases is already passed If <cycles> is more than one, the first Cycle must then be started by NextCycle (NextStep/NextItem are ignored). If it is one, NextItem/NextStep can then be called
    	:param items:
    	:type items: int
    	:param cycles: default value is 1
    	:type cycles: int
    	:rtype: void
    """
    return _Interface.Interface_STAT_NextPhase(*args)

def Interface_STAT_NextStep(*args) -> "void":
    """
    * Commands to resume the preceeding step of the cycle Ignored if count of steps is already passed NextItem can be called for this step, NextStep passes to next
    	:rtype: void
    """
    return _Interface.Interface_STAT_NextStep(*args)

def Interface_STAT_Percent(*args) -> "Standard_Integer":
    """
    * Returns the advancement as a percentage : <phase> True : inside the current phase <phase> False (D) : relative to the whole process
    	:param phase: default value is Standard_False
    	:type phase: bool
    	:rtype: int
    """
    return _Interface.Interface_STAT_Percent(*args)

def Interface_STAT_SetPhase(*args) -> "void":
    """
    * Changes the parameters of the phase to start To be used before first counting (i.e. just after NextPhase) Can be used by an operator which has to reajust counts on run
    	:param items:
    	:type items: int
    	:param cycles: default value is 1
    	:type cycles: int
    	:rtype: void
    """
    return _Interface.Interface_STAT_SetPhase(*args)

def Interface_STAT_StartCount(*args) -> "void":
    """
    * Starts a default STAT, with no phase, no step, ready to just count items. <items> gives the total count of items Hence, NextItem is available to directly count
    	:param items:
    	:type items: int
    	:param title: default value is 
    	:type title: char *
    	:rtype: void
    """
    return _Interface.Interface_STAT_StartCount(*args)

def Interface_STAT_Where(*args) -> "char const *":
    """
    * Returns an identification of the STAT : <phase> True (D) : the name of the current phase <phase> False : the title of the current STAT
    	:param phase: default value is Standard_True
    	:type phase: bool
    	:rtype: char *
    """
    return _Interface.Interface_STAT_Where(*args)

class Interface_ShareFlags(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a ShareFlags from a Model and builds required data (flags) by calling the General Service Library given as argument <lib>
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param lib:
        	:type lib: Interface_GeneralLib
        	:rtype: None
        * Same as above, but GeneralLib is detained by a GTool
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param gtool:
        	:type gtool: Interface_GTool
        	:rtype: None
        * Same as above, but GeneralLib is defined through a Protocol
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:rtype: None
        * Same as above, but works with the GTool of the Model
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        * Creates a ShareFlags by querying informations from a Graph (remark that Graph also has a method IsShared)
        	:param agraph:
        	:type agraph: Interface_Graph
        	:rtype: None
        """
        _Interface.Interface_ShareFlags_swiginit(self, _Interface.new_Interface_ShareFlags(*args))

    def IsShared(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <ent> is Shared by one or more other Entity(ies) of the Model
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_ShareFlags_IsShared(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the Model used for the evaluation
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_ShareFlags_Model(self, *args)


    def NbRoots(self, *args) -> "Standard_Integer":
        """
        * Returns the count of root entities
        	:rtype: int
        """
        return _Interface.Interface_ShareFlags_NbRoots(self, *args)


    def Root(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns a root entity according its rank in the list of roots By default, it returns the first one
        	:param num: default value is 1
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_ShareFlags_Root(self, *args)


    def RootEntities(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the Entities which are not Shared (see their flags)
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_ShareFlags_RootEntities(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ShareFlags
Interface_ShareFlags.IsShared = new_instancemethod(_Interface.Interface_ShareFlags_IsShared, None, Interface_ShareFlags)
Interface_ShareFlags.Model = new_instancemethod(_Interface.Interface_ShareFlags_Model, None, Interface_ShareFlags)
Interface_ShareFlags.NbRoots = new_instancemethod(_Interface.Interface_ShareFlags_NbRoots, None, Interface_ShareFlags)
Interface_ShareFlags.Root = new_instancemethod(_Interface.Interface_ShareFlags_Root, None, Interface_ShareFlags)
Interface_ShareFlags.RootEntities = new_instancemethod(_Interface.Interface_ShareFlags_RootEntities, None, Interface_ShareFlags)
Interface_ShareFlags_swigregister = _Interface.Interface_ShareFlags_swigregister
Interface_ShareFlags_swigregister(Interface_ShareFlags)

class Interface_ShareTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def All(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the complete list of entities shared by <ent> at any level, including <ent> itself If <ent> is the Model, considers the concatenation of AllShared for each root If <rootlast> is True (D), the list starts with lower level entities and ends by the root. Else, the root is first and the lower level entities are at end
        	:param ent:
        	:type ent: Standard_Transient
        	:param rootlast: default value is Standard_True
        	:type rootlast: bool
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_ShareTool_All(self, *args)


    def Graph(self, *args) -> "Interface_Graph const &":
        """
        * Returns the data used by the ShareTool to work Can then be used directly (read only)
        	:rtype: Interface_Graph
        """
        return _Interface.Interface_ShareTool_Graph(self, *args)


    def __init__(self, *args):
        """
        * Creates a ShareTool from a Model and builds all required data, by calling the General Service Library and Modules (GeneralLib given as an argument)
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param lib:
        	:type lib: Interface_GeneralLib
        	:rtype: None
        * Same a above, but GeneralLib is detained by a GTool
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param gtool:
        	:type gtool: Interface_GTool
        	:rtype: None
        * Same a above, but GeneralLib is defined through a Protocol Protocol is used to build the working library
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:param protocol:
        	:type protocol: Interface_Protocol
        	:rtype: None
        * Same as above, but works with the GTool of the Model
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        * Creates a ShareTool from an already defined Graph Remark that the data of the Graph are copied
        	:param agraph:
        	:type agraph: Interface_Graph
        	:rtype: None
        * Completes the Graph by Adding Implied References. Hence, they are considered as Sharing References in all the other queries
        	:param ahgraph:
        	:type ahgraph: Interface_HGraph
        	:rtype: None
        """
        _Interface.Interface_ShareTool_swiginit(self, _Interface.new_Interface_ShareTool(*args))

    def IsShared(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <ent> is Shared by other Entities in the Model
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _Interface.Interface_ShareTool_IsShared(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the Model used for Creation (directly or for Graph)
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_ShareTool_Model(self, *args)


    def NbTypedSharings(self, *args) -> "Standard_Integer":
        """
        * Returns the count of Sharing Entities of an Entity, which are Kind of a given Type
        	:param ent:
        	:type ent: Standard_Transient
        	:param atype:
        	:type atype: Standard_Type
        	:rtype: int
        """
        return _Interface.Interface_ShareTool_NbTypedSharings(self, *args)


    def Print(self, *args) -> "void":
        """
        * Utility method which Prints the content of an iterator (by their Numbers)
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:param S:
        	:type S: Message_Messenger
        	:rtype: None
        """
        return _Interface.Interface_ShareTool_Print(self, *args)


    def RootEntities(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the Entities which are not Shared (their Sharing List is empty) in the Model
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_ShareTool_RootEntities(self, *args)


    def Shareds(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the List of Entities Shared by a given Entity <ent>
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_ShareTool_Shareds(self, *args)


    def Sharings(self, *args) -> "Interface_EntityIterator":
        """
        * Returns the List of Entities Sharing a given Entity <ent>
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_ShareTool_Sharings(self, *args)


    def TypedSharing(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns the Sharing Entity of an Entity, which is Kind of a given Type. Allows to access a Sharing Entity of a given type when there is one and only one (current case)
        	:param ent:
        	:type ent: Standard_Transient
        	:param atype:
        	:type atype: Standard_Type
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_ShareTool_TypedSharing(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ShareTool
Interface_ShareTool.All = new_instancemethod(_Interface.Interface_ShareTool_All, None, Interface_ShareTool)
Interface_ShareTool.Graph = new_instancemethod(_Interface.Interface_ShareTool_Graph, None, Interface_ShareTool)
Interface_ShareTool.IsShared = new_instancemethod(_Interface.Interface_ShareTool_IsShared, None, Interface_ShareTool)
Interface_ShareTool.Model = new_instancemethod(_Interface.Interface_ShareTool_Model, None, Interface_ShareTool)
Interface_ShareTool.NbTypedSharings = new_instancemethod(_Interface.Interface_ShareTool_NbTypedSharings, None, Interface_ShareTool)
Interface_ShareTool.Print = new_instancemethod(_Interface.Interface_ShareTool_Print, None, Interface_ShareTool)
Interface_ShareTool.RootEntities = new_instancemethod(_Interface.Interface_ShareTool_RootEntities, None, Interface_ShareTool)
Interface_ShareTool.Shareds = new_instancemethod(_Interface.Interface_ShareTool_Shareds, None, Interface_ShareTool)
Interface_ShareTool.Sharings = new_instancemethod(_Interface.Interface_ShareTool_Sharings, None, Interface_ShareTool)
Interface_ShareTool.TypedSharing = new_instancemethod(_Interface.Interface_ShareTool_TypedSharing, None, Interface_ShareTool)
Interface_ShareTool_swigregister = _Interface.Interface_ShareTool_swigregister
Interface_ShareTool_swigregister(Interface_ShareTool)

class Interface_SignLabel(OCC.Core.MoniTool.MoniTool_SignText):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _Interface.Interface_SignLabel_swiginit(self, _Interface.new_Interface_SignLabel(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Interface_SignLabel_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_SignLabel
Interface_SignLabel_swigregister = _Interface.Interface_SignLabel_swigregister
Interface_SignLabel_swigregister(Interface_SignLabel)

class Interface_SignType(OCC.Core.MoniTool.MoniTool_SignText):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ClassName(*args) -> "char const *":
        """
        * From a CDL Type Name, returns the Class part (package dropped) WARNING : buffered, to be immediately copied or printed
        	:param typnam:
        	:type typnam: char *
        	:rtype: char *
        """
        return _Interface.Interface_SignType_ClassName(*args)

    ClassName = staticmethod(ClassName)

    def Value(self, *args) -> "char const *":
        """
        * Returns the Signature for a Transient object. It is specific of each sub-class of Signature. For a Null Handle, it should provide '' It can work with the model which contains the entity
        	:param ent:
        	:type ent: Standard_Transient
        	:param model:
        	:type model: Interface_InterfaceModel
        	:rtype: char *
        """
        return _Interface.Interface_SignType_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_SignType_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_SignType
Interface_SignType.Value = new_instancemethod(_Interface.Interface_SignType_Value, None, Interface_SignType)
Interface_SignType_swigregister = _Interface.Interface_SignType_swigregister
Interface_SignType_swigregister(Interface_SignType)

def Interface_SignType_ClassName(*args) -> "char const *":
    """
    * From a CDL Type Name, returns the Class part (package dropped) WARNING : buffered, to be immediately copied or printed
    	:param typnam:
    	:type typnam: char *
    	:rtype: char *
    """
    return _Interface.Interface_SignType_ClassName(*args)

class Interface_TypedValue(OCC.Core.MoniTool.MoniTool_TypedValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a TypedValue, with a name //! type gives the type of the parameter, default is free text Also available : Integer, Real, Enum, Entity (i.e. Object) More precise specifications, titles, can be given to the TypedValue once created //! init gives an initial value. If it is not given, the TypedValue begins as 'not set', its value is empty
        	:param name:
        	:type name: char *
        	:param type: default value is Interface_ParamText
        	:type type: Interface_ParamType
        	:param init: default value is 
        	:type init: char *
        	:rtype: None
        """
        _Interface.Interface_TypedValue_swiginit(self, _Interface.new_Interface_TypedValue(*args))

    def ParamTypeToValueType(*args) -> "MoniTool_ValueType":
        """
        * Correspondance ParamType from Interface to ValueType from MoniTool
        	:param typ:
        	:type typ: Interface_ParamType
        	:rtype: MoniTool_ValueType
        """
        return _Interface.Interface_TypedValue_ParamTypeToValueType(*args)

    ParamTypeToValueType = staticmethod(ParamTypeToValueType)

    def Type(self, *args) -> "Interface_ParamType":
        """
        * Returns the type I.E. calls ValueType then makes correspondance between ParamType from Interface (which remains for compatibility reasons) and ValueType from MoniTool
        	:rtype: Interface_ParamType
        """
        return _Interface.Interface_TypedValue_Type(self, *args)


    def ValueTypeToParamType(*args) -> "Interface_ParamType":
        """
        * Correspondance ParamType from Interface to ValueType from MoniTool
        	:param typ:
        	:type typ: MoniTool_ValueType
        	:rtype: Interface_ParamType
        """
        return _Interface.Interface_TypedValue_ValueTypeToParamType(*args)

    ValueTypeToParamType = staticmethod(ValueTypeToParamType)


    @staticmethod
    def DownCast(t):
      return Handle_Interface_TypedValue_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_TypedValue
Interface_TypedValue.Type = new_instancemethod(_Interface.Interface_TypedValue_Type, None, Interface_TypedValue)
Interface_TypedValue_swigregister = _Interface.Interface_TypedValue_swigregister
Interface_TypedValue_swigregister(Interface_TypedValue)

def Interface_TypedValue_ParamTypeToValueType(*args) -> "MoniTool_ValueType":
    """
    * Correspondance ParamType from Interface to ValueType from MoniTool
    	:param typ:
    	:type typ: Interface_ParamType
    	:rtype: MoniTool_ValueType
    """
    return _Interface.Interface_TypedValue_ParamTypeToValueType(*args)

def Interface_TypedValue_ValueTypeToParamType(*args) -> "Interface_ParamType":
    """
    * Correspondance ParamType from Interface to ValueType from MoniTool
    	:param typ:
    	:type typ: MoniTool_ValueType
    	:rtype: Interface_ParamType
    """
    return _Interface.Interface_TypedValue_ValueTypeToParamType(*args)

class Interface_UndefinedContent(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddEntity(self, *args) -> "void":
        """
        * Adds a Parameter which references an Entity
        	:param ptype:
        	:type ptype: Interface_ParamType
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_UndefinedContent_AddEntity(self, *args)


    def AddLiteral(self, *args) -> "void":
        """
        * Adds a literal Parameter to the list
        	:param ptype:
        	:type ptype: Interface_ParamType
        	:param val:
        	:type val: TCollection_HAsciiString
        	:rtype: None
        """
        return _Interface.Interface_UndefinedContent_AddLiteral(self, *args)


    def EntityList(self, *args) -> "Interface_EntityList":
        """
        * Returns globally the list of param entities. Note that it can be used as shared entity list for the UndefinedEntity
        	:rtype: Interface_EntityList
        """
        return _Interface.Interface_UndefinedContent_EntityList(self, *args)


    def GetFromAnother(self, *args) -> "void":
        """
        * Copies contents of undefined entities; deigned to be called by GetFromAnother method from Undefined entity of each Interface (the basic operation is the same regardless the norm)
        	:param other:
        	:type other: Interface_UndefinedContent
        	:param TC:
        	:type TC: Interface_CopyTool
        	:rtype: None
        """
        return _Interface.Interface_UndefinedContent_GetFromAnother(self, *args)


    def __init__(self, *args):
        """
        * Defines an empty UndefinedContent
        	:rtype: None
        """
        _Interface.Interface_UndefinedContent_swiginit(self, _Interface.new_Interface_UndefinedContent(*args))

    def IsParamEntity(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a Parameter is recorded as an entity Error if num is not between 1 and NbParams
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _Interface.Interface_UndefinedContent_IsParamEntity(self, *args)


    def NbLiterals(self, *args) -> "Standard_Integer":
        """
        * Gives count of Literal Parameters
        	:rtype: int
        """
        return _Interface.Interface_UndefinedContent_NbLiterals(self, *args)


    def NbParams(self, *args) -> "Standard_Integer":
        """
        * Gives count of recorded parameters
        	:rtype: int
        """
        return _Interface.Interface_UndefinedContent_NbParams(self, *args)


    def ParamData(self, *args) -> "Standard_Boolean":
        """
        * Returns data of a Parameter : its type, and the entity if it designates en entity ('ent') or its literal value else ('str') Returned value (Boolean) : True if it is an Entity, False else
        	:param num:
        	:type num: int
        	:param ptype:
        	:type ptype: Interface_ParamType
        	:param ent:
        	:type ent: Standard_Transient
        	:param val:
        	:type val: TCollection_HAsciiString
        	:rtype: bool
        """
        return _Interface.Interface_UndefinedContent_ParamData(self, *args)


    def ParamEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns Entity corresponding to a Param, given its rank
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _Interface.Interface_UndefinedContent_ParamEntity(self, *args)


    def ParamType(self, *args) -> "Interface_ParamType":
        """
        * Returns the ParamType of a Param, given its rank Error if num is not between 1 and NbParams
        	:param num:
        	:type num: int
        	:rtype: Interface_ParamType
        """
        return _Interface.Interface_UndefinedContent_ParamType(self, *args)


    def ParamValue(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        * Returns litteral value of a Parameter, given its rank
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _Interface.Interface_UndefinedContent_ParamValue(self, *args)


    def RemoveParam(self, *args) -> "void":
        """
        * Removes a Parameter given its rank
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _Interface.Interface_UndefinedContent_RemoveParam(self, *args)


    def Reservate(self, *args) -> "void":
        """
        * Manages reservation for parameters (internal use) (nb : total count of parameters, nblit : count of literals)
        	:param nb:
        	:type nb: int
        	:param nblit:
        	:type nblit: int
        	:rtype: None
        """
        return _Interface.Interface_UndefinedContent_Reservate(self, *args)


    def SetEntity(self, *args) -> "void":
        """
        * Sets a new value for the Parameter <num>, to reference an Entity. To simply change the Entity, see the variant below
        	:param num:
        	:type num: int
        	:param ptype:
        	:type ptype: Interface_ParamType
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        * Changes the Entity referenced by the Parameter <num> (with same ParamType)
        	:param num:
        	:type num: int
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _Interface.Interface_UndefinedContent_SetEntity(self, *args)


    def SetLiteral(self, *args) -> "void":
        """
        * Sets a new value for the Parameter <num>, to a literal value (if it referenced formerly an Entity, this Entity is removed)
        	:param num:
        	:type num: int
        	:param ptype:
        	:type ptype: Interface_ParamType
        	:param val:
        	:type val: TCollection_HAsciiString
        	:rtype: None
        """
        return _Interface.Interface_UndefinedContent_SetLiteral(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_UndefinedContent_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_UndefinedContent
Interface_UndefinedContent.AddEntity = new_instancemethod(_Interface.Interface_UndefinedContent_AddEntity, None, Interface_UndefinedContent)
Interface_UndefinedContent.AddLiteral = new_instancemethod(_Interface.Interface_UndefinedContent_AddLiteral, None, Interface_UndefinedContent)
Interface_UndefinedContent.EntityList = new_instancemethod(_Interface.Interface_UndefinedContent_EntityList, None, Interface_UndefinedContent)
Interface_UndefinedContent.GetFromAnother = new_instancemethod(_Interface.Interface_UndefinedContent_GetFromAnother, None, Interface_UndefinedContent)
Interface_UndefinedContent.IsParamEntity = new_instancemethod(_Interface.Interface_UndefinedContent_IsParamEntity, None, Interface_UndefinedContent)
Interface_UndefinedContent.NbLiterals = new_instancemethod(_Interface.Interface_UndefinedContent_NbLiterals, None, Interface_UndefinedContent)
Interface_UndefinedContent.NbParams = new_instancemethod(_Interface.Interface_UndefinedContent_NbParams, None, Interface_UndefinedContent)
Interface_UndefinedContent.ParamData = new_instancemethod(_Interface.Interface_UndefinedContent_ParamData, None, Interface_UndefinedContent)
Interface_UndefinedContent.ParamEntity = new_instancemethod(_Interface.Interface_UndefinedContent_ParamEntity, None, Interface_UndefinedContent)
Interface_UndefinedContent.ParamType = new_instancemethod(_Interface.Interface_UndefinedContent_ParamType, None, Interface_UndefinedContent)
Interface_UndefinedContent.ParamValue = new_instancemethod(_Interface.Interface_UndefinedContent_ParamValue, None, Interface_UndefinedContent)
Interface_UndefinedContent.RemoveParam = new_instancemethod(_Interface.Interface_UndefinedContent_RemoveParam, None, Interface_UndefinedContent)
Interface_UndefinedContent.Reservate = new_instancemethod(_Interface.Interface_UndefinedContent_Reservate, None, Interface_UndefinedContent)
Interface_UndefinedContent.SetEntity = new_instancemethod(_Interface.Interface_UndefinedContent_SetEntity, None, Interface_UndefinedContent)
Interface_UndefinedContent.SetLiteral = new_instancemethod(_Interface.Interface_UndefinedContent_SetLiteral, None, Interface_UndefinedContent)
Interface_UndefinedContent_swigregister = _Interface.Interface_UndefinedContent_swigregister
Interface_UndefinedContent_swigregister(Interface_UndefinedContent)

class Interface_CopyMap(Interface_CopyControl):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a CopyMap adapted to work from a Model
        	:param amodel:
        	:type amodel: Interface_InterfaceModel
        	:rtype: None
        """
        _Interface.Interface_CopyMap_swiginit(self, _Interface.new_Interface_CopyMap(*args))

    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        * Returns the InterfaceModel used at Creation time
        	:rtype: opencascade::handle<Interface_InterfaceModel>
        """
        return _Interface.Interface_CopyMap_Model(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_CopyMap_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CopyMap
Interface_CopyMap.Model = new_instancemethod(_Interface.Interface_CopyMap_Model, None, Interface_CopyMap)
Interface_CopyMap_swigregister = _Interface.Interface_CopyMap_swigregister
Interface_CopyMap_swigregister(Interface_CopyMap)

class Interface_GraphContent(Interface_EntityIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Begin(self, *args) -> "void":
        """
        * Does the Evaluation before starting the iteration itself (in out)
        	:rtype: None
        """
        return _Interface.Interface_GraphContent_Begin(self, *args)


    def Evaluate(self, *args) -> "void":
        """
        * Evaluates list of Entities to be iterated. Called by Start Default is set to doing nothing : intended to be redefined by each sub-class
        	:rtype: void
        """
        return _Interface.Interface_GraphContent_Evaluate(self, *args)


    def GetFromGraph(self, *args) -> "void":
        """
        * Gets all Entities designated by a Graph (once created), adds them to those already recorded
        	:param agraph:
        	:type agraph: Interface_Graph
        	:rtype: None
        * Gets entities from a graph which have a specific Status value (one created), adds them to those already recorded
        	:param agraph:
        	:type agraph: Interface_Graph
        	:param stat:
        	:type stat: int
        	:rtype: None
        """
        return _Interface.Interface_GraphContent_GetFromGraph(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty GraphContent, ready to be filled
        	:rtype: None
        * Creates with all entities designated by a Graph
        	:param agraph:
        	:type agraph: Interface_Graph
        	:rtype: None
        * Creates with entities having specific Status value in a Graph
        	:param agraph:
        	:type agraph: Interface_Graph
        	:param stat:
        	:type stat: int
        	:rtype: None
        * Creates an Iterator with Shared entities of an entity (equivalente to EntityIterator but with a Graph)
        	:param agraph:
        	:type agraph: Interface_Graph
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        _Interface.Interface_GraphContent_swiginit(self, _Interface.new_Interface_GraphContent(*args))

    def Result(self, *args) -> "Interface_EntityIterator":
        """
        * Returns Result under the exact form of an EntityIterator : Can be used when EntityIterator itself is required (as a returned value for instance), whitout way for a sub-class
        	:rtype: Interface_EntityIterator
        """
        return _Interface.Interface_GraphContent_Result(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GraphContent
Interface_GraphContent.Begin = new_instancemethod(_Interface.Interface_GraphContent_Begin, None, Interface_GraphContent)
Interface_GraphContent.Evaluate = new_instancemethod(_Interface.Interface_GraphContent_Evaluate, None, Interface_GraphContent)
Interface_GraphContent.GetFromGraph = new_instancemethod(_Interface.Interface_GraphContent_GetFromGraph, None, Interface_GraphContent)
Interface_GraphContent.Result = new_instancemethod(_Interface.Interface_GraphContent_Result, None, Interface_GraphContent)
Interface_GraphContent_swigregister = _Interface.Interface_GraphContent_swigregister
Interface_GraphContent_swigregister(Interface_GraphContent)

class Interface_Static(Interface_TypedValue):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CDef(*args) -> "char const *":
        """
        * Returns a part of the definition of a Static, as a CString The part is designated by its name, as a CString If the required value is not a string, it is converted to a CString then returned If <name> is not present, or <part> not defined for <name>, this function returns an empty string //! Allowed parts for CDef : family : the family type : the type ('integer','real','text','enum') label : the label satis : satisfy function name if any rmin : minimum real value rmax : maximum real value imin : minimum integer value imax : maximum integer value enum nn (nn : value of an integer) : enum value for nn unit : unit definition for a real
        	:param name:
        	:type name: char *
        	:param part:
        	:type part: char *
        	:rtype: char *
        """
        return _Interface.Interface_Static_CDef(*args)

    CDef = staticmethod(CDef)

    def CVal(*args) -> "char const *":
        """
        * Returns the value of the parameter identified by the string name. If the specified parameter does not exist, an empty string is returned. Example Interface_Static::CVal('write.step.schema'); which could return: 'AP214'
        	:param name:
        	:type name: char *
        	:rtype: char *
        """
        return _Interface.Interface_Static_CVal(*args)

    CVal = staticmethod(CVal)

    def Family(self, *args) -> "char const *":
        """
        * Returns the family. It can be : a resource name for applis, an internal name between : $e (environment variables), $l (other, purely local)
        	:rtype: char *
        """
        return _Interface.Interface_Static_Family(self, *args)


    def IDef(*args) -> "Standard_Integer":
        """
        * Returns a part of the definition of a Static, as an Integer The part is designated by its name, as a CString If the required value is not a string, returns zero For a Boolean, 0 for false, 1 for true If <name> is not present, or <part> not defined for <name>, this function returns zero //! Allowed parts for IDef : imin, imax : minimum or maximum integer value estart : starting number for enum ecount : count of enum values (starting from estart) ematch : exact match status eval val : case determined from a string
        	:param name:
        	:type name: char *
        	:param part:
        	:type part: char *
        	:rtype: int
        """
        return _Interface.Interface_Static_IDef(*args)

    IDef = staticmethod(IDef)

    def IVal(*args) -> "Standard_Integer":
        """
        * Returns the integer value of the translation parameter identified by the string name. Returns the value 0 if the parameter does not exist. Example Interface_Static::IVal('write.step.schema'); which could return: 3
        	:param name:
        	:type name: char *
        	:rtype: int
        """
        return _Interface.Interface_Static_IVal(*args)

    IVal = staticmethod(IVal)

    def Init(*args) -> "Standard_Boolean":
        """
        * Declares a new Static (by calling its constructor) If this name is already taken, does nothing and returns False Else, creates it and returns True For additional definitions, get the Static then edit it
        	:param family:
        	:type family: char *
        	:param name:
        	:type name: char *
        	:param type:
        	:type type: Interface_ParamType
        	:param init: default value is 
        	:type init: char *
        	:rtype: bool
        * As Init with ParamType, but type is given as a character This allows a simpler call Types : 'i' Integer, 'r' Real, 't' Text, 'e' Enum, 'o' Object '=' for same definition as, <init> gives the initial Static Returns False if <type> does not match this list
        	:param family:
        	:type family: char *
        	:param name:
        	:type name: char *
        	:param type:
        	:type type: Standard_Character
        	:param init: default value is 
        	:type init: char *
        	:rtype: bool
        """
        return _Interface.Interface_Static_Init(*args)

    Init = staticmethod(Init)

    def __init__(self, *args):
        """
        * Creates and records a Static, with a family and a name family can report to a name of ressource or to a system or internal definition. The name must be unique. //! type gives the type of the parameter, default is free text Also available : Integer, Real, Enum, Entity (i.e. Object) More precise specifications, titles, can be given to the Static once created //! init gives an initial value. If it is not given, the Static begin as 'not set', its value is empty
        	:param family:
        	:type family: char *
        	:param name:
        	:type name: char *
        	:param type: default value is Interface_ParamText
        	:type type: Interface_ParamType
        	:param init: default value is 
        	:type init: char *
        	:rtype: None
        * Creates a new Static with same definition as another one (value is copied, except for Entity : it remains null)
        	:param family:
        	:type family: char *
        	:param name:
        	:type name: char *
        	:param other:
        	:type other: Interface_Static
        	:rtype: None
        """
        _Interface.Interface_Static_swiginit(self, _Interface.new_Interface_Static(*args))

    def IsPresent(*args) -> "Standard_Boolean":
        """
        * Returns True if a Static named <name> is present, False else
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _Interface.Interface_Static_IsPresent(*args)

    IsPresent = staticmethod(IsPresent)

    def IsSet(*args) -> "Standard_Boolean":
        """
        * Returns True if <name> is present AND set <proper> True (D) : considers this item only <proper> False : if not set and attached to a wild-card, considers this wild-card
        	:param name:
        	:type name: char *
        	:param proper: default value is Standard_True
        	:type proper: bool
        	:rtype: bool
        """
        return _Interface.Interface_Static_IsSet(*args)

    IsSet = staticmethod(IsSet)

    def IsUpdated(*args) -> "Standard_Boolean":
        """
        * Returns the status 'uptodate' from a Static Returns False if <name> is not present
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _Interface.Interface_Static_IsUpdated(*args)

    IsUpdated = staticmethod(IsUpdated)

    def Items(*args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        * Returns a list of names of statics : <mode> = 0 (D) : criter is for family <mode> = 1 : criter is regexp on names, takes final items (ignore wild cards) <mode> = 2 : idem but take only wilded, not final items <mode> = 3 : idem, take all items matching criter idem + 100 : takes only non-updated items idem + 200 : takes only updated items criter empty (D) : returns all names else returns names which match the given criter Remark : families beginning by '$' are not listed by criter '' they are listed only by criter '$' //! This allows for instance to set new values after having loaded or reloaded a resource, then to update them as required
        	:param mode: default value is 0
        	:type mode: int
        	:param criter: default value is 
        	:type criter: char *
        	:rtype: opencascade::handle<TColStd_HSequenceOfHAsciiString>
        """
        return _Interface.Interface_Static_Items(*args)

    Items = staticmethod(Items)

    def PrintStatic(self, *args) -> "void":
        """
        * Writes the properties of a parameter in the diagnostic file. These include: - Name - Family, - Wildcard (if it has one) - Current status (empty string if it was updated or if it is the original one) - Value
        	:param S:
        	:type S: Message_Messenger
        	:rtype: None
        """
        return _Interface.Interface_Static_PrintStatic(self, *args)


    def RVal(*args) -> "Standard_Real":
        """
        * Returns the value of a static translation parameter identified by the string name. Returns the value 0.0 if the parameter does not exist.
        	:param name:
        	:type name: char *
        	:rtype: float
        """
        return _Interface.Interface_Static_RVal(*args)

    RVal = staticmethod(RVal)

    def SetCVal(*args) -> "Standard_Boolean":
        """
        * Modifies the value of the parameter identified by name. The modification is specified by the string val. false is returned if the parameter does not exist. Example Interface_Static::SetCVal ('write.step.schema','AP203') This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: char *
        	:rtype: bool
        """
        return _Interface.Interface_Static_SetCVal(*args)

    SetCVal = staticmethod(SetCVal)

    def SetIVal(*args) -> "Standard_Boolean":
        """
        * Modifies the value of the parameter identified by name. The modification is specified by the integer value val. false is returned if the parameter does not exist. Example Interface_Static::SetIVal ('write.step.schema', 3) This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.S
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: int
        	:rtype: bool
        """
        return _Interface.Interface_Static_SetIVal(*args)

    SetIVal = staticmethod(SetIVal)

    def SetRVal(*args) -> "Standard_Boolean":
        """
        * Modifies the value of a translation parameter. false is returned if the parameter does not exist. The modification is specified by the real number value val.
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: float
        	:rtype: bool
        """
        return _Interface.Interface_Static_SetRVal(*args)

    SetRVal = staticmethod(SetRVal)

    def SetUptodate(self, *args) -> "void":
        """
        * Records a Static has 'uptodate', i.e. its value has been taken into account by a reinitialisation procedure This flag is reset at each successful SetValue
        	:rtype: None
        """
        return _Interface.Interface_Static_SetUptodate(self, *args)


    def SetWild(self, *args) -> "void":
        """
        * Sets a 'wild-card' static : its value will be considered if <self> is not properly set. (reset by set a null one)
        	:param wildcard:
        	:type wildcard: Interface_Static
        	:rtype: None
        """
        return _Interface.Interface_Static_SetWild(self, *args)


    def Standards(*args) -> "void":
        """
        * Initializes all standard static parameters, which can be used by every function. statics specific of a norm or a function must be defined around it
        	:rtype: void
        """
        return _Interface.Interface_Static_Standards(*args)

    Standards = staticmethod(Standards)

    def Static(*args) -> "opencascade::handle< Interface_Static >":
        """
        * Returns a Static from its name. Null Handle if not present
        	:param name:
        	:type name: char *
        	:rtype: opencascade::handle<Interface_Static>
        """
        return _Interface.Interface_Static_Static(*args)

    Static = staticmethod(Static)

    def Update(*args) -> "Standard_Boolean":
        """
        * Sets a Static to be 'uptodate' Returns False if <name> is not present This status can be used by a reinitialisation procedure to rerun if a value has been changed
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _Interface.Interface_Static_Update(*args)

    Update = staticmethod(Update)

    def UpdatedStatus(self, *args) -> "Standard_Boolean":
        """
        * Returns the status 'uptodate'
        	:rtype: bool
        """
        return _Interface.Interface_Static_UpdatedStatus(self, *args)


    def Wild(self, *args) -> "opencascade::handle< Interface_Static >":
        """
        * Returns the wildcard static, which can be (is most often) null
        	:rtype: opencascade::handle<Interface_Static>
        """
        return _Interface.Interface_Static_Wild(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_Static_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Static
Interface_Static.Family = new_instancemethod(_Interface.Interface_Static_Family, None, Interface_Static)
Interface_Static.PrintStatic = new_instancemethod(_Interface.Interface_Static_PrintStatic, None, Interface_Static)
Interface_Static.SetUptodate = new_instancemethod(_Interface.Interface_Static_SetUptodate, None, Interface_Static)
Interface_Static.SetWild = new_instancemethod(_Interface.Interface_Static_SetWild, None, Interface_Static)
Interface_Static.UpdatedStatus = new_instancemethod(_Interface.Interface_Static_UpdatedStatus, None, Interface_Static)
Interface_Static.Wild = new_instancemethod(_Interface.Interface_Static_Wild, None, Interface_Static)
Interface_Static_swigregister = _Interface.Interface_Static_swigregister
Interface_Static_swigregister(Interface_Static)

def Interface_Static_CDef(*args) -> "char const *":
    """
    * Returns a part of the definition of a Static, as a CString The part is designated by its name, as a CString If the required value is not a string, it is converted to a CString then returned If <name> is not present, or <part> not defined for <name>, this function returns an empty string //! Allowed parts for CDef : family : the family type : the type ('integer','real','text','enum') label : the label satis : satisfy function name if any rmin : minimum real value rmax : maximum real value imin : minimum integer value imax : maximum integer value enum nn (nn : value of an integer) : enum value for nn unit : unit definition for a real
    	:param name:
    	:type name: char *
    	:param part:
    	:type part: char *
    	:rtype: char *
    """
    return _Interface.Interface_Static_CDef(*args)

def Interface_Static_CVal(*args) -> "char const *":
    """
    * Returns the value of the parameter identified by the string name. If the specified parameter does not exist, an empty string is returned. Example Interface_Static::CVal('write.step.schema'); which could return: 'AP214'
    	:param name:
    	:type name: char *
    	:rtype: char *
    """
    return _Interface.Interface_Static_CVal(*args)

def Interface_Static_IDef(*args) -> "Standard_Integer":
    """
    * Returns a part of the definition of a Static, as an Integer The part is designated by its name, as a CString If the required value is not a string, returns zero For a Boolean, 0 for false, 1 for true If <name> is not present, or <part> not defined for <name>, this function returns zero //! Allowed parts for IDef : imin, imax : minimum or maximum integer value estart : starting number for enum ecount : count of enum values (starting from estart) ematch : exact match status eval val : case determined from a string
    	:param name:
    	:type name: char *
    	:param part:
    	:type part: char *
    	:rtype: int
    """
    return _Interface.Interface_Static_IDef(*args)

def Interface_Static_IVal(*args) -> "Standard_Integer":
    """
    * Returns the integer value of the translation parameter identified by the string name. Returns the value 0 if the parameter does not exist. Example Interface_Static::IVal('write.step.schema'); which could return: 3
    	:param name:
    	:type name: char *
    	:rtype: int
    """
    return _Interface.Interface_Static_IVal(*args)

def Interface_Static_Init(*args) -> "Standard_Boolean":
    """
    * Declares a new Static (by calling its constructor) If this name is already taken, does nothing and returns False Else, creates it and returns True For additional definitions, get the Static then edit it
    	:param family:
    	:type family: char *
    	:param name:
    	:type name: char *
    	:param type:
    	:type type: Interface_ParamType
    	:param init: default value is 
    	:type init: char *
    	:rtype: bool
    * As Init with ParamType, but type is given as a character This allows a simpler call Types : 'i' Integer, 'r' Real, 't' Text, 'e' Enum, 'o' Object '=' for same definition as, <init> gives the initial Static Returns False if <type> does not match this list
    	:param family:
    	:type family: char *
    	:param name:
    	:type name: char *
    	:param type:
    	:type type: Standard_Character
    	:param init: default value is 
    	:type init: char *
    	:rtype: bool
    """
    return _Interface.Interface_Static_Init(*args)

def Interface_Static_IsPresent(*args) -> "Standard_Boolean":
    """
    * Returns True if a Static named <name> is present, False else
    	:param name:
    	:type name: char *
    	:rtype: bool
    """
    return _Interface.Interface_Static_IsPresent(*args)

def Interface_Static_IsSet(*args) -> "Standard_Boolean":
    """
    * Returns True if <name> is present AND set <proper> True (D) : considers this item only <proper> False : if not set and attached to a wild-card, considers this wild-card
    	:param name:
    	:type name: char *
    	:param proper: default value is Standard_True
    	:type proper: bool
    	:rtype: bool
    """
    return _Interface.Interface_Static_IsSet(*args)

def Interface_Static_IsUpdated(*args) -> "Standard_Boolean":
    """
    * Returns the status 'uptodate' from a Static Returns False if <name> is not present
    	:param name:
    	:type name: char *
    	:rtype: bool
    """
    return _Interface.Interface_Static_IsUpdated(*args)

def Interface_Static_Items(*args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
    """
    * Returns a list of names of statics : <mode> = 0 (D) : criter is for family <mode> = 1 : criter is regexp on names, takes final items (ignore wild cards) <mode> = 2 : idem but take only wilded, not final items <mode> = 3 : idem, take all items matching criter idem + 100 : takes only non-updated items idem + 200 : takes only updated items criter empty (D) : returns all names else returns names which match the given criter Remark : families beginning by '$' are not listed by criter '' they are listed only by criter '$' //! This allows for instance to set new values after having loaded or reloaded a resource, then to update them as required
    	:param mode: default value is 0
    	:type mode: int
    	:param criter: default value is 
    	:type criter: char *
    	:rtype: opencascade::handle<TColStd_HSequenceOfHAsciiString>
    """
    return _Interface.Interface_Static_Items(*args)

def Interface_Static_RVal(*args) -> "Standard_Real":
    """
    * Returns the value of a static translation parameter identified by the string name. Returns the value 0.0 if the parameter does not exist.
    	:param name:
    	:type name: char *
    	:rtype: float
    """
    return _Interface.Interface_Static_RVal(*args)

def Interface_Static_SetCVal(*args) -> "Standard_Boolean":
    """
    * Modifies the value of the parameter identified by name. The modification is specified by the string val. false is returned if the parameter does not exist. Example Interface_Static::SetCVal ('write.step.schema','AP203') This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.
    	:param name:
    	:type name: char *
    	:param val:
    	:type val: char *
    	:rtype: bool
    """
    return _Interface.Interface_Static_SetCVal(*args)

def Interface_Static_SetIVal(*args) -> "Standard_Boolean":
    """
    * Modifies the value of the parameter identified by name. The modification is specified by the integer value val. false is returned if the parameter does not exist. Example Interface_Static::SetIVal ('write.step.schema', 3) This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.S
    	:param name:
    	:type name: char *
    	:param val:
    	:type val: int
    	:rtype: bool
    """
    return _Interface.Interface_Static_SetIVal(*args)

def Interface_Static_SetRVal(*args) -> "Standard_Boolean":
    """
    * Modifies the value of a translation parameter. false is returned if the parameter does not exist. The modification is specified by the real number value val.
    	:param name:
    	:type name: char *
    	:param val:
    	:type val: float
    	:rtype: bool
    """
    return _Interface.Interface_Static_SetRVal(*args)

def Interface_Static_Standards(*args) -> "void":
    """
    * Initializes all standard static parameters, which can be used by every function. statics specific of a norm or a function must be defined around it
    	:rtype: void
    """
    return _Interface.Interface_Static_Standards(*args)

def Interface_Static_Static(*args) -> "opencascade::handle< Interface_Static >":
    """
    * Returns a Static from its name. Null Handle if not present
    	:param name:
    	:type name: char *
    	:rtype: opencascade::handle<Interface_Static>
    """
    return _Interface.Interface_Static_Static(*args)

def Interface_Static_Update(*args) -> "Standard_Boolean":
    """
    * Sets a Static to be 'uptodate' Returns False if <name> is not present This status can be used by a reinitialisation procedure to rerun if a value has been changed
    	:param name:
    	:type name: char *
    	:rtype: bool
    """
    return _Interface.Interface_Static_Update(*args)

class Interface_HArray1OfHAsciiString(Interface_Array1OfHAsciiString, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Interface.Interface_HArray1OfHAsciiString_swiginit(self, _Interface.new_Interface_HArray1OfHAsciiString(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Interface_HArray1OfHAsciiString_DownCast(t)

    __swig_destroy__ = _Interface.delete_Interface_HArray1OfHAsciiString
Interface_HArray1OfHAsciiString.Array1 = new_instancemethod(_Interface.Interface_HArray1OfHAsciiString_Array1, None, Interface_HArray1OfHAsciiString)
Interface_HArray1OfHAsciiString.ChangeArray1 = new_instancemethod(_Interface.Interface_HArray1OfHAsciiString_ChangeArray1, None, Interface_HArray1OfHAsciiString)
Interface_HArray1OfHAsciiString_swigregister = _Interface.Interface_HArray1OfHAsciiString_swigregister
Interface_HArray1OfHAsciiString_swigregister(Interface_HArray1OfHAsciiString)

class Interface_HSequenceOfCheck(Interface_SequenceOfCheck, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Interface.Interface_HSequenceOfCheck_swiginit(self, _Interface.new_Interface_HSequenceOfCheck(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Interface_HSequenceOfCheck_DownCast(t)

    __swig_destroy__ = _Interface.delete_Interface_HSequenceOfCheck
Interface_HSequenceOfCheck.Sequence = new_instancemethod(_Interface.Interface_HSequenceOfCheck_Sequence, None, Interface_HSequenceOfCheck)
Interface_HSequenceOfCheck.Append = new_instancemethod(_Interface.Interface_HSequenceOfCheck_Append, None, Interface_HSequenceOfCheck)
Interface_HSequenceOfCheck.ChangeSequence = new_instancemethod(_Interface.Interface_HSequenceOfCheck_ChangeSequence, None, Interface_HSequenceOfCheck)
Interface_HSequenceOfCheck_swigregister = _Interface.Interface_HSequenceOfCheck_swigregister
Interface_HSequenceOfCheck_swigregister(Interface_HSequenceOfCheck)



