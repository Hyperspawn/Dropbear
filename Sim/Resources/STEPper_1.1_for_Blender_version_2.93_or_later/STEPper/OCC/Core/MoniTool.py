# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
MoniTool module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_monitool.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _MoniTool.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_MoniTool')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_MoniTool')
    _MoniTool = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_MoniTool', [dirname(__file__)])
        except ImportError:
            import _MoniTool
            return _MoniTool
        try:
            _mod = imp.load_module('_MoniTool', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _MoniTool = swig_import_helper()
    del swig_import_helper
else:
    import _MoniTool
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _MoniTool.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_MoniTool.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_MoniTool.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_MoniTool.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_MoniTool.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_MoniTool.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_MoniTool.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_MoniTool.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_MoniTool.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_MoniTool.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_MoniTool.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_MoniTool.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_MoniTool.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_MoniTool.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_MoniTool.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_MoniTool.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_MoniTool.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _MoniTool.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _MoniTool.process_exception(error, method_name, class_name)
process_exception = _MoniTool.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TCollection
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.OSD
import OCC.Core.TColStd
MoniTool_ValueMisc = _MoniTool.MoniTool_ValueMisc
MoniTool_ValueInteger = _MoniTool.MoniTool_ValueInteger
MoniTool_ValueReal = _MoniTool.MoniTool_ValueReal
MoniTool_ValueIdent = _MoniTool.MoniTool_ValueIdent
MoniTool_ValueVoid = _MoniTool.MoniTool_ValueVoid
MoniTool_ValueText = _MoniTool.MoniTool_ValueText
MoniTool_ValueEnum = _MoniTool.MoniTool_ValueEnum
MoniTool_ValueLogical = _MoniTool.MoniTool_ValueLogical
MoniTool_ValueSub = _MoniTool.MoniTool_ValueSub
MoniTool_ValueHexa = _MoniTool.MoniTool_ValueHexa
MoniTool_ValueBinary = _MoniTool.MoniTool_ValueBinary

def Handle_MoniTool_CaseData_Create() -> "opencascade::handle< MoniTool_CaseData >":
    return _MoniTool.Handle_MoniTool_CaseData_Create()
Handle_MoniTool_CaseData_Create = _MoniTool.Handle_MoniTool_CaseData_Create

def Handle_MoniTool_CaseData_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_CaseData >":
    return _MoniTool.Handle_MoniTool_CaseData_DownCast(t)
Handle_MoniTool_CaseData_DownCast = _MoniTool.Handle_MoniTool_CaseData_DownCast

def Handle_MoniTool_CaseData_IsNull(t: 'opencascade::handle< MoniTool_CaseData > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_CaseData_IsNull(t)
Handle_MoniTool_CaseData_IsNull = _MoniTool.Handle_MoniTool_CaseData_IsNull

def Handle_MoniTool_Element_Create() -> "opencascade::handle< MoniTool_Element >":
    return _MoniTool.Handle_MoniTool_Element_Create()
Handle_MoniTool_Element_Create = _MoniTool.Handle_MoniTool_Element_Create

def Handle_MoniTool_Element_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_Element >":
    return _MoniTool.Handle_MoniTool_Element_DownCast(t)
Handle_MoniTool_Element_DownCast = _MoniTool.Handle_MoniTool_Element_DownCast

def Handle_MoniTool_Element_IsNull(t: 'opencascade::handle< MoniTool_Element > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_Element_IsNull(t)
Handle_MoniTool_Element_IsNull = _MoniTool.Handle_MoniTool_Element_IsNull

def Handle_MoniTool_IntVal_Create() -> "opencascade::handle< MoniTool_IntVal >":
    return _MoniTool.Handle_MoniTool_IntVal_Create()
Handle_MoniTool_IntVal_Create = _MoniTool.Handle_MoniTool_IntVal_Create

def Handle_MoniTool_IntVal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_IntVal >":
    return _MoniTool.Handle_MoniTool_IntVal_DownCast(t)
Handle_MoniTool_IntVal_DownCast = _MoniTool.Handle_MoniTool_IntVal_DownCast

def Handle_MoniTool_IntVal_IsNull(t: 'opencascade::handle< MoniTool_IntVal > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_IntVal_IsNull(t)
Handle_MoniTool_IntVal_IsNull = _MoniTool.Handle_MoniTool_IntVal_IsNull

def Handle_MoniTool_RealVal_Create() -> "opencascade::handle< MoniTool_RealVal >":
    return _MoniTool.Handle_MoniTool_RealVal_Create()
Handle_MoniTool_RealVal_Create = _MoniTool.Handle_MoniTool_RealVal_Create

def Handle_MoniTool_RealVal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_RealVal >":
    return _MoniTool.Handle_MoniTool_RealVal_DownCast(t)
Handle_MoniTool_RealVal_DownCast = _MoniTool.Handle_MoniTool_RealVal_DownCast

def Handle_MoniTool_RealVal_IsNull(t: 'opencascade::handle< MoniTool_RealVal > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_RealVal_IsNull(t)
Handle_MoniTool_RealVal_IsNull = _MoniTool.Handle_MoniTool_RealVal_IsNull

def Handle_MoniTool_SignText_Create() -> "opencascade::handle< MoniTool_SignText >":
    return _MoniTool.Handle_MoniTool_SignText_Create()
Handle_MoniTool_SignText_Create = _MoniTool.Handle_MoniTool_SignText_Create

def Handle_MoniTool_SignText_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_SignText >":
    return _MoniTool.Handle_MoniTool_SignText_DownCast(t)
Handle_MoniTool_SignText_DownCast = _MoniTool.Handle_MoniTool_SignText_DownCast

def Handle_MoniTool_SignText_IsNull(t: 'opencascade::handle< MoniTool_SignText > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_SignText_IsNull(t)
Handle_MoniTool_SignText_IsNull = _MoniTool.Handle_MoniTool_SignText_IsNull

def Handle_MoniTool_Timer_Create() -> "opencascade::handle< MoniTool_Timer >":
    return _MoniTool.Handle_MoniTool_Timer_Create()
Handle_MoniTool_Timer_Create = _MoniTool.Handle_MoniTool_Timer_Create

def Handle_MoniTool_Timer_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_Timer >":
    return _MoniTool.Handle_MoniTool_Timer_DownCast(t)
Handle_MoniTool_Timer_DownCast = _MoniTool.Handle_MoniTool_Timer_DownCast

def Handle_MoniTool_Timer_IsNull(t: 'opencascade::handle< MoniTool_Timer > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_Timer_IsNull(t)
Handle_MoniTool_Timer_IsNull = _MoniTool.Handle_MoniTool_Timer_IsNull

def Handle_MoniTool_TypedValue_Create() -> "opencascade::handle< MoniTool_TypedValue >":
    return _MoniTool.Handle_MoniTool_TypedValue_Create()
Handle_MoniTool_TypedValue_Create = _MoniTool.Handle_MoniTool_TypedValue_Create

def Handle_MoniTool_TypedValue_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_TypedValue >":
    return _MoniTool.Handle_MoniTool_TypedValue_DownCast(t)
Handle_MoniTool_TypedValue_DownCast = _MoniTool.Handle_MoniTool_TypedValue_DownCast

def Handle_MoniTool_TypedValue_IsNull(t: 'opencascade::handle< MoniTool_TypedValue > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_TypedValue_IsNull(t)
Handle_MoniTool_TypedValue_IsNull = _MoniTool.Handle_MoniTool_TypedValue_IsNull

def Handle_MoniTool_SignShape_Create() -> "opencascade::handle< MoniTool_SignShape >":
    return _MoniTool.Handle_MoniTool_SignShape_Create()
Handle_MoniTool_SignShape_Create = _MoniTool.Handle_MoniTool_SignShape_Create

def Handle_MoniTool_SignShape_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_SignShape >":
    return _MoniTool.Handle_MoniTool_SignShape_DownCast(t)
Handle_MoniTool_SignShape_DownCast = _MoniTool.Handle_MoniTool_SignShape_DownCast

def Handle_MoniTool_SignShape_IsNull(t: 'opencascade::handle< MoniTool_SignShape > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_SignShape_IsNull(t)
Handle_MoniTool_SignShape_IsNull = _MoniTool.Handle_MoniTool_SignShape_IsNull

def Handle_MoniTool_TransientElem_Create() -> "opencascade::handle< MoniTool_TransientElem >":
    return _MoniTool.Handle_MoniTool_TransientElem_Create()
Handle_MoniTool_TransientElem_Create = _MoniTool.Handle_MoniTool_TransientElem_Create

def Handle_MoniTool_TransientElem_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_TransientElem >":
    return _MoniTool.Handle_MoniTool_TransientElem_DownCast(t)
Handle_MoniTool_TransientElem_DownCast = _MoniTool.Handle_MoniTool_TransientElem_DownCast

def Handle_MoniTool_TransientElem_IsNull(t: 'opencascade::handle< MoniTool_TransientElem > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_TransientElem_IsNull(t)
Handle_MoniTool_TransientElem_IsNull = _MoniTool.Handle_MoniTool_TransientElem_IsNull

def Handle_MoniTool_HSequenceOfElement_Create() -> "opencascade::handle< MoniTool_HSequenceOfElement >":
    return _MoniTool.Handle_MoniTool_HSequenceOfElement_Create()
Handle_MoniTool_HSequenceOfElement_Create = _MoniTool.Handle_MoniTool_HSequenceOfElement_Create

def Handle_MoniTool_HSequenceOfElement_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_HSequenceOfElement >":
    return _MoniTool.Handle_MoniTool_HSequenceOfElement_DownCast(t)
Handle_MoniTool_HSequenceOfElement_DownCast = _MoniTool.Handle_MoniTool_HSequenceOfElement_DownCast

def Handle_MoniTool_HSequenceOfElement_IsNull(t: 'opencascade::handle< MoniTool_HSequenceOfElement > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_HSequenceOfElement_IsNull(t)
Handle_MoniTool_HSequenceOfElement_IsNull = _MoniTool.Handle_MoniTool_HSequenceOfElement_IsNull
class MoniTool_DataMapOfShapeTransient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MoniTool.MoniTool_DataMapOfShapeTransient_swiginit(self, _MoniTool.new_MoniTool_DataMapOfShapeTransient(*args))
    __swig_destroy__ = _MoniTool.delete_MoniTool_DataMapOfShapeTransient
MoniTool_DataMapOfShapeTransient.begin = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_begin, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.end = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_end, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.cbegin = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_cbegin, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.cend = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_cend, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.Exchange = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_Exchange, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.Assign = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_Assign, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.Set = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_Set, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.ReSize = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_ReSize, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.Bind = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_Bind, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.Bound = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_Bound, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.IsBound = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_IsBound, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.UnBind = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_UnBind, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.Seek = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_Seek, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.Find = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_Find, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.ChangeSeek = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_ChangeSeek, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.ChangeFind = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_ChangeFind, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.__call__ = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient___call__, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.Clear = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_Clear, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient.Size = new_instancemethod(_MoniTool.MoniTool_DataMapOfShapeTransient_Size, None, MoniTool_DataMapOfShapeTransient)
MoniTool_DataMapOfShapeTransient_swigregister = _MoniTool.MoniTool_DataMapOfShapeTransient_swigregister
MoniTool_DataMapOfShapeTransient_swigregister(MoniTool_DataMapOfShapeTransient)

class MoniTool_SequenceOfElement(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MoniTool.MoniTool_SequenceOfElement_swiginit(self, _MoniTool.new_MoniTool_SequenceOfElement(*args))
    delNode = staticmethod(_MoniTool.MoniTool_SequenceOfElement_delNode)
    __swig_destroy__ = _MoniTool.delete_MoniTool_SequenceOfElement
MoniTool_SequenceOfElement.begin = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_begin, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.end = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_end, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.cbegin = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_cbegin, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.cend = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_cend, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Size = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Size, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Length = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Length, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Lower = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Lower, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Upper = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Upper, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.IsEmpty = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_IsEmpty, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Reverse = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Reverse, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Exchange = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Exchange, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Clear = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Clear, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Assign = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Assign, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Set = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Set, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Remove = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Remove, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Append = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Append, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Prepend = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Prepend, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.InsertBefore = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_InsertBefore, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.InsertAfter = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_InsertAfter, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Split = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Split, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.First = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_First, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.ChangeFirst = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_ChangeFirst, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Last = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Last, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.ChangeLast = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_ChangeLast, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.Value = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_Value, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.ChangeValue = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_ChangeValue, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.__call__ = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement___call__, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement.SetValue = new_instancemethod(_MoniTool.MoniTool_SequenceOfElement_SetValue, None, MoniTool_SequenceOfElement)
MoniTool_SequenceOfElement_swigregister = _MoniTool.MoniTool_SequenceOfElement_swigregister
MoniTool_SequenceOfElement_swigregister(MoniTool_SequenceOfElement)

def MoniTool_SequenceOfElement_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _MoniTool.MoniTool_SequenceOfElement_delNode(theNode, theAl)
MoniTool_SequenceOfElement_delNode = _MoniTool.MoniTool_SequenceOfElement_delNode

class MoniTool_DataMapOfTimer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MoniTool.MoniTool_DataMapOfTimer_swiginit(self, _MoniTool.new_MoniTool_DataMapOfTimer(*args))
    __swig_destroy__ = _MoniTool.delete_MoniTool_DataMapOfTimer
MoniTool_DataMapOfTimer.begin = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_begin, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.end = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_end, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.cbegin = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_cbegin, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.cend = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_cend, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.Exchange = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_Exchange, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.Assign = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_Assign, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.Set = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_Set, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.ReSize = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_ReSize, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.Bind = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_Bind, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.Bound = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_Bound, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.IsBound = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_IsBound, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.UnBind = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_UnBind, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.Seek = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_Seek, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.Find = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_Find, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.ChangeSeek = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_ChangeSeek, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.ChangeFind = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_ChangeFind, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.__call__ = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer___call__, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.Clear = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_Clear, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer.Size = new_instancemethod(_MoniTool.MoniTool_DataMapOfTimer_Size, None, MoniTool_DataMapOfTimer)
MoniTool_DataMapOfTimer_swigregister = _MoniTool.MoniTool_DataMapOfTimer_swigregister
MoniTool_DataMapOfTimer_swigregister(MoniTool_DataMapOfTimer)

class MoniTool_IndexedDataMapOfShapeTransient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_swiginit(self, _MoniTool.new_MoniTool_IndexedDataMapOfShapeTransient(*args))
    __swig_destroy__ = _MoniTool.delete_MoniTool_IndexedDataMapOfShapeTransient
MoniTool_IndexedDataMapOfShapeTransient.begin = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_begin, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.end = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_end, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.cbegin = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_cbegin, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.cend = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_cend, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Exchange = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Exchange, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Assign = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Assign, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Set = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Set, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.ReSize = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_ReSize, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Add = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Add, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Contains = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Contains, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Substitute = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Substitute, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Swap = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Swap, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.RemoveLast = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_RemoveLast, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.RemoveFromIndex = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_RemoveFromIndex, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.RemoveKey = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_RemoveKey, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.FindKey = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_FindKey, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.FindFromIndex = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_FindFromIndex, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.ChangeFromIndex = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_ChangeFromIndex, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.__call__ = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient___call__, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.FindIndex = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_FindIndex, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.ChangeFromKey = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_ChangeFromKey, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Seek = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Seek, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.ChangeSeek = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_ChangeSeek, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.FindFromKey = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_FindFromKey, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Clear = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Clear, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient.Size = new_instancemethod(_MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Size, None, MoniTool_IndexedDataMapOfShapeTransient)
MoniTool_IndexedDataMapOfShapeTransient_swigregister = _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_swigregister
MoniTool_IndexedDataMapOfShapeTransient_swigregister(MoniTool_IndexedDataMapOfShapeTransient)

class MoniTool_AttrList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AttrList(self, *args) -> "NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const &":
        """
        * Returns the exhaustive list of attributes
        	:rtype: NCollection_DataMap<TCollection_AsciiString, opencascade::handle<Standard_Transient> >
        """
        return _MoniTool.MoniTool_AttrList_AttrList(self, *args)


    def Attribute(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns an attribute from its name. Null Handle if not recorded (whatever Transient, Integer, Real ...) Integer is recorded as IntVal Real is recorded as RealVal Text is recorded as HAsciiString
        	:param name:
        	:type name: char *
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _MoniTool.MoniTool_AttrList_Attribute(self, *args)


    def AttributeType(self, *args) -> "MoniTool_ValueType":
        """
        * Returns the type of an attribute : ValueInt , ValueReal , ValueText (String) , ValueIdent (any) or ValueVoid (not recorded)
        	:param name:
        	:type name: char *
        	:rtype: MoniTool_ValueType
        """
        return _MoniTool.MoniTool_AttrList_AttributeType(self, *args)


    def GetAttribute(self, *args) -> "Standard_Boolean":
        """
        * Returns an attribute from its name, filtered by a type If no attribute has this name, or if it is not kind of this type, <val> is Null and returned value is False Else, it is True
        	:param name:
        	:type name: char *
        	:param type:
        	:type type: Standard_Type
        	:param val:
        	:type val: Standard_Transient
        	:rtype: bool
        """
        return _MoniTool.MoniTool_AttrList_GetAttribute(self, *args)


    def GetAttributes(self, *args) -> "void":
        """
        * Gets the list of attributes from <other>, by copying it By default, considers all the attributes from <other> If <fromname> is given, considers only the attributes with name beginning by <fromname> //! For each attribute, if <copied> is True (D), its value is also copied if it is a basic type (Integer,Real,String), else it remains shared between <other> and <self> //! These new attributes are added to the existing ones in <self>, in case of same name, they replace the existing ones
        	:param other:
        	:type other: MoniTool_AttrList
        	:param fromname: default value is 
        	:type fromname: char *
        	:param copied: default value is Standard_True
        	:type copied: bool
        	:rtype: None
        """
        return _MoniTool.MoniTool_AttrList_GetAttributes(self, *args)


    def GetIntegerAttribute(self, *args) -> "Standard_Boolean":
        """
        * Returns an attribute from its name, as integer If no attribute has this name, or not an integer, <val> is 0 and returned value is False Else, it is True
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: int
        	:rtype: bool
        """
        return _MoniTool.MoniTool_AttrList_GetIntegerAttribute(self, *args)


    def GetRealAttribute(self, *args) -> "Standard_Boolean":
        """
        * Returns an attribute from its name, as real If no attribute has this name, or not a real <val> is 0.0 and returned value is False Else, it is True
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: float
        	:rtype: bool
        """
        return _MoniTool.MoniTool_AttrList_GetRealAttribute(self, *args)


    def GetStringAttribute(self, *args) -> "Standard_Boolean":
        """
        * Returns an attribute from its name, as String If no attribute has this name, or not a String <val> is 0.0 and returned value is False Else, it is True
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: char *
        	:rtype: bool
        """
        return _MoniTool.MoniTool_AttrList_GetStringAttribute(self, *args)


    def IntegerAttribute(self, *args) -> "Standard_Integer":
        """
        * Returns an integer attribute from its name. 0 if not recorded
        	:param name:
        	:type name: char *
        	:rtype: int
        """
        return _MoniTool.MoniTool_AttrList_IntegerAttribute(self, *args)


    def __init__(self, *args):
        """
        * Creates an AttrList, empty
        	:rtype: None
        * Creates an AttrList from another one, definitions are shared (calls SameAttributes)
        	:param other:
        	:type other: MoniTool_AttrList
        	:rtype: None
        """
        _MoniTool.MoniTool_AttrList_swiginit(self, _MoniTool.new_MoniTool_AttrList(*args))

    def RealAttribute(self, *args) -> "Standard_Real":
        """
        * Returns a real attribute from its name. 0.0 if not recorded
        	:param name:
        	:type name: char *
        	:rtype: float
        """
        return _MoniTool.MoniTool_AttrList_RealAttribute(self, *args)


    def RemoveAttribute(self, *args) -> "Standard_Boolean":
        """
        * Removes an attribute Returns True when done, False if this attribute did not exist
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _MoniTool.MoniTool_AttrList_RemoveAttribute(self, *args)


    def SameAttributes(self, *args) -> "void":
        """
        * Gets the list of attributes from <other>, as such, i.e. not copied : attributes are shared, any attribute edited, added, or removed in <other> is also in <self> and vice versa The former list of attributes of <self> is dropped
        	:param other:
        	:type other: MoniTool_AttrList
        	:rtype: None
        """
        return _MoniTool.MoniTool_AttrList_SameAttributes(self, *args)


    def SetAttribute(self, *args) -> "void":
        """
        * Adds an attribute with a given name (replaces the former one with the same name if already exists)
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: Standard_Transient
        	:rtype: None
        """
        return _MoniTool.MoniTool_AttrList_SetAttribute(self, *args)


    def SetIntegerAttribute(self, *args) -> "void":
        """
        * Adds an integer value for an attribute
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_AttrList_SetIntegerAttribute(self, *args)


    def SetRealAttribute(self, *args) -> "void":
        """
        * Adds a real value for an attribute
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: float
        	:rtype: None
        """
        return _MoniTool.MoniTool_AttrList_SetRealAttribute(self, *args)


    def SetStringAttribute(self, *args) -> "void":
        """
        * Adds a String value for an attribute
        	:param name:
        	:type name: char *
        	:param val:
        	:type val: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_AttrList_SetStringAttribute(self, *args)


    def StringAttribute(self, *args) -> "char const *":
        """
        * Returns a String attribute from its name. '' if not recorded
        	:param name:
        	:type name: char *
        	:rtype: char *
        """
        return _MoniTool.MoniTool_AttrList_StringAttribute(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_AttrList
MoniTool_AttrList.AttrList = new_instancemethod(_MoniTool.MoniTool_AttrList_AttrList, None, MoniTool_AttrList)
MoniTool_AttrList.Attribute = new_instancemethod(_MoniTool.MoniTool_AttrList_Attribute, None, MoniTool_AttrList)
MoniTool_AttrList.AttributeType = new_instancemethod(_MoniTool.MoniTool_AttrList_AttributeType, None, MoniTool_AttrList)
MoniTool_AttrList.GetAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_GetAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.GetAttributes = new_instancemethod(_MoniTool.MoniTool_AttrList_GetAttributes, None, MoniTool_AttrList)
MoniTool_AttrList.GetIntegerAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_GetIntegerAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.GetRealAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_GetRealAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.GetStringAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_GetStringAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.IntegerAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_IntegerAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.RealAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_RealAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.RemoveAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_RemoveAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.SameAttributes = new_instancemethod(_MoniTool.MoniTool_AttrList_SameAttributes, None, MoniTool_AttrList)
MoniTool_AttrList.SetAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_SetAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.SetIntegerAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_SetIntegerAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.SetRealAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_SetRealAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.SetStringAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_SetStringAttribute, None, MoniTool_AttrList)
MoniTool_AttrList.StringAttribute = new_instancemethod(_MoniTool.MoniTool_AttrList_StringAttribute, None, MoniTool_AttrList)
MoniTool_AttrList_swigregister = _MoniTool.MoniTool_AttrList_swigregister
MoniTool_AttrList_swigregister(MoniTool_AttrList)

class MoniTool_CaseData(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddAny(self, *args) -> "void":
        """
        * Adds a Transient, with no more meaning
        	:param val:
        	:type val: Standard_Transient
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddAny(self, *args)


    def AddCPU(self, *args) -> "void":
        """
        * Adds the CPU time between lastCPU and now if <curCPU> is given, the CPU amount is curCPU-lastCPU else it is currently measured CPU - lastCPU lastCPU has been read by call to GetCPU See GetCPU to get amount, and LargeCPU to test large amount
        	:param lastCPU:
        	:type lastCPU: float
        	:param curCPU: default value is 0
        	:type curCPU: float
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddCPU(self, *args)


    def AddData(self, *args) -> "void":
        """
        * Unitary adding a data; rather internal
        	:param val:
        	:type val: Standard_Transient
        	:param kind:
        	:type kind: int
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddData(self, *args)


    def AddEntity(self, *args) -> "void":
        """
        * Adds a Transient, as an Entity from an InterfaceModel for instance : it will then be printed with the help of a DBPE
        	:param ent:
        	:type ent: Standard_Transient
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddEntity(self, *args)


    def AddGeom(self, *args) -> "void":
        """
        * Adds a Geometric as a Transient (Curve, Surface ...)
        	:param geom:
        	:type geom: Standard_Transient
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddGeom(self, *args)


    def AddInteger(self, *args) -> "void":
        """
        * Adds an Integer
        	:param val:
        	:type val: int
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddInteger(self, *args)


    def AddRaised(self, *args) -> "void":
        """
        * Adds the currently caught exception
        	:param theException:
        	:type theException: Standard_Failure
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddRaised(self, *args)


    def AddReal(self, *args) -> "void":
        """
        * Adds a Real
        	:param val:
        	:type val: float
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddReal(self, *args)


    def AddReals(self, *args) -> "void":
        """
        * Adds two reals (for instance, two parameters)
        	:param v1:
        	:type v1: float
        	:param v2:
        	:type v2: float
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddReals(self, *args)


    def AddShape(self, *args) -> "void":
        """
        * Adds a Shape (recorded as a HShape)
        	:param sh:
        	:type sh: TopoDS_Shape
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddShape(self, *args)


    def AddText(self, *args) -> "void":
        """
        * Adds a Text (as HAsciiString)
        	:param text:
        	:type text: char *
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddText(self, *args)


    def AddXY(self, *args) -> "void":
        """
        * Adds a XY
        	:param aXY:
        	:type aXY: gp_XY
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddXY(self, *args)


    def AddXYZ(self, *args) -> "void":
        """
        * Adds a XYZ
        	:param aXYZ:
        	:type aXYZ: gp_XYZ
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_AddXYZ(self, *args)


    def CaseId(self, *args) -> "char const *":
        """
        * Returns the CaseId
        	:rtype: char *
        """
        return _MoniTool.MoniTool_CaseData_CaseId(self, *args)


    def Data(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns a data item (n0 <nd> in the set <num>)
        	:param nd:
        	:type nd: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _MoniTool.MoniTool_CaseData_Data(self, *args)


    def DefCheck(*args) -> "Standard_Integer":
        """
        * Returns Check Status for a Code : 0 non/info (default), 1 warning, 2 fail //! Remark : DefCheck is used to set the check status of a CaseData when it is attached to a case code, it can be changed later (by SetFail, SetWarning, ResetCheck)
        	:param acode:
        	:type acode: char *
        	:rtype: int
        """
        return _MoniTool.MoniTool_CaseData_DefCheck(*args)

    DefCheck = staticmethod(DefCheck)

    def DefMsg(*args) -> "char const *":
        """
        * Returns the message definition for a case code Empty if no message attached
        	:param casecode:
        	:type casecode: char *
        	:rtype: char *
        """
        return _MoniTool.MoniTool_CaseData_DefMsg(*args)

    DefMsg = staticmethod(DefMsg)

    def GetCPU(self, *args) -> "Standard_Real":
        """
        * Returns the current amount of CPU This allows to laterly test and record CPU amount Its value has to be given to LargeCPU and AddCPU
        	:rtype: float
        """
        return _MoniTool.MoniTool_CaseData_GetCPU(self, *args)


    def GetData(self, *args) -> "Standard_Boolean":
        """
        * Returns a data item, under control of a Type If the data item is kind of this type, it is returned in <val> and the returned value is True Else, <val> is unchanged and the returned value is False
        	:param nd:
        	:type nd: int
        	:param type:
        	:type type: Standard_Type
        	:param val:
        	:type val: Standard_Transient
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_GetData(self, *args)


    def Integer(self, *args) -> "Standard_Boolean":
        """
        * Returns an Integer
        	:param nd:
        	:type nd: int
        	:param val:
        	:type val: int
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_Integer(self, *args)


    def IsCheck(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is Check (Warning or Fail), else it is Info
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_IsCheck(self, *args)


    def IsFail(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is Fail
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_IsFail(self, *args)


    def IsWarning(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is Warning
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_IsWarning(self, *args)


    def Kind(self, *args) -> "Standard_Integer":
        """
        * Returns the kind of a data : KIND TYPE MEANING 0 ANY any (not one of the followings) 1 EX raised exception 2 EN entity 3 G geom 4 SH shape 5 XYZ XYZ 6 XY or UV XY 7 RR 2 reals 8 R 1 real 9 CPU CPU (1 real) 10 T text 11 I integer //! For NameNum, these codes for TYPE must be given exact i.e. SH for a Shape, not S nor SHAPE nor SOLID etc
        	:param nd:
        	:type nd: int
        	:rtype: int
        """
        return _MoniTool.MoniTool_CaseData_Kind(self, *args)


    def LargeCPU(self, *args) -> "Standard_Boolean":
        """
        * Tells if a CPU time amount is large <maxCPU> gives the amount over which an amount is large <lastCPU> gives the start CPU amount if <curCPU> is given, the tested CPU amount is curCPU-lastCPU else it is currently measured CPU - lastCPU
        	:param maxCPU:
        	:type maxCPU: float
        	:param lastCPU:
        	:type lastCPU: float
        	:param curCPU: default value is 0
        	:type curCPU: float
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_LargeCPU(self, *args)


    def __init__(self, *args):
        """
        * Creates a CaseData with a CaseId and a Name (by default not defined)
        	:param caseid: default value is 
        	:type caseid: char *
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        _MoniTool.MoniTool_CaseData_swiginit(self, _MoniTool.new_MoniTool_CaseData(*args))

    def Msg(self, *args) -> "Message_Msg":
        """
        * Returns a Msg from a CaseData : it is build from DefMsg, which gives the message code plus the designation of items of the CaseData to be added to the Msg Empty if no message attached //! Remains to be implemented
        	:rtype: Message_Msg
        """
        return _MoniTool.MoniTool_CaseData_Msg(self, *args)


    def Name(self, *args) -> "TCollection_AsciiString const &":
        """
        * Returns the Name
        	:rtype: char *
        * Returns the name of a data. If it has no name, the string is empty (length = 0)
        	:param nd:
        	:type nd: int
        	:rtype: TCollection_AsciiString
        """
        return _MoniTool.MoniTool_CaseData_Name(self, *args)


    def NameNum(self, *args) -> "Standard_Integer":
        """
        * Returns the first suitable data rank for a given name Exact maching (exact case, no completion) is required Firstly checks the recorded names If not found, considers the name as follows : Name = 'TYPE' : search for the first item with this TYPE Name = 'TYPE:nn' : search for the nn.th item with this TYPE See allowed values in method Kind
        	:param name:
        	:type name: char *
        	:rtype: int
        """
        return _MoniTool.MoniTool_CaseData_NameNum(self, *args)


    def NbData(self, *args) -> "Standard_Integer":
        """
        * Returns the count of data recorded to a set
        	:rtype: int
        """
        return _MoniTool.MoniTool_CaseData_NbData(self, *args)


    def Real(self, *args) -> "Standard_Boolean":
        """
        * Returns a real or CPU amount (stored in Geom2d_CartesianPoint) (allows an Integer converted to a Real)
        	:param nd:
        	:type nd: int
        	:param val:
        	:type val: float
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_Real(self, *args)


    def Reals(self, *args) -> "Standard_Boolean":
        """
        * Returns a couple of reals (stored in Geom2d_CartesianPoint)
        	:param nd:
        	:type nd: int
        	:param v1:
        	:type v1: float
        	:param v2:
        	:type v2: float
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_Reals(self, *args)


    def RemoveData(self, *args) -> "void":
        """
        * Removes a Data from its rank. Does nothing if out of range
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_RemoveData(self, *args)


    def ResetCheck(self, *args) -> "void":
        """
        * Resets Check Status, i.e. sets <self> as Info
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_ResetCheck(self, *args)


    def SetCaseId(self, *args) -> "void":
        """
        * Sets a CaseId
        	:param caseid:
        	:type caseid: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_SetCaseId(self, *args)


    def SetChange(self, *args) -> "void":
        """
        * Sets the next Add... not to add but to change the data item designated by its name. If next Add... is not called with a name, SetChange is ignored Reset by next Add... , whatever <num> is correct or not
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_SetChange(self, *args)


    def SetDefFail(*args) -> "void":
        """
        * Sets a Code to give a Fail
        	:param acode:
        	:type acode: char *
        	:rtype: void
        """
        return _MoniTool.MoniTool_CaseData_SetDefFail(*args)

    SetDefFail = staticmethod(SetDefFail)

    def SetDefMsg(*args) -> "void":
        """
        * Attaches a message definition to a case code This definition includes the message code plus designation of items of the CaseData to be added to the message (this part not yet implemented)
        	:param casecode:
        	:type casecode: char *
        	:param mesdef:
        	:type mesdef: char *
        	:rtype: void
        """
        return _MoniTool.MoniTool_CaseData_SetDefMsg(*args)

    SetDefMsg = staticmethod(SetDefMsg)

    def SetDefWarning(*args) -> "void":
        """
        * Sets a Code to give a Warning
        	:param acode:
        	:type acode: char *
        	:rtype: void
        """
        return _MoniTool.MoniTool_CaseData_SetDefWarning(*args)

    SetDefWarning = staticmethod(SetDefWarning)

    def SetFail(self, *args) -> "void":
        """
        * Sets <self> as Fail
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_SetFail(self, *args)


    def SetName(self, *args) -> "void":
        """
        * Sets a Name
        	:param name:
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_SetName(self, *args)


    def SetReplace(self, *args) -> "void":
        """
        * Sets the next Add... not to add but to replace the data item <num>, if <num> is between 1 and NbData. Reset by next Add... , whatever <num> is correct or not
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_SetReplace(self, *args)


    def SetWarning(self, *args) -> "void":
        """
        * Sets <self> as Warning
        	:rtype: None
        """
        return _MoniTool.MoniTool_CaseData_SetWarning(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape":
        """
        * Returns a data as a shape, Null if not a shape
        	:param nd:
        	:type nd: int
        	:rtype: TopoDS_Shape
        """
        return _MoniTool.MoniTool_CaseData_Shape(self, *args)


    def Text(self, *args) -> "Standard_Boolean":
        """
        * Returns a text (stored in TCollection_HAsciiString)
        	:param nd:
        	:type nd: int
        	:param text:
        	:type text: char *
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_Text(self, *args)


    def XY(self, *args) -> "Standard_Boolean":
        """
        * Returns a data as a XY (i.e. Geom2d_CartesianPoint) Returns False if not the good type
        	:param nd:
        	:type nd: int
        	:param val:
        	:type val: gp_XY
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_XY(self, *args)


    def XYZ(self, *args) -> "Standard_Boolean":
        """
        * Returns a data as a XYZ (i.e. Geom_CartesianPoint) Returns False if not the good type
        	:param nd:
        	:type nd: int
        	:param val:
        	:type val: gp_XYZ
        	:rtype: bool
        """
        return _MoniTool.MoniTool_CaseData_XYZ(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_CaseData_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_CaseData
MoniTool_CaseData.AddAny = new_instancemethod(_MoniTool.MoniTool_CaseData_AddAny, None, MoniTool_CaseData)
MoniTool_CaseData.AddCPU = new_instancemethod(_MoniTool.MoniTool_CaseData_AddCPU, None, MoniTool_CaseData)
MoniTool_CaseData.AddData = new_instancemethod(_MoniTool.MoniTool_CaseData_AddData, None, MoniTool_CaseData)
MoniTool_CaseData.AddEntity = new_instancemethod(_MoniTool.MoniTool_CaseData_AddEntity, None, MoniTool_CaseData)
MoniTool_CaseData.AddGeom = new_instancemethod(_MoniTool.MoniTool_CaseData_AddGeom, None, MoniTool_CaseData)
MoniTool_CaseData.AddInteger = new_instancemethod(_MoniTool.MoniTool_CaseData_AddInteger, None, MoniTool_CaseData)
MoniTool_CaseData.AddRaised = new_instancemethod(_MoniTool.MoniTool_CaseData_AddRaised, None, MoniTool_CaseData)
MoniTool_CaseData.AddReal = new_instancemethod(_MoniTool.MoniTool_CaseData_AddReal, None, MoniTool_CaseData)
MoniTool_CaseData.AddReals = new_instancemethod(_MoniTool.MoniTool_CaseData_AddReals, None, MoniTool_CaseData)
MoniTool_CaseData.AddShape = new_instancemethod(_MoniTool.MoniTool_CaseData_AddShape, None, MoniTool_CaseData)
MoniTool_CaseData.AddText = new_instancemethod(_MoniTool.MoniTool_CaseData_AddText, None, MoniTool_CaseData)
MoniTool_CaseData.AddXY = new_instancemethod(_MoniTool.MoniTool_CaseData_AddXY, None, MoniTool_CaseData)
MoniTool_CaseData.AddXYZ = new_instancemethod(_MoniTool.MoniTool_CaseData_AddXYZ, None, MoniTool_CaseData)
MoniTool_CaseData.CaseId = new_instancemethod(_MoniTool.MoniTool_CaseData_CaseId, None, MoniTool_CaseData)
MoniTool_CaseData.Data = new_instancemethod(_MoniTool.MoniTool_CaseData_Data, None, MoniTool_CaseData)
MoniTool_CaseData.GetCPU = new_instancemethod(_MoniTool.MoniTool_CaseData_GetCPU, None, MoniTool_CaseData)
MoniTool_CaseData.GetData = new_instancemethod(_MoniTool.MoniTool_CaseData_GetData, None, MoniTool_CaseData)
MoniTool_CaseData.Integer = new_instancemethod(_MoniTool.MoniTool_CaseData_Integer, None, MoniTool_CaseData)
MoniTool_CaseData.IsCheck = new_instancemethod(_MoniTool.MoniTool_CaseData_IsCheck, None, MoniTool_CaseData)
MoniTool_CaseData.IsFail = new_instancemethod(_MoniTool.MoniTool_CaseData_IsFail, None, MoniTool_CaseData)
MoniTool_CaseData.IsWarning = new_instancemethod(_MoniTool.MoniTool_CaseData_IsWarning, None, MoniTool_CaseData)
MoniTool_CaseData.Kind = new_instancemethod(_MoniTool.MoniTool_CaseData_Kind, None, MoniTool_CaseData)
MoniTool_CaseData.LargeCPU = new_instancemethod(_MoniTool.MoniTool_CaseData_LargeCPU, None, MoniTool_CaseData)
MoniTool_CaseData.Msg = new_instancemethod(_MoniTool.MoniTool_CaseData_Msg, None, MoniTool_CaseData)
MoniTool_CaseData.Name = new_instancemethod(_MoniTool.MoniTool_CaseData_Name, None, MoniTool_CaseData)
MoniTool_CaseData.NameNum = new_instancemethod(_MoniTool.MoniTool_CaseData_NameNum, None, MoniTool_CaseData)
MoniTool_CaseData.NbData = new_instancemethod(_MoniTool.MoniTool_CaseData_NbData, None, MoniTool_CaseData)
MoniTool_CaseData.Real = new_instancemethod(_MoniTool.MoniTool_CaseData_Real, None, MoniTool_CaseData)
MoniTool_CaseData.Reals = new_instancemethod(_MoniTool.MoniTool_CaseData_Reals, None, MoniTool_CaseData)
MoniTool_CaseData.RemoveData = new_instancemethod(_MoniTool.MoniTool_CaseData_RemoveData, None, MoniTool_CaseData)
MoniTool_CaseData.ResetCheck = new_instancemethod(_MoniTool.MoniTool_CaseData_ResetCheck, None, MoniTool_CaseData)
MoniTool_CaseData.SetCaseId = new_instancemethod(_MoniTool.MoniTool_CaseData_SetCaseId, None, MoniTool_CaseData)
MoniTool_CaseData.SetChange = new_instancemethod(_MoniTool.MoniTool_CaseData_SetChange, None, MoniTool_CaseData)
MoniTool_CaseData.SetFail = new_instancemethod(_MoniTool.MoniTool_CaseData_SetFail, None, MoniTool_CaseData)
MoniTool_CaseData.SetName = new_instancemethod(_MoniTool.MoniTool_CaseData_SetName, None, MoniTool_CaseData)
MoniTool_CaseData.SetReplace = new_instancemethod(_MoniTool.MoniTool_CaseData_SetReplace, None, MoniTool_CaseData)
MoniTool_CaseData.SetWarning = new_instancemethod(_MoniTool.MoniTool_CaseData_SetWarning, None, MoniTool_CaseData)
MoniTool_CaseData.Shape = new_instancemethod(_MoniTool.MoniTool_CaseData_Shape, None, MoniTool_CaseData)
MoniTool_CaseData.Text = new_instancemethod(_MoniTool.MoniTool_CaseData_Text, None, MoniTool_CaseData)
MoniTool_CaseData.XY = new_instancemethod(_MoniTool.MoniTool_CaseData_XY, None, MoniTool_CaseData)
MoniTool_CaseData.XYZ = new_instancemethod(_MoniTool.MoniTool_CaseData_XYZ, None, MoniTool_CaseData)
MoniTool_CaseData_swigregister = _MoniTool.MoniTool_CaseData_swigregister
MoniTool_CaseData_swigregister(MoniTool_CaseData)

def MoniTool_CaseData_DefCheck(*args) -> "Standard_Integer":
    """
    * Returns Check Status for a Code : 0 non/info (default), 1 warning, 2 fail //! Remark : DefCheck is used to set the check status of a CaseData when it is attached to a case code, it can be changed later (by SetFail, SetWarning, ResetCheck)
    	:param acode:
    	:type acode: char *
    	:rtype: int
    """
    return _MoniTool.MoniTool_CaseData_DefCheck(*args)

def MoniTool_CaseData_DefMsg(*args) -> "char const *":
    """
    * Returns the message definition for a case code Empty if no message attached
    	:param casecode:
    	:type casecode: char *
    	:rtype: char *
    """
    return _MoniTool.MoniTool_CaseData_DefMsg(*args)

def MoniTool_CaseData_SetDefFail(*args) -> "void":
    """
    * Sets a Code to give a Fail
    	:param acode:
    	:type acode: char *
    	:rtype: void
    """
    return _MoniTool.MoniTool_CaseData_SetDefFail(*args)

def MoniTool_CaseData_SetDefMsg(*args) -> "void":
    """
    * Attaches a message definition to a case code This definition includes the message code plus designation of items of the CaseData to be added to the message (this part not yet implemented)
    	:param casecode:
    	:type casecode: char *
    	:param mesdef:
    	:type mesdef: char *
    	:rtype: void
    """
    return _MoniTool.MoniTool_CaseData_SetDefMsg(*args)

def MoniTool_CaseData_SetDefWarning(*args) -> "void":
    """
    * Sets a Code to give a Warning
    	:param acode:
    	:type acode: char *
    	:rtype: void
    """
    return _MoniTool.MoniTool_CaseData_SetDefWarning(*args)

class MoniTool_DataInfo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Type(*args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns the Type attached to an object Here, the Dynamic Type of a Transient. Null Type if unknown
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _MoniTool.MoniTool_DataInfo_Type(*args)

    Type = staticmethod(Type)

    def TypeName(*args) -> "char const *":
        """
        * Returns Type Name (string) Allows to name type of non-handled objects
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: char *
        """
        return _MoniTool.MoniTool_DataInfo_TypeName(*args)

    TypeName = staticmethod(TypeName)

    __repr__ = _dumps_object


    def __init__(self):
        _MoniTool.MoniTool_DataInfo_swiginit(self, _MoniTool.new_MoniTool_DataInfo())
    __swig_destroy__ = _MoniTool.delete_MoniTool_DataInfo
MoniTool_DataInfo_swigregister = _MoniTool.MoniTool_DataInfo_swigregister
MoniTool_DataInfo_swigregister(MoniTool_DataInfo)

def MoniTool_DataInfo_Type(*args) -> "opencascade::handle< Standard_Type >":
    """
    * Returns the Type attached to an object Here, the Dynamic Type of a Transient. Null Type if unknown
    	:param ent:
    	:type ent: Standard_Transient
    	:rtype: opencascade::handle<Standard_Type>
    """
    return _MoniTool.MoniTool_DataInfo_Type(*args)

def MoniTool_DataInfo_TypeName(*args) -> "char const *":
    """
    * Returns Type Name (string) Allows to name type of non-handled objects
    	:param ent:
    	:type ent: Standard_Transient
    	:rtype: char *
    """
    return _MoniTool.MoniTool_DataInfo_TypeName(*args)

class MoniTool_ElemHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args) -> "Standard_Integer":
        """
        * Returns hash code for the given element, in the range [1, theUpperBound]. Asks theElement its HashCode, then transforms it to be in the required range. @param theElement the element which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
        	:param theElement:
        	:type theElement: MoniTool_Element
        	:param theUpperBound:
        	:type theUpperBound: int
        	:rtype: int
        """
        return _MoniTool.MoniTool_ElemHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        * Returns True if two keys are the same. The test does not work on the Elements themselves but by calling their methods Equates
        	:param K1:
        	:type K1: MoniTool_Element
        	:param K2:
        	:type K2: MoniTool_Element
        	:rtype: bool
        """
        return _MoniTool.MoniTool_ElemHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object


    def __init__(self):
        _MoniTool.MoniTool_ElemHasher_swiginit(self, _MoniTool.new_MoniTool_ElemHasher())
    __swig_destroy__ = _MoniTool.delete_MoniTool_ElemHasher
MoniTool_ElemHasher_swigregister = _MoniTool.MoniTool_ElemHasher_swigregister
MoniTool_ElemHasher_swigregister(MoniTool_ElemHasher)

def MoniTool_ElemHasher_HashCode(*args) -> "Standard_Integer":
    """
    * Returns hash code for the given element, in the range [1, theUpperBound]. Asks theElement its HashCode, then transforms it to be in the required range. @param theElement the element which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
    	:param theElement:
    	:type theElement: MoniTool_Element
    	:param theUpperBound:
    	:type theUpperBound: int
    	:rtype: int
    """
    return _MoniTool.MoniTool_ElemHasher_HashCode(*args)

def MoniTool_ElemHasher_IsEqual(*args) -> "Standard_Boolean":
    """
    * Returns True if two keys are the same. The test does not work on the Elements themselves but by calling their methods Equates
    	:param K1:
    	:type K1: MoniTool_Element
    	:param K2:
    	:type K2: MoniTool_Element
    	:rtype: bool
    """
    return _MoniTool.MoniTool_ElemHasher_IsEqual(*args)

class MoniTool_Element(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ChangeAttr(self, *args) -> "MoniTool_AttrList &":
        """
        * Returns (modifiable) the Attribute List
        	:rtype: MoniTool_AttrList
        """
        return _MoniTool.MoniTool_Element_ChangeAttr(self, *args)


    def Equates(self, *args) -> "Standard_Boolean":
        """
        * Specific testof equallity : to be defined by each sub-class, must be False if Elements have not the same true Type, else their contents must be compared
        	:param other:
        	:type other: MoniTool_Element
        	:rtype: bool
        """
        return _MoniTool.MoniTool_Element_Equates(self, *args)


    def GetHashCode(self, *args) -> "Standard_Integer":
        """
        * Returns the HashCode which has been stored by SetHashCode (remark that HashCode could be deferred then be defined by sub-classes, the result is the same)
        	:rtype: int
        """
        return _MoniTool.MoniTool_Element_GetHashCode(self, *args)


    def ListAttr(self, *args) -> "MoniTool_AttrList const &":
        """
        * Returns (readonly) the Attribute List
        	:rtype: MoniTool_AttrList
        """
        return _MoniTool.MoniTool_Element_ListAttr(self, *args)


    def ValueType(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns the Type of the Value. By default, returns the DynamicType of <self>, but can be redefined
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _MoniTool.MoniTool_Element_ValueType(self, *args)


    def ValueTypeName(self, *args) -> "char const *":
        """
        * Returns the name of the Type of the Value. Default is name of ValueType, unless it is for a non-handled object
        	:rtype: char *
        """
        return _MoniTool.MoniTool_Element_ValueTypeName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_Element_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_Element
MoniTool_Element.ChangeAttr = new_instancemethod(_MoniTool.MoniTool_Element_ChangeAttr, None, MoniTool_Element)
MoniTool_Element.Equates = new_instancemethod(_MoniTool.MoniTool_Element_Equates, None, MoniTool_Element)
MoniTool_Element.GetHashCode = new_instancemethod(_MoniTool.MoniTool_Element_GetHashCode, None, MoniTool_Element)
MoniTool_Element.ListAttr = new_instancemethod(_MoniTool.MoniTool_Element_ListAttr, None, MoniTool_Element)
MoniTool_Element.ValueType = new_instancemethod(_MoniTool.MoniTool_Element_ValueType, None, MoniTool_Element)
MoniTool_Element.ValueTypeName = new_instancemethod(_MoniTool.MoniTool_Element_ValueTypeName, None, MoniTool_Element)
MoniTool_Element_swigregister = _MoniTool.MoniTool_Element_swigregister
MoniTool_Element_swigregister(MoniTool_Element)

class MoniTool_IntVal(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetCValue(self) -> "Standard_Integer":
        """GetCValue(MoniTool_IntVal self) -> Standard_Integer"""
        return _MoniTool.MoniTool_IntVal_GetCValue(self)


    def SetCValue(self, value: 'Standard_Integer') -> "void":
        """SetCValue(MoniTool_IntVal self, Standard_Integer value)"""
        return _MoniTool.MoniTool_IntVal_SetCValue(self, value)


    def __init__(self, *args):
        """
        :param val: default value is 0
        	:type val: int
        	:rtype: None
        """
        _MoniTool.MoniTool_IntVal_swiginit(self, _MoniTool.new_MoniTool_IntVal(*args))

    def Value(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _MoniTool.MoniTool_IntVal_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_IntVal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_IntVal
MoniTool_IntVal.GetCValue = new_instancemethod(_MoniTool.MoniTool_IntVal_GetCValue, None, MoniTool_IntVal)
MoniTool_IntVal.SetCValue = new_instancemethod(_MoniTool.MoniTool_IntVal_SetCValue, None, MoniTool_IntVal)
MoniTool_IntVal.Value = new_instancemethod(_MoniTool.MoniTool_IntVal_Value, None, MoniTool_IntVal)
MoniTool_IntVal_swigregister = _MoniTool.MoniTool_IntVal_swigregister
MoniTool_IntVal_swigregister(MoniTool_IntVal)

class MoniTool_MTHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args) -> "Standard_Integer":
        """
        * Returns hash code for the given string, in the range [1, theUpperBound] @param theString the string which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
        	:param theString:
        	:type theString: char *
        	:param theUpperBound:
        	:type theUpperBound: int
        	:rtype: int
        """
        return _MoniTool.MoniTool_MTHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        * Returns True when the two CString are the same. Two same strings must have the same hashcode, the contrary is not necessary. Default Str1 == Str2
        	:param Str1:
        	:type Str1: char *
        	:param Str2:
        	:type Str2: char *
        	:rtype: bool
        """
        return _MoniTool.MoniTool_MTHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object


    def __init__(self):
        _MoniTool.MoniTool_MTHasher_swiginit(self, _MoniTool.new_MoniTool_MTHasher())
    __swig_destroy__ = _MoniTool.delete_MoniTool_MTHasher
MoniTool_MTHasher_swigregister = _MoniTool.MoniTool_MTHasher_swigregister
MoniTool_MTHasher_swigregister(MoniTool_MTHasher)

def MoniTool_MTHasher_HashCode(*args) -> "Standard_Integer":
    """
    * Returns hash code for the given string, in the range [1, theUpperBound] @param theString the string which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
    	:param theString:
    	:type theString: char *
    	:param theUpperBound:
    	:type theUpperBound: int
    	:rtype: int
    """
    return _MoniTool.MoniTool_MTHasher_HashCode(*args)

def MoniTool_MTHasher_IsEqual(*args) -> "Standard_Boolean":
    """
    * Returns True when the two CString are the same. Two same strings must have the same hashcode, the contrary is not necessary. Default Str1 == Str2
    	:param Str1:
    	:type Str1: char *
    	:param Str2:
    	:type Str2: char *
    	:rtype: bool
    """
    return _MoniTool.MoniTool_MTHasher_IsEqual(*args)

class MoniTool_RealVal(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetCValue(self) -> "Standard_Real":
        """GetCValue(MoniTool_RealVal self) -> Standard_Real"""
        return _MoniTool.MoniTool_RealVal_GetCValue(self)


    def SetCValue(self, value: 'Standard_Real') -> "void":
        """SetCValue(MoniTool_RealVal self, Standard_Real value)"""
        return _MoniTool.MoniTool_RealVal_SetCValue(self, value)


    def __init__(self, *args):
        """
        :param val: default value is 0.0
        	:type val: float
        	:rtype: None
        """
        _MoniTool.MoniTool_RealVal_swiginit(self, _MoniTool.new_MoniTool_RealVal(*args))

    def Value(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _MoniTool.MoniTool_RealVal_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_RealVal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_RealVal
MoniTool_RealVal.GetCValue = new_instancemethod(_MoniTool.MoniTool_RealVal_GetCValue, None, MoniTool_RealVal)
MoniTool_RealVal.SetCValue = new_instancemethod(_MoniTool.MoniTool_RealVal_SetCValue, None, MoniTool_RealVal)
MoniTool_RealVal.Value = new_instancemethod(_MoniTool.MoniTool_RealVal_Value, None, MoniTool_RealVal)
MoniTool_RealVal_swigregister = _MoniTool.MoniTool_RealVal_swigregister
MoniTool_RealVal_swigregister(MoniTool_RealVal)

class MoniTool_SignText(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Name(self, *args) -> "char const *":
        """
        * Returns an identification of the Signature (a word), given at initialization time
        	:rtype: char *
        """
        return _MoniTool.MoniTool_SignText_Name(self, *args)


    def Text(self, *args) -> "TCollection_AsciiString":
        """
        * Gives a text as a signature for a transient object in a context If the context is senseless, it can be given as Null Handle empty result if nothing to give (at least the DynamicType could be sent ?)
        	:param ent:
        	:type ent: Standard_Transient
        	:param context:
        	:type context: Standard_Transient
        	:rtype: TCollection_AsciiString
        """
        return _MoniTool.MoniTool_SignText_Text(self, *args)


    def TextAlone(self, *args) -> "TCollection_AsciiString":
        """
        * Gives a text as a signature for a transient object alone, i.e. without defined context. By default, calls Text with undefined context (Null Handle) and if empty, then returns DynamicType
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: TCollection_AsciiString
        """
        return _MoniTool.MoniTool_SignText_TextAlone(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_SignText_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_SignText
MoniTool_SignText.Name = new_instancemethod(_MoniTool.MoniTool_SignText_Name, None, MoniTool_SignText)
MoniTool_SignText.Text = new_instancemethod(_MoniTool.MoniTool_SignText_Text, None, MoniTool_SignText)
MoniTool_SignText.TextAlone = new_instancemethod(_MoniTool.MoniTool_SignText_TextAlone, None, MoniTool_SignText)
MoniTool_SignText_swigregister = _MoniTool.MoniTool_SignText_swigregister
MoniTool_SignText_swigregister(MoniTool_SignText)

class MoniTool_Stat(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Directly addes items
        	:param nb: default value is 1
        	:type nb: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_Stat_Add(self, *args)


    def AddEnd(self, *args) -> "void":
        """
        * Ends the AddSub and cumulates the sub-count to current level
        	:rtype: None
        """
        return _MoniTool.MoniTool_Stat_AddEnd(self, *args)


    def AddSub(self, *args) -> "void":
        """
        * Declares a count of items to be added later. If a sub-counter is opened, its percentage multiplies this sub-count to compute the percent of current level
        	:param nb: default value is 1
        	:type nb: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_Stat_AddSub(self, *args)


    def Close(self, *args) -> "void":
        """
        :param id:
        	:type id: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_Stat_Close(self, *args)


    def Current(*args) -> "MoniTool_Stat &":
        """:rtype: MoniTool_Stat"""
        return _MoniTool.MoniTool_Stat_Current(*args)

    Current = staticmethod(Current)

    def Level(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _MoniTool.MoniTool_Stat_Level(self, *args)


    def __init__(self, *args):
        """
        * Creates a Stat form. At start, one default phase is defined, with one default step. Then, it suffises to start with a count of items (and cycles if several) then record items, to have a queryable report.
        	:param title: default value is 
        	:type title: char *
        	:rtype: None
        * used when starting
        	:param other:
        	:type other: MoniTool_Stat
        	:rtype: None
        """
        _MoniTool.MoniTool_Stat_swiginit(self, _MoniTool.new_MoniTool_Stat(*args))

    def Open(self, *args) -> "Standard_Integer":
        """
        * Opens a new counter with a starting count of items
        	:param nb: default value is 100
        	:type nb: int
        	:rtype: int
        """
        return _MoniTool.MoniTool_Stat_Open(self, *args)


    def OpenMore(self, *args) -> "void":
        """
        * Adds more items to be counted by Add... on current level
        	:param id:
        	:type id: int
        	:param nb:
        	:type nb: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_Stat_OpenMore(self, *args)


    def Percent(self, *args) -> "Standard_Real":
        """
        :param fromlev: default value is 0
        	:type fromlev: int
        	:rtype: float
        """
        return _MoniTool.MoniTool_Stat_Percent(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_Stat
MoniTool_Stat.Add = new_instancemethod(_MoniTool.MoniTool_Stat_Add, None, MoniTool_Stat)
MoniTool_Stat.AddEnd = new_instancemethod(_MoniTool.MoniTool_Stat_AddEnd, None, MoniTool_Stat)
MoniTool_Stat.AddSub = new_instancemethod(_MoniTool.MoniTool_Stat_AddSub, None, MoniTool_Stat)
MoniTool_Stat.Close = new_instancemethod(_MoniTool.MoniTool_Stat_Close, None, MoniTool_Stat)
MoniTool_Stat.Level = new_instancemethod(_MoniTool.MoniTool_Stat_Level, None, MoniTool_Stat)
MoniTool_Stat.Open = new_instancemethod(_MoniTool.MoniTool_Stat_Open, None, MoniTool_Stat)
MoniTool_Stat.OpenMore = new_instancemethod(_MoniTool.MoniTool_Stat_OpenMore, None, MoniTool_Stat)
MoniTool_Stat.Percent = new_instancemethod(_MoniTool.MoniTool_Stat_Percent, None, MoniTool_Stat)
MoniTool_Stat_swigregister = _MoniTool.MoniTool_Stat_swigregister
MoniTool_Stat_swigregister(MoniTool_Stat)

def MoniTool_Stat_Current(*args) -> "MoniTool_Stat &":
    """:rtype: MoniTool_Stat"""
    return _MoniTool.MoniTool_Stat_Current(*args)

class MoniTool_Timer(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Amend(self, *args) -> "Standard_Real":
        """
        * Return value of accumulated amendment on CPU time
        	:rtype: float
        """
        return _MoniTool.MoniTool_Timer_Amend(self, *args)


    def CPU(self, *args) -> "Standard_Real":
        """
        * Return value of CPU time minus accumulated amendment
        	:rtype: float
        """
        return _MoniTool.MoniTool_Timer_CPU(self, *args)


    def ClearTimers(*args) -> "void":
        """
        * Clears map of timers
        	:rtype: void
        """
        return _MoniTool.MoniTool_Timer_ClearTimers(*args)

    ClearTimers = staticmethod(ClearTimers)

    def ComputeAmendments(*args) -> "void":
        """
        * Computes and remembers amendments for times to access, start, and stop of timer, and estimates second-order error measured by 10 nested timers
        	:rtype: void
        """
        return _MoniTool.MoniTool_Timer_ComputeAmendments(*args)

    ComputeAmendments = staticmethod(ComputeAmendments)

    def Count(self, *args) -> "Standard_Integer":
        """
        * Return value of hits counter (count of Start/Stop pairs)
        	:rtype: int
        """
        return _MoniTool.MoniTool_Timer_Count(self, *args)


    def Dictionary(*args) -> "MoniTool_DataMapOfTimer &":
        """
        * Returns map of timers
        	:rtype: MoniTool_DataMapOfTimer
        """
        return _MoniTool.MoniTool_Timer_Dictionary(*args)

    Dictionary = staticmethod(Dictionary)

    def DumpToString(self) -> "std::string":
        """DumpToString(MoniTool_Timer self) -> std::string"""
        return _MoniTool.MoniTool_Timer_DumpToString(self)


    def DumpTimersToString(self) -> "std::string":
        """DumpTimersToString(MoniTool_Timer self) -> std::string"""
        return _MoniTool.MoniTool_Timer_DumpTimersToString(self)


    def GetAmendments(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
        """
        * The computed amendmens are returned (for information only)
        	:param Access:
        	:type Access: float
        	:param Internal:
        	:type Internal: float
        	:param External:
        	:type External: float
        	:param Error10:
        	:type Error10: float
        	:rtype: void
        """
        return _MoniTool.MoniTool_Timer_GetAmendments(*args)

    GetAmendments = staticmethod(GetAmendments)

    def IsRunning(self, *args) -> "Standard_Integer":
        """
        * Returns value of nesting counter
        	:rtype: int
        """
        return _MoniTool.MoniTool_Timer_IsRunning(self, *args)


    def __init__(self, *args):
        """
        * Create timer in empty state
        	:rtype: None
        """
        _MoniTool.MoniTool_Timer_swiginit(self, _MoniTool.new_MoniTool_Timer(*args))

    def Reset(self, *args) -> "void":
        """
        * Start, Stop and reset the timer In addition to doing that to embedded OSD_Timer, manage also counter of hits
        	:rtype: None
        """
        return _MoniTool.MoniTool_Timer_Reset(self, *args)


    def Start(*args) -> "void":
        """
        :rtype: None
        :param name:
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_Timer_Start(*args)

    Start = staticmethod(Start)

    def Stop(*args) -> "void":
        """
        :rtype: None
        * Inline methods to conveniently start/stop timer by name Shortcut to Timer(name)->Start/Stop()
        	:param name:
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_Timer_Stop(*args)

    Stop = staticmethod(Stop)

    def Timer(*args) -> "opencascade::handle< MoniTool_Timer >":
        """
        :rtype: OSD_Timer
        * Returns a timer from a dictionary by its name If timer not existed, creates a new one
        	:param name:
        	:type name: char *
        	:rtype: opencascade::handle<MoniTool_Timer>
        """
        return _MoniTool.MoniTool_Timer_Timer(*args)

    Timer = staticmethod(Timer)


    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_Timer_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_Timer
MoniTool_Timer.Amend = new_instancemethod(_MoniTool.MoniTool_Timer_Amend, None, MoniTool_Timer)
MoniTool_Timer.CPU = new_instancemethod(_MoniTool.MoniTool_Timer_CPU, None, MoniTool_Timer)
MoniTool_Timer.Count = new_instancemethod(_MoniTool.MoniTool_Timer_Count, None, MoniTool_Timer)
MoniTool_Timer.DumpToString = new_instancemethod(_MoniTool.MoniTool_Timer_DumpToString, None, MoniTool_Timer)
MoniTool_Timer.DumpTimersToString = new_instancemethod(_MoniTool.MoniTool_Timer_DumpTimersToString, None, MoniTool_Timer)
MoniTool_Timer.IsRunning = new_instancemethod(_MoniTool.MoniTool_Timer_IsRunning, None, MoniTool_Timer)
MoniTool_Timer.Reset = new_instancemethod(_MoniTool.MoniTool_Timer_Reset, None, MoniTool_Timer)
MoniTool_Timer_swigregister = _MoniTool.MoniTool_Timer_swigregister
MoniTool_Timer_swigregister(MoniTool_Timer)

def MoniTool_Timer_ClearTimers(*args) -> "void":
    """
    * Clears map of timers
    	:rtype: void
    """
    return _MoniTool.MoniTool_Timer_ClearTimers(*args)

def MoniTool_Timer_ComputeAmendments(*args) -> "void":
    """
    * Computes and remembers amendments for times to access, start, and stop of timer, and estimates second-order error measured by 10 nested timers
    	:rtype: void
    """
    return _MoniTool.MoniTool_Timer_ComputeAmendments(*args)

def MoniTool_Timer_Dictionary(*args) -> "MoniTool_DataMapOfTimer &":
    """
    * Returns map of timers
    	:rtype: MoniTool_DataMapOfTimer
    """
    return _MoniTool.MoniTool_Timer_Dictionary(*args)

def MoniTool_Timer_GetAmendments(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
    """
    * The computed amendmens are returned (for information only)
    	:param Access:
    	:type Access: float
    	:param Internal:
    	:type Internal: float
    	:param External:
    	:type External: float
    	:param Error10:
    	:type Error10: float
    	:rtype: void
    """
    return _MoniTool.MoniTool_Timer_GetAmendments(*args)

def MoniTool_Timer_Start(*args) -> "void":
    """
    :rtype: None
    :param name:
    	:type name: char *
    	:rtype: None
    """
    return _MoniTool.MoniTool_Timer_Start(*args)

def MoniTool_Timer_Stop(*args) -> "void":
    """
    :rtype: None
    * Inline methods to conveniently start/stop timer by name Shortcut to Timer(name)->Start/Stop()
    	:param name:
    	:type name: char *
    	:rtype: None
    """
    return _MoniTool.MoniTool_Timer_Stop(*args)

def MoniTool_Timer_Timer(*args) -> "opencascade::handle< MoniTool_Timer >":
    """
    :rtype: OSD_Timer
    * Returns a timer from a dictionary by its name If timer not existed, creates a new one
    	:param name:
    	:type name: char *
    	:rtype: opencascade::handle<MoniTool_Timer>
    """
    return _MoniTool.MoniTool_Timer_Timer(*args)

class MoniTool_TimerSentry(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor creates an instance and runs the corresponding timer
        	:param cname:
        	:type cname: char *
        	:rtype: None
        * Constructor creates an instance and runs the corresponding timer
        	:param timer:
        	:type timer: MoniTool_Timer
        	:rtype: None
        """
        _MoniTool.MoniTool_TimerSentry_swiginit(self, _MoniTool.new_MoniTool_TimerSentry(*args))

    def Stop(self, *args) -> "void":
        """
        * Manually stops the timer
        	:rtype: None
        """
        return _MoniTool.MoniTool_TimerSentry_Stop(self, *args)


    def Timer(self, *args) -> "opencascade::handle< MoniTool_Timer >":
        """:rtype: opencascade::handle<MoniTool_Timer>"""
        return _MoniTool.MoniTool_TimerSentry_Timer(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_TimerSentry
MoniTool_TimerSentry.Stop = new_instancemethod(_MoniTool.MoniTool_TimerSentry_Stop, None, MoniTool_TimerSentry)
MoniTool_TimerSentry.Timer = new_instancemethod(_MoniTool.MoniTool_TimerSentry_Timer, None, MoniTool_TimerSentry)
MoniTool_TimerSentry_swigregister = _MoniTool.MoniTool_TimerSentry_swigregister
MoniTool_TimerSentry_swigregister(MoniTool_TimerSentry)

class MoniTool_TypedValue(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddDef(self, *args) -> "Standard_Boolean":
        """
        * Completes the definition of a TypedValue by command <initext>, once created with its type Returns True if done, False if could not be interpreted <initext> may be : imin ival : minimum value for an integer imax ival : maximum value for an integer rmin rval : minimum value for a real rmax rval : maximum value for a real unit name : name of unit ematch i : enum from integer value i, match required enum i : enum from integer value i, match not required eval text : add an enumerative value (increments max by 1) eval : add a non-authorised enum value (to be skipped) tmax l : maximum length for a text
        	:param initext:
        	:type initext: char *
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_AddDef(self, *args)


    def AddEnum(self, *args) -> "void":
        """
        * Adds enumerative definitions. For more than 10, several calls
        	:param v1: default value is 
        	:type v1: char *
        	:param v2: default value is 
        	:type v2: char *
        	:param v3: default value is 
        	:type v3: char *
        	:param v4: default value is 
        	:type v4: char *
        	:param v5: default value is 
        	:type v5: char *
        	:param v6: default value is 
        	:type v6: char *
        	:param v7: default value is 
        	:type v7: char *
        	:param v8: default value is 
        	:type v8: char *
        	:param v9: default value is 
        	:type v9: char *
        	:param v10: default value is 
        	:type v10: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_AddEnum(self, *args)


    def AddEnumValue(self, *args) -> "void":
        """
        * Adds an enumeration definition, by its string and numeric values. If it is the first setting for this value, it is recorded as main value. Else, it is recognized as alternate string for this numeric value
        	:param val:
        	:type val: char *
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_AddEnumValue(self, *args)


    def AddLib(*args) -> "Standard_Boolean":
        """
        * Adds a TypedValue in the library. It is recorded then will be accessed by its Name Its Definition may be imposed, else it is computed as usual By default it will be accessed by its Definition (string) Returns True if done, False if tv is Null or brings no Definition or <def> not defined //! If a TypedValue was already recorded under this name, it is replaced
        	:param tv:
        	:type tv: MoniTool_TypedValue
        	:param def: default value is 
        	:type def: char *
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_AddLib(*args)

    AddLib = staticmethod(AddLib)

    def CStringValue(self, *args) -> "char const *":
        """
        * Returns the value, as a cstring. Empty if not set.
        	:rtype: char *
        """
        return _MoniTool.MoniTool_TypedValue_CStringValue(self, *args)


    def ClearValue(self, *args) -> "void":
        """
        * Clears the recorded Value : it is now unset
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_ClearValue(self, *args)


    def Definition(self, *args) -> "TCollection_AsciiString":
        """
        * Returns the Definition By priority, the enforced one, else an automatic one, computed from the specification
        	:rtype: TCollection_AsciiString
        """
        return _MoniTool.MoniTool_TypedValue_Definition(self, *args)


    def EnumCase(self, *args) -> "Standard_Integer":
        """
        * Returns the case number which cooresponds to a string value Works with main and additionnal values Returns (StartEnum - 1) if not OK, -1 if not an Enum
        	:param val:
        	:type val: char *
        	:rtype: int
        """
        return _MoniTool.MoniTool_TypedValue_EnumCase(self, *args)


    def EnumDef(self, *args) -> "Standard_Boolean":
        """
        * Gives the Enum definitions : start value, end value, match status. Returns True for an Enum, False else.
        	:param startcase:
        	:type startcase: int
        	:param endcase:
        	:type endcase: int
        	:param match:
        	:type match: bool
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_EnumDef(self, *args)


    def EnumVal(self, *args) -> "char const *":
        """
        * Returns the value of an enumerative definition, from its rank Empty string if out of range or not an Enum
        	:param num:
        	:type num: int
        	:rtype: char *
        """
        return _MoniTool.MoniTool_TypedValue_EnumVal(self, *args)


    def FromLib(*args) -> "opencascade::handle< MoniTool_TypedValue >":
        """
        * Returns a COPY of the TypedValue bound with a given Name Null Handle if none recorded
        	:param def:
        	:type def: char *
        	:rtype: opencascade::handle<MoniTool_TypedValue>
        """
        return _MoniTool.MoniTool_TypedValue_FromLib(*args)

    FromLib = staticmethod(FromLib)

    def GetObjectValue(self, *args) -> "void":
        """
        * Same as ObjectValue, but avoids DownCast : the receiving variable is directly loaded. It is assumed that it complies with the definition of ObjectType ! Otherwise, big trouble
        	:param val:
        	:type val: Standard_Transient
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_GetObjectValue(self, *args)


    def HStringValue(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        * Returns the value, as a opencascade::handle<canthenbeshared> Null if not defined
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _MoniTool.MoniTool_TypedValue_HStringValue(self, *args)


    def HasInterpret(self, *args) -> "Standard_Boolean":
        """
        * Tells if a TypedValue has an Interpret
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_HasInterpret(self, *args)


    def IntegerLimit(self, *args) -> "Standard_Boolean":
        """
        * Gives an Integer Limit (upper if <max> True, lower if <max> False). Returns True if this limit is defined, False else (in that case, gives the natural limit for Integer)
        	:param max:
        	:type max: bool
        	:param val:
        	:type val: int
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_IntegerLimit(self, *args)


    def IntegerValue(self, *args) -> "Standard_Integer":
        """
        * Returns the value as integer, i.e. : For type = Integer, the integer itself; 0 if not set For type = Enum, the designated rank (see Enum definition) StartEnum - 1 if not set or not in the definition Else, returns 0
        	:rtype: int
        """
        return _MoniTool.MoniTool_TypedValue_IntegerValue(self, *args)


    def Internals(self, *args) -> "void":
        """
        * Access to internal data which have no other access
        	:param interp:
        	:type interp: MoniTool_ValueInterpret
        	:param satisf:
        	:type satisf: MoniTool_ValueSatisfies
        	:param satisname:
        	:type satisname: char *
        	:param enums:
        	:type enums: NCollection_DataMap<TCollection_AsciiString, int>
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_Internals(self, *args)


    def Interpret(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        * Interprets a value. <native> True : returns a native value <native> False : returns a coded value If the Interpret function is set, calls it Else, for an Enum, Native returns the Text, Coded returns the number STANDARD RETURNS : = hval means no specific interpretation Null means senseless Can also be redefined
        	:param hval:
        	:type hval: TCollection_HAsciiString
        	:param native:
        	:type native: bool
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _MoniTool.MoniTool_TypedValue_Interpret(self, *args)


    def IsSetValue(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the value is set (not empty/not null object)
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_IsSetValue(self, *args)


    def Label(self, *args) -> "char const *":
        """
        * Returns the label, if set; else returns an empty string
        	:rtype: char *
        """
        return _MoniTool.MoniTool_TypedValue_Label(self, *args)


    def Lib(*args) -> "opencascade::handle< MoniTool_TypedValue >":
        """
        * Returns the TypedValue bound with a given Name Null Handle if none recorded Warning : it is the original, not duplicated
        	:param def:
        	:type def: char *
        	:rtype: opencascade::handle<MoniTool_TypedValue>
        """
        return _MoniTool.MoniTool_TypedValue_Lib(*args)

    Lib = staticmethod(Lib)

    def LibList(*args) -> "opencascade::handle< TColStd_HSequenceOfAsciiString >":
        """
        * Returns the list of names of items of the Library of Types -- Library of TypedValue as Valued Parameters, -- -- accessed by parameter name for use by management of Static Parameters
        	:rtype: opencascade::handle<TColStd_HSequenceOfAsciiString>
        """
        return _MoniTool.MoniTool_TypedValue_LibList(*args)

    LibList = staticmethod(LibList)

    def MaxLength(self, *args) -> "Standard_Integer":
        """
        * Returns the maximum length, 0 if not set
        	:rtype: int
        """
        return _MoniTool.MoniTool_TypedValue_MaxLength(self, *args)


    def __init__(self, *args):
        """
        * Creates a TypedValue, with a name //! type gives the type of the parameter, default is free text Also available : Integer, Real, Enum, Entity (i.e. Object) More precise specifications, titles, can be given to the TypedValue once created //! init gives an initial value. If it is not given, the TypedValue begins as 'not set', its value is empty
        	:param name:
        	:type name: char *
        	:param type: default value is MoniTool_ValueText
        	:type type: MoniTool_ValueType
        	:param init: default value is 
        	:type init: char *
        	:rtype: None
        * Creates a TypedValue from another one, by duplication
        	:param other:
        	:type other: MoniTool_TypedValue
        	:rtype: None
        """
        _MoniTool.MoniTool_TypedValue_swiginit(self, _MoniTool.new_MoniTool_TypedValue(*args))

    def Name(self, *args) -> "char const *":
        """
        * Returns the name
        	:rtype: char *
        """
        return _MoniTool.MoniTool_TypedValue_Name(self, *args)


    def ObjectType(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns the type of which an Object TypedValue must be kind of Default is Standard_Transient Null for a TypedValue not an Object
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _MoniTool.MoniTool_TypedValue_ObjectType(self, *args)


    def ObjectTypeName(self, *args) -> "char const *":
        """
        * Returns the type name of the ObjectValue, or an empty string if not set
        	:rtype: char *
        """
        return _MoniTool.MoniTool_TypedValue_ObjectTypeName(self, *args)


    def ObjectValue(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns the value as Transient Object, only for Object/Entity Remark that the 'HString value' is IGNORED here Null if not set; remains to be casted
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _MoniTool.MoniTool_TypedValue_ObjectValue(self, *args)


    def Print(self, *args) -> "void":
        """
        * Prints definition, specification, and actual status and value
        	:param S:
        	:type S: Message_Messenger
        	:rtype: void
        """
        return _MoniTool.MoniTool_TypedValue_Print(self, *args)


    def PrintValue(self, *args) -> "void":
        """
        * Prints only the Value
        	:param S:
        	:type S: Message_Messenger
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_PrintValue(self, *args)


    def RealLimit(self, *args) -> "Standard_Boolean":
        """
        * Gives an Real Limit (upper if <max> True, lower if <max> False). Returns True if this limit is defined, False else (in that case, gives the natural limit for Real)
        	:param max:
        	:type max: bool
        	:param val:
        	:type val: float
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_RealLimit(self, *args)


    def RealValue(self, *args) -> "Standard_Real":
        """
        * Returns the value as real, for a Real type TypedValue Else, returns 0.
        	:rtype: float
        """
        return _MoniTool.MoniTool_TypedValue_RealValue(self, *args)


    def Satisfies(self, *args) -> "Standard_Boolean":
        """
        * Returns True if a value statifies the specification (remark : does not apply to Entity : see ObjectType, for this type, the string is just a comment)
        	:param hval:
        	:type hval: TCollection_HAsciiString
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_Satisfies(self, *args)


    def SatisfiesName(self, *args) -> "char const *":
        """
        * Returns name of specific satisfy, empty string if none
        	:rtype: char *
        """
        return _MoniTool.MoniTool_TypedValue_SatisfiesName(self, *args)


    def SetCStringValue(self, *args) -> "Standard_Boolean":
        """
        * Changes the value. The new one must satisfy the specification Returns False (and did not set) if the new value does not satisfy the specification Can be redefined to be managed (in a subclass)
        	:param val:
        	:type val: char *
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_SetCStringValue(self, *args)


    def SetDefinition(self, *args) -> "void":
        """
        * Enforces a Definition
        	:param deftext:
        	:type deftext: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_SetDefinition(self, *args)


    def SetHStringValue(self, *args) -> "Standard_Boolean":
        """
        * Forces a new Handle for the Value It can be empty, else (if Type is not free Text), it must satisfy the specification. Not only the value is changed, but also the way it is shared Remark : for Type=Object, this value is not controlled, it can be set as a comment Returns False (and did not set) if the new value does not satisfy the specification Can be redefined to be managed (in a subclass)
        	:param hval:
        	:type hval: TCollection_HAsciiString
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_SetHStringValue(self, *args)


    def SetIntegerLimit(self, *args) -> "void":
        """
        * Sets an Integer limit (included) to <val>, the upper limit if <max> is True, the lower limit if <max> is False
        	:param max:
        	:type max: bool
        	:param val:
        	:type val: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_SetIntegerLimit(self, *args)


    def SetIntegerValue(self, *args) -> "Standard_Boolean":
        """
        * Changes the value as an integer, only for Integer or Enum
        	:param ival:
        	:type ival: int
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_SetIntegerValue(self, *args)


    def SetInterpret(self, *args) -> "void":
        """
        * Sets a specific Interpret function
        	:param func:
        	:type func: MoniTool_ValueInterpret
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_SetInterpret(self, *args)


    def SetLabel(self, *args) -> "void":
        """
        * Sets a label, which can then be displayed
        	:param label:
        	:type label: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_SetLabel(self, *args)


    def SetMaxLength(self, *args) -> "void":
        """
        * Sets a maximum length for a text (active only for a free text)
        	:param max:
        	:type max: int
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_SetMaxLength(self, *args)


    def SetObjectType(self, *args) -> "void":
        """
        * Sets type of which an Object TypedValue must be kind of Error for a TypedValue not an Object (Entity)
        	:param typ:
        	:type typ: Standard_Type
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_SetObjectType(self, *args)


    def SetObjectValue(self, *args) -> "Standard_Boolean":
        """
        * Changes the value as Transient Object, only for Object/Entity Returns False if DynamicType does not satisfy ObjectType Can be redefined to be managed (in a subclass)
        	:param obj:
        	:type obj: Standard_Transient
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_SetObjectValue(self, *args)


    def SetRealLimit(self, *args) -> "void":
        """
        * Sets a Real limit (included) to <val>, the upper limit if <max> is True, the lower limit if <max> is False
        	:param max:
        	:type max: bool
        	:param val:
        	:type val: float
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_SetRealLimit(self, *args)


    def SetRealValue(self, *args) -> "Standard_Boolean":
        """
        * Changes the value as a real, only for Real
        	:param rval:
        	:type rval: float
        	:rtype: bool
        """
        return _MoniTool.MoniTool_TypedValue_SetRealValue(self, *args)


    def SetSatisfies(self, *args) -> "void":
        """
        * Sets a specific Satisfies function : it is added to the already defined criteria It must match the form : statisfies (val : HAsciiString) returns Boolean
        	:param func:
        	:type func: MoniTool_ValueSatisfies
        	:param name:
        	:type name: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_SetSatisfies(self, *args)


    def SetUnitDef(self, *args) -> "void":
        """
        * Sets (Clears if <def> empty) a unit definition, as an equation of dimensions. TypedValue just records this definition, does not exploit it, to be done as required by user applications
        	:param def:
        	:type def: char *
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_SetUnitDef(self, *args)


    def StartEnum(self, *args) -> "void":
        """
        * For an enumeration, precises the starting value (default 0) and the match condition : if True (D), the string value must match the definition, else it may take another value : in that case, the Integer Value will be Start - 1. (empty value remains allowed)
        	:param start: default value is 0
        	:type start: int
        	:param match: default value is Standard_True
        	:type match: bool
        	:rtype: None
        """
        return _MoniTool.MoniTool_TypedValue_StartEnum(self, *args)


    def StaticValue(*args) -> "opencascade::handle< MoniTool_TypedValue >":
        """
        * Returns a static value from its name, null if unknown
        	:param name:
        	:type name: char *
        	:rtype: opencascade::handle<MoniTool_TypedValue>
        """
        return _MoniTool.MoniTool_TypedValue_StaticValue(*args)

    StaticValue = staticmethod(StaticValue)

    def UnitDef(self, *args) -> "char const *":
        """
        * Returns the recorded unit definition, empty if not set
        	:rtype: char *
        """
        return _MoniTool.MoniTool_TypedValue_UnitDef(self, *args)


    def ValueType(self, *args) -> "MoniTool_ValueType":
        """
        * Returns the type of the value
        	:rtype: MoniTool_ValueType
        """
        return _MoniTool.MoniTool_TypedValue_ValueType(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_TypedValue_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_TypedValue
MoniTool_TypedValue.AddDef = new_instancemethod(_MoniTool.MoniTool_TypedValue_AddDef, None, MoniTool_TypedValue)
MoniTool_TypedValue.AddEnum = new_instancemethod(_MoniTool.MoniTool_TypedValue_AddEnum, None, MoniTool_TypedValue)
MoniTool_TypedValue.AddEnumValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_AddEnumValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.CStringValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_CStringValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.ClearValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_ClearValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.Definition = new_instancemethod(_MoniTool.MoniTool_TypedValue_Definition, None, MoniTool_TypedValue)
MoniTool_TypedValue.EnumCase = new_instancemethod(_MoniTool.MoniTool_TypedValue_EnumCase, None, MoniTool_TypedValue)
MoniTool_TypedValue.EnumDef = new_instancemethod(_MoniTool.MoniTool_TypedValue_EnumDef, None, MoniTool_TypedValue)
MoniTool_TypedValue.EnumVal = new_instancemethod(_MoniTool.MoniTool_TypedValue_EnumVal, None, MoniTool_TypedValue)
MoniTool_TypedValue.GetObjectValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_GetObjectValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.HStringValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_HStringValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.HasInterpret = new_instancemethod(_MoniTool.MoniTool_TypedValue_HasInterpret, None, MoniTool_TypedValue)
MoniTool_TypedValue.IntegerLimit = new_instancemethod(_MoniTool.MoniTool_TypedValue_IntegerLimit, None, MoniTool_TypedValue)
MoniTool_TypedValue.IntegerValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_IntegerValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.Internals = new_instancemethod(_MoniTool.MoniTool_TypedValue_Internals, None, MoniTool_TypedValue)
MoniTool_TypedValue.Interpret = new_instancemethod(_MoniTool.MoniTool_TypedValue_Interpret, None, MoniTool_TypedValue)
MoniTool_TypedValue.IsSetValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_IsSetValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.Label = new_instancemethod(_MoniTool.MoniTool_TypedValue_Label, None, MoniTool_TypedValue)
MoniTool_TypedValue.MaxLength = new_instancemethod(_MoniTool.MoniTool_TypedValue_MaxLength, None, MoniTool_TypedValue)
MoniTool_TypedValue.Name = new_instancemethod(_MoniTool.MoniTool_TypedValue_Name, None, MoniTool_TypedValue)
MoniTool_TypedValue.ObjectType = new_instancemethod(_MoniTool.MoniTool_TypedValue_ObjectType, None, MoniTool_TypedValue)
MoniTool_TypedValue.ObjectTypeName = new_instancemethod(_MoniTool.MoniTool_TypedValue_ObjectTypeName, None, MoniTool_TypedValue)
MoniTool_TypedValue.ObjectValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_ObjectValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.Print = new_instancemethod(_MoniTool.MoniTool_TypedValue_Print, None, MoniTool_TypedValue)
MoniTool_TypedValue.PrintValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_PrintValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.RealLimit = new_instancemethod(_MoniTool.MoniTool_TypedValue_RealLimit, None, MoniTool_TypedValue)
MoniTool_TypedValue.RealValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_RealValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.Satisfies = new_instancemethod(_MoniTool.MoniTool_TypedValue_Satisfies, None, MoniTool_TypedValue)
MoniTool_TypedValue.SatisfiesName = new_instancemethod(_MoniTool.MoniTool_TypedValue_SatisfiesName, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetCStringValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetCStringValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetDefinition = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetDefinition, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetHStringValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetHStringValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetIntegerLimit = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetIntegerLimit, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetIntegerValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetIntegerValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetInterpret = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetInterpret, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetLabel = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetLabel, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetMaxLength = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetMaxLength, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetObjectType = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetObjectType, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetObjectValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetObjectValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetRealLimit = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetRealLimit, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetRealValue = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetRealValue, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetSatisfies = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetSatisfies, None, MoniTool_TypedValue)
MoniTool_TypedValue.SetUnitDef = new_instancemethod(_MoniTool.MoniTool_TypedValue_SetUnitDef, None, MoniTool_TypedValue)
MoniTool_TypedValue.StartEnum = new_instancemethod(_MoniTool.MoniTool_TypedValue_StartEnum, None, MoniTool_TypedValue)
MoniTool_TypedValue.UnitDef = new_instancemethod(_MoniTool.MoniTool_TypedValue_UnitDef, None, MoniTool_TypedValue)
MoniTool_TypedValue.ValueType = new_instancemethod(_MoniTool.MoniTool_TypedValue_ValueType, None, MoniTool_TypedValue)
MoniTool_TypedValue_swigregister = _MoniTool.MoniTool_TypedValue_swigregister
MoniTool_TypedValue_swigregister(MoniTool_TypedValue)

def MoniTool_TypedValue_AddLib(*args) -> "Standard_Boolean":
    """
    * Adds a TypedValue in the library. It is recorded then will be accessed by its Name Its Definition may be imposed, else it is computed as usual By default it will be accessed by its Definition (string) Returns True if done, False if tv is Null or brings no Definition or <def> not defined //! If a TypedValue was already recorded under this name, it is replaced
    	:param tv:
    	:type tv: MoniTool_TypedValue
    	:param def: default value is 
    	:type def: char *
    	:rtype: bool
    """
    return _MoniTool.MoniTool_TypedValue_AddLib(*args)

def MoniTool_TypedValue_FromLib(*args) -> "opencascade::handle< MoniTool_TypedValue >":
    """
    * Returns a COPY of the TypedValue bound with a given Name Null Handle if none recorded
    	:param def:
    	:type def: char *
    	:rtype: opencascade::handle<MoniTool_TypedValue>
    """
    return _MoniTool.MoniTool_TypedValue_FromLib(*args)

def MoniTool_TypedValue_Lib(*args) -> "opencascade::handle< MoniTool_TypedValue >":
    """
    * Returns the TypedValue bound with a given Name Null Handle if none recorded Warning : it is the original, not duplicated
    	:param def:
    	:type def: char *
    	:rtype: opencascade::handle<MoniTool_TypedValue>
    """
    return _MoniTool.MoniTool_TypedValue_Lib(*args)

def MoniTool_TypedValue_LibList(*args) -> "opencascade::handle< TColStd_HSequenceOfAsciiString >":
    """
    * Returns the list of names of items of the Library of Types -- Library of TypedValue as Valued Parameters, -- -- accessed by parameter name for use by management of Static Parameters
    	:rtype: opencascade::handle<TColStd_HSequenceOfAsciiString>
    """
    return _MoniTool.MoniTool_TypedValue_LibList(*args)

def MoniTool_TypedValue_StaticValue(*args) -> "opencascade::handle< MoniTool_TypedValue >":
    """
    * Returns a static value from its name, null if unknown
    	:param name:
    	:type name: char *
    	:rtype: opencascade::handle<MoniTool_TypedValue>
    """
    return _MoniTool.MoniTool_TypedValue_StaticValue(*args)

class MoniTool_SignShape(MoniTool_SignText):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _MoniTool.MoniTool_SignShape_swiginit(self, _MoniTool.new_MoniTool_SignShape(*args))


    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_SignShape_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_SignShape
MoniTool_SignShape_swigregister = _MoniTool.MoniTool_SignShape_swigregister
MoniTool_SignShape_swigregister(MoniTool_SignShape)

class MoniTool_TransientElem(MoniTool_Element):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a TransientElem with a Value. This Value can then not be changed. It is used by the Hasher to compute the HashCode, which will then be stored for an immediate reading.
        	:param akey:
        	:type akey: Standard_Transient
        	:rtype: None
        """
        _MoniTool.MoniTool_TransientElem_swiginit(self, _MoniTool.new_MoniTool_TransientElem(*args))

    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the contained value
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _MoniTool.MoniTool_TransientElem_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_TransientElem_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_TransientElem
MoniTool_TransientElem.Value = new_instancemethod(_MoniTool.MoniTool_TransientElem_Value, None, MoniTool_TransientElem)
MoniTool_TransientElem_swigregister = _MoniTool.MoniTool_TransientElem_swigregister
MoniTool_TransientElem_swigregister(MoniTool_TransientElem)

class MoniTool_HSequenceOfElement(MoniTool_SequenceOfElement, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _MoniTool.MoniTool_HSequenceOfElement_swiginit(self, _MoniTool.new_MoniTool_HSequenceOfElement(*args))


    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_HSequenceOfElement_DownCast(t)

    __swig_destroy__ = _MoniTool.delete_MoniTool_HSequenceOfElement
MoniTool_HSequenceOfElement.Sequence = new_instancemethod(_MoniTool.MoniTool_HSequenceOfElement_Sequence, None, MoniTool_HSequenceOfElement)
MoniTool_HSequenceOfElement.Append = new_instancemethod(_MoniTool.MoniTool_HSequenceOfElement_Append, None, MoniTool_HSequenceOfElement)
MoniTool_HSequenceOfElement.ChangeSequence = new_instancemethod(_MoniTool.MoniTool_HSequenceOfElement_ChangeSequence, None, MoniTool_HSequenceOfElement)
MoniTool_HSequenceOfElement_swigregister = _MoniTool.MoniTool_HSequenceOfElement_swigregister
MoniTool_HSequenceOfElement_swigregister(MoniTool_HSequenceOfElement)



