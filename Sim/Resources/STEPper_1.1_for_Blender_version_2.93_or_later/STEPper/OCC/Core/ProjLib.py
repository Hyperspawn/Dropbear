# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
ProjLib module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_projlib.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _ProjLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ProjLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ProjLib')
    _ProjLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ProjLib', [dirname(__file__)])
        except ImportError:
            import _ProjLib
            return _ProjLib
        try:
            _mod = imp.load_module('_ProjLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ProjLib = swig_import_helper()
    del swig_import_helper
else:
    import _ProjLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ProjLib.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_ProjLib.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_ProjLib.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_ProjLib.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_ProjLib.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_ProjLib.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_ProjLib.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_ProjLib.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_ProjLib.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_ProjLib.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_ProjLib.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_ProjLib.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_ProjLib.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_ProjLib.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_ProjLib.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_ProjLib.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_ProjLib.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _ProjLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _ProjLib.process_exception(error, method_name, class_name)
process_exception = _ProjLib.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColgp
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.AppParCurves
import OCC.Core.GeomAdaptor

def Handle_ProjLib_HCompProjectedCurve_Create() -> "opencascade::handle< ProjLib_HCompProjectedCurve >":
    return _ProjLib.Handle_ProjLib_HCompProjectedCurve_Create()
Handle_ProjLib_HCompProjectedCurve_Create = _ProjLib.Handle_ProjLib_HCompProjectedCurve_Create

def Handle_ProjLib_HCompProjectedCurve_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ProjLib_HCompProjectedCurve >":
    return _ProjLib.Handle_ProjLib_HCompProjectedCurve_DownCast(t)
Handle_ProjLib_HCompProjectedCurve_DownCast = _ProjLib.Handle_ProjLib_HCompProjectedCurve_DownCast

def Handle_ProjLib_HCompProjectedCurve_IsNull(t: 'opencascade::handle< ProjLib_HCompProjectedCurve > const &') -> "bool":
    return _ProjLib.Handle_ProjLib_HCompProjectedCurve_IsNull(t)
Handle_ProjLib_HCompProjectedCurve_IsNull = _ProjLib.Handle_ProjLib_HCompProjectedCurve_IsNull

def Handle_ProjLib_HProjectedCurve_Create() -> "opencascade::handle< ProjLib_HProjectedCurve >":
    return _ProjLib.Handle_ProjLib_HProjectedCurve_Create()
Handle_ProjLib_HProjectedCurve_Create = _ProjLib.Handle_ProjLib_HProjectedCurve_Create

def Handle_ProjLib_HProjectedCurve_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ProjLib_HProjectedCurve >":
    return _ProjLib.Handle_ProjLib_HProjectedCurve_DownCast(t)
Handle_ProjLib_HProjectedCurve_DownCast = _ProjLib.Handle_ProjLib_HProjectedCurve_DownCast

def Handle_ProjLib_HProjectedCurve_IsNull(t: 'opencascade::handle< ProjLib_HProjectedCurve > const &') -> "bool":
    return _ProjLib.Handle_ProjLib_HProjectedCurve_IsNull(t)
Handle_ProjLib_HProjectedCurve_IsNull = _ProjLib.Handle_ProjLib_HProjectedCurve_IsNull

def Handle_ProjLib_HSequenceOfHSequenceOfPnt_Create() -> "opencascade::handle< ProjLib_HSequenceOfHSequenceOfPnt >":
    return _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_Create()
Handle_ProjLib_HSequenceOfHSequenceOfPnt_Create = _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_Create

def Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ProjLib_HSequenceOfHSequenceOfPnt >":
    return _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast(t)
Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast = _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast

def Handle_ProjLib_HSequenceOfHSequenceOfPnt_IsNull(t: 'opencascade::handle< ProjLib_HSequenceOfHSequenceOfPnt > const &') -> "bool":
    return _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_IsNull(t)
Handle_ProjLib_HSequenceOfHSequenceOfPnt_IsNull = _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_IsNull
class ProjLib_SequenceOfHSequenceOfPnt(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_swiginit(self, _ProjLib.new_ProjLib_SequenceOfHSequenceOfPnt(*args))
    delNode = staticmethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_delNode)
    __swig_destroy__ = _ProjLib.delete_ProjLib_SequenceOfHSequenceOfPnt
ProjLib_SequenceOfHSequenceOfPnt.begin = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_begin, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.end = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_end, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.cbegin = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_cbegin, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.cend = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_cend, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Size = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Size, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Length = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Length, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Lower = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Lower, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Upper = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Upper, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.IsEmpty = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_IsEmpty, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Reverse = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Reverse, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Exchange = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Exchange, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Clear = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Clear, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Assign = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Assign, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Set = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Set, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Remove = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Remove, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Append = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Append, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Prepend = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Prepend, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.InsertBefore = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertBefore, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.InsertAfter = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertAfter, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Split = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Split, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.First = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_First, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.ChangeFirst = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_ChangeFirst, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Last = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Last, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.ChangeLast = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_ChangeLast, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Value = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Value, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.ChangeValue = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_ChangeValue, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.__call__ = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt___call__, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.SetValue = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_SetValue, None, ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt_swigregister = _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_swigregister
ProjLib_SequenceOfHSequenceOfPnt_swigregister(ProjLib_SequenceOfHSequenceOfPnt)

def ProjLib_SequenceOfHSequenceOfPnt_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_delNode(theNode, theAl)
ProjLib_SequenceOfHSequenceOfPnt_delNode = _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_delNode

class projlib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsAnaSurf(*args) -> "Standard_Boolean":
        """
        * Returns 'true' if surface is analytical, that is it can be Plane, Cylinder, Cone, Sphere, Torus. For all other types of surface method returns 'false'.
        	:param theAS:
        	:type theAS: Adaptor3d_HSurface
        	:rtype: bool
        """
        return _ProjLib.projlib_IsAnaSurf(*args)

    IsAnaSurf = staticmethod(IsAnaSurf)

    def MakePCurveOfType(*args) -> "void":
        """
        * Make empty P-Curve <aC> of relevant to <PC> type
        	:param PC:
        	:type PC: ProjLib_ProjectedCurve
        	:param aC:
        	:type aC: Geom2d_Curve
        	:rtype: void
        """
        return _ProjLib.projlib_MakePCurveOfType(*args)

    MakePCurveOfType = staticmethod(MakePCurveOfType)

    def Project(*args) -> "gp_Lin2d":
        """
        :param Pl:
        	:type Pl: gp_Pln
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Pnt2d
        :param Pl:
        	:type Pl: gp_Pln
        	:param L:
        	:type L: gp_Lin
        	:rtype: gp_Lin2d
        :param Pl:
        	:type Pl: gp_Pln
        	:param C:
        	:type C: gp_Circ
        	:rtype: gp_Circ2d
        :param Pl:
        	:type Pl: gp_Pln
        	:param E:
        	:type E: gp_Elips
        	:rtype: gp_Elips2d
        :param Pl:
        	:type Pl: gp_Pln
        	:param P:
        	:type P: gp_Parab
        	:rtype: gp_Parab2d
        :param Pl:
        	:type Pl: gp_Pln
        	:param H:
        	:type H: gp_Hypr
        	:rtype: gp_Hypr2d
        :param Cy:
        	:type Cy: gp_Cylinder
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Pnt2d
        :param Cy:
        	:type Cy: gp_Cylinder
        	:param L:
        	:type L: gp_Lin
        	:rtype: gp_Lin2d
        :param Cy:
        	:type Cy: gp_Cylinder
        	:param Ci:
        	:type Ci: gp_Circ
        	:rtype: gp_Lin2d
        :param Co:
        	:type Co: gp_Cone
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Pnt2d
        :param Co:
        	:type Co: gp_Cone
        	:param L:
        	:type L: gp_Lin
        	:rtype: gp_Lin2d
        :param Co:
        	:type Co: gp_Cone
        	:param Ci:
        	:type Ci: gp_Circ
        	:rtype: gp_Lin2d
        :param Sp:
        	:type Sp: gp_Sphere
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Pnt2d
        :param Sp:
        	:type Sp: gp_Sphere
        	:param Ci:
        	:type Ci: gp_Circ
        	:rtype: gp_Lin2d
        :param To:
        	:type To: gp_Torus
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Pnt2d
        :param To:
        	:type To: gp_Torus
        	:param Ci:
        	:type Ci: gp_Circ
        	:rtype: gp_Lin2d
        """
        return _ProjLib.projlib_Project(*args)

    Project = staticmethod(Project)

    __repr__ = _dumps_object


    def __init__(self):
        _ProjLib.projlib_swiginit(self, _ProjLib.new_projlib())
    __swig_destroy__ = _ProjLib.delete_projlib
projlib_swigregister = _ProjLib.projlib_swigregister
projlib_swigregister(projlib)

def projlib_IsAnaSurf(*args) -> "Standard_Boolean":
    """
    * Returns 'true' if surface is analytical, that is it can be Plane, Cylinder, Cone, Sphere, Torus. For all other types of surface method returns 'false'.
    	:param theAS:
    	:type theAS: Adaptor3d_HSurface
    	:rtype: bool
    """
    return _ProjLib.projlib_IsAnaSurf(*args)

def projlib_MakePCurveOfType(*args) -> "void":
    """
    * Make empty P-Curve <aC> of relevant to <PC> type
    	:param PC:
    	:type PC: ProjLib_ProjectedCurve
    	:param aC:
    	:type aC: Geom2d_Curve
    	:rtype: void
    """
    return _ProjLib.projlib_MakePCurveOfType(*args)

def projlib_Project(*args) -> "gp_Lin2d":
    """
    :param Pl:
    	:type Pl: gp_Pln
    	:param P:
    	:type P: gp_Pnt
    	:rtype: gp_Pnt2d
    :param Pl:
    	:type Pl: gp_Pln
    	:param L:
    	:type L: gp_Lin
    	:rtype: gp_Lin2d
    :param Pl:
    	:type Pl: gp_Pln
    	:param C:
    	:type C: gp_Circ
    	:rtype: gp_Circ2d
    :param Pl:
    	:type Pl: gp_Pln
    	:param E:
    	:type E: gp_Elips
    	:rtype: gp_Elips2d
    :param Pl:
    	:type Pl: gp_Pln
    	:param P:
    	:type P: gp_Parab
    	:rtype: gp_Parab2d
    :param Pl:
    	:type Pl: gp_Pln
    	:param H:
    	:type H: gp_Hypr
    	:rtype: gp_Hypr2d
    :param Cy:
    	:type Cy: gp_Cylinder
    	:param P:
    	:type P: gp_Pnt
    	:rtype: gp_Pnt2d
    :param Cy:
    	:type Cy: gp_Cylinder
    	:param L:
    	:type L: gp_Lin
    	:rtype: gp_Lin2d
    :param Cy:
    	:type Cy: gp_Cylinder
    	:param Ci:
    	:type Ci: gp_Circ
    	:rtype: gp_Lin2d
    :param Co:
    	:type Co: gp_Cone
    	:param P:
    	:type P: gp_Pnt
    	:rtype: gp_Pnt2d
    :param Co:
    	:type Co: gp_Cone
    	:param L:
    	:type L: gp_Lin
    	:rtype: gp_Lin2d
    :param Co:
    	:type Co: gp_Cone
    	:param Ci:
    	:type Ci: gp_Circ
    	:rtype: gp_Lin2d
    :param Sp:
    	:type Sp: gp_Sphere
    	:param P:
    	:type P: gp_Pnt
    	:rtype: gp_Pnt2d
    :param Sp:
    	:type Sp: gp_Sphere
    	:param Ci:
    	:type Ci: gp_Circ
    	:rtype: gp_Lin2d
    :param To:
    	:type To: gp_Torus
    	:param P:
    	:type P: gp_Pnt
    	:rtype: gp_Pnt2d
    :param To:
    	:type To: gp_Torus
    	:param Ci:
    	:type Ci: gp_Circ
    	:rtype: gp_Lin2d
    """
    return _ProjLib.projlib_Project(*args)

class ProjLib_CompProjectedCurve(OCC.Core.Adaptor2d.Adaptor2d_Curve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounds(self, *args) -> "void":
        """
        * returns the bounds of the continuous part corresponding to Index
        	:param Index:
        	:type Index: int
        	:param Udeb:
        	:type Udeb: float
        	:param Ufin:
        	:type Ufin: float
        	:rtype: None
        """
        return _ProjLib.ProjLib_CompProjectedCurve_Bounds(self, *args)


    def GetCurve(self, *args) -> "opencascade::handle< Adaptor3d_HCurve > const &":
        """:rtype: opencascade::handle<Adaptor3d_HCurve>"""
        return _ProjLib.ProjLib_CompProjectedCurve_GetCurve(self, *args)


    def GetSequence(self, *args) -> "opencascade::handle< ProjLib_HSequenceOfHSequenceOfPnt > const &":
        """:rtype: opencascade::handle<ProjLib_HSequenceOfHSequenceOfPnt>"""
        return _ProjLib.ProjLib_CompProjectedCurve_GetSequence(self, *args)


    def GetSurface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """:rtype: opencascade::handle<Adaptor3d_HSurface>"""
        return _ProjLib.ProjLib_CompProjectedCurve_GetSurface(self, *args)


    def GetTolerance(self, *args) -> "void":
        """
        :param TolU:
        	:type TolU: float
        	:param TolV:
        	:type TolV: float
        	:rtype: None
        """
        return _ProjLib.ProjLib_CompProjectedCurve_GetTolerance(self, *args)


    def Init(self, *args) -> "void":
        """
        * computes a set of projected point and determine the continuous parts of the projected curves. The points corresponding to a projection on the bounds of the surface are included in this set of points.
        	:rtype: None
        """
        return _ProjLib.ProjLib_CompProjectedCurve_Init(self, *args)


    def IsSinglePnt(self, *args) -> "Standard_Boolean":
        """
        * returns True if part of projection with number Index is a single point and writes its coordinates in P
        	:param Index:
        	:type Index: int
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: bool
        """
        return _ProjLib.ProjLib_CompProjectedCurve_IsSinglePnt(self, *args)


    def IsUIso(self, *args) -> "Standard_Boolean":
        """
        * returns True if part of projection with number Index is an u-isoparametric curve of input surface
        	:param Index:
        	:type Index: int
        	:param U:
        	:type U: float
        	:rtype: bool
        """
        return _ProjLib.ProjLib_CompProjectedCurve_IsUIso(self, *args)


    def IsVIso(self, *args) -> "Standard_Boolean":
        """
        * returns True if part of projection with number Index is an v-isoparametric curve of input surface
        	:param Index:
        	:type Index: int
        	:param V:
        	:type V: float
        	:rtype: bool
        """
        return _ProjLib.ProjLib_CompProjectedCurve_IsVIso(self, *args)


    def Load(self, *args) -> "void":
        """
        * Changes the surface.
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: None
        * Changes the curve.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: None
        """
        return _ProjLib.ProjLib_CompProjectedCurve_Load(self, *args)


    def MaxDistance(self, *args) -> "Standard_Real":
        """
        * returns the maximum distance between curve to project and surface
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _ProjLib.ProjLib_CompProjectedCurve_MaxDistance(self, *args)


    def NbCurves(self, *args) -> "Standard_Integer":
        """
        * returns the number of continuous part of the projected curve
        	:rtype: int
        """
        return _ProjLib.ProjLib_CompProjectedCurve_NbCurves(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        * try to find all solutions
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param TolU:
        	:type TolU: float
        	:param TolV:
        	:type TolV: float
        	:rtype: None
        * this constructor tries to optimize the search using the assumption that maximum distance between surface and curve less or equal then MaxDist. if MaxDist < 0 then algorithm works as above.
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param TolU:
        	:type TolU: float
        	:param TolV:
        	:type TolV: float
        	:param MaxDist:
        	:type MaxDist: float
        	:rtype: None
        """
        _ProjLib.ProjLib_CompProjectedCurve_swiginit(self, _ProjLib.new_ProjLib_CompProjectedCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_CompProjectedCurve
ProjLib_CompProjectedCurve.Bounds = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_Bounds, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetCurve = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetCurve, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetSequence = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetSequence, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetSurface = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetSurface, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetTolerance = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetTolerance, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.Init = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_Init, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.IsSinglePnt = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_IsSinglePnt, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.IsUIso = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_IsUIso, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.IsVIso = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_IsVIso, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.Load = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_Load, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.MaxDistance = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_MaxDistance, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.NbCurves = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_NbCurves, None, ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve_swigregister = _ProjLib.ProjLib_CompProjectedCurve_swigregister
ProjLib_CompProjectedCurve_swigregister(ProjLib_CompProjectedCurve)

class ProjLib_ComputeApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSpline(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """:rtype: opencascade::handle<Geom2d_BSplineCurve>"""
        return _ProjLib.ProjLib_ComputeApprox_BSpline(self, *args)


    def Bezier(self, *args) -> "opencascade::handle< Geom2d_BezierCurve >":
        """:rtype: opencascade::handle<Geom2d_BezierCurve>"""
        return _ProjLib.ProjLib_ComputeApprox_Bezier(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Performs projecting. In case of approximation current values of parameters are used: default values or set by corresponding methods Set...
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApprox_Perform(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor, it only sets some initial values for class fields.
        	:rtype: None
        * <Tol> is the tolerance with which the approximation is performed. Other parameters for approximation have default values.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _ProjLib.ProjLib_ComputeApprox_swiginit(self, _ProjLib.new_ProjLib_ComputeApprox(*args))

    def SetBndPnt(self, *args) -> "void":
        """
        * Set the parameter, which defines type of boundary condition between segments during approximation. It can be AppParCurves_PassPoint or AppParCurves_TangencyPoint. Default value is AppParCurves_TangencyPoint;
        	:param theBndPnt:
        	:type theBndPnt: AppParCurves_Constraint
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApprox_SetBndPnt(self, *args)


    def SetDegree(self, *args) -> "void":
        """
        * Set min and max possible degree of result BSpline curve2d, which is got by approximation. If theDegMin/Max < 0, algorithm uses values that are chosen depending of types curve 3d and surface.
        	:param theDegMin:
        	:type theDegMin: int
        	:param theDegMax:
        	:type theDegMax: int
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApprox_SetDegree(self, *args)


    def SetMaxSegments(self, *args) -> "void":
        """
        * Set the parameter, which defines maximal value of parametric intervals the projected curve can be cut for approximation. If theMaxSegments < 0, algorithm uses default value = 1000.
        	:param theMaxSegments:
        	:type theMaxSegments: int
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApprox_SetMaxSegments(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Set tolerance of approximation. Default value is Precision::Confusion().
        	:param theTolerance:
        	:type theTolerance: float
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApprox_SetTolerance(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * returns the reached Tolerance.
        	:rtype: float
        """
        return _ProjLib.ProjLib_ComputeApprox_Tolerance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_ComputeApprox
ProjLib_ComputeApprox.BSpline = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_BSpline, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox.Bezier = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_Bezier, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox.Perform = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_Perform, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox.SetBndPnt = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_SetBndPnt, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox.SetDegree = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_SetDegree, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox.SetMaxSegments = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_SetMaxSegments, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox.SetTolerance = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_SetTolerance, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox.Tolerance = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_Tolerance, None, ProjLib_ComputeApprox)
ProjLib_ComputeApprox_swigregister = _ProjLib.ProjLib_ComputeApprox_swigregister
ProjLib_ComputeApprox_swigregister(ProjLib_ComputeApprox)

class ProjLib_ComputeApproxOnPolarSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSpline(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        * Returns result curve 2d.
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_BSpline(self, *args)


    def BuildInitialCurve2d(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d >":
        """
        * Builds initial 2d curve as BSpline with degree = 1 using Extrema algoritm. Method is used in method Perform(...).
        	:param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: opencascade::handle<Adaptor2d_HCurve2d>
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_BuildInitialCurve2d(self, *args)


    def Curve2d(self, *args) -> "opencascade::handle< Geom2d_Curve >":
        """
        * Returns second 2d curve.
        	:rtype: opencascade::handle<Geom2d_Curve>
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_Curve2d(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_IsDone(self, *args)


    def Perform(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        * Method, which performs projecting, using default values of parameters or they must be set by corresponding methods before using.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: None
        * Method, which performs projecting, using default values of parameters or they must be set by corresponding methods before using. Parameter InitCurve2d is any rough estimation of 2d result curve.
        	:param InitCurve2d:
        	:type InitCurve2d: Adaptor2d_HCurve2d
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_Perform(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor, it only sets some initial values for class fields.
        	:rtype: None
        * Constructor, which performs projecting.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param Tol: default value is 1.0e-4
        	:type Tol: float
        	:rtype: None
        * Constructor, which performs projecting, using initial curve 2d InitCurve2d, which is any rough approximation of result curve. Parameter Tol is 3d tolerance of approximation.
        	:param InitCurve2d:
        	:type InitCurve2d: Adaptor2d_HCurve2d
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        * Constructor, which performs projecting, using two initial curves 2d: InitCurve2d and InitCurve2dBis that are any rough approximations of result curves. This constructor is used to get two pcurves for seem edge. Parameter Tol is 3d tolerance of approximation.
        	:param InitCurve2d:
        	:type InitCurve2d: Adaptor2d_HCurve2d
        	:param InitCurve2dBis:
        	:type InitCurve2dBis: Adaptor2d_HCurve2d
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _ProjLib.ProjLib_ComputeApproxOnPolarSurface_swiginit(self, _ProjLib.new_ProjLib_ComputeApproxOnPolarSurface(*args))

    def ProjectUsingInitialCurve2d(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        * Method, which performs projecting. Method is used in method Perform(...).
        	:param Curve:
        	:type Curve: Adaptor3d_HCurve
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param InitCurve2d:
        	:type InitCurve2d: Adaptor2d_HCurve2d
        	:rtype: opencascade::handle<Geom2d_BSplineCurve>
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_ProjectUsingInitialCurve2d(self, *args)


    def SetBndPnt(self, *args) -> "void":
        """
        * Set the parameter, which defines type of boundary condition between segments during approximation. It can be AppParCurves_PassPoint or AppParCurves_TangencyPoint. Default value is AppParCurves_TangencyPoint.
        	:param theBndPnt:
        	:type theBndPnt: AppParCurves_Constraint
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetBndPnt(self, *args)


    def SetDegree(self, *args) -> "void":
        """
        * Set min and max possible degree of result BSpline curve2d, which is got by approximation. If theDegMin/Max < 0, algorithm uses values min = 2, max = 8.
        	:param theDegMin:
        	:type theDegMin: int
        	:param theDegMax:
        	:type theDegMax: int
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetDegree(self, *args)


    def SetMaxDist(self, *args) -> "void":
        """
        * Set the parameter, which defines maximal possible distance between projected curve and surface. It is used only for projecting on not analytical surfaces. If theMaxDist < 0, algoritm uses default value 100.*Tolerance. If real distance between curve and surface more then theMaxDist, algorithm stops working.
        	:param theMaxDist:
        	:type theMaxDist: float
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetMaxDist(self, *args)


    def SetMaxSegments(self, *args) -> "void":
        """
        * Set the parameter, which defines maximal value of parametric intervals the projected curve can be cut for approximation. If theMaxSegments < 0, algorithm uses default value = 1000.
        	:param theMaxSegments:
        	:type theMaxSegments: int
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetMaxSegments(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Set the tolerance used to project the curve on the surface. Default value is Precision::Approximation().
        	:param theTolerance:
        	:type theTolerance: float
        	:rtype: None
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetTolerance(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * returns the reached Tolerance.
        	:rtype: float
        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_Tolerance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_ComputeApproxOnPolarSurface
ProjLib_ComputeApproxOnPolarSurface.BSpline = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_BSpline, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.BuildInitialCurve2d = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_BuildInitialCurve2d, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.Curve2d = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_Curve2d, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.IsDone = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_IsDone, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.Perform = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_Perform, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.ProjectUsingInitialCurve2d = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_ProjectUsingInitialCurve2d, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.SetBndPnt = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetBndPnt, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.SetDegree = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetDegree, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.SetMaxDist = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetMaxDist, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.SetMaxSegments = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetMaxSegments, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.SetTolerance = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_SetTolerance, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.Tolerance = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_Tolerance, None, ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface_swigregister = _ProjLib.ProjLib_ComputeApproxOnPolarSurface_swigregister
ProjLib_ComputeApproxOnPolarSurface_swigregister(ProjLib_ComputeApproxOnPolarSurface)

class ProjLib_HCompProjectedCurve(OCC.Core.Adaptor2d.Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ChangeCurve2d(self, *args) -> "ProjLib_CompProjectedCurve &":
        """
        * Returns the curve used to create the GenHCurve.
        	:rtype: ProjLib_CompProjectedCurve
        """
        return _ProjLib.ProjLib_HCompProjectedCurve_ChangeCurve2d(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty GenHCurve2d.
        	:rtype: None
        * Creates a GenHCurve2d from a Curve
        	:param C:
        	:type C: ProjLib_CompProjectedCurve
        	:rtype: None
        """
        _ProjLib.ProjLib_HCompProjectedCurve_swiginit(self, _ProjLib.new_ProjLib_HCompProjectedCurve(*args))

    def Set(self, *args) -> "void":
        """
        * Sets the field of the GenHCurve2d.
        	:param C:
        	:type C: ProjLib_CompProjectedCurve
        	:rtype: None
        """
        return _ProjLib.ProjLib_HCompProjectedCurve_Set(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_ProjLib_HCompProjectedCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_HCompProjectedCurve
ProjLib_HCompProjectedCurve.ChangeCurve2d = new_instancemethod(_ProjLib.ProjLib_HCompProjectedCurve_ChangeCurve2d, None, ProjLib_HCompProjectedCurve)
ProjLib_HCompProjectedCurve.Set = new_instancemethod(_ProjLib.ProjLib_HCompProjectedCurve_Set, None, ProjLib_HCompProjectedCurve)
ProjLib_HCompProjectedCurve_swigregister = _ProjLib.ProjLib_HCompProjectedCurve_swigregister
ProjLib_HCompProjectedCurve_swigregister(ProjLib_HCompProjectedCurve)

class ProjLib_HProjectedCurve(OCC.Core.Adaptor2d.Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ChangeCurve2d(self, *args) -> "ProjLib_ProjectedCurve &":
        """
        * Returns the curve used to create the GenHCurve.
        	:rtype: ProjLib_ProjectedCurve
        """
        return _ProjLib.ProjLib_HProjectedCurve_ChangeCurve2d(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty GenHCurve2d.
        	:rtype: None
        * Creates a GenHCurve2d from a Curve
        	:param C:
        	:type C: ProjLib_ProjectedCurve
        	:rtype: None
        """
        _ProjLib.ProjLib_HProjectedCurve_swiginit(self, _ProjLib.new_ProjLib_HProjectedCurve(*args))

    def Set(self, *args) -> "void":
        """
        * Sets the field of the GenHCurve2d.
        	:param C:
        	:type C: ProjLib_ProjectedCurve
        	:rtype: None
        """
        return _ProjLib.ProjLib_HProjectedCurve_Set(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_ProjLib_HProjectedCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_HProjectedCurve
ProjLib_HProjectedCurve.ChangeCurve2d = new_instancemethod(_ProjLib.ProjLib_HProjectedCurve_ChangeCurve2d, None, ProjLib_HProjectedCurve)
ProjLib_HProjectedCurve.Set = new_instancemethod(_ProjLib.ProjLib_HProjectedCurve_Set, None, ProjLib_HProjectedCurve)
ProjLib_HProjectedCurve_swigregister = _ProjLib.ProjLib_HProjectedCurve_swigregister
ProjLib_HProjectedCurve_swigregister(ProjLib_HProjectedCurve)

class ProjLib_PrjFunc(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param C:
        	:type C: Adaptor3d_CurvePtr
        	:param FixVal:
        	:type FixVal: float
        	:param S:
        	:type S: Adaptor3d_SurfacePtr
        	:param Fix:
        	:type Fix: int
        	:rtype: None
        """
        _ProjLib.ProjLib_PrjFunc_swiginit(self, _ProjLib.new_ProjLib_PrjFunc(*args))

    def Solution(self, *args) -> "gp_Pnt2d":
        """
        * returns point on surface
        	:rtype: gp_Pnt2d
        """
        return _ProjLib.ProjLib_PrjFunc_Solution(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_PrjFunc
ProjLib_PrjFunc.Solution = new_instancemethod(_ProjLib.ProjLib_PrjFunc_Solution, None, ProjLib_PrjFunc)
ProjLib_PrjFunc_swigregister = _ProjLib.ProjLib_PrjFunc_swigregister
ProjLib_PrjFunc_swigregister(ProjLib_PrjFunc)

class ProjLib_PrjResolve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the distance is found.
        	:rtype: bool
        """
        return _ProjLib.ProjLib_PrjResolve_IsDone(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Calculates the ort from C(t) to S with a close point. The close point is defined by the parameter values U0 and V0. The function F(u,v)=distance(S(u,v),C(t)) has an extremum when gradient(F)=0. The algorithm searchs a zero near the close point.
        	:param t:
        	:type t: float
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:param Tol:
        	:type Tol: gp_Pnt2d
        	:param Inf:
        	:type Inf: gp_Pnt2d
        	:param Sup:
        	:type Sup: gp_Pnt2d
        	:param FTol: default value is -1
        	:type FTol: float
        	:param StrictInside: default value is Standard_False
        	:type StrictInside: bool
        	:rtype: None
        """
        return _ProjLib.ProjLib_PrjResolve_Perform(self, *args)


    def __init__(self, *args):
        """
        :param C:
        	:type C: Adaptor3d_Curve
        	:param S:
        	:type S: Adaptor3d_Surface
        	:param Fix:
        	:type Fix: int
        	:rtype: None
        """
        _ProjLib.ProjLib_PrjResolve_swiginit(self, _ProjLib.new_ProjLib_PrjResolve(*args))

    def Solution(self, *args) -> "gp_Pnt2d":
        """
        * Returns the point of the extremum distance.
        	:rtype: gp_Pnt2d
        """
        return _ProjLib.ProjLib_PrjResolve_Solution(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_PrjResolve
ProjLib_PrjResolve.IsDone = new_instancemethod(_ProjLib.ProjLib_PrjResolve_IsDone, None, ProjLib_PrjResolve)
ProjLib_PrjResolve.Perform = new_instancemethod(_ProjLib.ProjLib_PrjResolve_Perform, None, ProjLib_PrjResolve)
ProjLib_PrjResolve.Solution = new_instancemethod(_ProjLib.ProjLib_PrjResolve_Solution, None, ProjLib_PrjResolve)
ProjLib_PrjResolve_swigregister = _ProjLib.ProjLib_PrjResolve_swigregister
ProjLib_PrjResolve_swigregister(ProjLib_PrjResolve)

class ProjLib_ProjectOnPlane(OCC.Core.Adaptor3d.Adaptor3d_Curve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetCurve(self, *args) -> "opencascade::handle< Adaptor3d_HCurve > const &":
        """:rtype: opencascade::handle<Adaptor3d_HCurve>"""
        return _ProjLib.ProjLib_ProjectOnPlane_GetCurve(self, *args)


    def GetDirection(self, *args) -> "gp_Dir const":
        """:rtype: gp_Dir"""
        return _ProjLib.ProjLib_ProjectOnPlane_GetDirection(self, *args)


    def GetPlane(self, *args) -> "gp_Ax3 const":
        """:rtype: gp_Ax3"""
        return _ProjLib.ProjLib_ProjectOnPlane_GetPlane(self, *args)


    def GetResult(self, *args) -> "opencascade::handle< GeomAdaptor_HCurve > const &":
        """:rtype: opencascade::handle<GeomAdaptor_HCurve>"""
        return _ProjLib.ProjLib_ProjectOnPlane_GetResult(self, *args)


    def Load(self, *args) -> "void":
        """
        * Sets the Curve and perform the projection. if <KeepParametrization> is true, the parametrization of the Projected Curve <PC> will be the same as the parametrization of the initial curve <C>. It meens: proj(C(u)) = PC(u) for each u. Otherwize, the parametrization may change.
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param Tolerance:
        	:type Tolerance: float
        	:param KeepParametrization: default value is Standard_True
        	:type KeepParametrization: bool
        	:rtype: None
        """
        return _ProjLib.ProjLib_ProjectOnPlane_Load(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor.
        	:rtype: None
        * The projection will be normal to the Plane defined by the Ax3 <Pl>.
        	:param Pl:
        	:type Pl: gp_Ax3
        	:rtype: None
        * The projection will be along the direction <D> on the plane defined by the Ax3 <Pl>. raises if the direction <D> is parallel to the plane <Pl>.
        	:param Pl:
        	:type Pl: gp_Ax3
        	:param D:
        	:type D: gp_Dir
        	:rtype: None
        """
        _ProjLib.ProjLib_ProjectOnPlane_swiginit(self, _ProjLib.new_ProjLib_ProjectOnPlane(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_ProjectOnPlane
ProjLib_ProjectOnPlane.GetCurve = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetCurve, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.GetDirection = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetDirection, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.GetPlane = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetPlane, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.GetResult = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetResult, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.Load = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_Load, None, ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane_swigregister = _ProjLib.ProjLib_ProjectOnPlane_swigregister
ProjLib_ProjectOnPlane_swigregister(ProjLib_ProjectOnPlane)

class ProjLib_ProjectOnSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSpline(self, *args) -> "opencascade::handle< Geom_BSplineCurve >":
        """:rtype: opencascade::handle<Geom_BSplineCurve>"""
        return _ProjLib.ProjLib_ProjectOnSurface_BSpline(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _ProjLib.ProjLib_ProjectOnSurface_IsDone(self, *args)


    def __init__(self, *args):
        """
        * Create an empty projector.
        	:rtype: None
        * Create a projector normaly to the surface <S>.
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: None
        """
        _ProjLib.ProjLib_ProjectOnSurface_swiginit(self, _ProjLib.new_ProjLib_ProjectOnSurface(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_ProjectOnSurface
ProjLib_ProjectOnSurface.BSpline = new_instancemethod(_ProjLib.ProjLib_ProjectOnSurface_BSpline, None, ProjLib_ProjectOnSurface)
ProjLib_ProjectOnSurface.IsDone = new_instancemethod(_ProjLib.ProjLib_ProjectOnSurface_IsDone, None, ProjLib_ProjectOnSurface)
ProjLib_ProjectOnSurface_swigregister = _ProjLib.ProjLib_ProjectOnSurface_swigregister
ProjLib_ProjectOnSurface_swigregister(ProjLib_ProjectOnSurface)

class ProjLib_ProjectedCurve(OCC.Core.Adaptor2d.Adaptor2d_Curve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetCurve(self, *args) -> "opencascade::handle< Adaptor3d_HCurve > const &":
        """:rtype: opencascade::handle<Adaptor3d_HCurve>"""
        return _ProjLib.ProjLib_ProjectedCurve_GetCurve(self, *args)


    def GetSurface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """:rtype: opencascade::handle<Adaptor3d_HSurface>"""
        return _ProjLib.ProjLib_ProjectedCurve_GetSurface(self, *args)


    def GetTolerance(self, *args) -> "Standard_Real":
        """
        * returns the tolerance reached if an approximation is Done.
        	:rtype: float
        """
        return _ProjLib.ProjLib_ProjectedCurve_GetTolerance(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Performs projecting for given curve. If projecting uses approximation, approximation parameters can be set before by corresponding methods SetDegree(...), SetMaxSegmets(...), SetBndPnt(...), SetMaxDist(...)
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: None
        """
        return _ProjLib.ProjLib_ProjectedCurve_Perform(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor, it only sets some initial values for class fields.
        	:rtype: None
        * Constructor with initialisation field mySurface
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:rtype: None
        * Constructor, which performs projecting. If projecting uses approximation, default parameters are used, in particular, 3d tolerance of approximation is Precision::Confusion()
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:rtype: None
        * Constructor, which performs projecting. If projecting uses approximation, 3d tolerance is Tol, default parameters are used,
        	:param S:
        	:type S: Adaptor3d_HSurface
        	:param C:
        	:type C: Adaptor3d_HCurve
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _ProjLib.ProjLib_ProjectedCurve_swiginit(self, _ProjLib.new_ProjLib_ProjectedCurve(*args))

    def SetBndPnt(self, *args) -> "void":
        """
        * Set the parameter, which defines type of boundary condition between segments during approximation. It can be AppParCurves_PassPoint or AppParCurves_TangencyPoint. Default value is AppParCurves_TangencyPoint;
        	:param theBndPnt:
        	:type theBndPnt: AppParCurves_Constraint
        	:rtype: None
        """
        return _ProjLib.ProjLib_ProjectedCurve_SetBndPnt(self, *args)


    def SetDegree(self, *args) -> "void":
        """
        * Set min and max possible degree of result BSpline curve2d, which is got by approximation. If theDegMin/Max < 0, algorithm uses values that are chosen depending of types curve 3d and surface.
        	:param theDegMin:
        	:type theDegMin: int
        	:param theDegMax:
        	:type theDegMax: int
        	:rtype: None
        """
        return _ProjLib.ProjLib_ProjectedCurve_SetDegree(self, *args)


    def SetMaxDist(self, *args) -> "void":
        """
        * Set the parameter, which degines maximal possible distance between projected curve and surface. It uses only for projecting on not analytical surfaces. If theMaxDist < 0, algoritm uses default value 100.*Tolerance. If real distance between curve and surface more then theMaxDist, algorithm stops working.
        	:param theMaxDist:
        	:type theMaxDist: float
        	:rtype: None
        """
        return _ProjLib.ProjLib_ProjectedCurve_SetMaxDist(self, *args)


    def SetMaxSegments(self, *args) -> "void":
        """
        * Set the parameter, which defines maximal value of parametric intervals the projected curve can be cut for approximation. If theMaxSegments < 0, algorithm uses default value = 1000.
        	:param theMaxSegments:
        	:type theMaxSegments: int
        	:rtype: None
        """
        return _ProjLib.ProjLib_ProjectedCurve_SetMaxSegments(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_ProjectedCurve
ProjLib_ProjectedCurve.GetCurve = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_GetCurve, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.GetSurface = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_GetSurface, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.GetTolerance = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_GetTolerance, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.Perform = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_Perform, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.SetBndPnt = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_SetBndPnt, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.SetDegree = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_SetDegree, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.SetMaxDist = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_SetMaxDist, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.SetMaxSegments = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_SetMaxSegments, None, ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve_swigregister = _ProjLib.ProjLib_ProjectedCurve_swigregister
ProjLib_ProjectedCurve_swigregister(ProjLib_ProjectedCurve)

class ProjLib_Projector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BSpline(self, *args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """:rtype: opencascade::handle<Geom2d_BSplineCurve>"""
        return _ProjLib.ProjLib_Projector_BSpline(self, *args)


    def Bezier(self, *args) -> "opencascade::handle< Geom2d_BezierCurve >":
        """:rtype: opencascade::handle<Geom2d_BezierCurve>"""
        return _ProjLib.ProjLib_Projector_Bezier(self, *args)


    def Circle(self, *args) -> "gp_Circ2d const":
        """:rtype: gp_Circ2d"""
        return _ProjLib.ProjLib_Projector_Circle(self, *args)


    def Done(self, *args) -> "void":
        """
        * Set isDone = Standard_True;
        	:rtype: None
        """
        return _ProjLib.ProjLib_Projector_Done(self, *args)


    def Ellipse(self, *args) -> "gp_Elips2d const":
        """:rtype: gp_Elips2d"""
        return _ProjLib.ProjLib_Projector_Ellipse(self, *args)


    def GetType(self, *args) -> "GeomAbs_CurveType":
        """:rtype: GeomAbs_CurveType"""
        return _ProjLib.ProjLib_Projector_GetType(self, *args)


    def Hyperbola(self, *args) -> "gp_Hypr2d const":
        """:rtype: gp_Hypr2d"""
        return _ProjLib.ProjLib_Projector_Hyperbola(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _ProjLib.ProjLib_Projector_IsDone(self, *args)


    def IsPeriodic(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _ProjLib.ProjLib_Projector_IsPeriodic(self, *args)


    def Line(self, *args) -> "gp_Lin2d const":
        """:rtype: gp_Lin2d"""
        return _ProjLib.ProjLib_Projector_Line(self, *args)


    def Parabola(self, *args) -> "gp_Parab2d const":
        """:rtype: gp_Parab2d"""
        return _ProjLib.ProjLib_Projector_Parabola(self, *args)


    def __init__(self, *args):
        """
        * Sets the type to OtherCurve
        	:rtype: None
        """
        _ProjLib.ProjLib_Projector_swiginit(self, _ProjLib.new_ProjLib_Projector(*args))

    def Project(self, *args) -> "void":
        """
        :param L:
        	:type L: gp_Lin
        	:rtype: void
        :param C:
        	:type C: gp_Circ
        	:rtype: void
        :param E:
        	:type E: gp_Elips
        	:rtype: void
        :param P:
        	:type P: gp_Parab
        	:rtype: void
        :param H:
        	:type H: gp_Hypr
        	:rtype: void
        """
        return _ProjLib.ProjLib_Projector_Project(self, *args)


    def SetBSpline(self, *args) -> "void":
        """
        :param C:
        	:type C: Geom2d_BSplineCurve
        	:rtype: None
        """
        return _ProjLib.ProjLib_Projector_SetBSpline(self, *args)


    def SetBezier(self, *args) -> "void":
        """
        :param C:
        	:type C: Geom2d_BezierCurve
        	:rtype: None
        """
        return _ProjLib.ProjLib_Projector_SetBezier(self, *args)


    def SetPeriodic(self, *args) -> "void":
        """:rtype: None"""
        return _ProjLib.ProjLib_Projector_SetPeriodic(self, *args)


    def SetType(self, *args) -> "void":
        """
        :param Type:
        	:type Type: GeomAbs_CurveType
        	:rtype: None
        """
        return _ProjLib.ProjLib_Projector_SetType(self, *args)


    def UFrame(self, *args) -> "void":
        """
        * Translates the 2d curve to set the part of the curve [CFirst, CLast] in the range [ UFirst, UFirst + Period [
        	:param CFirst:
        	:type CFirst: float
        	:param CLast:
        	:type CLast: float
        	:param UFirst:
        	:type UFirst: float
        	:param Period:
        	:type Period: float
        	:rtype: None
        """
        return _ProjLib.ProjLib_Projector_UFrame(self, *args)


    def VFrame(self, *args) -> "void":
        """
        * Translates the 2d curve to set the part of the curve [CFirst, CLast] in the range [ VFirst, VFirst + Period [
        	:param CFirst:
        	:type CFirst: float
        	:param CLast:
        	:type CLast: float
        	:param VFirst:
        	:type VFirst: float
        	:param Period:
        	:type Period: float
        	:rtype: None
        """
        return _ProjLib.ProjLib_Projector_VFrame(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_Projector
ProjLib_Projector.BSpline = new_instancemethod(_ProjLib.ProjLib_Projector_BSpline, None, ProjLib_Projector)
ProjLib_Projector.Bezier = new_instancemethod(_ProjLib.ProjLib_Projector_Bezier, None, ProjLib_Projector)
ProjLib_Projector.Circle = new_instancemethod(_ProjLib.ProjLib_Projector_Circle, None, ProjLib_Projector)
ProjLib_Projector.Done = new_instancemethod(_ProjLib.ProjLib_Projector_Done, None, ProjLib_Projector)
ProjLib_Projector.Ellipse = new_instancemethod(_ProjLib.ProjLib_Projector_Ellipse, None, ProjLib_Projector)
ProjLib_Projector.GetType = new_instancemethod(_ProjLib.ProjLib_Projector_GetType, None, ProjLib_Projector)
ProjLib_Projector.Hyperbola = new_instancemethod(_ProjLib.ProjLib_Projector_Hyperbola, None, ProjLib_Projector)
ProjLib_Projector.IsDone = new_instancemethod(_ProjLib.ProjLib_Projector_IsDone, None, ProjLib_Projector)
ProjLib_Projector.IsPeriodic = new_instancemethod(_ProjLib.ProjLib_Projector_IsPeriodic, None, ProjLib_Projector)
ProjLib_Projector.Line = new_instancemethod(_ProjLib.ProjLib_Projector_Line, None, ProjLib_Projector)
ProjLib_Projector.Parabola = new_instancemethod(_ProjLib.ProjLib_Projector_Parabola, None, ProjLib_Projector)
ProjLib_Projector.Project = new_instancemethod(_ProjLib.ProjLib_Projector_Project, None, ProjLib_Projector)
ProjLib_Projector.SetBSpline = new_instancemethod(_ProjLib.ProjLib_Projector_SetBSpline, None, ProjLib_Projector)
ProjLib_Projector.SetBezier = new_instancemethod(_ProjLib.ProjLib_Projector_SetBezier, None, ProjLib_Projector)
ProjLib_Projector.SetPeriodic = new_instancemethod(_ProjLib.ProjLib_Projector_SetPeriodic, None, ProjLib_Projector)
ProjLib_Projector.SetType = new_instancemethod(_ProjLib.ProjLib_Projector_SetType, None, ProjLib_Projector)
ProjLib_Projector.UFrame = new_instancemethod(_ProjLib.ProjLib_Projector_UFrame, None, ProjLib_Projector)
ProjLib_Projector.VFrame = new_instancemethod(_ProjLib.ProjLib_Projector_VFrame, None, ProjLib_Projector)
ProjLib_Projector_swigregister = _ProjLib.ProjLib_Projector_swigregister
ProjLib_Projector_swigregister(ProjLib_Projector)

class ProjLib_Cone(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args) -> "void":
        """
        :param Co:
        	:type Co: gp_Cone
        	:rtype: None
        """
        return _ProjLib.ProjLib_Cone_Init(self, *args)


    def __init__(self, *args):
        """
        * Undefined projection.
        	:rtype: None
        * Projection on the cone <Co>.
        	:param Co:
        	:type Co: gp_Cone
        	:rtype: None
        * Projection of the line <L> on the cone <Co>.
        	:param Co:
        	:type Co: gp_Cone
        	:param L:
        	:type L: gp_Lin
        	:rtype: None
        * Projection of the circle <C> on the cone <Co>.
        	:param Co:
        	:type Co: gp_Cone
        	:param C:
        	:type C: gp_Circ
        	:rtype: None
        """
        _ProjLib.ProjLib_Cone_swiginit(self, _ProjLib.new_ProjLib_Cone(*args))

    def Project(self, *args) -> "void":
        """
        :param L:
        	:type L: gp_Lin
        	:rtype: void
        :param C:
        	:type C: gp_Circ
        	:rtype: void
        :param E:
        	:type E: gp_Elips
        	:rtype: void
        :param P:
        	:type P: gp_Parab
        	:rtype: void
        :param H:
        	:type H: gp_Hypr
        	:rtype: void
        """
        return _ProjLib.ProjLib_Cone_Project(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_Cone
ProjLib_Cone.Init = new_instancemethod(_ProjLib.ProjLib_Cone_Init, None, ProjLib_Cone)
ProjLib_Cone.Project = new_instancemethod(_ProjLib.ProjLib_Cone_Project, None, ProjLib_Cone)
ProjLib_Cone_swigregister = _ProjLib.ProjLib_Cone_swigregister
ProjLib_Cone_swigregister(ProjLib_Cone)

class ProjLib_Cylinder(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args) -> "void":
        """
        :param Cyl:
        	:type Cyl: gp_Cylinder
        	:rtype: None
        """
        return _ProjLib.ProjLib_Cylinder_Init(self, *args)


    def __init__(self, *args):
        """
        * Undefined projection.
        	:rtype: None
        * Projection on the cylinder <Cyl>.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:rtype: None
        * Projection of the line <L> on the cylinder <Cyl>.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param L:
        	:type L: gp_Lin
        	:rtype: None
        * Projection of the circle <C> on the cylinder <Cyl>.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param C:
        	:type C: gp_Circ
        	:rtype: None
        * Projection of the ellipse <E> on the cylinder <Cyl>.
        	:param Cyl:
        	:type Cyl: gp_Cylinder
        	:param E:
        	:type E: gp_Elips
        	:rtype: None
        """
        _ProjLib.ProjLib_Cylinder_swiginit(self, _ProjLib.new_ProjLib_Cylinder(*args))

    def Project(self, *args) -> "void":
        """
        :param L:
        	:type L: gp_Lin
        	:rtype: void
        :param C:
        	:type C: gp_Circ
        	:rtype: void
        :param E:
        	:type E: gp_Elips
        	:rtype: void
        :param P:
        	:type P: gp_Parab
        	:rtype: void
        :param H:
        	:type H: gp_Hypr
        	:rtype: void
        """
        return _ProjLib.ProjLib_Cylinder_Project(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_Cylinder
ProjLib_Cylinder.Init = new_instancemethod(_ProjLib.ProjLib_Cylinder_Init, None, ProjLib_Cylinder)
ProjLib_Cylinder.Project = new_instancemethod(_ProjLib.ProjLib_Cylinder_Project, None, ProjLib_Cylinder)
ProjLib_Cylinder_swigregister = _ProjLib.ProjLib_Cylinder_swigregister
ProjLib_Cylinder_swigregister(ProjLib_Cylinder)

class ProjLib_Plane(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args) -> "void":
        """
        :param Pl:
        	:type Pl: gp_Pln
        	:rtype: None
        """
        return _ProjLib.ProjLib_Plane_Init(self, *args)


    def __init__(self, *args):
        """
        * Undefined projection.
        	:rtype: None
        * Projection on the plane <Pl>.
        	:param Pl:
        	:type Pl: gp_Pln
        	:rtype: None
        * Projection of the line <L> on the plane <Pl>.
        	:param Pl:
        	:type Pl: gp_Pln
        	:param L:
        	:type L: gp_Lin
        	:rtype: None
        * Projection of the circle <C> on the plane <Pl>.
        	:param Pl:
        	:type Pl: gp_Pln
        	:param C:
        	:type C: gp_Circ
        	:rtype: None
        * Projection of the ellipse <E> on the plane <Pl>.
        	:param Pl:
        	:type Pl: gp_Pln
        	:param E:
        	:type E: gp_Elips
        	:rtype: None
        * Projection of the parabola <P> on the plane <Pl>.
        	:param Pl:
        	:type Pl: gp_Pln
        	:param P:
        	:type P: gp_Parab
        	:rtype: None
        * Projection of the hyperbola <H> on the plane <Pl>.
        	:param Pl:
        	:type Pl: gp_Pln
        	:param H:
        	:type H: gp_Hypr
        	:rtype: None
        """
        _ProjLib.ProjLib_Plane_swiginit(self, _ProjLib.new_ProjLib_Plane(*args))

    def Project(self, *args) -> "void":
        """
        :param L:
        	:type L: gp_Lin
        	:rtype: void
        :param C:
        	:type C: gp_Circ
        	:rtype: void
        :param E:
        	:type E: gp_Elips
        	:rtype: void
        :param P:
        	:type P: gp_Parab
        	:rtype: void
        :param H:
        	:type H: gp_Hypr
        	:rtype: void
        """
        return _ProjLib.ProjLib_Plane_Project(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_Plane
ProjLib_Plane.Init = new_instancemethod(_ProjLib.ProjLib_Plane_Init, None, ProjLib_Plane)
ProjLib_Plane.Project = new_instancemethod(_ProjLib.ProjLib_Plane_Project, None, ProjLib_Plane)
ProjLib_Plane_swigregister = _ProjLib.ProjLib_Plane_swigregister
ProjLib_Plane_swigregister(ProjLib_Plane)

class ProjLib_Sphere(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args) -> "void":
        """
        :param Sp:
        	:type Sp: gp_Sphere
        	:rtype: None
        """
        return _ProjLib.ProjLib_Sphere_Init(self, *args)


    def __init__(self, *args):
        """
        * Undefined projection.
        	:rtype: None
        * Projection on the sphere <Sp>.
        	:param Sp:
        	:type Sp: gp_Sphere
        	:rtype: None
        * Projection of the circle <C> on the sphere <Sp>.
        	:param Sp:
        	:type Sp: gp_Sphere
        	:param C:
        	:type C: gp_Circ
        	:rtype: None
        """
        _ProjLib.ProjLib_Sphere_swiginit(self, _ProjLib.new_ProjLib_Sphere(*args))

    def Project(self, *args) -> "void":
        """
        :param L:
        	:type L: gp_Lin
        	:rtype: void
        :param C:
        	:type C: gp_Circ
        	:rtype: void
        :param E:
        	:type E: gp_Elips
        	:rtype: void
        :param P:
        	:type P: gp_Parab
        	:rtype: void
        :param H:
        	:type H: gp_Hypr
        	:rtype: void
        """
        return _ProjLib.ProjLib_Sphere_Project(self, *args)


    def SetInBounds(self, *args) -> "void":
        """
        * Set the point of parameter U on C in the natural restrictions of the sphere.
        	:param U:
        	:type U: float
        	:rtype: None
        """
        return _ProjLib.ProjLib_Sphere_SetInBounds(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_Sphere
ProjLib_Sphere.Init = new_instancemethod(_ProjLib.ProjLib_Sphere_Init, None, ProjLib_Sphere)
ProjLib_Sphere.Project = new_instancemethod(_ProjLib.ProjLib_Sphere_Project, None, ProjLib_Sphere)
ProjLib_Sphere.SetInBounds = new_instancemethod(_ProjLib.ProjLib_Sphere_SetInBounds, None, ProjLib_Sphere)
ProjLib_Sphere_swigregister = _ProjLib.ProjLib_Sphere_swigregister
ProjLib_Sphere_swigregister(ProjLib_Sphere)

class ProjLib_Torus(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args) -> "void":
        """
        :param To:
        	:type To: gp_Torus
        	:rtype: None
        """
        return _ProjLib.ProjLib_Torus_Init(self, *args)


    def __init__(self, *args):
        """
        * Undefined projection.
        	:rtype: None
        * Projection on the torus <To>.
        	:param To:
        	:type To: gp_Torus
        	:rtype: None
        * Projection of the circle <C> on the torus <To>.
        	:param To:
        	:type To: gp_Torus
        	:param C:
        	:type C: gp_Circ
        	:rtype: None
        """
        _ProjLib.ProjLib_Torus_swiginit(self, _ProjLib.new_ProjLib_Torus(*args))

    def Project(self, *args) -> "void":
        """
        :param L:
        	:type L: gp_Lin
        	:rtype: void
        :param C:
        	:type C: gp_Circ
        	:rtype: void
        :param E:
        	:type E: gp_Elips
        	:rtype: void
        :param P:
        	:type P: gp_Parab
        	:rtype: void
        :param H:
        	:type H: gp_Hypr
        	:rtype: void
        """
        return _ProjLib.ProjLib_Torus_Project(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ProjLib.delete_ProjLib_Torus
ProjLib_Torus.Init = new_instancemethod(_ProjLib.ProjLib_Torus_Init, None, ProjLib_Torus)
ProjLib_Torus.Project = new_instancemethod(_ProjLib.ProjLib_Torus_Project, None, ProjLib_Torus)
ProjLib_Torus_swigregister = _ProjLib.ProjLib_Torus_swigregister
ProjLib_Torus_swigregister(ProjLib_Torus)

class ProjLib_HSequenceOfHSequenceOfPnt(ProjLib_SequenceOfHSequenceOfPnt, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_swiginit(self, _ProjLib.new_ProjLib_HSequenceOfHSequenceOfPnt(*args))


    @staticmethod
    def DownCast(t):
      return Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast(t)

    __swig_destroy__ = _ProjLib.delete_ProjLib_HSequenceOfHSequenceOfPnt
ProjLib_HSequenceOfHSequenceOfPnt.Sequence = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Sequence, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Append = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Append, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.ChangeSequence = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ChangeSequence, None, ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt_swigregister = _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_swigregister
ProjLib_HSequenceOfHSequenceOfPnt_swigregister(ProjLib_HSequenceOfHSequenceOfPnt)



