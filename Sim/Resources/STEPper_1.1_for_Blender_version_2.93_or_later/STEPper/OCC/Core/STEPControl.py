# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
STEPControl module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_stepcontrol.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _STEPControl.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_STEPControl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_STEPControl')
    _STEPControl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_STEPControl', [dirname(__file__)])
        except ImportError:
            import _STEPControl
            return _STEPControl
        try:
            _mod = imp.load_module('_STEPControl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _STEPControl = swig_import_helper()
    del swig_import_helper
else:
    import _STEPControl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _STEPControl.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_STEPControl.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_STEPControl.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_STEPControl.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_STEPControl.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_STEPControl.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_STEPControl.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_STEPControl.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_STEPControl.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_STEPControl.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_STEPControl.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_STEPControl.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_STEPControl.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_STEPControl.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_STEPControl.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_STEPControl.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_STEPControl.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _STEPControl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _STEPControl.process_exception(error, method_name, class_name)
process_exception = _STEPControl.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Transfer
import OCC.Core.Interface
import OCC.Core.TCollection
import OCC.Core.TColStd
import OCC.Core.Message
import OCC.Core.MoniTool
import OCC.Core.TopoDS
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.OSD
import OCC.Core.StepRepr
import OCC.Core.StepData
import OCC.Core.StepBasic
import OCC.Core.StepGeom
import OCC.Core.StepShape
import OCC.Core.TopTools
import OCC.Core.XSControl
import OCC.Core.IFSelect
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.Geom2d
STEPControl_AsIs = _STEPControl.STEPControl_AsIs
STEPControl_ManifoldSolidBrep = _STEPControl.STEPControl_ManifoldSolidBrep
STEPControl_BrepWithVoids = _STEPControl.STEPControl_BrepWithVoids
STEPControl_FacetedBrep = _STEPControl.STEPControl_FacetedBrep
STEPControl_FacetedBrepAndBrepWithVoids = _STEPControl.STEPControl_FacetedBrepAndBrepWithVoids
STEPControl_ShellBasedSurfaceModel = _STEPControl.STEPControl_ShellBasedSurfaceModel
STEPControl_GeometricCurveSet = _STEPControl.STEPControl_GeometricCurveSet
STEPControl_Hybrid = _STEPControl.STEPControl_Hybrid

def Handle_STEPControl_ActorRead_Create() -> "opencascade::handle< STEPControl_ActorRead >":
    return _STEPControl.Handle_STEPControl_ActorRead_Create()
Handle_STEPControl_ActorRead_Create = _STEPControl.Handle_STEPControl_ActorRead_Create

def Handle_STEPControl_ActorRead_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< STEPControl_ActorRead >":
    return _STEPControl.Handle_STEPControl_ActorRead_DownCast(t)
Handle_STEPControl_ActorRead_DownCast = _STEPControl.Handle_STEPControl_ActorRead_DownCast

def Handle_STEPControl_ActorRead_IsNull(t: 'opencascade::handle< STEPControl_ActorRead > const &') -> "bool":
    return _STEPControl.Handle_STEPControl_ActorRead_IsNull(t)
Handle_STEPControl_ActorRead_IsNull = _STEPControl.Handle_STEPControl_ActorRead_IsNull

def Handle_STEPControl_ActorWrite_Create() -> "opencascade::handle< STEPControl_ActorWrite >":
    return _STEPControl.Handle_STEPControl_ActorWrite_Create()
Handle_STEPControl_ActorWrite_Create = _STEPControl.Handle_STEPControl_ActorWrite_Create

def Handle_STEPControl_ActorWrite_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< STEPControl_ActorWrite >":
    return _STEPControl.Handle_STEPControl_ActorWrite_DownCast(t)
Handle_STEPControl_ActorWrite_DownCast = _STEPControl.Handle_STEPControl_ActorWrite_DownCast

def Handle_STEPControl_ActorWrite_IsNull(t: 'opencascade::handle< STEPControl_ActorWrite > const &') -> "bool":
    return _STEPControl.Handle_STEPControl_ActorWrite_IsNull(t)
Handle_STEPControl_ActorWrite_IsNull = _STEPControl.Handle_STEPControl_ActorWrite_IsNull

def Handle_STEPControl_Controller_Create() -> "opencascade::handle< STEPControl_Controller >":
    return _STEPControl.Handle_STEPControl_Controller_Create()
Handle_STEPControl_Controller_Create = _STEPControl.Handle_STEPControl_Controller_Create

def Handle_STEPControl_Controller_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< STEPControl_Controller >":
    return _STEPControl.Handle_STEPControl_Controller_DownCast(t)
Handle_STEPControl_Controller_DownCast = _STEPControl.Handle_STEPControl_Controller_DownCast

def Handle_STEPControl_Controller_IsNull(t: 'opencascade::handle< STEPControl_Controller > const &') -> "bool":
    return _STEPControl.Handle_STEPControl_Controller_IsNull(t)
Handle_STEPControl_Controller_IsNull = _STEPControl.Handle_STEPControl_Controller_IsNull
class STEPControl_ActorRead(OCC.Core.Transfer.Transfer_ActorOfTransientProcess):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ComputeSRRWT(self, *args) -> "Standard_Boolean":
        """
        * Computes transformation defined by given REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION
        	:param SRR:
        	:type SRR: StepRepr_RepresentationRelationship
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:param Trsf:
        	:type Trsf: gp_Trsf
        	:rtype: bool
        """
        return _STEPControl.STEPControl_ActorRead_ComputeSRRWT(self, *args)


    def ComputeTransformation(self, *args) -> "Standard_Boolean":
        """
        * Computes transformation defined by two axis placements (in MAPPED_ITEM or ITEM_DEFINED_TRANSFORMATION) taking into account their representation contexts (i.e. units, which may be different) Returns True if transformation is computed and is not an identity.
        	:param Origin:
        	:type Origin: StepGeom_Axis2Placement3d
        	:param Target:
        	:type Target: StepGeom_Axis2Placement3d
        	:param OrigContext:
        	:type OrigContext: StepRepr_Representation
        	:param TargContext:
        	:type TargContext: StepRepr_Representation
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:param Trsf:
        	:type Trsf: gp_Trsf
        	:rtype: bool
        """
        return _STEPControl.STEPControl_ActorRead_ComputeTransformation(self, *args)


    def PrepareUnits(self, *args) -> "void":
        """
        * set units and tolerances context by given ShapeRepresentation
        	:param rep:
        	:type rep: StepRepr_Representation
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:rtype: None
        """
        return _STEPControl.STEPControl_ActorRead_PrepareUnits(self, *args)


    def ResetUnits(self, *args) -> "void":
        """
        * reset units and tolerances context to default (mm, radians, read.precision.val, etc.)
        	:rtype: None
        """
        return _STEPControl.STEPControl_ActorRead_ResetUnits(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _STEPControl.STEPControl_ActorRead_swiginit(self, _STEPControl.new_STEPControl_ActorRead(*args))

    def TransferShape(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        :param start:
        	:type start: Standard_Transient
        	:param TP:
        	:type TP: Transfer_TransientProcess
        	:param isManifold: default value is Standard_True
        	:type isManifold: bool
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _STEPControl.STEPControl_ActorRead_TransferShape(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_STEPControl_ActorRead_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _STEPControl.delete_STEPControl_ActorRead
STEPControl_ActorRead.ComputeSRRWT = new_instancemethod(_STEPControl.STEPControl_ActorRead_ComputeSRRWT, None, STEPControl_ActorRead)
STEPControl_ActorRead.ComputeTransformation = new_instancemethod(_STEPControl.STEPControl_ActorRead_ComputeTransformation, None, STEPControl_ActorRead)
STEPControl_ActorRead.PrepareUnits = new_instancemethod(_STEPControl.STEPControl_ActorRead_PrepareUnits, None, STEPControl_ActorRead)
STEPControl_ActorRead.ResetUnits = new_instancemethod(_STEPControl.STEPControl_ActorRead_ResetUnits, None, STEPControl_ActorRead)
STEPControl_ActorRead.TransferShape = new_instancemethod(_STEPControl.STEPControl_ActorRead_TransferShape, None, STEPControl_ActorRead)
STEPControl_ActorRead_swigregister = _STEPControl.STEPControl_ActorRead_swigregister
STEPControl_ActorRead_swigregister(STEPControl_ActorRead)

class STEPControl_ActorWrite(OCC.Core.Transfer.Transfer_ActorOfFinderProcess):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GroupMode(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _STEPControl.STEPControl_ActorWrite_GroupMode(self, *args)


    def IsAssembly(self, *args) -> "Standard_Boolean":
        """
        * Customizable method to check whether shape S should be written as assembly or not Default implementation uses flag GroupMode and analyses the shape itself NOTE: this method can modify shape
        	:param S:
        	:type S: TopoDS_Shape
        	:rtype: bool
        """
        return _STEPControl.STEPControl_ActorWrite_IsAssembly(self, *args)


    def Mode(self, *args) -> "STEPControl_StepModelType":
        """:rtype: STEPControl_StepModelType"""
        return _STEPControl.STEPControl_ActorWrite_Mode(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _STEPControl.STEPControl_ActorWrite_swiginit(self, _STEPControl.new_STEPControl_ActorWrite(*args))

    def SetGroupMode(self, *args) -> "void":
        """
        :param mode:
        	:type mode: int
        	:rtype: None
        """
        return _STEPControl.STEPControl_ActorWrite_SetGroupMode(self, *args)


    def SetMode(self, *args) -> "void":
        """
        :param M:
        	:type M: STEPControl_StepModelType
        	:rtype: None
        """
        return _STEPControl.STEPControl_ActorWrite_SetMode(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        :param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _STEPControl.STEPControl_ActorWrite_SetTolerance(self, *args)


    def TransferCompound(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        :param start:
        	:type start: Transfer_Finder
        	:param SDR:
        	:type SDR: StepShape_ShapeDefinitionRepresentation
        	:param FP:
        	:type FP: Transfer_FinderProcess
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _STEPControl.STEPControl_ActorWrite_TransferCompound(self, *args)


    def TransferShape(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        :param start:
        	:type start: Transfer_Finder
        	:param SDR:
        	:type SDR: StepShape_ShapeDefinitionRepresentation
        	:param FP:
        	:type FP: Transfer_FinderProcess
        	:param shapeGroup: default value is NULL
        	:type shapeGroup: TopTools_HSequenceOfShape
        	:param isManifold: default value is Standard_True
        	:type isManifold: bool
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _STEPControl.STEPControl_ActorWrite_TransferShape(self, *args)


    def TransferSubShape(self, *args) -> "opencascade::handle< Transfer_Binder >":
        """
        :param start:
        	:type start: Transfer_Finder
        	:param SDR:
        	:type SDR: StepShape_ShapeDefinitionRepresentation
        	:param AX1:
        	:type AX1: StepGeom_Axis2Placement3d
        	:param FP:
        	:type FP: Transfer_FinderProcess
        	:param shapeGroup: default value is NULL
        	:type shapeGroup: TopTools_HSequenceOfShape
        	:param isManifold: default value is Standard_True
        	:type isManifold: bool
        	:rtype: opencascade::handle<Transfer_Binder>
        """
        return _STEPControl.STEPControl_ActorWrite_TransferSubShape(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_STEPControl_ActorWrite_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _STEPControl.delete_STEPControl_ActorWrite
STEPControl_ActorWrite.GroupMode = new_instancemethod(_STEPControl.STEPControl_ActorWrite_GroupMode, None, STEPControl_ActorWrite)
STEPControl_ActorWrite.IsAssembly = new_instancemethod(_STEPControl.STEPControl_ActorWrite_IsAssembly, None, STEPControl_ActorWrite)
STEPControl_ActorWrite.Mode = new_instancemethod(_STEPControl.STEPControl_ActorWrite_Mode, None, STEPControl_ActorWrite)
STEPControl_ActorWrite.SetGroupMode = new_instancemethod(_STEPControl.STEPControl_ActorWrite_SetGroupMode, None, STEPControl_ActorWrite)
STEPControl_ActorWrite.SetMode = new_instancemethod(_STEPControl.STEPControl_ActorWrite_SetMode, None, STEPControl_ActorWrite)
STEPControl_ActorWrite.SetTolerance = new_instancemethod(_STEPControl.STEPControl_ActorWrite_SetTolerance, None, STEPControl_ActorWrite)
STEPControl_ActorWrite.TransferCompound = new_instancemethod(_STEPControl.STEPControl_ActorWrite_TransferCompound, None, STEPControl_ActorWrite)
STEPControl_ActorWrite.TransferShape = new_instancemethod(_STEPControl.STEPControl_ActorWrite_TransferShape, None, STEPControl_ActorWrite)
STEPControl_ActorWrite.TransferSubShape = new_instancemethod(_STEPControl.STEPControl_ActorWrite_TransferSubShape, None, STEPControl_ActorWrite)
STEPControl_ActorWrite_swigregister = _STEPControl.STEPControl_ActorWrite_swigregister
STEPControl_ActorWrite_swigregister(STEPControl_ActorWrite)

class STEPControl_Controller(OCC.Core.XSControl.XSControl_Controller):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(*args) -> "Standard_Boolean":
        """
        * Standard Initialisation. It creates a Controller for STEP and records it to various names, available to select it later Returns True when done, False if could not be done
        	:rtype: bool
        """
        return _STEPControl.STEPControl_Controller_Init(*args)

    Init = staticmethod(Init)

    def __init__(self, *args):
        """
        * Initializes the use of STEP Norm (the first time) and returns a Controller
        	:rtype: None
        """
        _STEPControl.STEPControl_Controller_swiginit(self, _STEPControl.new_STEPControl_Controller(*args))


    @staticmethod
    def DownCast(t):
      return Handle_STEPControl_Controller_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _STEPControl.delete_STEPControl_Controller
STEPControl_Controller_swigregister = _STEPControl.STEPControl_Controller_swigregister
STEPControl_Controller_swigregister(STEPControl_Controller)

def STEPControl_Controller_Init(*args) -> "Standard_Boolean":
    """
    * Standard Initialisation. It creates a Controller for STEP and records it to various names, available to select it later Returns True when done, False if could not be done
    	:rtype: bool
    """
    return _STEPControl.STEPControl_Controller_Init(*args)

class STEPControl_Reader(OCC.Core.XSControl.XSControl_Reader):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FileUnits(self, *args) -> "void":
        """
        * Returns sequence of all unit names for shape representations found in file
        	:param theUnitLengthNames:
        	:type theUnitLengthNames: TColStd_SequenceOfAsciiString
        	:param theUnitAngleNames:
        	:type theUnitAngleNames: TColStd_SequenceOfAsciiString
        	:param theUnitSolidAngleNames:
        	:type theUnitSolidAngleNames: TColStd_SequenceOfAsciiString
        	:rtype: None
        """
        return _STEPControl.STEPControl_Reader_FileUnits(self, *args)


    def __init__(self, *args):
        """
        * Creates a reader object with an empty STEP model.
        	:rtype: None
        * Creates a Reader for STEP from an already existing Session Clears the session if it was not yet set for STEP
        	:param WS:
        	:type WS: XSControl_WorkSession
        	:param scratch: default value is Standard_True
        	:type scratch: bool
        	:rtype: None
        """
        _STEPControl.STEPControl_Reader_swiginit(self, _STEPControl.new_STEPControl_Reader(*args))

    def StepModel(self, *args) -> "opencascade::handle< StepData_StepModel >":
        """
        * Returns the model as a StepModel. It can then be consulted (header, product)
        	:rtype: opencascade::handle<StepData_StepModel>
        """
        return _STEPControl.STEPControl_Reader_StepModel(self, *args)


    def TransferRoot(self, *args) -> "Standard_Boolean":
        """
        * Transfers a root given its rank in the list of candidate roots Default is the first one Returns True if a shape has resulted, false else Same as inherited TransferOneRoot, kept for compatibility
        	:param num: default value is 1
        	:type num: int
        	:rtype: bool
        """
        return _STEPControl.STEPControl_Reader_TransferRoot(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _STEPControl.delete_STEPControl_Reader
STEPControl_Reader.FileUnits = new_instancemethod(_STEPControl.STEPControl_Reader_FileUnits, None, STEPControl_Reader)
STEPControl_Reader.StepModel = new_instancemethod(_STEPControl.STEPControl_Reader_StepModel, None, STEPControl_Reader)
STEPControl_Reader.TransferRoot = new_instancemethod(_STEPControl.STEPControl_Reader_TransferRoot, None, STEPControl_Reader)
STEPControl_Reader_swigregister = _STEPControl.STEPControl_Reader_swigregister
STEPControl_Reader_swigregister(STEPControl_Reader)

class STEPControl_Writer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Model(self, *args) -> "opencascade::handle< StepData_StepModel >":
        """
        * Returns the produced model. Produces a new one if not yet done or if <newone> is True This method allows for instance to edit product or header data before writing.
        	:param newone: default value is Standard_False
        	:type newone: bool
        	:rtype: opencascade::handle<StepData_StepModel>
        """
        return _STEPControl.STEPControl_Writer_Model(self, *args)


    def PrintStatsTransfer(self, *args) -> "void":
        """
        * Displays the statistics for the last translation. what defines the kind of statistics that are displayed: - 0 gives general statistics (number of translated roots, number of warnings, number of fail messages), - 1 gives root results, - 2 gives statistics for all checked entities, - 3 gives the list of translated entities, - 4 gives warning and fail messages, - 5 gives fail messages only. mode is used according to the use of what. If what is 0, mode is ignored. If what is 1, 2 or 3, mode defines the following: - 0 lists the numbers of STEP entities in a STEP model, - 1 gives the number, identifier, type and result type for each STEP entity and/or its status (fail, warning, etc.), - 2 gives maximum information for each STEP entity (i.e. checks), - 3 gives the number of entities by the type of a STEP entity, - 4 gives the number of of STEP entities per result type and/or status, - 5 gives the number of pairs (STEP or result type and status), - 6 gives the number of pairs (STEP or result type and status) AND the list of entity numbers in the STEP model.
        	:param what:
        	:type what: int
        	:param mode: default value is 0
        	:type mode: int
        	:rtype: None
        """
        return _STEPControl.STEPControl_Writer_PrintStatsTransfer(self, *args)


    def __init__(self, *args):
        """
        * Creates a Writer from scratch
        	:rtype: None
        * Creates a Writer from an already existing Session If <scratch> is True (D), clears already recorded data
        	:param WS:
        	:type WS: XSControl_WorkSession
        	:param scratch: default value is Standard_True
        	:type scratch: bool
        	:rtype: None
        """
        _STEPControl.STEPControl_Writer_swiginit(self, _STEPControl.new_STEPControl_Writer(*args))

    def SetTolerance(self, *args) -> "void":
        """
        * Sets a length-measure value that will be written to uncertainty-measure-with-unit when the next shape is translated.
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        return _STEPControl.STEPControl_Writer_SetTolerance(self, *args)


    def SetWS(self, *args) -> "void":
        """
        * Sets a specific session to <self>
        	:param WS:
        	:type WS: XSControl_WorkSession
        	:param scratch: default value is Standard_True
        	:type scratch: bool
        	:rtype: None
        """
        return _STEPControl.STEPControl_Writer_SetWS(self, *args)


    def Transfer(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Translates shape sh to a STEP entity. mode defines the STEP entity type to be output: - STEPControlStd_AsIs translates a shape to its highest possible STEP representation. - STEPControlStd_ManifoldSolidBrep translates a shape to a STEP manifold_solid_brep or brep_with_voids entity. - STEPControlStd_FacetedBrep translates a shape into a STEP faceted_brep entity. - STEPControlStd_ShellBasedSurfaceModel translates a shape into a STEP shell_based_surface_model entity. - STEPControlStd_GeometricCurveSet translates a shape into a STEP geometric_curve_set entity.
        	:param sh:
        	:type sh: TopoDS_Shape
        	:param mode:
        	:type mode: STEPControl_StepModelType
        	:param compgraph: default value is Standard_True
        	:type compgraph: bool
        	:rtype: IFSelect_ReturnStatus
        """
        return _STEPControl.STEPControl_Writer_Transfer(self, *args)


    def UnsetTolerance(self, *args) -> "void":
        """
        * Unsets the tolerance formerly forced by SetTolerance
        	:rtype: None
        """
        return _STEPControl.STEPControl_Writer_UnsetTolerance(self, *args)


    def WS(self, *args) -> "opencascade::handle< XSControl_WorkSession >":
        """
        * Returns the session used in <self>
        	:rtype: opencascade::handle<XSControl_WorkSession>
        """
        return _STEPControl.STEPControl_Writer_WS(self, *args)


    def Write(self, *args) -> "IFSelect_ReturnStatus":
        """
        * Writes a STEP model in the file identified by filename.
        	:param filename:
        	:type filename: char *
        	:rtype: IFSelect_ReturnStatus
        """
        return _STEPControl.STEPControl_Writer_Write(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _STEPControl.delete_STEPControl_Writer
STEPControl_Writer.Model = new_instancemethod(_STEPControl.STEPControl_Writer_Model, None, STEPControl_Writer)
STEPControl_Writer.PrintStatsTransfer = new_instancemethod(_STEPControl.STEPControl_Writer_PrintStatsTransfer, None, STEPControl_Writer)
STEPControl_Writer.SetTolerance = new_instancemethod(_STEPControl.STEPControl_Writer_SetTolerance, None, STEPControl_Writer)
STEPControl_Writer.SetWS = new_instancemethod(_STEPControl.STEPControl_Writer_SetWS, None, STEPControl_Writer)
STEPControl_Writer.Transfer = new_instancemethod(_STEPControl.STEPControl_Writer_Transfer, None, STEPControl_Writer)
STEPControl_Writer.UnsetTolerance = new_instancemethod(_STEPControl.STEPControl_Writer_UnsetTolerance, None, STEPControl_Writer)
STEPControl_Writer.WS = new_instancemethod(_STEPControl.STEPControl_Writer_WS, None, STEPControl_Writer)
STEPControl_Writer.Write = new_instancemethod(_STEPControl.STEPControl_Writer_Write, None, STEPControl_Writer)
STEPControl_Writer_swigregister = _STEPControl.STEPControl_Writer_swigregister
STEPControl_Writer_swigregister(STEPControl_Writer)



