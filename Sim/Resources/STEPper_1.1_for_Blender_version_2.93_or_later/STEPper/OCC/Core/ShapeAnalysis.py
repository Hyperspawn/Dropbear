# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
ShapeAnalysis module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_shapeanalysis.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _ShapeAnalysis.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ShapeAnalysis')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ShapeAnalysis')
    _ShapeAnalysis = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ShapeAnalysis', [dirname(__file__)])
        except ImportError:
            import _ShapeAnalysis
            return _ShapeAnalysis
        try:
            _mod = imp.load_module('_ShapeAnalysis', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ShapeAnalysis = swig_import_helper()
    del swig_import_helper
else:
    import _ShapeAnalysis
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ShapeAnalysis.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_ShapeAnalysis.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_ShapeAnalysis.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_ShapeAnalysis.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_ShapeAnalysis.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_ShapeAnalysis.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_ShapeAnalysis.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_ShapeAnalysis.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_ShapeAnalysis.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_ShapeAnalysis.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_ShapeAnalysis.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_ShapeAnalysis.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_ShapeAnalysis.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_ShapeAnalysis.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_ShapeAnalysis.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_ShapeAnalysis.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_ShapeAnalysis.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _ShapeAnalysis.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _ShapeAnalysis.process_exception(error, method_name, class_name)
process_exception = _ShapeAnalysis.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.ShapeExtend
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.TColGeom
import OCC.Core.TopTools
import OCC.Core.Geom2d
import OCC.Core.Bnd
import OCC.Core.BVH
import OCC.Core.Adaptor3d
import OCC.Core.Adaptor2d
import OCC.Core.math
import OCC.Core.GeomAdaptor
import OCC.Core.IntRes2d

def Handle_ShapeAnalysis_FreeBoundData_Create() -> "opencascade::handle< ShapeAnalysis_FreeBoundData >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Create()
Handle_ShapeAnalysis_FreeBoundData_Create = _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Create

def Handle_ShapeAnalysis_FreeBoundData_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ShapeAnalysis_FreeBoundData >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_DownCast(t)
Handle_ShapeAnalysis_FreeBoundData_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_DownCast

def Handle_ShapeAnalysis_FreeBoundData_IsNull(t: 'opencascade::handle< ShapeAnalysis_FreeBoundData > const &') -> "bool":
    return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_IsNull(t)
Handle_ShapeAnalysis_FreeBoundData_IsNull = _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_IsNull

def Handle_ShapeAnalysis_Surface_Create() -> "opencascade::handle< ShapeAnalysis_Surface >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Create()
Handle_ShapeAnalysis_Surface_Create = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Create

def Handle_ShapeAnalysis_Surface_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ShapeAnalysis_Surface >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_DownCast(t)
Handle_ShapeAnalysis_Surface_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_DownCast

def Handle_ShapeAnalysis_Surface_IsNull(t: 'opencascade::handle< ShapeAnalysis_Surface > const &') -> "bool":
    return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_IsNull(t)
Handle_ShapeAnalysis_Surface_IsNull = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_IsNull

def Handle_ShapeAnalysis_TransferParameters_Create() -> "opencascade::handle< ShapeAnalysis_TransferParameters >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_Create()
Handle_ShapeAnalysis_TransferParameters_Create = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_Create

def Handle_ShapeAnalysis_TransferParameters_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ShapeAnalysis_TransferParameters >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_DownCast(t)
Handle_ShapeAnalysis_TransferParameters_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_DownCast

def Handle_ShapeAnalysis_TransferParameters_IsNull(t: 'opencascade::handle< ShapeAnalysis_TransferParameters > const &') -> "bool":
    return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_IsNull(t)
Handle_ShapeAnalysis_TransferParameters_IsNull = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_IsNull

def Handle_ShapeAnalysis_Wire_Create() -> "opencascade::handle< ShapeAnalysis_Wire >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Create()
Handle_ShapeAnalysis_Wire_Create = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Create

def Handle_ShapeAnalysis_Wire_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ShapeAnalysis_Wire >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_DownCast(t)
Handle_ShapeAnalysis_Wire_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_DownCast

def Handle_ShapeAnalysis_Wire_IsNull(t: 'opencascade::handle< ShapeAnalysis_Wire > const &') -> "bool":
    return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_IsNull(t)
Handle_ShapeAnalysis_Wire_IsNull = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_IsNull

def Handle_ShapeAnalysis_TransferParametersProj_Create() -> "opencascade::handle< ShapeAnalysis_TransferParametersProj >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_Create()
Handle_ShapeAnalysis_TransferParametersProj_Create = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_Create

def Handle_ShapeAnalysis_TransferParametersProj_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ShapeAnalysis_TransferParametersProj >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_DownCast(t)
Handle_ShapeAnalysis_TransferParametersProj_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_DownCast

def Handle_ShapeAnalysis_TransferParametersProj_IsNull(t: 'opencascade::handle< ShapeAnalysis_TransferParametersProj > const &') -> "bool":
    return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_IsNull(t)
Handle_ShapeAnalysis_TransferParametersProj_IsNull = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_IsNull

def Handle_ShapeAnalysis_HSequenceOfFreeBounds_Create() -> "opencascade::handle< ShapeAnalysis_HSequenceOfFreeBounds >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_Create()
Handle_ShapeAnalysis_HSequenceOfFreeBounds_Create = _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_Create

def Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< ShapeAnalysis_HSequenceOfFreeBounds >":
    return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast(t)
Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast

def Handle_ShapeAnalysis_HSequenceOfFreeBounds_IsNull(t: 'opencascade::handle< ShapeAnalysis_HSequenceOfFreeBounds > const &') -> "bool":
    return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_IsNull(t)
Handle_ShapeAnalysis_HSequenceOfFreeBounds_IsNull = _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_IsNull
class ShapeAnalysis_SequenceOfFreeBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_SequenceOfFreeBounds(*args))
    delNode = staticmethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_delNode)
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_SequenceOfFreeBounds
ShapeAnalysis_SequenceOfFreeBounds.begin = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_begin, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.end = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_end, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.cbegin = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_cbegin, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.cend = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_cend, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Size = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Size, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Length = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Length, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Lower = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Lower, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Upper = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Upper, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.IsEmpty = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_IsEmpty, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Reverse = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Reverse, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Exchange = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Exchange, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Clear = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Clear, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Assign = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Assign, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Set = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Set, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Remove = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Remove, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Append = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Append, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Prepend = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Prepend, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.InsertBefore = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_InsertBefore, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.InsertAfter = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_InsertAfter, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Split = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Split, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.First = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_First, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.ChangeFirst = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_ChangeFirst, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Last = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Last, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.ChangeLast = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_ChangeLast, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.Value = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_Value, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.ChangeValue = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_ChangeValue, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.__call__ = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds___call__, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds.SetValue = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_SetValue, None, ShapeAnalysis_SequenceOfFreeBounds)
ShapeAnalysis_SequenceOfFreeBounds_swigregister = _ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_swigregister
ShapeAnalysis_SequenceOfFreeBounds_swigregister(ShapeAnalysis_SequenceOfFreeBounds)

def ShapeAnalysis_SequenceOfFreeBounds_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_delNode(theNode, theAl)
ShapeAnalysis_SequenceOfFreeBounds_delNode = _ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds_delNode

class ShapeAnalysis_DataMapOfShapeListOfReal(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_DataMapOfShapeListOfReal(*args))
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_DataMapOfShapeListOfReal
ShapeAnalysis_DataMapOfShapeListOfReal.begin = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_begin, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.end = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_end, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.cbegin = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_cbegin, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.cend = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_cend, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.Exchange = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_Exchange, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.Assign = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_Assign, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.Set = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_Set, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.ReSize = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_ReSize, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.Bind = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_Bind, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.Bound = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_Bound, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.IsBound = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_IsBound, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.UnBind = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_UnBind, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.Seek = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_Seek, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.Find = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_Find, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.ChangeSeek = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_ChangeSeek, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.ChangeFind = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_ChangeFind, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.__call__ = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal___call__, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.Clear = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_Clear, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal.Size = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_Size, None, ShapeAnalysis_DataMapOfShapeListOfReal)
ShapeAnalysis_DataMapOfShapeListOfReal_swigregister = _ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal_swigregister
ShapeAnalysis_DataMapOfShapeListOfReal_swigregister(ShapeAnalysis_DataMapOfShapeListOfReal)

class ShapeAnalysis_BoxBndTree(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ShapeAnalysis.ShapeAnalysis_BoxBndTree_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_BoxBndTree(*args))
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_BoxBndTree
ShapeAnalysis_BoxBndTree.Add = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_BoxBndTree_Add, None, ShapeAnalysis_BoxBndTree)
ShapeAnalysis_BoxBndTree.Select = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_BoxBndTree_Select, None, ShapeAnalysis_BoxBndTree)
ShapeAnalysis_BoxBndTree.Clear = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_BoxBndTree_Clear, None, ShapeAnalysis_BoxBndTree)
ShapeAnalysis_BoxBndTree.IsEmpty = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_BoxBndTree_IsEmpty, None, ShapeAnalysis_BoxBndTree)
ShapeAnalysis_BoxBndTree.Root = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_BoxBndTree_Root, None, ShapeAnalysis_BoxBndTree)
ShapeAnalysis_BoxBndTree.Allocator = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_BoxBndTree_Allocator, None, ShapeAnalysis_BoxBndTree)
ShapeAnalysis_BoxBndTree_swigregister = _ShapeAnalysis.ShapeAnalysis_BoxBndTree_swigregister
ShapeAnalysis_BoxBndTree_swigregister(ShapeAnalysis_BoxBndTree)

class shapeanalysis(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AdjustByPeriod(*args) -> "Standard_Real":
        """
        * Returns a shift required to move point <Val> to the range [ToVal-Period/2,ToVal+Period/2]. This shift will be the divisible by Period. Intended for adjusting parameters on periodic surfaces.
        	:param Val:
        	:type Val: float
        	:param ToVal:
        	:type ToVal: float
        	:param Period:
        	:type Period: float
        	:rtype: float
        """
        return _ShapeAnalysis.shapeanalysis_AdjustByPeriod(*args)

    AdjustByPeriod = staticmethod(AdjustByPeriod)

    def AdjustToPeriod(*args) -> "Standard_Real":
        """
        * Returns a shift required to move point <Val> to the range [ValMin,ValMax]. This shift will be the divisible by Period with Period = ValMax - ValMin. Intended for adjusting parameters on periodic surfaces.
        	:param Val:
        	:type Val: float
        	:param ValMin:
        	:type ValMin: float
        	:param ValMax:
        	:type ValMax: float
        	:rtype: float
        """
        return _ShapeAnalysis.shapeanalysis_AdjustToPeriod(*args)

    AdjustToPeriod = staticmethod(AdjustToPeriod)

    def ContourArea(*args) -> "Standard_Real":
        """
        * Returns a total area of 3d wire
        	:param theWire:
        	:type theWire: TopoDS_Wire
        	:rtype: float
        """
        return _ShapeAnalysis.shapeanalysis_ContourArea(*args)

    ContourArea = staticmethod(ContourArea)

    def FindBounds(*args) -> "void":
        """
        * Finds the start and end vertices of the shape Shape can be of the following type: vertex: V1 and V2 are the same and equal to <shape>, edge : V1 is start and V2 is end vertex (see ShapeAnalysis_Edge methods FirstVertex and LastVertex), wire : V1 is start vertex of the first edge, V2 is end vertex of the last edge (also see ShapeAnalysis_Edge). If wire contains no edges V1 and V2 are nullified If none of the above V1 and V2 are nullified
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param V1:
        	:type V1: TopoDS_Vertex
        	:param V2:
        	:type V2: TopoDS_Vertex
        	:rtype: void
        """
        return _ShapeAnalysis.shapeanalysis_FindBounds(*args)

    FindBounds = staticmethod(FindBounds)

    def GetFaceUVBounds(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
        """
        * Computes exact UV bounds of all wires on the face
        	:param F:
        	:type F: TopoDS_Face
        	:param Umin:
        	:type Umin: float
        	:param Umax:
        	:type Umax: float
        	:param Vmin:
        	:type Vmin: float
        	:param Vmax:
        	:type Vmax: float
        	:rtype: void
        """
        return _ShapeAnalysis.shapeanalysis_GetFaceUVBounds(*args)

    GetFaceUVBounds = staticmethod(GetFaceUVBounds)

    def IsOuterBound(*args) -> "Standard_Boolean":
        """
        * Returns True if <F> has outer bound.
        	:param face:
        	:type face: TopoDS_Face
        	:rtype: bool
        """
        return _ShapeAnalysis.shapeanalysis_IsOuterBound(*args)

    IsOuterBound = staticmethod(IsOuterBound)

    def OuterWire(*args) -> "TopoDS_Wire":
        """
        * Returns the outer wire on the face <Face>. This is replacement of the method BRepTools::OuterWire until it works badly. Returns the first wire oriented as outer according to FClass2d_Classifier. If none, last wire is returned.
        	:param face:
        	:type face: TopoDS_Face
        	:rtype: TopoDS_Wire
        """
        return _ShapeAnalysis.shapeanalysis_OuterWire(*args)

    OuterWire = staticmethod(OuterWire)

    def TotCross2D(*args) -> "Standard_Real":
        """
        * Returns a total area of 2d wire
        	:param sewd:
        	:type sewd: ShapeExtend_WireData
        	:param aFace:
        	:type aFace: TopoDS_Face
        	:rtype: float
        """
        return _ShapeAnalysis.shapeanalysis_TotCross2D(*args)

    TotCross2D = staticmethod(TotCross2D)

    __repr__ = _dumps_object


    def __init__(self):
        _ShapeAnalysis.shapeanalysis_swiginit(self, _ShapeAnalysis.new_shapeanalysis())
    __swig_destroy__ = _ShapeAnalysis.delete_shapeanalysis
shapeanalysis_swigregister = _ShapeAnalysis.shapeanalysis_swigregister
shapeanalysis_swigregister(shapeanalysis)

def shapeanalysis_AdjustByPeriod(*args) -> "Standard_Real":
    """
    * Returns a shift required to move point <Val> to the range [ToVal-Period/2,ToVal+Period/2]. This shift will be the divisible by Period. Intended for adjusting parameters on periodic surfaces.
    	:param Val:
    	:type Val: float
    	:param ToVal:
    	:type ToVal: float
    	:param Period:
    	:type Period: float
    	:rtype: float
    """
    return _ShapeAnalysis.shapeanalysis_AdjustByPeriod(*args)

def shapeanalysis_AdjustToPeriod(*args) -> "Standard_Real":
    """
    * Returns a shift required to move point <Val> to the range [ValMin,ValMax]. This shift will be the divisible by Period with Period = ValMax - ValMin. Intended for adjusting parameters on periodic surfaces.
    	:param Val:
    	:type Val: float
    	:param ValMin:
    	:type ValMin: float
    	:param ValMax:
    	:type ValMax: float
    	:rtype: float
    """
    return _ShapeAnalysis.shapeanalysis_AdjustToPeriod(*args)

def shapeanalysis_ContourArea(*args) -> "Standard_Real":
    """
    * Returns a total area of 3d wire
    	:param theWire:
    	:type theWire: TopoDS_Wire
    	:rtype: float
    """
    return _ShapeAnalysis.shapeanalysis_ContourArea(*args)

def shapeanalysis_FindBounds(*args) -> "void":
    """
    * Finds the start and end vertices of the shape Shape can be of the following type: vertex: V1 and V2 are the same and equal to <shape>, edge : V1 is start and V2 is end vertex (see ShapeAnalysis_Edge methods FirstVertex and LastVertex), wire : V1 is start vertex of the first edge, V2 is end vertex of the last edge (also see ShapeAnalysis_Edge). If wire contains no edges V1 and V2 are nullified If none of the above V1 and V2 are nullified
    	:param shape:
    	:type shape: TopoDS_Shape
    	:param V1:
    	:type V1: TopoDS_Vertex
    	:param V2:
    	:type V2: TopoDS_Vertex
    	:rtype: void
    """
    return _ShapeAnalysis.shapeanalysis_FindBounds(*args)

def shapeanalysis_GetFaceUVBounds(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
    """
    * Computes exact UV bounds of all wires on the face
    	:param F:
    	:type F: TopoDS_Face
    	:param Umin:
    	:type Umin: float
    	:param Umax:
    	:type Umax: float
    	:param Vmin:
    	:type Vmin: float
    	:param Vmax:
    	:type Vmax: float
    	:rtype: void
    """
    return _ShapeAnalysis.shapeanalysis_GetFaceUVBounds(*args)

def shapeanalysis_IsOuterBound(*args) -> "Standard_Boolean":
    """
    * Returns True if <F> has outer bound.
    	:param face:
    	:type face: TopoDS_Face
    	:rtype: bool
    """
    return _ShapeAnalysis.shapeanalysis_IsOuterBound(*args)

def shapeanalysis_OuterWire(*args) -> "TopoDS_Wire":
    """
    * Returns the outer wire on the face <Face>. This is replacement of the method BRepTools::OuterWire until it works badly. Returns the first wire oriented as outer according to FClass2d_Classifier. If none, last wire is returned.
    	:param face:
    	:type face: TopoDS_Face
    	:rtype: TopoDS_Wire
    """
    return _ShapeAnalysis.shapeanalysis_OuterWire(*args)

def shapeanalysis_TotCross2D(*args) -> "Standard_Real":
    """
    * Returns a total area of 2d wire
    	:param sewd:
    	:type sewd: ShapeExtend_WireData
    	:param aFace:
    	:type aFace: TopoDS_Face
    	:rtype: float
    """
    return _ShapeAnalysis.shapeanalysis_TotCross2D(*args)

class ShapeAnalysis_CheckSmallFace(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CheckPin(self, *args) -> "Standard_Boolean":
        """
        * Checks if a Face has a pin, which can be edited No singularity : no pin, returns 0 If there is a pin, checked topics, with returned value : - 0 : nothing to do more - 1 : 'smooth', i.e. not a really sharp pin -> diagnostic 'SmoothPin' - 2 : stretched pin, i.e. is possible to relimit the face by another vertex, so that this vertex still gives a pin -> diagnostic 'StretchedPin' with location of vertex (Pnt)
        	:param F:
        	:type F: TopoDS_Face
        	:param whatrow:
        	:type whatrow: int
        	:param sence:
        	:type sence: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckPin(self, *args)


    def CheckPinEdges(self, *args) -> "Standard_Boolean":
        """
        :param theFirstEdge:
        	:type theFirstEdge: TopoDS_Edge
        	:param theSecondEdge:
        	:type theSecondEdge: TopoDS_Edge
        	:param coef1:
        	:type coef1: float
        	:param coef2:
        	:type coef2: float
        	:param toler:
        	:type toler: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckPinEdges(self, *args)


    def CheckPinFace(self, *args) -> "Standard_Boolean":
        """
        :param F:
        	:type F: TopoDS_Face
        	:param mapEdges:
        	:type mapEdges: TopTools_DataMapOfShapeShape
        	:param toler: default value is -1.0
        	:type toler: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckPinFace(self, *args)


    def CheckSingleStrip(self, *args) -> "Standard_Boolean":
        """
        * Checks if a Face is a single strip, i.e. brings two great edges which are confused on their whole length, possible other edges are small or null length //! Returns 0 if not a strip support, 1 strip in U, 2 strip in V Records diagnostic in info if it is a single strip
        	:param F:
        	:type F: TopoDS_Face
        	:param E1:
        	:type E1: TopoDS_Edge
        	:param E2:
        	:type E2: TopoDS_Edge
        	:param tol: default value is -1.0
        	:type tol: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckSingleStrip(self, *args)


    def CheckSplittingVertices(self, *args) -> "Standard_Integer":
        """
        * Checks if a Face brings vertices which split it, either confused with non adjacent vertices, or confused with their projection on non adjacent edges Returns the count of found splitting vertices Each vertex then brings a diagnostic 'SplittingVertex', with data : 'Face' for the face, 'Edge' for the split edge
        	:param F:
        	:type F: TopoDS_Face
        	:param MapEdges:
        	:type MapEdges: TopTools_DataMapOfShapeListOfShape
        	:param MapParam:
        	:type MapParam: ShapeAnalysis_DataMapOfShapeListOfReal
        	:param theAllVert:
        	:type theAllVert: TopoDS_Compound
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckSplittingVertices(self, *args)


    def CheckSpotFace(self, *args) -> "Standard_Boolean":
        """
        * Acts as IsSpotFace, but records in <infos> a diagnostic 'SpotFace' with the Pnt as value (data 'Location')
        	:param F:
        	:type F: TopoDS_Face
        	:param tol: default value is -1.0
        	:type tol: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckSpotFace(self, *args)


    def CheckStripEdges(self, *args) -> "Standard_Boolean":
        """
        * Checks if two edges define a strip, i.e. distance maxi below tolerance, given or some of those of E1 and E2
        	:param E1:
        	:type E1: TopoDS_Edge
        	:param E2:
        	:type E2: TopoDS_Edge
        	:param tol:
        	:type tol: float
        	:param dmax:
        	:type dmax: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckStripEdges(self, *args)


    def CheckStripFace(self, *args) -> "Standard_Boolean":
        """
        * Checks if a Face is as a Strip Returns 0 if not or non determined, 1 if in U, 2 if in V By default, considers the tolerance zone of its edges A given value <tol> may be given to check a strip of max this width //! If a Face is determined as a Strip, it is delinited by two lists of edges. These lists are recorded in diagnostic Diagnostic 'StripFace' brings data 'Direction' (U or V), 'List1' , 'List2' (if they could be computed)
        	:param F:
        	:type F: TopoDS_Face
        	:param E1:
        	:type E1: TopoDS_Edge
        	:param E2:
        	:type E2: TopoDS_Edge
        	:param tol: default value is -1.0
        	:type tol: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckStripFace(self, *args)


    def CheckTwisted(self, *args) -> "Standard_Boolean":
        """
        * Checks if a Face is twisted (apart from checking Pin, i.e. it does not give information on pin, only 'it is twisted')
        	:param F:
        	:type F: TopoDS_Face
        	:param paramu:
        	:type paramu: float
        	:param paramv:
        	:type paramv: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckTwisted(self, *args)


    def FindStripEdges(self, *args) -> "Standard_Boolean":
        """
        * Searchs for two and only two edges up tolerance Returns True if OK, false if not 2 edges If True, returns the two edges and their maximum distance
        	:param F:
        	:type F: TopoDS_Face
        	:param E1:
        	:type E1: TopoDS_Edge
        	:param E2:
        	:type E2: TopoDS_Edge
        	:param tol:
        	:type tol: float
        	:param dmax:
        	:type dmax: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_FindStripEdges(self, *args)


    def IsSpotFace(self, *args) -> "Standard_Integer":
        """
        * Checks if a Face is as a Spot Returns 0 if not, 1 if yes, 2 if yes and all vertices are the same By default, considers the tolerance zone of its vertices A given value <tol> may be given to check a spot of this size If a Face is a Spot, its location is returned in <spot>, and <spotol> returns an equivalent tolerance, which is computed as half of max dimension of min-max box of the face
        	:param F:
        	:type F: TopoDS_Face
        	:param spot:
        	:type spot: gp_Pnt
        	:param spotol:
        	:type spotol: float
        	:param tol: default value is -1.0
        	:type tol: float
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_IsSpotFace(self, *args)


    def IsStripSupport(self, *args) -> "Standard_Boolean":
        """
        * Checks if a Face lies on a Surface which is a strip So the Face is a strip. But a Face may be a strip elsewhere .. //! A given value <tol> may be given to check max width By default, considers the tolerance zone of its edges Returns 0 if not a strip support, 1 strip in U, 2 strip in V
        	:param F:
        	:type F: TopoDS_Face
        	:param tol: default value is -1.0
        	:type tol: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_IsStripSupport(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Sets a fixed Tolerance to check small face By default, local tolerance zone is considered Sets a fixed MaxTolerance to check small face Sets a fixed Tolerance to check small face By default, local tolerance zone is considered Unset fixed tolerance, comes back to local tolerance zones Unset fixed tolerance, comes back to local tolerance zones
        	:param tol:
        	:type tol: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_SetTolerance(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty tool Checks a Shape i.e. each of its faces, records checks as diagnostics in the <infos> //! If <infos> has not been set before, no check is done //! For faces which are in a Shell, topological data are recorded to allow recovering connectivities after fixing or removing the small faces or parts of faces Enchains various checks on a face inshell : to compute more informations, relevant to topology
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_CheckSmallFace(*args))

    def Status(self, *args) -> "Standard_Boolean":
        """
        * Returns the status of last call to Perform() ShapeExtend_OK : face was OK, nothing done ShapeExtend_DONE1: some wires are fixed ShapeExtend_DONE2: orientation of wires fixed ShapeExtend_DONE3: missing seam added ShapeExtend_DONE4: small area wire removed ShapeExtend_DONE5: natural bounds added ShapeExtend_FAIL1: some fails during fixing wires ShapeExtend_FAIL2: cannot fix orientation of wires ShapeExtend_FAIL3: cannot add missing seam ShapeExtend_FAIL4: cannot remove small area wire
        	:param status:
        	:type status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_Status(self, *args)


    def StatusPin(self, *args) -> "Standard_Boolean":
        """
        :param status:
        	:type status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusPin(self, *args)


    def StatusPinEdges(self, *args) -> "Standard_Boolean":
        """
        :param status:
        	:type status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusPinEdges(self, *args)


    def StatusPinFace(self, *args) -> "Standard_Boolean":
        """
        :param status:
        	:type status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusPinFace(self, *args)


    def StatusSplitVert(self, *args) -> "Standard_Boolean":
        """
        :param status:
        	:type status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusSplitVert(self, *args)


    def StatusSpot(self, *args) -> "Standard_Boolean":
        """
        :param status:
        	:type status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusSpot(self, *args)


    def StatusStrip(self, *args) -> "Standard_Boolean":
        """
        :param status:
        	:type status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusStrip(self, *args)


    def StatusTwisted(self, *args) -> "Standard_Boolean":
        """
        :param status:
        	:type status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusTwisted(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * Returns the tolerance to check small faces, negative value if local tolerances zones are to be considered
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_Tolerance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_CheckSmallFace
ShapeAnalysis_CheckSmallFace.CheckPin = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckPin, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.CheckPinEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckPinEdges, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.CheckPinFace = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckPinFace, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.CheckSingleStrip = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckSingleStrip, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.CheckSplittingVertices = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckSplittingVertices, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.CheckSpotFace = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckSpotFace, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.CheckStripEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckStripEdges, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.CheckStripFace = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckStripFace, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.CheckTwisted = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckTwisted, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.FindStripEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_FindStripEdges, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.IsSpotFace = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_IsSpotFace, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.IsStripSupport = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_IsStripSupport, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.SetTolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_SetTolerance, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.Status = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_Status, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.StatusPin = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusPin, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.StatusPinEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusPinEdges, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.StatusPinFace = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusPinFace, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.StatusSplitVert = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusSplitVert, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.StatusSpot = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusSpot, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.StatusStrip = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusStrip, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.StatusTwisted = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusTwisted, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace.Tolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_CheckSmallFace_Tolerance, None, ShapeAnalysis_CheckSmallFace)
ShapeAnalysis_CheckSmallFace_swigregister = _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_swigregister
ShapeAnalysis_CheckSmallFace_swigregister(ShapeAnalysis_CheckSmallFace)

class ShapeAnalysis_Curve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FillBndBox(self, *args) -> "void":
        """
        * Computes a boundary box on segment of curve C2d from First to Last. This is done by taking NPoints points from the curve and, if Exact is True, by searching for exact extrema. All these points are added to Box.
        	:param C2d:
        	:type C2d: Geom2d_Curve
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param NPoints:
        	:type NPoints: int
        	:param Exact:
        	:type Exact: bool
        	:param Box:
        	:type Box: Bnd_Box2d
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_FillBndBox(self, *args)


    def GetSamplePoints(*args) -> "Standard_Boolean":
        """
        * Returns sample points which will serve as linearisation of the2d curve in range (first, last) The distribution of sample points is consystent with what is used by BRepTopAdaptor_FClass2d
        	:param curve:
        	:type curve: Geom2d_Curve
        	:param first:
        	:type first: float
        	:param last:
        	:type last: float
        	:param seq:
        	:type seq: TColgp_SequenceOfPnt2d
        	:rtype: bool
        * Returns sample points which will serve as linearisation of the curve in range (first, last)
        	:param curve:
        	:type curve: Geom_Curve
        	:param first:
        	:type first: float
        	:param last:
        	:type last: float
        	:param seq:
        	:type seq: TColgp_SequenceOfPnt
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_GetSamplePoints(*args)

    GetSamplePoints = staticmethod(GetSamplePoints)

    def IsClosed(*args) -> "Standard_Boolean":
        """
        * Tells if the Curve is closed with given precision. If <preci> < 0 then Precision::Confusion is used.
        	:param curve:
        	:type curve: Geom_Curve
        	:param preci: default value is -1
        	:type preci: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args) -> "Standard_Boolean":
        """
        * This method was implemented as fix for changes in trimmed curve behaviour. For the moment trimmed curve returns false anyway. So it is necessary to adapt all Data exchange tools for this behaviour. Current implementation takes into account that curve may be offset.
        	:param curve:
        	:type curve: Geom_Curve
        	:rtype: bool
        * The same as for Curve3d.
        	:param curve:
        	:type curve: Geom2d_Curve
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def IsPlanar(*args) -> "Standard_Boolean":
        """
        * Checks if points are planar with given preci. If Normal has not zero modulus, checks with given normal
        	:param pnts:
        	:type pnts: TColgp_Array1OfPnt
        	:param Normal:
        	:type Normal: gp_XYZ
        	:param preci: default value is 0
        	:type preci: float
        	:rtype: bool
        * Checks if curve is planar with given preci. If Normal has not zero modulus, checks with given normal
        	:param curve:
        	:type curve: Geom_Curve
        	:param Normal:
        	:type Normal: gp_XYZ
        	:param preci: default value is 0
        	:type preci: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_IsPlanar(*args)

    IsPlanar = staticmethod(IsPlanar)

    def NextProject(self, *args) -> "Standard_Real":
        """
        * Projects a Point on a Curve using Newton method. <paramPrev> is taken as the first approximation of solution. If Newton algorithm fails the method Project() is used. If AdjustToEnds is True, point will be adjusted to the end of the curve if distance is less than <preci>
        	:param paramPrev:
        	:type paramPrev: float
        	:param C3D:
        	:type C3D: Geom_Curve
        	:param P3D:
        	:type P3D: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param proj:
        	:type proj: gp_Pnt
        	:param param:
        	:type param: float
        	:param cf:
        	:type cf: float
        	:param cl:
        	:type cl: float
        	:param AdjustToEnds: default value is Standard_True
        	:type AdjustToEnds: bool
        	:rtype: float
        * Projects a Point on a Curve using Newton method. <paramPrev> is taken as the first approximation of solution. If Newton algorithm fails the method Project() is used.
        	:param paramPrev:
        	:type paramPrev: float
        	:param C3D:
        	:type C3D: Adaptor3d_Curve
        	:param P3D:
        	:type P3D: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param proj:
        	:type proj: gp_Pnt
        	:param param:
        	:type param: float
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_NextProject(self, *args)


    def Project(self, *args) -> "Standard_Real":
        """
        * Projects a Point on a Curve. Computes the projected point and its parameter on the curve. <preci> is used as 3d precision (hence, 0 will produce reject unless exact confusion). The number of iterations is limited. If AdjustToEnds is True, point will be adjusted to the end of the curve if distance is less than <preci> //! Returned value is the distance between the given point and computed one.
        	:param C3D:
        	:type C3D: Geom_Curve
        	:param P3D:
        	:type P3D: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param proj:
        	:type proj: gp_Pnt
        	:param param:
        	:type param: float
        	:param AdjustToEnds: default value is Standard_True
        	:type AdjustToEnds: bool
        	:rtype: float
        * Projects a Point on a Curve. Computes the projected point and its parameter on the curve. <preci> is used as 3d precision (hence, 0 will produce reject unless exact confusion). The number of iterations is limited. //! Returned value is the distance between the given point and computed one.
        	:param C3D:
        	:type C3D: Adaptor3d_Curve
        	:param P3D:
        	:type P3D: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param proj:
        	:type proj: gp_Pnt
        	:param param:
        	:type param: float
        	:param AdjustToEnds: default value is Standard_True
        	:type AdjustToEnds: bool
        	:rtype: float
        * Projects a Point on a Curve, but parameters are limited between <cf> and <cl>. The range [cf, cl] is extended with help of Adaptor3d on the basis of 3d precision <preci>. If AdjustToEnds is True, point will be adjusted to the end of the curve if distance is less than <preci>
        	:param C3D:
        	:type C3D: Geom_Curve
        	:param P3D:
        	:type P3D: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param proj:
        	:type proj: gp_Pnt
        	:param param:
        	:type param: float
        	:param cf:
        	:type cf: float
        	:param cl:
        	:type cl: float
        	:param AdjustToEnds: default value is Standard_True
        	:type AdjustToEnds: bool
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_Project(self, *args)


    def ProjectAct(self, *args) -> "Standard_Real":
        """
        :param C3D:
        	:type C3D: Adaptor3d_Curve
        	:param P3D:
        	:type P3D: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param proj:
        	:type proj: gp_Pnt
        	:param param:
        	:type param: float
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_ProjectAct(self, *args)


    def SelectForwardSeam(self, *args) -> "Standard_Integer":
        """
        * Defines which pcurve (C1 or C2) should be chosen for FORWARD seam edge.
        	:param C1:
        	:type C1: Geom2d_Curve
        	:param C2:
        	:type C2: Geom2d_Curve
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_SelectForwardSeam(self, *args)


    def ValidateRange(self, *args) -> "Standard_Boolean":
        """
        * Validate parameters First and Last for the given curve in order to make them valid for creation of edge. This includes: - limiting range [First,Last] by range of curve - adjusting range [First,Last] for periodic (or closed) curve if Last < First Returns True if parameters are OK or are successfully corrected, or False if parameters cannot be corrected. In the latter case, parameters are reset to range of curve.
        	:param Crv:
        	:type Crv: Geom_Curve
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param prec:
        	:type prec: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_ValidateRange(self, *args)


    __repr__ = _dumps_object


    def __init__(self):
        _ShapeAnalysis.ShapeAnalysis_Curve_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_Curve())
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Curve
ShapeAnalysis_Curve.FillBndBox = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Curve_FillBndBox, None, ShapeAnalysis_Curve)
ShapeAnalysis_Curve.NextProject = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Curve_NextProject, None, ShapeAnalysis_Curve)
ShapeAnalysis_Curve.Project = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Curve_Project, None, ShapeAnalysis_Curve)
ShapeAnalysis_Curve.ProjectAct = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Curve_ProjectAct, None, ShapeAnalysis_Curve)
ShapeAnalysis_Curve.SelectForwardSeam = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Curve_SelectForwardSeam, None, ShapeAnalysis_Curve)
ShapeAnalysis_Curve.ValidateRange = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Curve_ValidateRange, None, ShapeAnalysis_Curve)
ShapeAnalysis_Curve_swigregister = _ShapeAnalysis.ShapeAnalysis_Curve_swigregister
ShapeAnalysis_Curve_swigregister(ShapeAnalysis_Curve)

def ShapeAnalysis_Curve_GetSamplePoints(*args) -> "Standard_Boolean":
    """
    * Returns sample points which will serve as linearisation of the2d curve in range (first, last) The distribution of sample points is consystent with what is used by BRepTopAdaptor_FClass2d
    	:param curve:
    	:type curve: Geom2d_Curve
    	:param first:
    	:type first: float
    	:param last:
    	:type last: float
    	:param seq:
    	:type seq: TColgp_SequenceOfPnt2d
    	:rtype: bool
    * Returns sample points which will serve as linearisation of the curve in range (first, last)
    	:param curve:
    	:type curve: Geom_Curve
    	:param first:
    	:type first: float
    	:param last:
    	:type last: float
    	:param seq:
    	:type seq: TColgp_SequenceOfPnt
    	:rtype: bool
    """
    return _ShapeAnalysis.ShapeAnalysis_Curve_GetSamplePoints(*args)

def ShapeAnalysis_Curve_IsClosed(*args) -> "Standard_Boolean":
    """
    * Tells if the Curve is closed with given precision. If <preci> < 0 then Precision::Confusion is used.
    	:param curve:
    	:type curve: Geom_Curve
    	:param preci: default value is -1
    	:type preci: float
    	:rtype: bool
    """
    return _ShapeAnalysis.ShapeAnalysis_Curve_IsClosed(*args)

def ShapeAnalysis_Curve_IsPeriodic(*args) -> "Standard_Boolean":
    """
    * This method was implemented as fix for changes in trimmed curve behaviour. For the moment trimmed curve returns false anyway. So it is necessary to adapt all Data exchange tools for this behaviour. Current implementation takes into account that curve may be offset.
    	:param curve:
    	:type curve: Geom_Curve
    	:rtype: bool
    * The same as for Curve3d.
    	:param curve:
    	:type curve: Geom2d_Curve
    	:rtype: bool
    """
    return _ShapeAnalysis.ShapeAnalysis_Curve_IsPeriodic(*args)

def ShapeAnalysis_Curve_IsPlanar(*args) -> "Standard_Boolean":
    """
    * Checks if points are planar with given preci. If Normal has not zero modulus, checks with given normal
    	:param pnts:
    	:type pnts: TColgp_Array1OfPnt
    	:param Normal:
    	:type Normal: gp_XYZ
    	:param preci: default value is 0
    	:type preci: float
    	:rtype: bool
    * Checks if curve is planar with given preci. If Normal has not zero modulus, checks with given normal
    	:param curve:
    	:type curve: Geom_Curve
    	:param Normal:
    	:type Normal: gp_XYZ
    	:param preci: default value is 0
    	:type preci: float
    	:rtype: bool
    """
    return _ShapeAnalysis.ShapeAnalysis_Curve_IsPlanar(*args)

class ShapeAnalysis_Edge(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BoundUV(self, *args) -> "Standard_Boolean":
        """
        :param edge:
        	:type edge: TopoDS_Edge
        	:param face:
        	:type face: TopoDS_Face
        	:param first:
        	:type first: gp_Pnt2d
        	:param last:
        	:type last: gp_Pnt2d
        	:rtype: bool
        * Returns the ends of pcurve Calls method PCurve with <orient> equal to True
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param surface:
        	:type surface: Geom_Surface
        	:param location:
        	:type location: TopLoc_Location
        	:param first:
        	:type first: gp_Pnt2d
        	:param last:
        	:type last: gp_Pnt2d
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_BoundUV(self, *args)


    def CheckCurve3dWithPCurve(self, *args) -> "Standard_Boolean":
        """
        :param edge:
        	:type edge: TopoDS_Edge
        	:param face:
        	:type face: TopoDS_Face
        	:rtype: bool
        * Checks mutual orientation of 3d curve and pcurve on the analysis of curves bounding points
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param surface:
        	:type surface: Geom_Surface
        	:param location:
        	:type location: TopLoc_Location
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckCurve3dWithPCurve(self, *args)


    def CheckOverlapping(self, *args) -> "Standard_Boolean":
        """
        * Checks the first edge is overlapped with second edge. If distance between two edges is less then theTolOverlap edges is overlapped. theDomainDis - length of part of edges on wich edges is overlapped.
        	:param theEdge1:
        	:type theEdge1: TopoDS_Edge
        	:param theEdge2:
        	:type theEdge2: TopoDS_Edge
        	:param theTolOverlap:
        	:type theTolOverlap: float
        	:param theDomainDist: default value is 0.0
        	:type theDomainDist: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckOverlapping(self, *args)


    def CheckPCurveRange(self, *args) -> "Standard_Boolean":
        """
        * Checks possibility for pcurve thePC to have range [theFirst, theLast] (edge range) having respect to real first, last parameters of thePC
        	:param theFirst:
        	:type theFirst: float
        	:param theLast:
        	:type theLast: float
        	:param thePC:
        	:type thePC: Geom2d_Curve
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckPCurveRange(self, *args)


    def CheckSameParameter(self, *args) -> "Standard_Boolean":
        """
        * Checks the edge to be SameParameter. Calculates the maximal deviation between 3d curve and each pcurve of the edge on <NbControl> equidistant points (the same algorithm as in BRepCheck; default value is 23 as in BRepCheck). This deviation is returned in <maxdev> parameter. If deviation is greater than tolerance of the edge (i.e. incorrect flag) returns False, else returns True.
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param maxdev:
        	:type maxdev: float
        	:param NbControl: default value is 23
        	:type NbControl: int
        	:rtype: bool
        * Checks the edge to be SameParameter. Calculates the maximal deviation between 3d curve and each pcurve of the edge on <NbControl> equidistant points (the same algorithm as in BRepCheck; default value is 23 as in BRepCheck). This deviation is returned in <maxdev> parameter. If deviation is greater than tolerance of the edge (i.e. incorrect flag) returns False, else returns True.
        	:param theEdge:
        	:type theEdge: TopoDS_Edge
        	:param theFace:
        	:type theFace: TopoDS_Face
        	:param theMaxdev:
        	:type theMaxdev: float
        	:param theNbControl: default value is 23
        	:type theNbControl: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckSameParameter(self, *args)


    def CheckVertexTolerance(self, *args) -> "Standard_Boolean":
        """
        :param edge:
        	:type edge: TopoDS_Edge
        	:param face:
        	:type face: TopoDS_Face
        	:param toler1:
        	:type toler1: float
        	:param toler2:
        	:type toler2: float
        	:rtype: bool
        * Checks if it is necessary to increase tolerances of the edge vertices to comprise the ends of 3d curve and pcurve on the given face (first method) or all pcurves stored in an edge (second one) toler1 returns necessary tolerance for first vertex, toler2 returns necessary tolerance for last vertex.
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param toler1:
        	:type toler1: float
        	:param toler2:
        	:type toler2: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckVertexTolerance(self, *args)


    def CheckVerticesWithCurve3d(self, *args) -> "Standard_Boolean":
        """
        * Checks the start and/or end vertex of the edge for matching with 3d curve with the given precision. <vtx> = 1 : start vertex only <vtx> = 2 : end vertex only <vtx> = 0 : both (default) If preci < 0 the vertices are considered with their own tolerances, else with the given <preci>.
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param preci: default value is -1
        	:type preci: float
        	:param vtx: default value is 0
        	:type vtx: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckVerticesWithCurve3d(self, *args)


    def CheckVerticesWithPCurve(self, *args) -> "Standard_Boolean":
        """
        :param edge:
        	:type edge: TopoDS_Edge
        	:param face:
        	:type face: TopoDS_Face
        	:param preci: default value is -1
        	:type preci: float
        	:param vtx: default value is 0
        	:type vtx: int
        	:rtype: bool
        * Checks the start and/or end vertex of the edge for matching with pcurve with the given precision. <vtx> = 1 : start vertex <vtx> = 2 : end vertex <vtx> = 0 : both If preci < 0 the vertices are considered with their own tolerances, else with the given <preci>.
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param surface:
        	:type surface: Geom_Surface
        	:param location:
        	:type location: TopLoc_Location
        	:param preci: default value is -1
        	:type preci: float
        	:param vtx: default value is 0
        	:type vtx: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckVerticesWithPCurve(self, *args)


    def ComputeDeviation(*args) -> "Standard_Real &":
        """
        * Computes the maximal deviation between the two curve representations. dev is an input/output parameter and contains the computed deviation (should be initialized with 0. for the first call). Used by CheckSameParameter().
        	:param CRef:
        	:type CRef: Adaptor3d_Curve
        	:param Other:
        	:type Other: Adaptor3d_Curve
        	:param SameParameter:
        	:type SameParameter: bool
        	:param dev:
        	:type dev: float
        	:param NCONTROL:
        	:type NCONTROL: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_ComputeDeviation(*args)

    ComputeDeviation = staticmethod(ComputeDeviation)

    def Curve3d(self, *args) -> "Standard_Boolean":
        """
        * Returns the 3d curve and bounding parameteres for the edge Returns False if no 3d curve. If <orient> is True (default), takes orientation into account: if the edge is reversed, cf and cl are toggled
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param C3d:
        	:type C3d: Geom_Curve
        	:param cf:
        	:type cf: float
        	:param cl:
        	:type cl: float
        	:param orient: default value is Standard_True
        	:type orient: bool
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_Curve3d(self, *args)


    def FirstVertex(self, *args) -> "TopoDS_Vertex":
        """
        * Returns start vertex of the edge (taking edge orientation into account).
        	:param edge:
        	:type edge: TopoDS_Edge
        	:rtype: TopoDS_Vertex
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_FirstVertex(self, *args)


    def GetEndTangent2d(self, *args) -> "Standard_Boolean":
        """
        :param edge:
        	:type edge: TopoDS_Edge
        	:param face:
        	:type face: TopoDS_Face
        	:param atEnd:
        	:type atEnd: bool
        	:param pos:
        	:type pos: gp_Pnt2d
        	:param tang:
        	:type tang: gp_Vec2d
        	:param dparam: default value is 0.0
        	:type dparam: float
        	:rtype: bool
        * Returns tangent of the edge pcurve at its start (if atEnd is False) or end (if True), regarding the orientation of edge. If edge is REVERSED, tangent is reversed before return. Returns True if pcurve is available and tangent is computed and is not null, else False.
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param surface:
        	:type surface: Geom_Surface
        	:param location:
        	:type location: TopLoc_Location
        	:param atEnd:
        	:type atEnd: bool
        	:param pos:
        	:type pos: gp_Pnt2d
        	:param tang:
        	:type tang: gp_Vec2d
        	:param dparam: default value is 0.0
        	:type dparam: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_GetEndTangent2d(self, *args)


    def HasCurve3d(self, *args) -> "Standard_Boolean":
        """
        * Tells if the edge has a 3d curve
        	:param edge:
        	:type edge: TopoDS_Edge
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_HasCurve3d(self, *args)


    def HasPCurve(self, *args) -> "Standard_Boolean":
        """
        * Tells if the Edge has a pcurve on the face.
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param face:
        	:type face: TopoDS_Face
        	:rtype: bool
        * Tells if the edge has a pcurve on the surface (with location).
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param surface:
        	:type surface: Geom_Surface
        	:param location:
        	:type location: TopLoc_Location
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_HasPCurve(self, *args)


    def IsClosed3d(self, *args) -> "Standard_Boolean":
        """
        * Gives True if the edge has a 3d curve, this curve is closed, and the edge has the same vertex at start and end
        	:param edge:
        	:type edge: TopoDS_Edge
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_IsClosed3d(self, *args)


    def IsSeam(self, *args) -> "Standard_Boolean":
        """
        :param edge:
        	:type edge: TopoDS_Edge
        	:param face:
        	:type face: TopoDS_Face
        	:rtype: bool
        * Returns True if the edge has two pcurves on one surface
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param surface:
        	:type surface: Geom_Surface
        	:param location:
        	:type location: TopLoc_Location
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_IsSeam(self, *args)


    def LastVertex(self, *args) -> "TopoDS_Vertex":
        """
        * Returns end vertex of the edge (taking edge orientation into account).
        	:param edge:
        	:type edge: TopoDS_Edge
        	:rtype: TopoDS_Vertex
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_LastVertex(self, *args)


    def PCurve(self, *args) -> "Standard_Boolean":
        """
        :param edge:
        	:type edge: TopoDS_Edge
        	:param face:
        	:type face: TopoDS_Face
        	:param C2d:
        	:type C2d: Geom2d_Curve
        	:param cf:
        	:type cf: float
        	:param cl:
        	:type cl: float
        	:param orient: default value is Standard_True
        	:type orient: bool
        	:rtype: bool
        * Returns the pcurve and bounding parameteres for the edge lying on the surface. Returns False if the edge has no pcurve on this surface. If <orient> is True (default), takes orientation into account: if the edge is reversed, cf and cl are toggled
        	:param edge:
        	:type edge: TopoDS_Edge
        	:param surface:
        	:type surface: Geom_Surface
        	:param location:
        	:type location: TopLoc_Location
        	:param C2d:
        	:type C2d: Geom2d_Curve
        	:param cf:
        	:type cf: float
        	:param cl:
        	:type cl: float
        	:param orient: default value is Standard_True
        	:type orient: bool
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_PCurve(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor; initialises Status to OK
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_Edge_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_Edge(*args))

    def Status(self, *args) -> "Standard_Boolean":
        """
        * Returns the status (in the form of True/False) of last Check
        	:param status:
        	:type status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_Status(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Edge
ShapeAnalysis_Edge.BoundUV = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_BoundUV, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.CheckCurve3dWithPCurve = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_CheckCurve3dWithPCurve, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.CheckOverlapping = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_CheckOverlapping, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.CheckPCurveRange = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_CheckPCurveRange, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.CheckSameParameter = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_CheckSameParameter, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.CheckVertexTolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_CheckVertexTolerance, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.CheckVerticesWithCurve3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_CheckVerticesWithCurve3d, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.CheckVerticesWithPCurve = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_CheckVerticesWithPCurve, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.Curve3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_Curve3d, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.FirstVertex = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_FirstVertex, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.GetEndTangent2d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_GetEndTangent2d, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.HasCurve3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_HasCurve3d, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.HasPCurve = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_HasPCurve, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.IsClosed3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_IsClosed3d, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.IsSeam = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_IsSeam, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.LastVertex = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_LastVertex, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.PCurve = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_PCurve, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge.Status = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Edge_Status, None, ShapeAnalysis_Edge)
ShapeAnalysis_Edge_swigregister = _ShapeAnalysis.ShapeAnalysis_Edge_swigregister
ShapeAnalysis_Edge_swigregister(ShapeAnalysis_Edge)

def ShapeAnalysis_Edge_ComputeDeviation(*args) -> "Standard_Real &":
    """
    * Computes the maximal deviation between the two curve representations. dev is an input/output parameter and contains the computed deviation (should be initialized with 0. for the first call). Used by CheckSameParameter().
    	:param CRef:
    	:type CRef: Adaptor3d_Curve
    	:param Other:
    	:type Other: Adaptor3d_Curve
    	:param SameParameter:
    	:type SameParameter: bool
    	:param dev:
    	:type dev: float
    	:param NCONTROL:
    	:type NCONTROL: int
    	:rtype: bool
    """
    return _ShapeAnalysis.ShapeAnalysis_Edge_ComputeDeviation(*args)

class ShapeAnalysis_FreeBoundData(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddNotch(self, *args) -> "void":
        """
        * Adds notch on the contour with its maximum width
        	:param notch:
        	:type notch: TopoDS_Wire
        	:param width:
        	:type width: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_AddNotch(self, *args)


    def Area(self, *args) -> "Standard_Real":
        """
        * Returns area of the contour
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Area(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears all properties of the contour. Contour bound itself is not cleared.
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Clear(self, *args)


    def FreeBound(self, *args) -> "TopoDS_Wire":
        """
        * Returns contour
        	:rtype: TopoDS_Wire
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_FreeBound(self, *args)


    def NbNotches(self, *args) -> "Standard_Integer":
        """
        * Returns number of notches on the contour
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_NbNotches(self, *args)


    def Notch(self, *args) -> "TopoDS_Wire":
        """
        * Returns notch on the contour
        	:param index:
        	:type index: int
        	:rtype: TopoDS_Wire
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Notch(self, *args)


    def NotchWidth(self, *args) -> "Standard_Real":
        """
        * Returns maximum width of notch specified by its rank number on the contour
        	:param index:
        	:type index: int
        	:rtype: float
        * Returns maximum width of notch specified as TopoDS_Wire on the contour
        	:param notch:
        	:type notch: TopoDS_Wire
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_NotchWidth(self, *args)


    def Notches(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """
        * Returns sequence of notches on the contour
        	:rtype: opencascade::handle<TopTools_HSequenceOfShape>
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Notches(self, *args)


    def Perimeter(self, *args) -> "Standard_Real":
        """
        * Returns perimeter of the contour
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Perimeter(self, *args)


    def Ratio(self, *args) -> "Standard_Real":
        """
        * Returns ratio of average length to average width of the contour
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Ratio(self, *args)


    def SetArea(self, *args) -> "void":
        """
        * Sets area of the contour
        	:param area:
        	:type area: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetArea(self, *args)


    def SetFreeBound(self, *args) -> "void":
        """
        * Sets contour
        	:param freebound:
        	:type freebound: TopoDS_Wire
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetFreeBound(self, *args)


    def SetPerimeter(self, *args) -> "void":
        """
        * Sets perimeter of the contour
        	:param perimeter:
        	:type perimeter: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetPerimeter(self, *args)


    def SetRatio(self, *args) -> "void":
        """
        * Sets ratio of average length to average width of the contour
        	:param ratio:
        	:type ratio: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetRatio(self, *args)


    def SetWidth(self, *args) -> "void":
        """
        * Sets average width of the contour
        	:param width:
        	:type width: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetWidth(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        * Creates object with contour given in the form of TopoDS_Wire
        	:param freebound:
        	:type freebound: TopoDS_Wire
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_FreeBoundData_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_FreeBoundData(*args))

    def Width(self, *args) -> "Standard_Real":
        """
        * Returns average width of the contour
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Width(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_ShapeAnalysis_FreeBoundData_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_FreeBoundData
ShapeAnalysis_FreeBoundData.AddNotch = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_AddNotch, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.Area = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_Area, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.Clear = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_Clear, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.FreeBound = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_FreeBound, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.NbNotches = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_NbNotches, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.Notch = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_Notch, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.NotchWidth = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_NotchWidth, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.Notches = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_Notches, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.Perimeter = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_Perimeter, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.Ratio = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_Ratio, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.SetArea = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetArea, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.SetFreeBound = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetFreeBound, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.SetPerimeter = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetPerimeter, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.SetRatio = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetRatio, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.SetWidth = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetWidth, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData.Width = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundData_Width, None, ShapeAnalysis_FreeBoundData)
ShapeAnalysis_FreeBoundData_swigregister = _ShapeAnalysis.ShapeAnalysis_FreeBoundData_swigregister
ShapeAnalysis_FreeBoundData_swigregister(ShapeAnalysis_FreeBoundData)

class ShapeAnalysis_FreeBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ConnectEdgesToWires(*args) -> "void":
        """
        * Builds sequnce of <wires> out of sequence of not sorted <edges>. Tries to build wires of maximum length. Building a wire is stopped when no edges can be connected to it at its head or at its tail. //! Orientation of the edge can change when connecting. If <shared> is True connection is performed only when adjacent edges share the same vertex. If <shared> is False connection is performed only when ends of adjacent edges are at distance less than <toler>.
        	:param edges:
        	:type edges: TopTools_HSequenceOfShape
        	:param toler:
        	:type toler: float
        	:param shared:
        	:type shared: bool
        	:param wires:
        	:type wires: TopTools_HSequenceOfShape
        	:rtype: void
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_ConnectEdgesToWires(*args)

    ConnectEdgesToWires = staticmethod(ConnectEdgesToWires)

    def ConnectWiresToWires(*args) -> "void":
        """
        :param iwires:
        	:type iwires: TopTools_HSequenceOfShape
        	:param toler:
        	:type toler: float
        	:param shared:
        	:type shared: bool
        	:param owires:
        	:type owires: TopTools_HSequenceOfShape
        	:rtype: void
        * Builds sequnce of <owires> out of sequence of not sorted <iwires>. Tries to build wires of maximum length. Building a wire is stopped when no wires can be connected to it at its head or at its tail. //! Orientation of the wire can change when connecting. If <shared> is True connection is performed only when adjacent wires share the same vertex. If <shared> is False connection is performed only when ends of adjacent wires are at distance less than <toler>. Map <vertices> stores the correspondence between original end vertices of the wires and new connecting vertices.
        	:param iwires:
        	:type iwires: TopTools_HSequenceOfShape
        	:param toler:
        	:type toler: float
        	:param shared:
        	:type shared: bool
        	:param owires:
        	:type owires: TopTools_HSequenceOfShape
        	:param vertices:
        	:type vertices: TopTools_DataMapOfShapeShape
        	:rtype: void
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_ConnectWiresToWires(*args)

    ConnectWiresToWires = staticmethod(ConnectWiresToWires)

    def DispatchWires(*args) -> "void":
        """
        * Dispatches sequence of <wires> into two compounds <closed> for closed wires and <open> for open wires. If a compound is not empty wires are added into it.
        	:param wires:
        	:type wires: TopTools_HSequenceOfShape
        	:param closed:
        	:type closed: TopoDS_Compound
        	:param open:
        	:type open: TopoDS_Compound
        	:rtype: void
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_DispatchWires(*args)

    DispatchWires = staticmethod(DispatchWires)

    def GetClosedWires(self, *args) -> "TopoDS_Compound const":
        """
        * Returns compound of closed wires out of free edges.
        	:rtype: TopoDS_Compound
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_GetClosedWires(self, *args)


    def GetOpenWires(self, *args) -> "TopoDS_Compound const":
        """
        * Returns compound of open wires out of free edges.
        	:rtype: TopoDS_Compound
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_GetOpenWires(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        * Builds forecasting free bounds of the <shape>. <shape> should be a compound of faces. This constructor is to be used for forecasting free edges with help of sewing analyzer BRepAlgo_Sewing which is called with tolerance <toler>. Free edges are connected into wires only when their ends are at distance less than <toler>. If <splitclosed> is True extracts closed sub-wires out of built closed wires. If <splitopen> is True extracts closed sub-wires out of built open wires.
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param toler:
        	:type toler: float
        	:param splitclosed: default value is Standard_False
        	:type splitclosed: bool
        	:param splitopen: default value is Standard_True
        	:type splitopen: bool
        	:rtype: None
        * Builds actual free bounds of the <shape>. <shape> should be a compound of shells. This constructor is to be used for getting free edges (ones referenced by the only face) with help of analyzer ShapeAnalysis_Shell. Free edges are connected into wires only when they share the same vertex. If <splitclosed> is True extracts closed sub-wires out of built closed wires. If <splitopen> is True extracts closed sub-wires out of built open wires.
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param splitclosed: default value is Standard_False
        	:type splitclosed: bool
        	:param splitopen: default value is Standard_True
        	:type splitopen: bool
        	:param checkinternaledges: default value is Standard_False
        	:type checkinternaledges: bool
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_FreeBounds_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_FreeBounds(*args))

    def SplitWires(*args) -> "void":
        """
        * Extracts closed sub-wires out of <wires> and adds them to <closed>, open wires remained after extraction are put into <open>. If <shared> is True extraction is performed only when edges share the same vertex. If <shared> is False connection is performed only when ends of the edges are at distance less than <toler>.
        	:param wires:
        	:type wires: TopTools_HSequenceOfShape
        	:param toler:
        	:type toler: float
        	:param shared:
        	:type shared: bool
        	:param closed:
        	:type closed: TopTools_HSequenceOfShape
        	:param open:
        	:type open: TopTools_HSequenceOfShape
        	:rtype: void
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_SplitWires(*args)

    SplitWires = staticmethod(SplitWires)

    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_FreeBounds
ShapeAnalysis_FreeBounds.GetClosedWires = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBounds_GetClosedWires, None, ShapeAnalysis_FreeBounds)
ShapeAnalysis_FreeBounds.GetOpenWires = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBounds_GetOpenWires, None, ShapeAnalysis_FreeBounds)
ShapeAnalysis_FreeBounds_swigregister = _ShapeAnalysis.ShapeAnalysis_FreeBounds_swigregister
ShapeAnalysis_FreeBounds_swigregister(ShapeAnalysis_FreeBounds)

def ShapeAnalysis_FreeBounds_ConnectEdgesToWires(*args) -> "void":
    """
    * Builds sequnce of <wires> out of sequence of not sorted <edges>. Tries to build wires of maximum length. Building a wire is stopped when no edges can be connected to it at its head or at its tail. //! Orientation of the edge can change when connecting. If <shared> is True connection is performed only when adjacent edges share the same vertex. If <shared> is False connection is performed only when ends of adjacent edges are at distance less than <toler>.
    	:param edges:
    	:type edges: TopTools_HSequenceOfShape
    	:param toler:
    	:type toler: float
    	:param shared:
    	:type shared: bool
    	:param wires:
    	:type wires: TopTools_HSequenceOfShape
    	:rtype: void
    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBounds_ConnectEdgesToWires(*args)

def ShapeAnalysis_FreeBounds_ConnectWiresToWires(*args) -> "void":
    """
    :param iwires:
    	:type iwires: TopTools_HSequenceOfShape
    	:param toler:
    	:type toler: float
    	:param shared:
    	:type shared: bool
    	:param owires:
    	:type owires: TopTools_HSequenceOfShape
    	:rtype: void
    * Builds sequnce of <owires> out of sequence of not sorted <iwires>. Tries to build wires of maximum length. Building a wire is stopped when no wires can be connected to it at its head or at its tail. //! Orientation of the wire can change when connecting. If <shared> is True connection is performed only when adjacent wires share the same vertex. If <shared> is False connection is performed only when ends of adjacent wires are at distance less than <toler>. Map <vertices> stores the correspondence between original end vertices of the wires and new connecting vertices.
    	:param iwires:
    	:type iwires: TopTools_HSequenceOfShape
    	:param toler:
    	:type toler: float
    	:param shared:
    	:type shared: bool
    	:param owires:
    	:type owires: TopTools_HSequenceOfShape
    	:param vertices:
    	:type vertices: TopTools_DataMapOfShapeShape
    	:rtype: void
    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBounds_ConnectWiresToWires(*args)

def ShapeAnalysis_FreeBounds_DispatchWires(*args) -> "void":
    """
    * Dispatches sequence of <wires> into two compounds <closed> for closed wires and <open> for open wires. If a compound is not empty wires are added into it.
    	:param wires:
    	:type wires: TopTools_HSequenceOfShape
    	:param closed:
    	:type closed: TopoDS_Compound
    	:param open:
    	:type open: TopoDS_Compound
    	:rtype: void
    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBounds_DispatchWires(*args)

def ShapeAnalysis_FreeBounds_SplitWires(*args) -> "void":
    """
    * Extracts closed sub-wires out of <wires> and adds them to <closed>, open wires remained after extraction are put into <open>. If <shared> is True extraction is performed only when edges share the same vertex. If <shared> is False connection is performed only when ends of the edges are at distance less than <toler>.
    	:param wires:
    	:type wires: TopTools_HSequenceOfShape
    	:param toler:
    	:type toler: float
    	:param shared:
    	:type shared: bool
    	:param closed:
    	:type closed: TopTools_HSequenceOfShape
    	:param open:
    	:type open: TopTools_HSequenceOfShape
    	:rtype: void
    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBounds_SplitWires(*args)

class ShapeAnalysis_FreeBoundsProperties(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CheckContours(self, *args) -> "Standard_Boolean":
        """
        :param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_CheckContours(self, *args)


    def CheckNotches(self, *args) -> "Standard_Boolean":
        """
        :param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        :param fbData:
        	:type fbData: ShapeAnalysis_FreeBoundData
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        :param freebound:
        	:type freebound: TopoDS_Wire
        	:param num:
        	:type num: int
        	:param notch:
        	:type notch: TopoDS_Wire
        	:param distMax:
        	:type distMax: float
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_CheckNotches(self, *args)


    def ClosedFreeBound(self, *args) -> "opencascade::handle< ShapeAnalysis_FreeBoundData >":
        """
        * Returns properties of closed free bound specified by its rank number
        	:param index:
        	:type index: int
        	:rtype: opencascade::handle<ShapeAnalysis_FreeBoundData>
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_ClosedFreeBound(self, *args)


    def ClosedFreeBounds(self, *args) -> "opencascade::handle< ShapeAnalysis_HSequenceOfFreeBounds >":
        """
        * Returns all closed free bounds
        	:rtype: opencascade::handle<ShapeAnalysis_HSequenceOfFreeBounds>
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_ClosedFreeBounds(self, *args)


    def DispatchBounds(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_DispatchBounds(self, *args)


    def FillProperties(self, *args) -> "Standard_Boolean":
        """
        :param fbData:
        	:type fbData: ShapeAnalysis_FreeBoundData
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_FillProperties(self, *args)


    def Init(self, *args) -> "void":
        """
        * Initializes the object with given parameters. <shape> should be a compound of faces.
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param tolerance:
        	:type tolerance: float
        	:param splitclosed: default value is Standard_False
        	:type splitclosed: bool
        	:param splitopen: default value is Standard_False
        	:type splitopen: bool
        	:rtype: None
        * Initializes the object with given parameters. <shape> should be a compound of shells.
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param splitclosed: default value is Standard_False
        	:type splitclosed: bool
        	:param splitopen: default value is Standard_False
        	:type splitopen: bool
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Init(self, *args)


    def IsLoaded(self, *args) -> "Standard_Boolean":
        """
        * Returns True if shape is loaded
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_IsLoaded(self, *args)


    def NbClosedFreeBounds(self, *args) -> "Standard_Integer":
        """
        * Returns number of closed free bounds
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_NbClosedFreeBounds(self, *args)


    def NbFreeBounds(self, *args) -> "Standard_Integer":
        """
        * Returns number of free bounds
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_NbFreeBounds(self, *args)


    def NbOpenFreeBounds(self, *args) -> "Standard_Integer":
        """
        * Returns number of open free bounds
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_NbOpenFreeBounds(self, *args)


    def OpenFreeBound(self, *args) -> "opencascade::handle< ShapeAnalysis_FreeBoundData >":
        """
        * Returns properties of open free bound specified by its rank number
        	:param index:
        	:type index: int
        	:rtype: opencascade::handle<ShapeAnalysis_FreeBoundData>
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_OpenFreeBound(self, *args)


    def OpenFreeBounds(self, *args) -> "opencascade::handle< ShapeAnalysis_HSequenceOfFreeBounds >":
        """
        * Returns all open free bounds
        	:rtype: opencascade::handle<ShapeAnalysis_HSequenceOfFreeBounds>
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_OpenFreeBounds(self, *args)


    def Perform(self, *args) -> "Standard_Boolean":
        """
        * Builds and analyzes free bounds of the shape. First calls ShapeAnalysis_FreeBounds for building free bounds. Then on each free bound computes its properties: - area of the contour, - perimeter of the contour, - ratio of average length to average width of the contour, - average width of contour, - notches on the contour and for each notch - maximum width of the notch.
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Perform(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape":
        """
        * Returns shape
        	:rtype: TopoDS_Shape
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Shape(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        * Creates the object and calls corresponding Init. <shape> should be a compound of faces.
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param tolerance:
        	:type tolerance: float
        	:param splitclosed: default value is Standard_False
        	:type splitclosed: bool
        	:param splitopen: default value is Standard_False
        	:type splitopen: bool
        	:rtype: None
        * Creates the object and calls corresponding Init. <shape> should be a compound of shells.
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param splitclosed: default value is Standard_False
        	:type splitclosed: bool
        	:param splitopen: default value is Standard_False
        	:type splitopen: bool
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_FreeBoundsProperties(*args))

    def Tolerance(self, *args) -> "Standard_Real":
        """
        * Returns tolerance
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Tolerance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_FreeBoundsProperties
ShapeAnalysis_FreeBoundsProperties.CheckContours = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_CheckContours, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.CheckNotches = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_CheckNotches, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.ClosedFreeBound = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_ClosedFreeBound, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.ClosedFreeBounds = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_ClosedFreeBounds, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.DispatchBounds = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_DispatchBounds, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.FillProperties = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_FillProperties, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.Init = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Init, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.IsLoaded = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_IsLoaded, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.NbClosedFreeBounds = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_NbClosedFreeBounds, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.NbFreeBounds = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_NbFreeBounds, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.NbOpenFreeBounds = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_NbOpenFreeBounds, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.OpenFreeBound = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_OpenFreeBound, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.OpenFreeBounds = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_OpenFreeBounds, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.Perform = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Perform, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.Shape = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Shape, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties.Tolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Tolerance, None, ShapeAnalysis_FreeBoundsProperties)
ShapeAnalysis_FreeBoundsProperties_swigregister = _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_swigregister
ShapeAnalysis_FreeBoundsProperties_swigregister(ShapeAnalysis_FreeBoundsProperties)

class ShapeAnalysis_Geom(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NearestPlane(*args) -> "Standard_Real &":
        """
        * Builds a plane out of a set of points in array Returns in <dmax> the maximal distance between the produced plane and given points
        	:param Pnts:
        	:type Pnts: TColgp_Array1OfPnt
        	:param aPln:
        	:type aPln: gp_Pln
        	:param Dmax:
        	:type Dmax: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Geom_NearestPlane(*args)

    NearestPlane = staticmethod(NearestPlane)

    def PositionTrsf(*args) -> "Standard_Boolean":
        """
        * Builds transfromation object out of matrix. Matrix must be 3 x 4. Unit is used as multiplier.
        	:param coefs:
        	:type coefs: TColStd_HArray2OfReal
        	:param trsf:
        	:type trsf: gp_Trsf
        	:param unit:
        	:type unit: float
        	:param prec:
        	:type prec: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Geom_PositionTrsf(*args)

    PositionTrsf = staticmethod(PositionTrsf)

    __repr__ = _dumps_object


    def __init__(self):
        _ShapeAnalysis.ShapeAnalysis_Geom_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_Geom())
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Geom
ShapeAnalysis_Geom_swigregister = _ShapeAnalysis.ShapeAnalysis_Geom_swigregister
ShapeAnalysis_Geom_swigregister(ShapeAnalysis_Geom)

def ShapeAnalysis_Geom_NearestPlane(*args) -> "Standard_Real &":
    """
    * Builds a plane out of a set of points in array Returns in <dmax> the maximal distance between the produced plane and given points
    	:param Pnts:
    	:type Pnts: TColgp_Array1OfPnt
    	:param aPln:
    	:type aPln: gp_Pln
    	:param Dmax:
    	:type Dmax: float
    	:rtype: bool
    """
    return _ShapeAnalysis.ShapeAnalysis_Geom_NearestPlane(*args)

def ShapeAnalysis_Geom_PositionTrsf(*args) -> "Standard_Boolean":
    """
    * Builds transfromation object out of matrix. Matrix must be 3 x 4. Unit is used as multiplier.
    	:param coefs:
    	:type coefs: TColStd_HArray2OfReal
    	:param trsf:
    	:type trsf: gp_Trsf
    	:param unit:
    	:type unit: float
    	:param prec:
    	:type prec: float
    	:rtype: bool
    """
    return _ShapeAnalysis.ShapeAnalysis_Geom_PositionTrsf(*args)

class ShapeAnalysis_ShapeContents(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BigSplineSec(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """:rtype: opencascade::handle<TopTools_HSequenceOfShape>"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_BigSplineSec(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears all accumulated statictics
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_Clear(self, *args)


    def ClearFlags(self, *args) -> "void":
        """
        * Clears all flags
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_ClearFlags(self, *args)


    def IndirectSec(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """:rtype: opencascade::handle<TopTools_HSequenceOfShape>"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_IndirectSec(self, *args)


    def GetModifyBigSplineMode(self) -> "Standard_Boolean":
        """GetModifyBigSplineMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyBigSplineMode(self)


    def SetModifyBigSplineMode(self, value: 'Standard_Boolean') -> "void":
        """SetModifyBigSplineMode(ShapeAnalysis_ShapeContents self, Standard_Boolean value)"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyBigSplineMode(self, value)


    def GetModifyIndirectMode(self) -> "Standard_Boolean":
        """GetModifyIndirectMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyIndirectMode(self)


    def SetModifyIndirectMode(self, value: 'Standard_Boolean') -> "void":
        """SetModifyIndirectMode(ShapeAnalysis_ShapeContents self, Standard_Boolean value)"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyIndirectMode(self, value)


    def GetModifyOffestSurfaceMode(self) -> "Standard_Boolean":
        """GetModifyOffestSurfaceMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyOffestSurfaceMode(self)


    def SetModifyOffestSurfaceMode(self, value: 'Standard_Boolean') -> "void":
        """SetModifyOffestSurfaceMode(ShapeAnalysis_ShapeContents self, Standard_Boolean value)"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyOffestSurfaceMode(self, value)


    def GetModifyOffsetCurveMode(self) -> "Standard_Boolean":
        """GetModifyOffsetCurveMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyOffsetCurveMode(self)


    def SetModifyOffsetCurveMode(self, value: 'Standard_Boolean') -> "void":
        """SetModifyOffsetCurveMode(ShapeAnalysis_ShapeContents self, Standard_Boolean value)"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyOffsetCurveMode(self, value)


    def GetModifyTrimmed2dMode(self) -> "Standard_Boolean":
        """GetModifyTrimmed2dMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyTrimmed2dMode(self)


    def SetModifyTrimmed2dMode(self, value: 'Standard_Boolean') -> "void":
        """SetModifyTrimmed2dMode(ShapeAnalysis_ShapeContents self, Standard_Boolean value)"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyTrimmed2dMode(self, value)


    def GetModifyTrimmed3dMode(self) -> "Standard_Boolean":
        """GetModifyTrimmed3dMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyTrimmed3dMode(self)


    def SetModifyTrimmed3dMode(self, value: 'Standard_Boolean') -> "void":
        """SetModifyTrimmed3dMode(ShapeAnalysis_ShapeContents self, Standard_Boolean value)"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyTrimmed3dMode(self, value)


    def NbBSplibeSurf(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbBSplibeSurf(self, *args)


    def NbBezierSurf(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbBezierSurf(self, *args)


    def NbBigSplines(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbBigSplines(self, *args)


    def NbC0Curves(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbC0Curves(self, *args)


    def NbC0Surfaces(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbC0Surfaces(self, *args)


    def NbEdges(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbEdges(self, *args)


    def NbFaceWithSevWires(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFaceWithSevWires(self, *args)


    def NbFaces(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFaces(self, *args)


    def NbFreeEdges(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFreeEdges(self, *args)


    def NbFreeFaces(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFreeFaces(self, *args)


    def NbFreeWires(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFreeWires(self, *args)


    def NbIndirectSurf(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbIndirectSurf(self, *args)


    def NbNoPCurve(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbNoPCurve(self, *args)


    def NbOffsetCurves(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbOffsetCurves(self, *args)


    def NbOffsetSurf(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbOffsetSurf(self, *args)


    def NbSharedEdges(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedEdges(self, *args)


    def NbSharedFaces(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedFaces(self, *args)


    def NbSharedFreeEdges(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedFreeEdges(self, *args)


    def NbSharedFreeWires(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedFreeWires(self, *args)


    def NbSharedShells(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedShells(self, *args)


    def NbSharedSolids(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedSolids(self, *args)


    def NbSharedVertices(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedVertices(self, *args)


    def NbSharedWires(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedWires(self, *args)


    def NbShells(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbShells(self, *args)


    def NbSolids(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSolids(self, *args)


    def NbSolidsWithVoids(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSolidsWithVoids(self, *args)


    def NbTrimSurf(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbTrimSurf(self, *args)


    def NbTrimmedCurve2d(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbTrimmedCurve2d(self, *args)


    def NbTrimmedCurve3d(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbTrimmedCurve3d(self, *args)


    def NbVertices(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbVertices(self, *args)


    def NbWireWithSevSeams(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbWireWithSevSeams(self, *args)


    def NbWireWitnSeam(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbWireWitnSeam(self, *args)


    def NbWires(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbWires(self, *args)


    def OffsetCurveSec(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """:rtype: opencascade::handle<TopTools_HSequenceOfShape>"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_OffsetCurveSec(self, *args)


    def OffsetSurfaceSec(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """:rtype: opencascade::handle<TopTools_HSequenceOfShape>"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_OffsetSurfaceSec(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Counts quantities of sun-shapes in shape and stores sub-shapes according to flags
        	:param shape:
        	:type shape: TopoDS_Shape
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_Perform(self, *args)


    def __init__(self, *args):
        """
        * Initialize fields and call ClearFlags()
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_ShapeContents_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_ShapeContents(*args))

    def Trimmed2dSec(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """:rtype: opencascade::handle<TopTools_HSequenceOfShape>"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_Trimmed2dSec(self, *args)


    def Trimmed3dSec(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """:rtype: opencascade::handle<TopTools_HSequenceOfShape>"""
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_Trimmed3dSec(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_ShapeContents
ShapeAnalysis_ShapeContents.BigSplineSec = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_BigSplineSec, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.Clear = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_Clear, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.ClearFlags = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_ClearFlags, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.IndirectSec = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_IndirectSec, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.GetModifyBigSplineMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyBigSplineMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.SetModifyBigSplineMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyBigSplineMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.GetModifyIndirectMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyIndirectMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.SetModifyIndirectMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyIndirectMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.GetModifyOffestSurfaceMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyOffestSurfaceMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.SetModifyOffestSurfaceMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyOffestSurfaceMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.GetModifyOffsetCurveMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyOffsetCurveMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.SetModifyOffsetCurveMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyOffsetCurveMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.GetModifyTrimmed2dMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyTrimmed2dMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.SetModifyTrimmed2dMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyTrimmed2dMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.GetModifyTrimmed3dMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_GetModifyTrimmed3dMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.SetModifyTrimmed3dMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_SetModifyTrimmed3dMode, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbBSplibeSurf = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbBSplibeSurf, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbBezierSurf = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbBezierSurf, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbBigSplines = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbBigSplines, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbC0Curves = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbC0Curves, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbC0Surfaces = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbC0Surfaces, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbEdges, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbFaceWithSevWires = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFaceWithSevWires, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbFaces = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFaces, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbFreeEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFreeEdges, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbFreeFaces = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFreeFaces, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbFreeWires = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFreeWires, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbIndirectSurf = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbIndirectSurf, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbNoPCurve = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbNoPCurve, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbOffsetCurves = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbOffsetCurves, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbOffsetSurf = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbOffsetSurf, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSharedEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedEdges, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSharedFaces = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedFaces, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSharedFreeEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedFreeEdges, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSharedFreeWires = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedFreeWires, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSharedShells = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedShells, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSharedSolids = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedSolids, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSharedVertices = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedVertices, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSharedWires = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedWires, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbShells = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbShells, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSolids = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSolids, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbSolidsWithVoids = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSolidsWithVoids, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbTrimSurf = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbTrimSurf, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbTrimmedCurve2d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbTrimmedCurve2d, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbTrimmedCurve3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbTrimmedCurve3d, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbVertices = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbVertices, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbWireWithSevSeams = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbWireWithSevSeams, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbWireWitnSeam = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbWireWitnSeam, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.NbWires = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_NbWires, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.OffsetCurveSec = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_OffsetCurveSec, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.OffsetSurfaceSec = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_OffsetSurfaceSec, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.Perform = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_Perform, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.Trimmed2dSec = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_Trimmed2dSec, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents.Trimmed3dSec = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeContents_Trimmed3dSec, None, ShapeAnalysis_ShapeContents)
ShapeAnalysis_ShapeContents_swigregister = _ShapeAnalysis.ShapeAnalysis_ShapeContents_swigregister
ShapeAnalysis_ShapeContents_swigregister(ShapeAnalysis_ShapeContents)

class ShapeAnalysis_ShapeTolerance(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddTolerance(self, *args) -> "void":
        """
        * Adds data on new Shape to compute Cumulated Tolerance (prepares three computations : maximal, average, minimal)
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param type: default value is TopAbs_SHAPE
        	:type type: TopAbs_ShapeEnum
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_AddTolerance(self, *args)


    def GlobalTolerance(self, *args) -> "Standard_Real":
        """
        * Returns the computed tolerance according to the <mode> <mode> = 0 : average <mode> > 0 : maximal <mode> < 0 : minimal
        	:param mode:
        	:type mode: int
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_GlobalTolerance(self, *args)


    def InTolerance(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """
        * Determines which shapes have a tolerance within a given interval <type> is interpreted as in the method Tolerance
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param valmin:
        	:type valmin: float
        	:param valmax:
        	:type valmax: float
        	:param type: default value is TopAbs_SHAPE
        	:type type: TopAbs_ShapeEnum
        	:rtype: opencascade::handle<TopTools_HSequenceOfShape>
        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_InTolerance(self, *args)


    def InitTolerance(self, *args) -> "void":
        """
        * Initializes computation of cumulated tolerance
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_InitTolerance(self, *args)


    def OverTolerance(self, *args) -> "opencascade::handle< TopTools_HSequenceOfShape >":
        """
        * Determines which shapes have a tolerance over the given value <type> is interpreted as in the method Tolerance
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param value:
        	:type value: float
        	:param type: default value is TopAbs_SHAPE
        	:type type: TopAbs_ShapeEnum
        	:rtype: opencascade::handle<TopTools_HSequenceOfShape>
        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_OverTolerance(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_ShapeTolerance(*args))

    def Tolerance(self, *args) -> "Standard_Real":
        """
        * Determines a tolerance from the ones stored in a shape Remark : calls InitTolerance and AddTolerance, hence, can be used to start a series for cumulating tolerance <mode> = 0 : returns the average value between sub-shapes, <mode> > 0 : returns the maximal found, <mode> < 0 : returns the minimal found. <type> defines what kinds of sub-shapes to consider: SHAPE (default) : all : VERTEX, EDGE, FACE, VERTEX : only vertices, EDGE : only edges, FACE : only faces, SHELL : combined SHELL + FACE, for each face (and containing shell), also checks EDGE and VERTEX
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param mode:
        	:type mode: int
        	:param type: default value is TopAbs_SHAPE
        	:type type: TopAbs_ShapeEnum
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_Tolerance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_ShapeTolerance
ShapeAnalysis_ShapeTolerance.AddTolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeTolerance_AddTolerance, None, ShapeAnalysis_ShapeTolerance)
ShapeAnalysis_ShapeTolerance.GlobalTolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeTolerance_GlobalTolerance, None, ShapeAnalysis_ShapeTolerance)
ShapeAnalysis_ShapeTolerance.InTolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeTolerance_InTolerance, None, ShapeAnalysis_ShapeTolerance)
ShapeAnalysis_ShapeTolerance.InitTolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeTolerance_InitTolerance, None, ShapeAnalysis_ShapeTolerance)
ShapeAnalysis_ShapeTolerance.OverTolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeTolerance_OverTolerance, None, ShapeAnalysis_ShapeTolerance)
ShapeAnalysis_ShapeTolerance.Tolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_ShapeTolerance_Tolerance, None, ShapeAnalysis_ShapeTolerance)
ShapeAnalysis_ShapeTolerance_swigregister = _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_swigregister
ShapeAnalysis_ShapeTolerance_swigregister(ShapeAnalysis_ShapeTolerance)

class ShapeAnalysis_Shell(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BadEdges(self, *args) -> "TopoDS_Compound":
        """
        * Returns the list of bad edges as a Compound It is empty (not null) if no edge are recorded as bad
        	:rtype: TopoDS_Compound
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_BadEdges(self, *args)


    def CheckOrientedShells(self, *args) -> "Standard_Boolean":
        """
        * Checks if shells fulfill orientation condition, i.e. if each edge is, either present once (free edge) or twice (connected edge) but with different orientations (FORWARD/REVERSED) Edges which do not fulfill these conditions are bad //! If <alsofree> is True free edges are considered. Free edges can be queried but are not bad
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param alsofree: default value is Standard_False
        	:type alsofree: bool
        	:param checkinternaledges: default value is Standard_False
        	:type checkinternaledges: bool
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_CheckOrientedShells(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears data about loaded shells and performed checks
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_Clear(self, *args)


    def FreeEdges(self, *args) -> "TopoDS_Compound":
        """
        * Returns the list of free (not connected) edges as a Compound It is empty (not null) if no edge are recorded as free
        	:rtype: TopoDS_Compound
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_FreeEdges(self, *args)


    def HasBadEdges(self, *args) -> "Standard_Boolean":
        """
        * Tells if at least one edge is recorded as bad
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_HasBadEdges(self, *args)


    def HasConnectedEdges(self, *args) -> "Standard_Boolean":
        """
        * Tells if at least one edge is connected (shared twice or more)
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_HasConnectedEdges(self, *args)


    def HasFreeEdges(self, *args) -> "Standard_Boolean":
        """
        * Tells if at least one edge is recorded as free (not connected)
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_HasFreeEdges(self, *args)


    def IsLoaded(self, *args) -> "Standard_Boolean":
        """
        * Tells if a shape is loaded (only shells are checked)
        	:param shape:
        	:type shape: TopoDS_Shape
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_IsLoaded(self, *args)


    def LoadShells(self, *args) -> "void":
        """
        * Adds shells contained in the <shape> to the list of loaded shells
        	:param shape:
        	:type shape: TopoDS_Shape
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_LoadShells(self, *args)


    def Loaded(self, *args) -> "TopoDS_Shape":
        """
        * Returns a loaded shape specified by its rank number. Returns null shape if <num> is out of range
        	:param num:
        	:type num: int
        	:rtype: TopoDS_Shape
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_Loaded(self, *args)


    def NbLoaded(self, *args) -> "Standard_Integer":
        """
        * Returns the actual number of loaded shapes (i.e. shells)
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_NbLoaded(self, *args)


    __repr__ = _dumps_object


    def __init__(self):
        _ShapeAnalysis.ShapeAnalysis_Shell_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_Shell())
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Shell
ShapeAnalysis_Shell.BadEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_BadEdges, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.CheckOrientedShells = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_CheckOrientedShells, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.Clear = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_Clear, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.FreeEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_FreeEdges, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.HasBadEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_HasBadEdges, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.HasConnectedEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_HasConnectedEdges, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.HasFreeEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_HasFreeEdges, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.IsLoaded = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_IsLoaded, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.LoadShells = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_LoadShells, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.Loaded = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_Loaded, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell.NbLoaded = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Shell_NbLoaded, None, ShapeAnalysis_Shell)
ShapeAnalysis_Shell_swigregister = _ShapeAnalysis.ShapeAnalysis_Shell_swigregister
ShapeAnalysis_Shell_swigregister(ShapeAnalysis_Shell)

class ShapeAnalysis_Surface(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Adaptor3d(self, *args) -> "opencascade::handle< GeomAdaptor_HSurface > const &":
        """
        * Returns the Adaptor. Creates it if not yet done.
        	:rtype: opencascade::handle<GeomAdaptor_HSurface>
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Adaptor3d(self, *args)


    def Bounds(self, *args) -> "void":
        """
        * Returns the bounds of the surface (from Bounds from Surface, but buffered)
        	:param ufirst:
        	:type ufirst: float
        	:param ulast:
        	:type ulast: float
        	:param vfirst:
        	:type vfirst: float
        	:param vlast:
        	:type vlast: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Bounds(self, *args)


    def ComputeBoundIsos(self, *args) -> "void":
        """
        * Computes bound isos (protected against exceptions)
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_ComputeBoundIsos(self, *args)


    def DegeneratedValues(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there is at least one surface iso-line which is considered as degenerated with <preci> and distance between P3d and corresponding singular point is less than <preci> (like IsDegenerated). Returns characteristics of the first found boundary matching those criteria.
        	:param P3d:
        	:type P3d: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param firstP2d:
        	:type firstP2d: gp_Pnt2d
        	:param lastP2d:
        	:type lastP2d: gp_Pnt2d
        	:param firstpar:
        	:type firstpar: float
        	:param lastpar:
        	:type lastpar: float
        	:param forward: default value is Standard_True
        	:type forward: bool
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_DegeneratedValues(self, *args)


    def Gap(self, *args) -> "Standard_Real":
        """
        * Returns 3D distance found by one of the following methods. IsDegenerated, DegeneratedValues, ProjectDegenerated (distance between 3D point and found or last (if not found) singularity), IsUClosed, IsVClosed (minimum value of precision to consider the surface to be closed), ValueOfUV (distance between 3D point and found solution).
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Gap(self, *args)


    def GetBoxUF(self, *args) -> "Bnd_Box const &":
        """:rtype: Bnd_Box"""
        return _ShapeAnalysis.ShapeAnalysis_Surface_GetBoxUF(self, *args)


    def GetBoxUL(self, *args) -> "Bnd_Box const &":
        """:rtype: Bnd_Box"""
        return _ShapeAnalysis.ShapeAnalysis_Surface_GetBoxUL(self, *args)


    def GetBoxVF(self, *args) -> "Bnd_Box const &":
        """:rtype: Bnd_Box"""
        return _ShapeAnalysis.ShapeAnalysis_Surface_GetBoxVF(self, *args)


    def GetBoxVL(self, *args) -> "Bnd_Box const &":
        """:rtype: Bnd_Box"""
        return _ShapeAnalysis.ShapeAnalysis_Surface_GetBoxVL(self, *args)


    def HasSingularities(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the surface has singularities for the given precision (i.e. if there are surface singularities with sizes not greater than precision).
        	:param preci:
        	:type preci: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_HasSingularities(self, *args)


    def Init(self, *args) -> "void":
        """
        * Loads existing surface
        	:param S:
        	:type S: Geom_Surface
        	:rtype: None
        * Reads all the data from another Surface, without recomputing
        	:param other:
        	:type other: ShapeAnalysis_Surface
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Init(self, *args)


    def IsDegenerated(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there is at least one surface boundary which is considered as degenerated with <preci> and distance between P3d and corresponding singular point is less than <preci>
        	:param P3d:
        	:type P3d: gp_Pnt
        	:param preci:
        	:type preci: float
        	:rtype: bool
        * Returns True if straight pcurve going from point p2d1 to p2d2 is degenerate, i.e. lies in the singularity of the surface. NOTE: it uses another method of detecting singularity than used by ComputeSingularities() et al.! For that, maximums of distances between points p2d1, p2d2 and 0.5*(p2d1+p2d2) and between corresponding 3d points are computed. The pcurve (p2d1, p2d2) is considered as degenerate if: - max distance in 3d is less than <tol> - max distance in 2d is at least <ratio> times greather than the Resolution computed from max distance in 3d (max3d < tol && max2d > ratio * Resolution(max3d)) NOTE: <ratio> should be >1 (e.g. 10)
        	:param p2d1:
        	:type p2d1: gp_Pnt2d
        	:param p2d2:
        	:type p2d2: gp_Pnt2d
        	:param tol:
        	:type tol: float
        	:param ratio:
        	:type ratio: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_IsDegenerated(self, *args)


    def IsUClosed(self, *args) -> "Standard_Boolean":
        """
        * Tells if the Surface is spatially closed in U with given precision. If <preci> < 0 then Precision::Confusion is used. If Geom_Surface says that the surface is U-closed, this method also says this. Otherwise additional analysis is performed, comparing given precision with the following distances: - periodic B-Splines are closed, - polinomial B-Spline with boundary multiplicities degree+1 and Bezier - maximum distance between poles, - rational B-Spline or one with boundary multiplicities not degree+1 - maximum distance computed at knots and their middles, - surface of extrusion - distance between ends of basis curve, - other (RectangularTrimmed and Offset) - maximum distance computed at 100 equi-distanted points.
        	:param preci: default value is -1
        	:type preci: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_IsUClosed(self, *args)


    def IsVClosed(self, *args) -> "Standard_Boolean":
        """
        * Tells if the Surface is spatially closed in V with given precision. If <preci> < 0 then Precision::Confusion is used. If Geom_Surface says that the surface is V-closed, this method also says this. Otherwise additional analysis is performed, comparing given precision with the following distances: - periodic B-Splines are closed, - polinomial B-Spline with boundary multiplicities degree+1 and Bezier - maximum distance between poles, - rational B-Spline or one with boundary multiplicities not degree+1 - maximum distance computed at knots and their middles, - surface of revolution - distance between ends of basis curve, - other (RectangularTrimmed and Offset) - maximum distance computed at 100 equi-distanted points.
        	:param preci: default value is -1
        	:type preci: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_IsVClosed(self, *args)


    def NbSingularities(self, *args) -> "Standard_Integer":
        """
        * Returns the number of singularities for the given precision (i.e. number of surface singularities with sizes not greater than precision).
        	:param preci:
        	:type preci: float
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_NbSingularities(self, *args)


    def NextValueOfUV(self, *args) -> "gp_Pnt2d":
        """
        * Projects a point P3D on the surface. Does the same thing as ValueOfUV but tries to optimize computations by taking into account previous point <p2dPrev>: makes a step by UV and tries Newton algorithm. If <maxpreci> >0. and distance between solution and P3D is greater than <maxpreci>, that solution is considered as bad, and ValueOfUV() is used. If not succeded, calls ValueOfUV()
        	:param p2dPrev:
        	:type p2dPrev: gp_Pnt2d
        	:param P3D:
        	:type P3D: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param maxpreci: default value is -1.0
        	:type maxpreci: float
        	:rtype: gp_Pnt2d
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_NextValueOfUV(self, *args)


    def ProjectDegenerated(self, *args) -> "Standard_Boolean":
        """
        * Projects a point <P3d> on a singularity by computing one of the coordinates of preliminary computed <result>. //! Finds the iso-line which is considered as degenerated with <preci> and a. distance between P3d and corresponding singular point is less than <preci> (like IsDegenerated) or b. difference between already computed <result>'s coordinate and iso-coordinate of the boundary is less than 2D resolution (computed from <preci> by Geom_Adaptor). Then sets not yet computed <result>'s coordinate taking it from <neighbour> and returns True.
        	:param P3d:
        	:type P3d: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param neighbour:
        	:type neighbour: gp_Pnt2d
        	:param result:
        	:type result: gp_Pnt2d
        	:rtype: bool
        * Checks points at the beginning (direct is True) or end (direct is False) of array <points> to lie in singularity of surface, and if yes, adjusts the indeterminate 2d coordinate of these points by nearest point which is not in singularity. Returns True if some points were adjusted.
        	:param nbrPnt:
        	:type nbrPnt: int
        	:param points:
        	:type points: TColgp_SequenceOfPnt
        	:param pnt2d:
        	:type pnt2d: TColgp_SequenceOfPnt2d
        	:param preci:
        	:type preci: float
        	:param direct:
        	:type direct: bool
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_ProjectDegenerated(self, *args)


    def SetDomain(self, *args) -> "void":
        """
        :param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_SetDomain(self, *args)


    def __init__(self, *args):
        """
        * Creates an analyzer object on the basis of existing surface
        	:param S:
        	:type S: Geom_Surface
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_Surface_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_Surface(*args))

    def Singularity(self, *args) -> "Standard_Boolean":
        """
        * Returns the characteristics of the singularity specified by its rank number <num>. That means, that it is not neccessary for <num> to be in the range [1, NbSingularities] but must be not greater than possible (see ComputeSingularities). The returned characteristics are: preci: the smallest precision with which the iso-line is considered as degenerated, P3d: 3D point of singularity (middle point of the surface iso-line), firstP2d and lastP2d: first and last 2D points of the iso-line in parametrical surface, firstpar and lastpar: first and last parameters of the iso-line in parametrical surface, uisodeg: if the degenerated iso-line is U-iso (True) or V-iso (False). Returns False if <num> is out of range, else returns True.
        	:param num:
        	:type num: int
        	:param preci:
        	:type preci: float
        	:param P3d:
        	:type P3d: gp_Pnt
        	:param firstP2d:
        	:type firstP2d: gp_Pnt2d
        	:param lastP2d:
        	:type lastP2d: gp_Pnt2d
        	:param firstpar:
        	:type firstpar: float
        	:param lastpar:
        	:type lastpar: float
        	:param uisodeg:
        	:type uisodeg: bool
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Singularity(self, *args)


    def Surface(self, *args) -> "opencascade::handle< Geom_Surface > const &":
        """
        * Returns a surface being analyzed
        	:rtype: opencascade::handle<Geom_Surface>
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Surface(self, *args)


    def TrueAdaptor3d(self, *args) -> "opencascade::handle< GeomAdaptor_HSurface > const &":
        """
        * Returns the Adaptor (may be Null if method Adaptor() was not called)
        	:rtype: opencascade::handle<GeomAdaptor_HSurface>
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_TrueAdaptor3d(self, *args)


    def UCloseVal(self, *args) -> "Standard_Real":
        """
        * Returns minimum value to consider the surface as U-closed
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_UCloseVal(self, *args)


    def UIso(self, *args) -> "opencascade::handle< Geom_Curve >":
        """
        * Returns a U-Iso. Null if not possible or failed Remark : bound isos are buffered
        	:param U:
        	:type U: float
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_UIso(self, *args)


    def UVFromIso(self, *args) -> "Standard_Real":
        """
        * Tries a refinement of an already computed couple (U,V) by using projecting 3D point on iso-lines: 1. boundaries of the surface, 2. iso-lines passing through (U,V) 3. iteratively received iso-lines passing through new U and new V (number of iterations is limited by 5 in each direction) Returns the best resulting distance between P3D and Value(U,V) in the case of success. Else, returns a very great value
        	:param P3D:
        	:type P3D: gp_Pnt
        	:param preci:
        	:type preci: float
        	:param U:
        	:type U: float
        	:param V:
        	:type V: float
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_UVFromIso(self, *args)


    def VCloseVal(self, *args) -> "Standard_Real":
        """
        * Returns minimum value to consider the surface as V-closed
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_VCloseVal(self, *args)


    def VIso(self, *args) -> "opencascade::handle< Geom_Curve >":
        """
        * Returns a V-Iso. Null if not possible or failed Remark : bound isos are buffered
        	:param V:
        	:type V: float
        	:rtype: opencascade::handle<Geom_Curve>
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_VIso(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        * Returns a 3D point specified by parameters in surface parametrical space
        	:param u:
        	:type u: float
        	:param v:
        	:type v: float
        	:rtype: gp_Pnt
        * Returns a 3d point specified by a point in surface parametrical space
        	:param p2d:
        	:type p2d: gp_Pnt2d
        	:rtype: gp_Pnt
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Value(self, *args)


    def ValueOfUV(self, *args) -> "gp_Pnt2d":
        """
        * Computes the parameters in the surface parametrical space of 3D point. The result is parameters of the point projected onto the surface. This method enhances functionality provided by the standard tool GeomAPI_ProjectPointOnSurface by treatment of cases when the projected point is near to the surface boundaries and when this standard tool fails.
        	:param P3D:
        	:type P3D: gp_Pnt
        	:param preci:
        	:type preci: float
        	:rtype: gp_Pnt2d
        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_ValueOfUV(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_ShapeAnalysis_Surface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Surface
ShapeAnalysis_Surface.Adaptor3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_Adaptor3d, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.Bounds = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_Bounds, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.ComputeBoundIsos = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_ComputeBoundIsos, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.DegeneratedValues = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_DegeneratedValues, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.Gap = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_Gap, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.GetBoxUF = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_GetBoxUF, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.GetBoxUL = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_GetBoxUL, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.GetBoxVF = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_GetBoxVF, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.GetBoxVL = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_GetBoxVL, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.HasSingularities = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_HasSingularities, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.Init = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_Init, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.IsDegenerated = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_IsDegenerated, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.IsUClosed = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_IsUClosed, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.IsVClosed = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_IsVClosed, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.NbSingularities = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_NbSingularities, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.NextValueOfUV = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_NextValueOfUV, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.ProjectDegenerated = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_ProjectDegenerated, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.SetDomain = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_SetDomain, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.Singularity = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_Singularity, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.Surface = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_Surface, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.TrueAdaptor3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_TrueAdaptor3d, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.UCloseVal = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_UCloseVal, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.UIso = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_UIso, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.UVFromIso = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_UVFromIso, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.VCloseVal = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_VCloseVal, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.VIso = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_VIso, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.Value = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_Value, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface.ValueOfUV = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Surface_ValueOfUV, None, ShapeAnalysis_Surface)
ShapeAnalysis_Surface_swigregister = _ShapeAnalysis.ShapeAnalysis_Surface_swigregister
ShapeAnalysis_Surface_swigregister(ShapeAnalysis_Surface)

class ShapeAnalysis_TransferParameters(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args) -> "void":
        """
        * Initialize a tool with edge and face
        	:param E:
        	:type E: TopoDS_Edge
        	:param F:
        	:type F: TopoDS_Face
        	:rtype: void
        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_Init(self, *args)


    def IsSameRange(self, *args) -> "Standard_Boolean":
        """
        * Returns True if 3d curve of edge and pcurve are SameRange (in default implementation, if myScale == 1 and myShift == 0)
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_IsSameRange(self, *args)


    def Perform(self, *args) -> "Standard_Real":
        """
        * Transfers parameters given by sequence Params from 3d curve to pcurve (if To2d is True) or back (if To2d is False)
        	:param Params:
        	:type Params: TColStd_HSequenceOfReal
        	:param To2d:
        	:type To2d: bool
        	:rtype: opencascade::handle<TColStd_HSequenceOfReal>
        * Transfers parameter given by sequence Params from 3d curve to pcurve (if To2d is True) or back (if To2d is False)
        	:param Param:
        	:type Param: float
        	:param To2d:
        	:type To2d: bool
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_Perform(self, *args)


    def SetMaxTolerance(self, *args) -> "void":
        """
        * Sets maximal tolerance to use linear recomputation of parameters.
        	:param maxtol:
        	:type maxtol: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_SetMaxTolerance(self, *args)


    def __init__(self, *args):
        """
        * Creates empty tool with myShift = 0 and myScale = 1
        	:rtype: None
        * Creates a tool and initializes it with edge and face
        	:param E:
        	:type E: TopoDS_Edge
        	:param F:
        	:type F: TopoDS_Face
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_TransferParameters_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_TransferParameters(*args))

    def TransferRange(self, *args) -> "void":
        """
        * Recomputes range of curves from NewEdge. If Is2d equals True parameters are recomputed by curve2d else by curve3d.
        	:param newEdge:
        	:type newEdge: TopoDS_Edge
        	:param prevPar:
        	:type prevPar: float
        	:param currPar:
        	:type currPar: float
        	:param To2d:
        	:type To2d: bool
        	:rtype: void
        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_TransferRange(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_ShapeAnalysis_TransferParameters_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_TransferParameters
ShapeAnalysis_TransferParameters.Init = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_TransferParameters_Init, None, ShapeAnalysis_TransferParameters)
ShapeAnalysis_TransferParameters.IsSameRange = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_TransferParameters_IsSameRange, None, ShapeAnalysis_TransferParameters)
ShapeAnalysis_TransferParameters.Perform = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_TransferParameters_Perform, None, ShapeAnalysis_TransferParameters)
ShapeAnalysis_TransferParameters.SetMaxTolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_TransferParameters_SetMaxTolerance, None, ShapeAnalysis_TransferParameters)
ShapeAnalysis_TransferParameters.TransferRange = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_TransferParameters_TransferRange, None, ShapeAnalysis_TransferParameters)
ShapeAnalysis_TransferParameters_swigregister = _ShapeAnalysis.ShapeAnalysis_TransferParameters_swigregister
ShapeAnalysis_TransferParameters_swigregister(ShapeAnalysis_TransferParameters)

class ShapeAnalysis_Wire(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CheckClosed(self, *args) -> "Standard_Boolean":
        """
        * Checks if wire is closed, performs CheckConnected, CheckDegenerated and CheckLacking for the first and the last edges Returns: True if at least one check returned True Status: FAIL1 or DONE1: see CheckConnected FAIL2 or DONE2: see CheckDegenerated
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckClosed(self, *args)


    def CheckConnected(self, *args) -> "Standard_Boolean":
        """
        * Calls to CheckConnected for each edge Returns: True if at least one pair of disconnected edges (not sharing the same vertex) was detected
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        * Checks connected edges (num-th and preceeding). Tests with starting preci from <SBWD> or with <prec> if it is greater. Considers Vertices. Returns: False if edges are connected by the common vertex, else True Status : OK : Vertices (end of num-1 th edge and start on num-th one) are already the same DONE1 : Absolutely confused (gp::Resolution) DONE2 : Confused at starting <preci> from <SBWD> DONE3 : Confused at <prec> but not <preci> FAIL1 : Not confused FAIL2 : Not confused but confused with <preci> if reverse num-th edge
        	:param num:
        	:type num: int
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckConnected(self, *args)


    def CheckCurveGap(self, *args) -> "Standard_Boolean":
        """
        * Checks gap between points on 3D curve and points on surface generated by pcurve of the num-th edge. The distance can be queried by MinDistance3d. //! Returns: True if status is DONE Status: OK : Gap is less than myPrecision DONE : Gap is greater than myPrecision FAIL : No 3d curve(s) on the edge(s)
        	:param num: default value is 0
        	:type num: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckCurveGap(self, *args)


    def CheckCurveGaps(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckCurveGaps(self, *args)


    def CheckDegenerated(self, *args) -> "Standard_Boolean":
        """
        * Calls to CheckDegenerated for each edge Returns: True if at least one incorrect degenerated edge was detected
        	:rtype: bool
        * Checks for degenerated edge between two adjacent ones. Fills parameters dgnr1 and dgnr2 with points in paramterical space that correspond to the singularity (either gap that needs to be filled by degenerated edge or that already filled) Returns: False if no singularity or edge is already degenerated, otherwise True Status: OK : No surface singularity, or edge is already degenerated DONE1: Degenerated edge should be inserted (gap in 2D) DONE2: Edge <num> should be made degenerated (recompute pcurve and set the flag) FAIL1: One of edges neighbouring to degenerated one has no pcurve FAIL2: Edge marked as degenerated and has no pcurve but singularity is not detected
        	:param num:
        	:type num: int
        	:param dgnr1:
        	:type dgnr1: gp_Pnt2d
        	:param dgnr2:
        	:type dgnr2: gp_Pnt2d
        	:rtype: bool
        * Checks for degenerated edge between two adjacent ones. Remark : Calls previous function Status : See the function above for details
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckDegenerated(self, *args)


    def CheckEdgeCurves(self, *args) -> "Standard_Boolean":
        """
        * Checks edges geometry (consitency of 2d and 3d senses, adjasment of curves to the vertices, etc.). The order of the checks : Call ShapeAnalysis_Wire to check: ShapeAnalysis_Edge::CheckCurve3dWithPCurve (1), ShapeAnalysis_Edge::CheckVertcesWithPCurve (2), ShapeAnalysis_Edge::CheckVertcesWithCurve3d (3), CheckSeam   (4) Additional: CheckGap3d  (5), CheckGap2d  (6), ShapeAnalysis_Edge::CheckSameParameter (7) Returns: True if at least one check returned True Remark: The numbers in brackets show with what DONEi or FAILi the status can be queried
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckEdgeCurves(self, *args)


    def CheckGap2d(self, *args) -> "Standard_Boolean":
        """
        * Checks gap between edges in 2D (pcurves). Checks the distance between ends of pcurves of the num-th and preceeding edge. The distance can be queried by MinDistance2d. //! Returns: True if status is DONE Status: OK : Gap is less than parametric precision out of myPrecision DONE : Gap is greater than parametric precision out of myPrecision FAIL : No pcurve(s) on the edge(s)
        	:param num: default value is 0
        	:type num: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckGap2d(self, *args)


    def CheckGap3d(self, *args) -> "Standard_Boolean":
        """
        * Checks gap between edges in 3D (3d curves). Checks the distance between ends of 3d curves of the num-th and preceeding edge. The distance can be queried by MinDistance3d. //! Returns: True if status is DONE Status: OK : Gap is less than myPrecision DONE : Gap is greater than myPrecision FAIL : No 3d curve(s) on the edge(s)
        	:param num: default value is 0
        	:type num: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckGap3d(self, *args)


    def CheckGaps2d(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckGaps2d(self, *args)


    def CheckGaps3d(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckGaps3d(self, *args)


    def CheckIntersectingEdges(self, *args) -> "Standard_Boolean":
        """
        * Checks two adjacent edges for intersecting. Intersection is reported only if intersection point is not enclosed by the common end vertex of the edges. Returns: True if intersection is found. If returns True it also fills the sequences of intersection points, corresponding 3d points, and errors for them (half-distances between intersection points in 3d calculated from one and from another edge) Status: FAIL1 : No pcurve FAIL2 : No vertices DONE1 : Self-intersection found
        	:param num:
        	:type num: int
        	:param points2d:
        	:type points2d: IntRes2d_SequenceOfIntersectionPoint
        	:param points3d:
        	:type points3d: TColgp_SequenceOfPnt
        	:param errors:
        	:type errors: TColStd_SequenceOfReal
        	:rtype: bool
        * Checks two adjacent edges for intersecting. Remark : Calls the previous method Status : See the function above for details
        	:param num:
        	:type num: int
        	:rtype: bool
        * Checks i-th and j-th edges for intersecting. Remark : See the previous method for details
        	:param num1:
        	:type num1: int
        	:param num2:
        	:type num2: int
        	:param points2d:
        	:type points2d: IntRes2d_SequenceOfIntersectionPoint
        	:param points3d:
        	:type points3d: TColgp_SequenceOfPnt
        	:param errors:
        	:type errors: TColStd_SequenceOfReal
        	:rtype: bool
        * Checks i-th and j-th edges for intersecting. Remark : Calls previous method. Status : See the function above for details
        	:param num1:
        	:type num1: int
        	:param num2:
        	:type num2: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckIntersectingEdges(self, *args)


    def CheckLacking(self, *args) -> "Standard_Boolean":
        """
        * Calls to CheckLacking for each edge Returns: True if at least one lacking edge was detected
        	:rtype: bool
        * Checks if there is a gap in 2d between edges, not comprised by the tolerance of their common vertex. If <Tolerance> is greater than 0. and less than tolerance of the vertex, then this value is used for check. Returns: True if not closed gap was detected p2d1 and p2d2 are the endpoint of <num-1>th edge and start of the <num>th edge in 2d. Status: OK: No edge is lacking (3d and 2d connection) FAIL1: edges have no vertices (at least one of them) FAIL2: edges are neither connected by common vertex, nor have coincided vertices FAIL1: edges have no pcurves DONE1: the gap is detected which cannot be closed by the tolerance of the common vertex (or with value of <Tolerance>) DONE2: is set (together with DONE1) if gap is detected and the vector (p2d2 - p2d1) goes in direction opposite to the pcurves of the edges (if angle is more than 0.9*PI).
        	:param num:
        	:type num: int
        	:param Tolerance:
        	:type Tolerance: float
        	:param p2d1:
        	:type p2d1: gp_Pnt2d
        	:param p2d2:
        	:type p2d2: gp_Pnt2d
        	:rtype: bool
        * Checks if there is a gap in 2D between edges and not comprised by vertex tolerance The value of SBWD.thepreci is used. Returns: False if no edge should be inserted Status: OK : No edge is lacking (3d and 2d connection) DONE1 : The vertex tolerance should be increased only (2d gap is small) DONE2 : Edge can be inserted (3d and 2d gaps are large enough)
        	:param num:
        	:type num: int
        	:param Tolerance: default value is 0.0
        	:type Tolerance: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckLacking(self, *args)


    def CheckLoop(self, *args) -> "Standard_Boolean":
        """
        * Checks existance of loop on wire and return vertices wich are loop vertices (vertices belonging to a few pairs of edges)
        	:param aMapLoopVertices:
        	:type aMapLoopVertices: TopTools_IndexedMapOfShape
        	:param aMapVertexEdges:
        	:type aMapVertexEdges: TopTools_DataMapOfShapeListOfShape
        	:param aMapSmallEdges:
        	:type aMapSmallEdges: TopTools_MapOfShape
        	:param aMapSeemEdges:
        	:type aMapSeemEdges: TopTools_MapOfShape
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckLoop(self, *args)


    def CheckNotchedEdges(self, *args) -> "Standard_Boolean":
        """
        * Detects a notch
        	:param num:
        	:type num: int
        	:param shortNum:
        	:type shortNum: int
        	:param param:
        	:type param: float
        	:param Tolerance: default value is 0.0
        	:type Tolerance: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckNotchedEdges(self, *args)


    def CheckOrder(self, *args) -> "Standard_Boolean":
        """
        * Calls CheckOrder and returns False if wire is already ordered (tail-to-head), True otherwise Flag <isClosed> defines if the wire is closed or not Flag <mode3d> defines which mode is used (3d or 2d)
        	:param isClosed: default value is Standard_True
        	:type isClosed: bool
        	:param mode3d: default value is Standard_True
        	:type mode3d: bool
        	:rtype: bool
        * Analyzes the order of the edges in the wire, uses class WireOrder for that purpose. Flag <isClosed> defines if the wire is closed or not Flag <mode3d> defines which mode is used (3d or 2d) Returns False if wire is already ordered (tail-to-head), True otherwise. Use returned WireOrder object for deeper analysis. Status: OK : the same edges orientation, the same edges sequence DONE1: the same edges orientation, not the same edges sequence DONE2: as DONE1 and gaps more than myPrecision DONE3: not the same edges orientation (some need to be reversed) DONE4: as DONE3 and gaps more than myPrecision FAIL : algorithm failed (could not detect order)
        	:param sawo:
        	:type sawo: ShapeAnalysis_WireOrder
        	:param isClosed: default value is Standard_True
        	:type isClosed: bool
        	:param mode3d: default value is Standard_True
        	:type mode3d: bool
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckOrder(self, *args)


    def CheckOuterBound(self, *args) -> "Standard_Boolean":
        """
        * Checks if wire defines an outer bound on the face Uses ShapeAnalysis::IsOuterBound for analysis If <APIMake> is True uses BRepAPI_MakeWire to build the wire, if False (to be used only when edges share common vertices) uses BRep_Builder to build the wire
        	:param APIMake: default value is Standard_True
        	:type APIMake: bool
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckOuterBound(self, *args)


    def CheckSeam(self, *args) -> "Standard_Boolean":
        """
        * Checks if a seam pcurves are correct oriented Returns: False (status OK) if given edge is not a seam or if it is OK C1 - current pcurve for FORWARD edge, C2 - current pcurve for REVERSED edge (if returns True they should be swapped for the seam), cf, cl - first and last parameters on curves Status: OK : Pcurves are correct or edge is not seam DONE : Seam pcurves should be swapped
        	:param num:
        	:type num: int
        	:param C1:
        	:type C1: Geom2d_Curve
        	:param C2:
        	:type C2: Geom2d_Curve
        	:param cf:
        	:type cf: float
        	:param cl:
        	:type cl: float
        	:rtype: bool
        * Checks if a seam pcurves are correct oriented See previous functions for details
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSeam(self, *args)


    def CheckSelfIntersectingEdge(self, *args) -> "Standard_Boolean":
        """
        * Checks if num-th edge is self-intersecting. Self-intersection is reported only if intersection point lies outside of both end vertices of the edge. Returns: True if edge is self-intersecting. If returns True it also fills the sequences of intersection points and corresponding 3d points (only that are not enclosed by a vertices) Status: FAIL1 : No pcurve FAIL2 : No vertices DONE1 : Self-intersection found
        	:param num:
        	:type num: int
        	:param points2d:
        	:type points2d: IntRes2d_SequenceOfIntersectionPoint
        	:param points3d:
        	:type points3d: TColgp_SequenceOfPnt
        	:rtype: bool
        :param num:
        	:type num: int
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSelfIntersectingEdge(self, *args)


    def CheckSelfIntersection(self, *args) -> "Standard_Boolean":
        """
        * Checks self-intersection of the wire (considering pcurves) Looks for self-intersecting edges and each pair of intersecting edges. Warning: It does not check each edge with any other one (only each two adjacent edges) The order of the checks : CheckSelfIntersectingEdge, CheckIntersectingEdges Returns: True if at least one check returned True Status: FAIL1 or DONE1 - see CheckSelfIntersectingEdge FAIL2 or DONE2 - see CheckIntersectingEdges
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSelfIntersection(self, *args)


    def CheckShapeConnect(self, *args) -> "Standard_Boolean":
        """
        * Checks with what orientation <shape> (wire or edge) can be connected to the wire. Tests distances with starting <preci> from <SBWD> (close confusion), but if given <prec> is greater, tests with <prec> (coarse confusion). The smallest found distance can be returned by MinDistance3d //! Returns: False if status is FAIL (see below) Status: DONE1 : If <shape> follows <SBWD>, direct sense (normal) DONE2 : If <shape> follows <SBWD>, but if reversed DONE3 : If <shape> preceeds <SBWD>, direct sense DONE4 : If <shape> preceeds <SBWD>, but if reversed FAIL1 : If <shape> is neither an edge nor a wire FAIL2 : If <shape> cannot be connected to <SBWD> //! DONE5 : To the tail of <SBWD> the <shape> is closer with direct sense DONE6 : To the head of <SBWD> the <shape> is closer with direct sense //! Remark: Statuses DONE1 - DONE4, FAIL1 - FAIL2 are basic and describe the nearest connection of the <shape> to <SBWD>. Statuses DONE5 and DONE6 are advanced and are to be used when analyzing with what sense (direct or reversed) the <shape> should be connected to <SBWD>: For tail of <SBWD> if DONE4 is True <shape> should be direct, otherwise reversed. For head of <SBWD> if DONE5 is True <shape> should be direct, otherwise reversed.
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        * The same as previous CheckShapeConnect but is more advanced. It returns the distances between each end of <sbwd> and each end of <shape>. For example, <tailhead> stores distance between tail of <sbwd> and head of <shape> Remark: First method CheckShapeConnect calls this one
        	:param tailhead:
        	:type tailhead: float
        	:param tailtail:
        	:type tailtail: float
        	:param headtail:
        	:type headtail: float
        	:param headhead:
        	:type headhead: float
        	:param shape:
        	:type shape: TopoDS_Shape
        	:param prec: default value is 0.0
        	:type prec: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckShapeConnect(self, *args)


    def CheckSmall(self, *args) -> "Standard_Boolean":
        """
        * Calls to CheckSmall for each edge Returns: True if at least one small edge was detected
        	:param precsmall: default value is 0.0
        	:type precsmall: float
        	:rtype: bool
        * Checks if an edge has a length not greater than myPreci or precsmall (if it is smaller) Returns: False if its length is greater than precision Status: OK : edge is not small or degenerated DONE1: edge is small, vertices are the same DONE2: edge is small, vertices are not the same FAIL : no 3d curve and pcurve
        	:param num:
        	:type num: int
        	:param precsmall: default value is 0.0
        	:type precsmall: float
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSmall(self, *args)


    def CheckSmallArea(self, *args) -> "Standard_Boolean":
        """
        * Checks if wire has parametric area less than precision.
        	:param theWire:
        	:type theWire: TopoDS_Wire
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSmallArea(self, *args)


    def CheckTail(self, *args) -> "Standard_Boolean":
        """
        :param theEdge1:
        	:type theEdge1: TopoDS_Edge
        	:param theEdge2:
        	:type theEdge2: TopoDS_Edge
        	:param theMaxSine:
        	:type theMaxSine: float
        	:param theMaxWidth:
        	:type theMaxWidth: float
        	:param theMaxTolerance:
        	:type theMaxTolerance: float
        	:param theEdge11:
        	:type theEdge11: TopoDS_Edge
        	:param theEdge12:
        	:type theEdge12: TopoDS_Edge
        	:param theEdge21:
        	:type theEdge21: TopoDS_Edge
        	:param theEdge22:
        	:type theEdge22: TopoDS_Edge
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckTail(self, *args)


    def ClearStatuses(self, *args) -> "void":
        """
        * Unsets all the status and distance fields wire, face and precision are not cleared
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_ClearStatuses(self, *args)


    def Face(self, *args) -> "TopoDS_Face const":
        """
        * Returns the working face
        	:rtype: TopoDS_Face
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Face(self, *args)


    def Init(self, *args) -> "void":
        """
        * Initializes the object with standard TopoDS_Wire, face and precision
        	:param wire:
        	:type wire: TopoDS_Wire
        	:param face:
        	:type face: TopoDS_Face
        	:param precision:
        	:type precision: float
        	:rtype: None
        * Initializes the object with WireData object, face and precision
        	:param sbwd:
        	:type sbwd: ShapeExtend_WireData
        	:param face:
        	:type face: TopoDS_Face
        	:param precision:
        	:type precision: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Init(self, *args)


    def IsLoaded(self, *args) -> "Standard_Boolean":
        """
        * Returns True if wire is loaded and has number of edges >0
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_IsLoaded(self, *args)


    def IsReady(self, *args) -> "Standard_Boolean":
        """
        * Returns True if IsLoaded and underlying face is not null
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_IsReady(self, *args)


    def LastCheckStatus(self, *args) -> "Standard_Boolean":
        """
        * Querying the status of the LAST perfomed 'Advanced' checking procedure
        	:param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_LastCheckStatus(self, *args)


    def Load(self, *args) -> "void":
        """
        * Loads the object with standard TopoDS_Wire
        	:param wire:
        	:type wire: TopoDS_Wire
        	:rtype: None
        * Loads the object with WireData object
        	:param sbwd:
        	:type sbwd: ShapeExtend_WireData
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Load(self, *args)


    def MaxDistance2d(self, *args) -> "Standard_Real":
        """
        * Returns the last maximal distance in 2D-UV computed by CheckContinuity2d
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_MaxDistance2d(self, *args)


    def MaxDistance3d(self, *args) -> "Standard_Real":
        """
        * Returns the last maximal distance in 3D computed by CheckOrientation, CheckConnected, CheckContinuity3d, CheckVertex, CheckNewVertex, CheckSameParameter
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_MaxDistance3d(self, *args)


    def MinDistance2d(self, *args) -> "Standard_Real":
        """
        * Returns the last lowest distance in 2D-UV computed by CheckContinuity2d
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_MinDistance2d(self, *args)


    def MinDistance3d(self, *args) -> "Standard_Real":
        """
        * Returns the last lowest distance in 3D computed by CheckOrientation, CheckConnected, CheckContinuity3d, CheckVertex, CheckNewVertex
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_MinDistance3d(self, *args)


    def NbEdges(self, *args) -> "Standard_Integer":
        """
        * Returns the number of edges in the wire, or 0 if it is not loaded
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_NbEdges(self, *args)


    def Perform(self, *args) -> "Standard_Boolean":
        """
        * Performs all the checks in the following order : CheckOrder, CheckSmall, CheckConected, CheckEdgeCurves, CheckDegenerated, CheckSelfIntersection, CheckLacking, CheckClosed Returns: True if at least one method returned True; For deeper analysis use Status...(status) methods
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Perform(self, *args)


    def Precision(self, *args) -> "Standard_Real":
        """
        * Returns the value of precision
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Precision(self, *args)


    def SetFace(self, *args) -> "void":
        """
        * Loads the face the wire lies on
        	:param face:
        	:type face: TopoDS_Face
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_SetFace(self, *args)


    def SetPrecision(self, *args) -> "void":
        """
        :param precision:
        	:type precision: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_SetPrecision(self, *args)


    def SetSurface(self, *args) -> "void":
        """
        * Loads the surface the wire lies on
        	:param surface:
        	:type surface: Geom_Surface
        	:rtype: None
        * Loads the surface the wire lies on
        	:param surface:
        	:type surface: Geom_Surface
        	:param location:
        	:type location: TopLoc_Location
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_SetSurface(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        * Creates object with standard TopoDS_Wire, face and precision
        	:param wire:
        	:type wire: TopoDS_Wire
        	:param face:
        	:type face: TopoDS_Face
        	:param precision:
        	:type precision: float
        	:rtype: None
        * Creates the object with WireData object, face and precision
        	:param sbwd:
        	:type sbwd: ShapeExtend_WireData
        	:param face:
        	:type face: TopoDS_Face
        	:param precision:
        	:type precision: float
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_Wire_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_Wire(*args))

    def StatusClosed(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusClosed(self, *args)


    def StatusConnected(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusConnected(self, *args)


    def StatusCurveGaps(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusCurveGaps(self, *args)


    def StatusDegenerated(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusDegenerated(self, *args)


    def StatusEdgeCurves(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusEdgeCurves(self, *args)


    def StatusGaps2d(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusGaps2d(self, *args)


    def StatusGaps3d(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusGaps3d(self, *args)


    def StatusLacking(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusLacking(self, *args)


    def StatusLoop(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusLoop(self, *args)


    def StatusOrder(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusOrder(self, *args)


    def StatusSelfIntersection(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusSelfIntersection(self, *args)


    def StatusSmall(self, *args) -> "Standard_Boolean":
        """
        :param Status:
        	:type Status: ShapeExtend_Status
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusSmall(self, *args)


    def Surface(self, *args) -> "opencascade::handle< ShapeAnalysis_Surface > const &":
        """
        * Returns the working surface
        	:rtype: opencascade::handle<ShapeAnalysis_Surface>
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Surface(self, *args)


    def WireData(self, *args) -> "opencascade::handle< ShapeExtend_WireData > const &":
        """
        * Returns wire object being analyzed
        	:rtype: opencascade::handle<ShapeExtend_WireData>
        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_WireData(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_ShapeAnalysis_Wire_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Wire
ShapeAnalysis_Wire.CheckClosed = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckClosed, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckConnected = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckConnected, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckCurveGap = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckCurveGap, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckCurveGaps = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckCurveGaps, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckDegenerated = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckDegenerated, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckEdgeCurves = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckEdgeCurves, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckGap2d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckGap2d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckGap3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckGap3d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckGaps2d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckGaps2d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckGaps3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckGaps3d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckIntersectingEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckIntersectingEdges, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckLacking = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckLacking, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckLoop = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckLoop, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckNotchedEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckNotchedEdges, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckOrder = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckOrder, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckOuterBound = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckOuterBound, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckSeam = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckSeam, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckSelfIntersectingEdge = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckSelfIntersectingEdge, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckSelfIntersection = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckSelfIntersection, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckShapeConnect = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckShapeConnect, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckSmall = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckSmall, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckSmallArea = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckSmallArea, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.CheckTail = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_CheckTail, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.ClearStatuses = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_ClearStatuses, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.Face = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_Face, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.Init = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_Init, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.IsLoaded = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_IsLoaded, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.IsReady = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_IsReady, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.LastCheckStatus = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_LastCheckStatus, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.Load = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_Load, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.MaxDistance2d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_MaxDistance2d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.MaxDistance3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_MaxDistance3d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.MinDistance2d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_MinDistance2d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.MinDistance3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_MinDistance3d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.NbEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_NbEdges, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.Perform = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_Perform, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.Precision = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_Precision, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.SetFace = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_SetFace, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.SetPrecision = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_SetPrecision, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.SetSurface = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_SetSurface, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusClosed = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusClosed, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusConnected = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusConnected, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusCurveGaps = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusCurveGaps, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusDegenerated = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusDegenerated, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusEdgeCurves = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusEdgeCurves, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusGaps2d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusGaps2d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusGaps3d = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusGaps3d, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusLacking = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusLacking, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusLoop = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusLoop, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusOrder = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusOrder, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusSelfIntersection = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusSelfIntersection, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.StatusSmall = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_StatusSmall, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.Surface = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_Surface, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire.WireData = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_Wire_WireData, None, ShapeAnalysis_Wire)
ShapeAnalysis_Wire_swigregister = _ShapeAnalysis.ShapeAnalysis_Wire_swigregister
ShapeAnalysis_Wire_swigregister(ShapeAnalysis_Wire)

class ShapeAnalysis_WireOrder(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a couple of points 3D (start,end)
        	:param start3d:
        	:type start3d: gp_XYZ
        	:param end3d:
        	:type end3d: gp_XYZ
        	:rtype: None
        * Adds a couple of points 2D (start,end)
        	:param start2d:
        	:type start2d: gp_XY
        	:param end2d:
        	:type end2d: gp_XY
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Add(self, *args)


    def Chain(self, *args) -> "void":
        """
        * Returns, for the chain n0 num, starting and ending numbers of edges. In the list of ordered edges (see Ordered for originals)
        	:param num:
        	:type num: int
        	:param n1:
        	:type n1: int
        	:param n2:
        	:type n2: int
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Chain(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears the list of edges, but not mode and tol
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Clear(self, *args)


    def Couple(self, *args) -> "void":
        """
        * Returns, for the couple n0 num, the two implied edges In the list of ordered edges
        	:param num:
        	:type num: int
        	:param n1:
        	:type n1: int
        	:param n2:
        	:type n2: int
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Couple(self, *args)


    def Gap(self, *args) -> "Standard_Real":
        """
        * Returns the gap between a couple and its preceeding <num> is considered ordered If <num> = 0 (D), returns the greatest gap found
        	:param num: default value is 0
        	:type num: int
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Gap(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Tells if Perform has been done Else, the following methods returns original values
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_IsDone(self, *args)


    def GetKeepLoopsMode(self) -> "Standard_Boolean":
        """GetKeepLoopsMode(ShapeAnalysis_WireOrder self) -> Standard_Boolean"""
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_GetKeepLoopsMode(self)


    def SetKeepLoopsMode(self, value: 'Standard_Boolean') -> "void":
        """SetKeepLoopsMode(ShapeAnalysis_WireOrder self, Standard_Boolean value)"""
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_SetKeepLoopsMode(self, value)


    def NbChains(self, *args) -> "Standard_Integer":
        """
        * Returns the count of computed chains
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_NbChains(self, *args)


    def NbCouples(self, *args) -> "Standard_Integer":
        """
        * Returns the count of computed couples
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_NbCouples(self, *args)


    def NbEdges(self, *args) -> "Standard_Integer":
        """
        * Returns the count of added couples of points (one per edges)
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_NbEdges(self, *args)


    def Ordered(self, *args) -> "Standard_Integer":
        """
        * Returns the number of original edge which correspond to the newly ordered number <n> Warning : the returned value is NEGATIVE if edge should be reversed
        	:param n:
        	:type n: int
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Ordered(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Computes the better order If <closed> is True (D) considers also closure Optimised if the couples were already in order The criterium is : two couples in order if distance between end-prec and start-cur is less then starting tolerance <tol> Else, the smallest distance is reached Gap corresponds to a smallest distance greater than <tol>
        	:param closed: default value is Standard_True
        	:type closed: bool
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Perform(self, *args)


    def SetChains(self, *args) -> "void":
        """
        * Determines the chains inside which successive edges have a gap less than a given value. Queried by NbChains and Chain
        	:param gap:
        	:type gap: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_SetChains(self, *args)


    def SetCouples(self, *args) -> "void":
        """
        * Determines the couples of edges for which end and start fit inside a given gap. Queried by NbCouples and Couple
        	:param gap:
        	:type gap: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_SetCouples(self, *args)


    def SetMode(self, *args) -> "void":
        """
        * Sets new values. Clears the connexion list If <mode3d> changes, also clears the edge list (else, doesnt)
        	:param mode3d:
        	:type mode3d: bool
        	:param tol:
        	:type tol: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_SetMode(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        * Creates a WireOrder in 3D (if mode3d is True) or 2D (if False) with a tolerance
        	:param mode3d:
        	:type mode3d: bool
        	:param tol:
        	:type tol: float
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_WireOrder_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_WireOrder(*args))

    def Status(self, *args) -> "Standard_Integer":
        """
        * Returns the status of the order (0 if not done) : 0 : all edges are direct and in sequence 1 : all edges are direct but some are not in sequence 2 : in addition, unresolved gaps remain -1 : some edges are reversed, but no gap remain -2 : some edges are reversed and some gaps remain -10 : COULD NOT BE RESOLVED, Failure on Reorder gap : regarding starting <tol>
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Status(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        * Returns the working tolerance
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Tolerance(self, *args)


    def XY(self, *args) -> "void":
        """
        * Returns the values of the couple <num>, as 2D values
        	:param num:
        	:type num: int
        	:param start2d:
        	:type start2d: gp_XY
        	:param end2d:
        	:type end2d: gp_XY
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_XY(self, *args)


    def XYZ(self, *args) -> "void":
        """
        * Returns the values of the couple <num>, as 3D values
        	:param num:
        	:type num: int
        	:param start3d:
        	:type start3d: gp_XYZ
        	:param end3d:
        	:type end3d: gp_XYZ
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_XYZ(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_WireOrder
ShapeAnalysis_WireOrder.Add = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_Add, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.Chain = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_Chain, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.Clear = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_Clear, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.Couple = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_Couple, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.Gap = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_Gap, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.IsDone = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_IsDone, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.GetKeepLoopsMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_GetKeepLoopsMode, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.SetKeepLoopsMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_SetKeepLoopsMode, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.NbChains = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_NbChains, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.NbCouples = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_NbCouples, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.NbEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_NbEdges, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.Ordered = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_Ordered, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.Perform = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_Perform, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.SetChains = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_SetChains, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.SetCouples = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_SetCouples, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.SetMode = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_SetMode, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.Status = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_Status, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.Tolerance = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_Tolerance, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.XY = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_XY, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder.XYZ = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireOrder_XYZ, None, ShapeAnalysis_WireOrder)
ShapeAnalysis_WireOrder_swigregister = _ShapeAnalysis.ShapeAnalysis_WireOrder_swigregister
ShapeAnalysis_WireOrder_swigregister(ShapeAnalysis_WireOrder)

class ShapeAnalysis_WireVertex(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Analyze(self, *args) -> "void":
        """:rtype: None"""
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Analyze(self, *args)


    def Data(self, *args) -> "Standard_Integer":
        """
        * Returns the recorded status for a vertex With its recorded position and parameters on both edges These values are relevant regarding the status: Status Meaning Position Preceeding Following 0 Same no no no 1 SameCoord no no no 2 Close no no no 3 End yes no yes 4 Start yes yes no 5 Inters yes yes yes -1 Disjoined no no no
        	:param num:
        	:type num: int
        	:param pos:
        	:type pos: gp_XYZ
        	:param upre:
        	:type upre: float
        	:param ufol:
        	:type ufol: float
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Data(self, *args)


    def Init(self, *args) -> "void":
        """
        :param wire:
        	:type wire: TopoDS_Wire
        	:param preci:
        	:type preci: float
        	:rtype: None
        :param swbd:
        	:type swbd: ShapeExtend_WireData
        	:param preci:
        	:type preci: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Init(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if analysis was performed, else returns False
        	:rtype: bool
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_IsDone(self, *args)


    def Load(self, *args) -> "void":
        """
        :param wire:
        	:type wire: TopoDS_Wire
        	:rtype: None
        :param sbwd:
        	:type sbwd: ShapeExtend_WireData
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Load(self, *args)


    def NbEdges(self, *args) -> "Standard_Integer":
        """
        * Returns the number of edges in analyzed wire (i.e. the length of all arrays)
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_NbEdges(self, *args)


    def NextCriter(self, *args) -> "Standard_Integer":
        """
        * For a given criter, returns the rank of the vertex which follows <num> and has the same status. 0 if no more Acts as an iterator, starts on the first one Criters are: 0: same vertex (status 0) 1: a solution exists (status >= 0) 2: same coords (i.e. same params) (status 0 1 2) 3: same coods but not same vertex (status 1 2) 4: redefined coords (status 3 4 5) -1: no solution (status -1)
        	:param crit:
        	:type crit: int
        	:param num: default value is 0
        	:type num: int
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_NextCriter(self, *args)


    def NextStatus(self, *args) -> "Standard_Integer":
        """
        * For a given status, returns the rank of the vertex which follows <num> and has the same status. 0 if no more Acts as an iterator, starts on the first one
        	:param stat:
        	:type stat: int
        	:param num: default value is 0
        	:type num: int
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_NextStatus(self, *args)


    def Position(self, *args) -> "gp_XYZ":
        """
        :param num:
        	:type num: int
        	:rtype: gp_XYZ
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Position(self, *args)


    def Precision(self, *args) -> "Standard_Real":
        """
        * Returns precision value used in analysis
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Precision(self, *args)


    def SetClose(self, *args) -> "void":
        """
        * Records status 'Close Coords' (at the Precision of <self>)
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetClose(self, *args)


    def SetDisjoined(self, *args) -> "void":
        """
        * <num> cannot be said as same vertex
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetDisjoined(self, *args)


    def SetEnd(self, *args) -> "void":
        """
        * <num> is the End of preceeding Edge, and its projection on the following one lies on it at the Precision of <self> <ufol> gives the parameter on the following edge
        	:param num:
        	:type num: int
        	:param pos:
        	:type pos: gp_XYZ
        	:param ufol:
        	:type ufol: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetEnd(self, *args)


    def SetInters(self, *args) -> "void":
        """
        * <num> is the Intersection of both Edges <upre> is the parameter on preceeding edge, <ufol> on following edge
        	:param num:
        	:type num: int
        	:param pos:
        	:type pos: gp_XYZ
        	:param upre:
        	:type upre: float
        	:param ufol:
        	:type ufol: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetInters(self, *args)


    def SetPrecision(self, *args) -> "void":
        """
        * Sets the precision for work Analysing: for each Vertex, comparison between the end of the preceeding edge and the start of the following edge Each Vertex rank corresponds to the End Vertex of the Edge of same rank, in the ShapeExtend_WireData. I.E. for Vertex <num>, Edge <num> is the preceeding one, <num+1> is the following one
        	:param preci:
        	:type preci: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetPrecision(self, *args)


    def SetSameCoords(self, *args) -> "void":
        """
        * Records status 'Same Coords' (at the Vertices Tolerances)
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetSameCoords(self, *args)


    def SetSameVertex(self, *args) -> "void":
        """
        * Records status 'Same Vertex' (logically) on Vertex <num>
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetSameVertex(self, *args)


    def SetStart(self, *args) -> "void":
        """
        * <num> is the Start of following Edge, its projection on the preceeding one lies on it at the Precision of <self> <upre> gives the parameter on the preceeding edge
        	:param num:
        	:type num: int
        	:param pos:
        	:type pos: gp_XYZ
        	:param upre:
        	:type upre: float
        	:rtype: None
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetStart(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_WireVertex_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_WireVertex(*args))

    def Status(self, *args) -> "Standard_Integer":
        """
        * Returns the recorded status for a vertex More detail by method Data
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Status(self, *args)


    def UFollowing(self, *args) -> "Standard_Real":
        """
        :param num:
        	:type num: int
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_UFollowing(self, *args)


    def UPrevious(self, *args) -> "Standard_Real":
        """
        :param num:
        	:type num: int
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_UPrevious(self, *args)


    def WireData(self, *args) -> "opencascade::handle< ShapeExtend_WireData > const &":
        """
        * Returns analyzed wire
        	:rtype: opencascade::handle<ShapeExtend_WireData>
        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_WireData(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_WireVertex
ShapeAnalysis_WireVertex.Analyze = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_Analyze, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.Data = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_Data, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.Init = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_Init, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.IsDone = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_IsDone, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.Load = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_Load, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.NbEdges = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_NbEdges, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.NextCriter = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_NextCriter, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.NextStatus = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_NextStatus, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.Position = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_Position, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.Precision = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_Precision, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.SetClose = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_SetClose, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.SetDisjoined = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_SetDisjoined, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.SetEnd = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_SetEnd, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.SetInters = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_SetInters, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.SetPrecision = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_SetPrecision, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.SetSameCoords = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_SetSameCoords, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.SetSameVertex = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_SetSameVertex, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.SetStart = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_SetStart, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.Status = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_Status, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.UFollowing = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_UFollowing, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.UPrevious = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_UPrevious, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex.WireData = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_WireVertex_WireData, None, ShapeAnalysis_WireVertex)
ShapeAnalysis_WireVertex_swigregister = _ShapeAnalysis.ShapeAnalysis_WireVertex_swigregister
ShapeAnalysis_WireVertex_swigregister(ShapeAnalysis_WireVertex)

class ShapeAnalysis_TransferParametersProj(ShapeAnalysis_TransferParameters):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CopyNMVertex(*args) -> "TopoDS_Vertex":
        """
        * Make a copy of non-manifold vertex theVert (i.e. create new TVertex and replace PointRepresentations for this vertex from fromedge to toedge. Other representations were copied)
        	:param theVert:
        	:type theVert: TopoDS_Vertex
        	:param toedge:
        	:type toedge: TopoDS_Edge
        	:param fromedge:
        	:type fromedge: TopoDS_Edge
        	:rtype: TopoDS_Vertex
        * Make a copy of non-manifold vertex theVert (i.e. create new TVertex and replace PointRepresentations for this vertex from fromFace to toFace. Other representations were copied)
        	:param theVert:
        	:type theVert: TopoDS_Vertex
        	:param toFace:
        	:type toFace: TopoDS_Face
        	:param fromFace:
        	:type fromFace: TopoDS_Face
        	:rtype: TopoDS_Vertex
        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_CopyNMVertex(*args)

    CopyNMVertex = staticmethod(CopyNMVertex)

    def GetForceProjection(self) -> "Standard_Boolean":
        """GetForceProjection(ShapeAnalysis_TransferParametersProj self) -> Standard_Boolean"""
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_GetForceProjection(self)


    def SetForceProjection(self, value: 'Standard_Boolean') -> "void":
        """SetForceProjection(ShapeAnalysis_TransferParametersProj self, Standard_Boolean value)"""
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_SetForceProjection(self, value)


    def Perform(self, *args) -> "Standard_Real":
        """
        * Transfers parameters given by sequence Params from 3d curve to pcurve (if To2d is True) or back (if To2d is False)
        	:param Papams:
        	:type Papams: TColStd_HSequenceOfReal
        	:param To2d:
        	:type To2d: bool
        	:rtype: opencascade::handle<TColStd_HSequenceOfReal>
        * Transfers parameter given by Param from 3d curve to pcurve (if To2d is True) or back (if To2d is False)
        	:param Param:
        	:type Param: float
        	:param To2d:
        	:type To2d: bool
        	:rtype: float
        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_Perform(self, *args)


    def __init__(self, *args):
        """
        * Creats empty constructor.
        	:rtype: None
        :param E:
        	:type E: TopoDS_Edge
        	:param F:
        	:type F: TopoDS_Face
        	:rtype: None
        """
        _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_TransferParametersProj(*args))


    @staticmethod
    def DownCast(t):
      return Handle_ShapeAnalysis_TransferParametersProj_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_TransferParametersProj
ShapeAnalysis_TransferParametersProj.GetForceProjection = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_TransferParametersProj_GetForceProjection, None, ShapeAnalysis_TransferParametersProj)
ShapeAnalysis_TransferParametersProj.SetForceProjection = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_TransferParametersProj_SetForceProjection, None, ShapeAnalysis_TransferParametersProj)
ShapeAnalysis_TransferParametersProj.Perform = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_TransferParametersProj_Perform, None, ShapeAnalysis_TransferParametersProj)
ShapeAnalysis_TransferParametersProj_swigregister = _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_swigregister
ShapeAnalysis_TransferParametersProj_swigregister(ShapeAnalysis_TransferParametersProj)

def ShapeAnalysis_TransferParametersProj_CopyNMVertex(*args) -> "TopoDS_Vertex":
    """
    * Make a copy of non-manifold vertex theVert (i.e. create new TVertex and replace PointRepresentations for this vertex from fromedge to toedge. Other representations were copied)
    	:param theVert:
    	:type theVert: TopoDS_Vertex
    	:param toedge:
    	:type toedge: TopoDS_Edge
    	:param fromedge:
    	:type fromedge: TopoDS_Edge
    	:rtype: TopoDS_Vertex
    * Make a copy of non-manifold vertex theVert (i.e. create new TVertex and replace PointRepresentations for this vertex from fromFace to toFace. Other representations were copied)
    	:param theVert:
    	:type theVert: TopoDS_Vertex
    	:param toFace:
    	:type toFace: TopoDS_Face
    	:param fromFace:
    	:type fromFace: TopoDS_Face
    	:rtype: TopoDS_Vertex
    """
    return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_CopyNMVertex(*args)

class ShapeAnalysis_HSequenceOfFreeBounds(ShapeAnalysis_SequenceOfFreeBounds, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_swiginit(self, _ShapeAnalysis.new_ShapeAnalysis_HSequenceOfFreeBounds(*args))


    @staticmethod
    def DownCast(t):
      return Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast(t)

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_HSequenceOfFreeBounds
ShapeAnalysis_HSequenceOfFreeBounds.Sequence = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_Sequence, None, ShapeAnalysis_HSequenceOfFreeBounds)
ShapeAnalysis_HSequenceOfFreeBounds.Append = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_Append, None, ShapeAnalysis_HSequenceOfFreeBounds)
ShapeAnalysis_HSequenceOfFreeBounds.ChangeSequence = new_instancemethod(_ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_ChangeSequence, None, ShapeAnalysis_HSequenceOfFreeBounds)
ShapeAnalysis_HSequenceOfFreeBounds_swigregister = _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_swigregister
ShapeAnalysis_HSequenceOfFreeBounds_swigregister(ShapeAnalysis_HSequenceOfFreeBounds)



