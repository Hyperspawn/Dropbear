# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Standard module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_standard.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Standard.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Standard')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Standard')
    _Standard = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Standard', [dirname(__file__)])
        except ImportError:
            import _Standard
            return _Standard
        try:
            _mod = imp.load_module('_Standard', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Standard = swig_import_helper()
    del swig_import_helper
else:
    import _Standard
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Standard.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_Standard.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Standard.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Standard.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Standard.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Standard.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Standard.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Standard.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Standard.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Standard.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Standard.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Standard.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Standard.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Standard.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Standard.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Standard.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Standard.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _Standard.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _Standard.process_exception(error, method_name, class_name)
process_exception = _Standard.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

Standard_HandlerVoid = _Standard.Standard_HandlerVoid
Standard_HandlerJumped = _Standard.Standard_HandlerJumped
Standard_HandlerProcessed = _Standard.Standard_HandlerProcessed

def Handle_Standard_Transient_Create() -> "opencascade::handle< Standard_Transient >":
    return _Standard.Handle_Standard_Transient_Create()
Handle_Standard_Transient_Create = _Standard.Handle_Standard_Transient_Create

def Handle_Standard_Transient_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Standard_Transient >":
    return _Standard.Handle_Standard_Transient_DownCast(t)
Handle_Standard_Transient_DownCast = _Standard.Handle_Standard_Transient_DownCast

def Handle_Standard_Transient_IsNull(t: 'opencascade::handle< Standard_Transient > const &') -> "bool":
    return _Standard.Handle_Standard_Transient_IsNull(t)
Handle_Standard_Transient_IsNull = _Standard.Handle_Standard_Transient_IsNull

def Handle_Standard_OutOfMemory_Create() -> "opencascade::handle< Standard_OutOfMemory >":
    return _Standard.Handle_Standard_OutOfMemory_Create()
Handle_Standard_OutOfMemory_Create = _Standard.Handle_Standard_OutOfMemory_Create

def Handle_Standard_OutOfMemory_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Standard_OutOfMemory >":
    return _Standard.Handle_Standard_OutOfMemory_DownCast(t)
Handle_Standard_OutOfMemory_DownCast = _Standard.Handle_Standard_OutOfMemory_DownCast

def Handle_Standard_OutOfMemory_IsNull(t: 'opencascade::handle< Standard_OutOfMemory > const &') -> "bool":
    return _Standard.Handle_Standard_OutOfMemory_IsNull(t)
Handle_Standard_OutOfMemory_IsNull = _Standard.Handle_Standard_OutOfMemory_IsNull

def Handle_Standard_Persistent_Create() -> "opencascade::handle< Standard_Persistent >":
    return _Standard.Handle_Standard_Persistent_Create()
Handle_Standard_Persistent_Create = _Standard.Handle_Standard_Persistent_Create

def Handle_Standard_Persistent_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Standard_Persistent >":
    return _Standard.Handle_Standard_Persistent_DownCast(t)
Handle_Standard_Persistent_DownCast = _Standard.Handle_Standard_Persistent_DownCast

def Handle_Standard_Persistent_IsNull(t: 'opencascade::handle< Standard_Persistent > const &') -> "bool":
    return _Standard.Handle_Standard_Persistent_IsNull(t)
Handle_Standard_Persistent_IsNull = _Standard.Handle_Standard_Persistent_IsNull
class standard(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Allocate(*args) -> "Standard_Address":
        """
        * Allocates memory blocks aSize - bytes to allocate
        	:param aSize:
        	:type aSize: Standard_Size
        	:rtype: Standard_Address
        """
        return _Standard.standard_Allocate(*args)

    Allocate = staticmethod(Allocate)

    def AllocateAligned(*args) -> "Standard_Address":
        """
        * Allocates aligned memory blocks. Should be used with CPU instructions which require specific alignment. For example: SSE requires 16 bytes, AVX requires 32 bytes. @param theSize bytes to allocate @param theAlign alignment in bytes
        	:param theSize:
        	:type theSize: Standard_Size
        	:param theAlign:
        	:type theAlign: Standard_Size
        	:rtype: Standard_Address
        """
        return _Standard.standard_AllocateAligned(*args)

    AllocateAligned = staticmethod(AllocateAligned)

    def Purge(*args) -> "Standard_Integer":
        """
        * Deallocates the storage retained on the free list and clears the list. Returns non-zero if some memory has been actually freed.
        	:rtype: int
        """
        return _Standard.standard_Purge(*args)

    Purge = staticmethod(Purge)

    def Reallocate(*args) -> "Standard_Address":
        """
        * Reallocates memory blocks aStorage - previously allocated memory block aNewSize - new size in bytes
        	:param aStorage:
        	:type aStorage: Standard_Address
        	:param aNewSize:
        	:type aNewSize: Standard_Size
        	:rtype: Standard_Address
        """
        return _Standard.standard_Reallocate(*args)

    Reallocate = staticmethod(Reallocate)

    __repr__ = _dumps_object


    def __init__(self):
        _Standard.standard_swiginit(self, _Standard.new_standard())
    __swig_destroy__ = _Standard.delete_standard
standard_swigregister = _Standard.standard_swigregister
standard_swigregister(standard)

def standard_Allocate(*args) -> "Standard_Address":
    """
    * Allocates memory blocks aSize - bytes to allocate
    	:param aSize:
    	:type aSize: Standard_Size
    	:rtype: Standard_Address
    """
    return _Standard.standard_Allocate(*args)

def standard_AllocateAligned(*args) -> "Standard_Address":
    """
    * Allocates aligned memory blocks. Should be used with CPU instructions which require specific alignment. For example: SSE requires 16 bytes, AVX requires 32 bytes. @param theSize bytes to allocate @param theAlign alignment in bytes
    	:param theSize:
    	:type theSize: Standard_Size
    	:param theAlign:
    	:type theAlign: Standard_Size
    	:rtype: Standard_Address
    """
    return _Standard.standard_AllocateAligned(*args)

def standard_Purge(*args) -> "Standard_Integer":
    """
    * Deallocates the storage retained on the free list and clears the list. Returns non-zero if some memory has been actually freed.
    	:rtype: int
    """
    return _Standard.standard_Purge(*args)

def standard_Reallocate(*args) -> "Standard_Address":
    """
    * Reallocates memory blocks aStorage - previously allocated memory block aNewSize - new size in bytes
    	:param aStorage:
    	:type aStorage: Standard_Address
    	:param aNewSize:
    	:type aNewSize: Standard_Size
    	:rtype: Standard_Address
    """
    return _Standard.standard_Reallocate(*args)

class Standard_ArrayStreamBuffer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args) -> "void":
        """
        * (Re)-initialize the stream. Passed pointer is stored as is (memory is NOT copied nor released with destructor). @param theBegin pointer to the beggining of pre-allocated buffer @param theSize length of pre-allocated buffer
        	:param theBegin:
        	:type theBegin: char *
        	:param theSize:
        	:type theSize: size_t
        	:rtype: void
        """
        return _Standard.Standard_ArrayStreamBuffer_Init(self, *args)


    def __init__(self, *args):
        """
        * Main constructor. Passed pointer is stored as is (memory is NOT copied nor released with destructor). @param theBegin pointer to the beggining of pre-allocated buffer @param theSize length of pre-allocated buffer
        	:param theBegin:
        	:type theBegin: char *
        	:param theSize:
        	:type theSize: size_t
        	:rtype: None
        """
        _Standard.Standard_ArrayStreamBuffer_swiginit(self, _Standard.new_Standard_ArrayStreamBuffer(*args))

    def xsgetn(self, *args) -> "std::streamsize":
        """
        * Read a bunch of bytes at once.
        	:param thePtr:
        	:type thePtr: char *
        	:param theCount:
        	:type theCount: std::streamsize
        	:rtype: std::streamsize
        """
        return _Standard.Standard_ArrayStreamBuffer_xsgetn(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_ArrayStreamBuffer
Standard_ArrayStreamBuffer.Init = new_instancemethod(_Standard.Standard_ArrayStreamBuffer_Init, None, Standard_ArrayStreamBuffer)
Standard_ArrayStreamBuffer.xsgetn = new_instancemethod(_Standard.Standard_ArrayStreamBuffer_xsgetn, None, Standard_ArrayStreamBuffer)
Standard_ArrayStreamBuffer_swigregister = _Standard.Standard_ArrayStreamBuffer_swigregister
Standard_ArrayStreamBuffer_swigregister(Standard_ArrayStreamBuffer)

class Standard_Condition(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Check(self, *args) -> "bool":
        """
        * Do not wait for signal - just test it state. returns true if get event
        	:rtype: bool
        """
        return _Standard.Standard_Condition_Check(self, *args)


    def CheckReset(self, *args) -> "bool":
        """
        * Method perform two steps at-once - reset the event object and returns true if it was in signaling state. returns true if event object was in signaling state.
        	:rtype: bool
        """
        return _Standard.Standard_Condition_CheckReset(self, *args)


    def Reset(self, *args) -> "void":
        """
        * Reset event (unset signaling state)
        	:rtype: None
        """
        return _Standard.Standard_Condition_Reset(self, *args)


    def Set(self, *args) -> "void":
        """
        * Set event into signaling state.
        	:rtype: None
        """
        return _Standard.Standard_Condition_Set(self, *args)


    def __init__(self, *args):
        """
        * Default constructor. @param theIsSet Initial flag state
        	:param theIsSet:
        	:type theIsSet: bool
        	:rtype: None
        """
        _Standard.Standard_Condition_swiginit(self, _Standard.new_Standard_Condition(*args))

    def Wait(self, *args) -> "bool":
        """
        * Wait for Event (infinity).
        	:rtype: None
        * Wait for signal requested time. @param theTimeMilliseconds wait limit in milliseconds returns true if get event
        	:param theTimeMilliseconds:
        	:type theTimeMilliseconds: int
        	:rtype: bool
        """
        return _Standard.Standard_Condition_Wait(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_Condition
Standard_Condition.Check = new_instancemethod(_Standard.Standard_Condition_Check, None, Standard_Condition)
Standard_Condition.CheckReset = new_instancemethod(_Standard.Standard_Condition_CheckReset, None, Standard_Condition)
Standard_Condition.Reset = new_instancemethod(_Standard.Standard_Condition_Reset, None, Standard_Condition)
Standard_Condition.Set = new_instancemethod(_Standard.Standard_Condition_Set, None, Standard_Condition)
Standard_Condition.Wait = new_instancemethod(_Standard.Standard_Condition_Wait, None, Standard_Condition)
Standard_Condition_swigregister = _Standard.Standard_Condition_swigregister
Standard_Condition_swigregister(Standard_Condition)

class Standard_ErrorHandler(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Catches(self, *args) -> "Standard_Boolean":
        """
        * Returns 'True' if the caught exception has the same type or inherits from 'aType'
        	:param aType:
        	:type aType: Standard_Type
        	:rtype: bool
        """
        return _Standard.Standard_ErrorHandler_Catches(self, *args)


    def Destroy(self, *args) -> "void":
        """
        * Unlinks and checks if there is a raised exception.
        	:rtype: None
        """
        return _Standard.Standard_ErrorHandler_Destroy(self, *args)


    def Error(self, *args) -> "opencascade::handle< Standard_Failure >":
        """
        * Returns the current Error.
        	:rtype: opencascade::handle<Standard_Failure>
        """
        return _Standard.Standard_ErrorHandler_Error(self, *args)


    def IsInTryBlock(*args) -> "Standard_Boolean":
        """
        * Test if the code is currently running in a try block
        	:rtype: bool
        """
        return _Standard.Standard_ErrorHandler_IsInTryBlock(*args)

    IsInTryBlock = staticmethod(IsInTryBlock)

    def Label(self, *args) -> "Standard_JmpBuf &":
        """
        * Returns label for jump
        	:rtype: Standard_JmpBuf
        """
        return _Standard.Standard_ErrorHandler_Label(self, *args)


    def LastCaughtError(*args) -> "opencascade::handle< Standard_Failure >":
        """
        * Returns the caught exception.
        	:rtype: opencascade::handle<Standard_Failure>
        """
        return _Standard.Standard_ErrorHandler_LastCaughtError(*args)

    LastCaughtError = staticmethod(LastCaughtError)

    def __init__(self, *args):
        """
        * Create a ErrorHandler (to be used with try{}catch(){}). It uses the 'setjmp' and 'longjmp' routines.
        	:rtype: None
        """
        _Standard.Standard_ErrorHandler_swiginit(self, _Standard.new_Standard_ErrorHandler(*args))

    def Unlink(self, *args) -> "void":
        """
        * Removes handler from the handlers list
        	:rtype: None
        """
        return _Standard.Standard_ErrorHandler_Unlink(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_ErrorHandler
Standard_ErrorHandler.Catches = new_instancemethod(_Standard.Standard_ErrorHandler_Catches, None, Standard_ErrorHandler)
Standard_ErrorHandler.Destroy = new_instancemethod(_Standard.Standard_ErrorHandler_Destroy, None, Standard_ErrorHandler)
Standard_ErrorHandler.Error = new_instancemethod(_Standard.Standard_ErrorHandler_Error, None, Standard_ErrorHandler)
Standard_ErrorHandler.Label = new_instancemethod(_Standard.Standard_ErrorHandler_Label, None, Standard_ErrorHandler)
Standard_ErrorHandler.Unlink = new_instancemethod(_Standard.Standard_ErrorHandler_Unlink, None, Standard_ErrorHandler)
Standard_ErrorHandler_swigregister = _Standard.Standard_ErrorHandler_swigregister
Standard_ErrorHandler_swigregister(Standard_ErrorHandler)

def Standard_ErrorHandler_IsInTryBlock(*args) -> "Standard_Boolean":
    """
    * Test if the code is currently running in a try block
    	:rtype: bool
    """
    return _Standard.Standard_ErrorHandler_IsInTryBlock(*args)

def Standard_ErrorHandler_LastCaughtError(*args) -> "opencascade::handle< Standard_Failure >":
    """
    * Returns the caught exception.
    	:rtype: opencascade::handle<Standard_Failure>
    """
    return _Standard.Standard_ErrorHandler_LastCaughtError(*args)

class Standard_GUID(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Assign(self, *args) -> "void":
        """
        :param uid:
        	:type uid: Standard_GUID
        	:rtype: None
        :param uid:
        	:type uid: Standard_UUID
        	:rtype: None
        """
        return _Standard.Standard_GUID_Assign(self, *args)


    def CheckGUIDFormat(*args) -> "Standard_Boolean":
        """
        * Check the format of a GUID string. It checks the size, the position of the '-' and the correct size of fields.
        	:param aGuid:
        	:type aGuid: char *
        	:rtype: bool
        """
        return _Standard.Standard_GUID_CheckGUIDFormat(*args)

    CheckGUIDFormat = staticmethod(CheckGUIDFormat)

    def Hash(self, *args) -> "Standard_Integer":
        """
        * Hash function for GUID.
        	:param Upper:
        	:type Upper: int
        	:rtype: int
        """
        return _Standard.Standard_GUID_Hash(self, *args)


    def HashCode(*args) -> "Standard_Integer":
        """
        * Computes a hash code for the given GUID of the Standard_Integer type, in the range [1, theUpperBound] @param theGUID the GUID which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
        	:param theGUID:
        	:type theGUID: Standard_GUID
        	:param theUpperBound:
        	:type theUpperBound: int
        	:rtype: int
        """
        return _Standard.Standard_GUID_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        * Returns True when the two GUID are the same.
        	:param string1:
        	:type string1: Standard_GUID
        	:param string2:
        	:type string2: Standard_GUID
        	:rtype: bool
        """
        return _Standard.Standard_GUID_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def IsNotSame(self, *args) -> "Standard_Boolean":
        """
        :param uid:
        	:type uid: Standard_GUID
        	:rtype: bool
        """
        return _Standard.Standard_GUID_IsNotSame(self, *args)


    def IsSame(self, *args) -> "Standard_Boolean":
        """
        :param uid:
        	:type uid: Standard_GUID
        	:rtype: bool
        """
        return _Standard.Standard_GUID_IsSame(self, *args)


    def ShallowDumpToString(self) -> "std::string":
        """ShallowDumpToString(Standard_GUID self) -> std::string"""
        return _Standard.Standard_GUID_ShallowDumpToString(self)


    def __init__(self, *args):
        """
        :rtype: None
        * build a GUID from an ascii string with the following format: Length : 36 char '00000000-0000-0000-0000-000000000000'
        	:param aGuid:
        	:type aGuid: char *
        	:rtype: None
        * build a GUID from an unicode string with the following format: //! '00000000-0000-0000-0000-000000000000'
        	:param aGuid:
        	:type aGuid: Standard_ExtString
        	:rtype: None
        :param a32b:
        	:type a32b: int
        	:param a16b1:
        	:type a16b1: Standard_ExtCharacter
        	:param a16b2:
        	:type a16b2: Standard_ExtCharacter
        	:param a16b3:
        	:type a16b3: Standard_ExtCharacter
        	:param a8b1:
        	:type a8b1: Standard_Byte
        	:param a8b2:
        	:type a8b2: Standard_Byte
        	:param a8b3:
        	:type a8b3: Standard_Byte
        	:param a8b4:
        	:type a8b4: Standard_Byte
        	:param a8b5:
        	:type a8b5: Standard_Byte
        	:param a8b6:
        	:type a8b6: Standard_Byte
        	:rtype: None
        :param aGuid:
        	:type aGuid: Standard_UUID
        	:rtype: None
        :param aGuid:
        	:type aGuid: Standard_GUID
        	:rtype: None
        """
        _Standard.Standard_GUID_swiginit(self, _Standard.new_Standard_GUID(*args))

    def ToCString(self, *args) -> "void":
        """
        * translate the GUID into ascii string the aStrGuid is allocated by user. the guid have the following format: //! '00000000-0000-0000-0000-000000000000'
        	:param aStrGuid:
        	:type aStrGuid: Standard_PCharacter
        	:rtype: None
        """
        return _Standard.Standard_GUID_ToCString(self, *args)


    def ToExtString(self, *args) -> "void":
        """
        * translate the GUID into unicode string the aStrGuid is allocated by user. the guid have the following format: //! '00000000-0000-0000-0000-000000000000'
        	:param aStrGuid:
        	:type aStrGuid: Standard_PExtCharacter
        	:rtype: None
        """
        return _Standard.Standard_GUID_ToExtString(self, *args)


    def ToUUID(self, *args) -> "Standard_UUID":
        """:rtype: Standard_UUID"""
        return _Standard.Standard_GUID_ToUUID(self, *args)


    def Set(self, *args) -> "void":
        """
        :param uid:
        	:type uid: Standard_GUID
        	:rtype: None
        :param uid:
        	:type uid: Standard_UUID
        	:rtype: None
        """
        return _Standard.Standard_GUID_Set(self, *args)


    def __eq_wrapper__(self, other: 'Standard_GUID') -> "bool":
        """__eq_wrapper__(Standard_GUID self, Standard_GUID other) -> bool"""
        return _Standard.Standard_GUID___eq_wrapper__(self, other)


    def __eq__(self, right):
        try:
            return self.__eq_wrapper__(right)
        except:
            return False


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_GUID
Standard_GUID.Assign = new_instancemethod(_Standard.Standard_GUID_Assign, None, Standard_GUID)
Standard_GUID.Hash = new_instancemethod(_Standard.Standard_GUID_Hash, None, Standard_GUID)
Standard_GUID.IsNotSame = new_instancemethod(_Standard.Standard_GUID_IsNotSame, None, Standard_GUID)
Standard_GUID.IsSame = new_instancemethod(_Standard.Standard_GUID_IsSame, None, Standard_GUID)
Standard_GUID.ShallowDumpToString = new_instancemethod(_Standard.Standard_GUID_ShallowDumpToString, None, Standard_GUID)
Standard_GUID.ToCString = new_instancemethod(_Standard.Standard_GUID_ToCString, None, Standard_GUID)
Standard_GUID.ToExtString = new_instancemethod(_Standard.Standard_GUID_ToExtString, None, Standard_GUID)
Standard_GUID.ToUUID = new_instancemethod(_Standard.Standard_GUID_ToUUID, None, Standard_GUID)
Standard_GUID.Set = new_instancemethod(_Standard.Standard_GUID_Set, None, Standard_GUID)
Standard_GUID.__eq_wrapper__ = new_instancemethod(_Standard.Standard_GUID___eq_wrapper__, None, Standard_GUID)
Standard_GUID_swigregister = _Standard.Standard_GUID_swigregister
Standard_GUID_swigregister(Standard_GUID)

def Standard_GUID_CheckGUIDFormat(*args) -> "Standard_Boolean":
    """
    * Check the format of a GUID string. It checks the size, the position of the '-' and the correct size of fields.
    	:param aGuid:
    	:type aGuid: char *
    	:rtype: bool
    """
    return _Standard.Standard_GUID_CheckGUIDFormat(*args)

def Standard_GUID_HashCode(*args) -> "Standard_Integer":
    """
    * Computes a hash code for the given GUID of the Standard_Integer type, in the range [1, theUpperBound] @param theGUID the GUID which hash code is to be computed @param theUpperBound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theUpperBound]
    	:param theGUID:
    	:type theGUID: Standard_GUID
    	:param theUpperBound:
    	:type theUpperBound: int
    	:rtype: int
    """
    return _Standard.Standard_GUID_HashCode(*args)

def Standard_GUID_IsEqual(*args) -> "Standard_Boolean":
    """
    * Returns True when the two GUID are the same.
    	:param string1:
    	:type string1: Standard_GUID
    	:param string2:
    	:type string2: Standard_GUID
    	:rtype: bool
    """
    return _Standard.Standard_GUID_IsEqual(*args)

class Standard_MMgrRoot(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Allocate(self, *args) -> "Standard_Address":
        """
        * Allocate specified number of bytes. The actually allocated space should be rounded up to double word size (4 bytes), as this is expected by implementation of some classes in OCC (e.g. TCollection_AsciiString)
        	:param theSize:
        	:type theSize: Standard_Size
        	:rtype: Standard_Address
        """
        return _Standard.Standard_MMgrRoot_Allocate(self, *args)


    def Free(self, *args) -> "void":
        """
        * Frees previously allocated memory at specified address.
        	:param thePtr:
        	:type thePtr: Standard_Address
        	:rtype: void
        """
        return _Standard.Standard_MMgrRoot_Free(self, *args)


    def Purge(self, *args) -> "Standard_Integer":
        """
        * Purge internally cached unused memory blocks (if any) by releasing them to the operating system. Must return non-zero if some memory has been actually released, or zero otherwise. If option isDestroyed is True, this means that memory manager is not expected to be used any more; note however that in general case it is still possible to have calls to that instance of memory manager after this (e.g. to free memory of static objects in OCC). Thus this option should command the memory manager to release any cached memory to the system and not cache any more, but still remain operable... //! Default implementation does nothing and returns 0.
        	:param isDestroyed: default value is Standard_False
        	:type isDestroyed: bool
        	:rtype: int
        """
        return _Standard.Standard_MMgrRoot_Purge(self, *args)


    def Reallocate(self, *args) -> "Standard_Address":
        """
        * Reallocate previously allocated memory to contain at least theSize bytes. In case of success, new pointer is returned.
        	:param thePtr:
        	:type thePtr: Standard_Address
        	:param theSize:
        	:type theSize: Standard_Size
        	:rtype: Standard_Address
        """
        return _Standard.Standard_MMgrRoot_Reallocate(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_MMgrRoot
Standard_MMgrRoot.Allocate = new_instancemethod(_Standard.Standard_MMgrRoot_Allocate, None, Standard_MMgrRoot)
Standard_MMgrRoot.Free = new_instancemethod(_Standard.Standard_MMgrRoot_Free, None, Standard_MMgrRoot)
Standard_MMgrRoot.Purge = new_instancemethod(_Standard.Standard_MMgrRoot_Purge, None, Standard_MMgrRoot)
Standard_MMgrRoot.Reallocate = new_instancemethod(_Standard.Standard_MMgrRoot_Reallocate, None, Standard_MMgrRoot)
Standard_MMgrRoot_swigregister = _Standard.Standard_MMgrRoot_swigregister
Standard_MMgrRoot_swigregister(Standard_MMgrRoot)

class Standard_Transient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DecrementRefCounter(self, *args) -> "Standard_Integer":
        """
        * Decrements the reference counter of this object; returns the decremented value
        	:rtype: int
        """
        return _Standard.Standard_Transient_DecrementRefCounter(self, *args)


    def Delete(self, *args) -> "void":
        """
        * Memory deallocator for transient classes
        	:rtype: void
        """
        return _Standard.Standard_Transient_Delete(self, *args)


    def DynamicType(self, *args) -> "opencascade::handle< Standard_Type > const &":
        """
        * Returns a type descriptor about this object.
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _Standard.Standard_Transient_DynamicType(self, *args)


    def GetRefCount(self, *args) -> "Standard_Integer":
        """
        * //!@name Reference counting, for use by handle<> Get the reference counter of this object
        	:rtype: int
        """
        return _Standard.Standard_Transient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args) -> "void":
        """
        * Increments the reference counter of this object
        	:rtype: None
        """
        return _Standard.Standard_Transient_IncrementRefCounter(self, *args)


    def IsInstance(self, *args) -> "Standard_Boolean":
        """
        * Returns a true value if this is an instance of Type.
        	:param theType:
        	:type theType: Standard_Type
        	:rtype: bool
        * Returns a true value if this is an instance of TypeName.
        	:param theTypeName:
        	:type theTypeName: char *
        	:rtype: bool
        """
        return _Standard.Standard_Transient_IsInstance(self, *args)


    def IsKind(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this is an instance of Type or an instance of any class that inherits from Type. Note that multiple inheritance is not supported by OCCT RTTI mechanism.
        	:param theType:
        	:type theType: Standard_Type
        	:rtype: bool
        * Returns true if this is an instance of TypeName or an instance of any class that inherits from TypeName. Note that multiple inheritance is not supported by OCCT RTTI mechanism.
        	:param theTypeName:
        	:type theTypeName: char *
        	:rtype: bool
        """
        return _Standard.Standard_Transient_IsKind(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor
        	:rtype: None
        * Copy constructor -- does nothing
        	:param &:
        	:type &: Standard_Transient
        	:rtype: None
        """
        _Standard.Standard_Transient_swiginit(self, _Standard.new_Standard_Transient(*args))

    def This(self, *args) -> "Standard_Transient *":
        """
        * Returns non-const pointer to this object (like const_cast). For protection against creating handle to objects allocated in stack or call from constructor, it will raise exception Standard_ProgramError if reference counter is zero.
        	:rtype: Standard_Transient *
        """
        return _Standard.Standard_Transient_This(self, *args)


    def get_type_descriptor(*args) -> "opencascade::handle< Standard_Type > const &":
        """
        * Returns type descriptor of Standard_Transient class
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _Standard.Standard_Transient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def get_type_name(*args) -> "char const *":
        """:rtype: char *"""
        return _Standard.Standard_Transient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)


    @staticmethod
    def DownCast(t):
      return Handle_Standard_Transient_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_Transient
Standard_Transient.DecrementRefCounter = new_instancemethod(_Standard.Standard_Transient_DecrementRefCounter, None, Standard_Transient)
Standard_Transient.Delete = new_instancemethod(_Standard.Standard_Transient_Delete, None, Standard_Transient)
Standard_Transient.DynamicType = new_instancemethod(_Standard.Standard_Transient_DynamicType, None, Standard_Transient)
Standard_Transient.GetRefCount = new_instancemethod(_Standard.Standard_Transient_GetRefCount, None, Standard_Transient)
Standard_Transient.IncrementRefCounter = new_instancemethod(_Standard.Standard_Transient_IncrementRefCounter, None, Standard_Transient)
Standard_Transient.IsInstance = new_instancemethod(_Standard.Standard_Transient_IsInstance, None, Standard_Transient)
Standard_Transient.IsKind = new_instancemethod(_Standard.Standard_Transient_IsKind, None, Standard_Transient)
Standard_Transient.This = new_instancemethod(_Standard.Standard_Transient_This, None, Standard_Transient)
Standard_Transient_swigregister = _Standard.Standard_Transient_swigregister
Standard_Transient_swigregister(Standard_Transient)

def Standard_Transient_get_type_descriptor(*args) -> "opencascade::handle< Standard_Type > const &":
    """
    * Returns type descriptor of Standard_Transient class
    	:rtype: opencascade::handle<Standard_Type>
    """
    return _Standard.Standard_Transient_get_type_descriptor(*args)

def Standard_Transient_get_type_name(*args) -> "char const *":
    """:rtype: char *"""
    return _Standard.Standard_Transient_get_type_name(*args)

class Standard_MMgrOpt(Standard_MMgrRoot):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor. If aClear is True, the allocated emmory will be nullified. For description of other parameters, see description of the class above.
        	:param aClear: default value is Standard_True
        	:type aClear: bool
        	:param aMMap: default value is Standard_True
        	:type aMMap: bool
        	:param aCellSize: default value is 200
        	:type aCellSize: Standard_Size
        	:param aNbPages: default value is 10000
        	:type aNbPages: int
        	:param aThreshold: default value is 40000
        	:type aThreshold: Standard_Size
        	:rtype: None
        """
        _Standard.Standard_MMgrOpt_swiginit(self, _Standard.new_Standard_MMgrOpt(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_MMgrOpt
Standard_MMgrOpt_swigregister = _Standard.Standard_MMgrOpt_swigregister
Standard_MMgrOpt_swigregister(Standard_MMgrOpt)

class Standard_MMgrRaw(Standard_MMgrRoot):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor; if aClear is True, the memory will be nullified upon allocation.
        	:param aClear: default value is Standard_False
        	:type aClear: bool
        	:rtype: None
        """
        _Standard.Standard_MMgrRaw_swiginit(self, _Standard.new_Standard_MMgrRaw(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_MMgrRaw
Standard_MMgrRaw_swigregister = _Standard.Standard_MMgrRaw_swigregister
Standard_MMgrRaw_swigregister(Standard_MMgrRaw)

class Standard_MMgrTBBalloc(Standard_MMgrRoot):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Constructor; if aClear is True, the memory will be nullified upon allocation.
        	:param aClear: default value is Standard_False
        	:type aClear: bool
        	:rtype: None
        """
        _Standard.Standard_MMgrTBBalloc_swiginit(self, _Standard.new_Standard_MMgrTBBalloc(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_MMgrTBBalloc
Standard_MMgrTBBalloc_swigregister = _Standard.Standard_MMgrTBBalloc_swigregister
Standard_MMgrTBBalloc_swigregister(Standard_MMgrTBBalloc)

class Standard_OutOfMemory(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetMessageString(self, *args) -> "char const *":
        """
        * Returns error message
        	:rtype: char *
        """
        return _Standard.Standard_OutOfMemory_GetMessageString(self, *args)


    def NewInstance(*args) -> "opencascade::handle< Standard_OutOfMemory >":
        """
        * Returns global instance of exception
        	:param theMessage: default value is 
        	:type theMessage: char *
        	:rtype: opencascade::handle<Standard_OutOfMemory>
        """
        return _Standard.Standard_OutOfMemory_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def Raise(*args) -> "void":
        """
        * Raises exception with specified message string
        	:param theMessage: default value is 
        	:type theMessage: char *
        	:rtype: void
        * Raises exception with specified message string
        	:param theMessage:
        	:type theMessage: Standard_SStream
        	:rtype: void
        """
        return _Standard.Standard_OutOfMemory_Raise(*args)

    Raise = staticmethod(Raise)

    def SetMessageString(self, *args) -> "void":
        """
        * Sets error message
        	:param aMessage:
        	:type aMessage: char *
        	:rtype: None
        """
        return _Standard.Standard_OutOfMemory_SetMessageString(self, *args)


    def __init__(self, *args):
        """
        * Constructor is kept public for backward compatibility
        	:param theMessage: default value is 0
        	:type theMessage: char *
        	:rtype: None
        """
        _Standard.Standard_OutOfMemory_swiginit(self, _Standard.new_Standard_OutOfMemory(*args))


    @staticmethod
    def DownCast(t):
      return Handle_Standard_OutOfMemory_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_OutOfMemory
Standard_OutOfMemory.GetMessageString = new_instancemethod(_Standard.Standard_OutOfMemory_GetMessageString, None, Standard_OutOfMemory)
Standard_OutOfMemory.SetMessageString = new_instancemethod(_Standard.Standard_OutOfMemory_SetMessageString, None, Standard_OutOfMemory)
Standard_OutOfMemory_swigregister = _Standard.Standard_OutOfMemory_swigregister
Standard_OutOfMemory_swigregister(Standard_OutOfMemory)

def Standard_OutOfMemory_NewInstance(*args) -> "opencascade::handle< Standard_OutOfMemory >":
    """
    * Returns global instance of exception
    	:param theMessage: default value is 
    	:type theMessage: char *
    	:rtype: opencascade::handle<Standard_OutOfMemory>
    """
    return _Standard.Standard_OutOfMemory_NewInstance(*args)

def Standard_OutOfMemory_Raise(*args) -> "void":
    """
    * Raises exception with specified message string
    	:param theMessage: default value is 
    	:type theMessage: char *
    	:rtype: void
    * Raises exception with specified message string
    	:param theMessage:
    	:type theMessage: Standard_SStream
    	:rtype: void
    """
    return _Standard.Standard_OutOfMemory_Raise(*args)

class Standard_Persistent(Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _Standard.Standard_Persistent_swiginit(self, _Standard.new_Standard_Persistent(*args))

    def GetTypeNum(self) -> "Standard_Integer":
        """GetTypeNum(Standard_Persistent self) -> Standard_Integer"""
        return _Standard.Standard_Persistent_GetTypeNum(self)


    def SetTypeNum(self, value: 'Standard_Integer') -> "void":
        """SetTypeNum(Standard_Persistent self, Standard_Integer value)"""
        return _Standard.Standard_Persistent_SetTypeNum(self, value)



    @staticmethod
    def DownCast(t):
      return Handle_Standard_Persistent_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Standard.delete_Standard_Persistent
Standard_Persistent.GetTypeNum = new_instancemethod(_Standard.Standard_Persistent_GetTypeNum, None, Standard_Persistent)
Standard_Persistent.SetTypeNum = new_instancemethod(_Standard.Standard_Persistent_SetTypeNum, None, Standard_Persistent)
Standard_Persistent_swigregister = _Standard.Standard_Persistent_swigregister
Standard_Persistent_swigregister(Standard_Persistent)



