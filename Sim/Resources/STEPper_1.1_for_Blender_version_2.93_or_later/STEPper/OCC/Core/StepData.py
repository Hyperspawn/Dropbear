# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
StepData module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_stepdata.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _StepData.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StepData')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StepData')
    _StepData = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StepData', [dirname(__file__)])
        except ImportError:
            import _StepData
            return _StepData
        try:
            _mod = imp.load_module('_StepData', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StepData = swig_import_helper()
    del swig_import_helper
else:
    import _StepData
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StepData.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_StepData.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_StepData.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_StepData.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_StepData.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_StepData.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_StepData.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_StepData.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_StepData.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_StepData.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_StepData.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_StepData.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_StepData.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_StepData.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_StepData.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_StepData.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_StepData.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _StepData.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _StepData.process_exception(error, method_name, class_name)
process_exception = _StepData.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Interface
import OCC.Core.TCollection
import OCC.Core.TColStd
import OCC.Core.Message
import OCC.Core.MoniTool
import OCC.Core.TopoDS
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.OSD
StepData_LFalse = _StepData.StepData_LFalse
StepData_LTrue = _StepData.StepData_LTrue
StepData_LUnknown = _StepData.StepData_LUnknown

def Handle_StepData_Described_Create() -> "opencascade::handle< StepData_Described >":
    return _StepData.Handle_StepData_Described_Create()
Handle_StepData_Described_Create = _StepData.Handle_StepData_Described_Create

def Handle_StepData_Described_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_Described >":
    return _StepData.Handle_StepData_Described_DownCast(t)
Handle_StepData_Described_DownCast = _StepData.Handle_StepData_Described_DownCast

def Handle_StepData_Described_IsNull(t: 'opencascade::handle< StepData_Described > const &') -> "bool":
    return _StepData.Handle_StepData_Described_IsNull(t)
Handle_StepData_Described_IsNull = _StepData.Handle_StepData_Described_IsNull

def Handle_StepData_EDescr_Create() -> "opencascade::handle< StepData_EDescr >":
    return _StepData.Handle_StepData_EDescr_Create()
Handle_StepData_EDescr_Create = _StepData.Handle_StepData_EDescr_Create

def Handle_StepData_EDescr_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_EDescr >":
    return _StepData.Handle_StepData_EDescr_DownCast(t)
Handle_StepData_EDescr_DownCast = _StepData.Handle_StepData_EDescr_DownCast

def Handle_StepData_EDescr_IsNull(t: 'opencascade::handle< StepData_EDescr > const &') -> "bool":
    return _StepData.Handle_StepData_EDescr_IsNull(t)
Handle_StepData_EDescr_IsNull = _StepData.Handle_StepData_EDescr_IsNull

def Handle_StepData_FileRecognizer_Create() -> "opencascade::handle< StepData_FileRecognizer >":
    return _StepData.Handle_StepData_FileRecognizer_Create()
Handle_StepData_FileRecognizer_Create = _StepData.Handle_StepData_FileRecognizer_Create

def Handle_StepData_FileRecognizer_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_FileRecognizer >":
    return _StepData.Handle_StepData_FileRecognizer_DownCast(t)
Handle_StepData_FileRecognizer_DownCast = _StepData.Handle_StepData_FileRecognizer_DownCast

def Handle_StepData_FileRecognizer_IsNull(t: 'opencascade::handle< StepData_FileRecognizer > const &') -> "bool":
    return _StepData.Handle_StepData_FileRecognizer_IsNull(t)
Handle_StepData_FileRecognizer_IsNull = _StepData.Handle_StepData_FileRecognizer_IsNull

def Handle_StepData_GeneralModule_Create() -> "opencascade::handle< StepData_GeneralModule >":
    return _StepData.Handle_StepData_GeneralModule_Create()
Handle_StepData_GeneralModule_Create = _StepData.Handle_StepData_GeneralModule_Create

def Handle_StepData_GeneralModule_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_GeneralModule >":
    return _StepData.Handle_StepData_GeneralModule_DownCast(t)
Handle_StepData_GeneralModule_DownCast = _StepData.Handle_StepData_GeneralModule_DownCast

def Handle_StepData_GeneralModule_IsNull(t: 'opencascade::handle< StepData_GeneralModule > const &') -> "bool":
    return _StepData.Handle_StepData_GeneralModule_IsNull(t)
Handle_StepData_GeneralModule_IsNull = _StepData.Handle_StepData_GeneralModule_IsNull

def Handle_StepData_GlobalNodeOfWriterLib_Create() -> "opencascade::handle< StepData_GlobalNodeOfWriterLib >":
    return _StepData.Handle_StepData_GlobalNodeOfWriterLib_Create()
Handle_StepData_GlobalNodeOfWriterLib_Create = _StepData.Handle_StepData_GlobalNodeOfWriterLib_Create

def Handle_StepData_GlobalNodeOfWriterLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_GlobalNodeOfWriterLib >":
    return _StepData.Handle_StepData_GlobalNodeOfWriterLib_DownCast(t)
Handle_StepData_GlobalNodeOfWriterLib_DownCast = _StepData.Handle_StepData_GlobalNodeOfWriterLib_DownCast

def Handle_StepData_GlobalNodeOfWriterLib_IsNull(t: 'opencascade::handle< StepData_GlobalNodeOfWriterLib > const &') -> "bool":
    return _StepData.Handle_StepData_GlobalNodeOfWriterLib_IsNull(t)
Handle_StepData_GlobalNodeOfWriterLib_IsNull = _StepData.Handle_StepData_GlobalNodeOfWriterLib_IsNull

def Handle_StepData_NodeOfWriterLib_Create() -> "opencascade::handle< StepData_NodeOfWriterLib >":
    return _StepData.Handle_StepData_NodeOfWriterLib_Create()
Handle_StepData_NodeOfWriterLib_Create = _StepData.Handle_StepData_NodeOfWriterLib_Create

def Handle_StepData_NodeOfWriterLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_NodeOfWriterLib >":
    return _StepData.Handle_StepData_NodeOfWriterLib_DownCast(t)
Handle_StepData_NodeOfWriterLib_DownCast = _StepData.Handle_StepData_NodeOfWriterLib_DownCast

def Handle_StepData_NodeOfWriterLib_IsNull(t: 'opencascade::handle< StepData_NodeOfWriterLib > const &') -> "bool":
    return _StepData.Handle_StepData_NodeOfWriterLib_IsNull(t)
Handle_StepData_NodeOfWriterLib_IsNull = _StepData.Handle_StepData_NodeOfWriterLib_IsNull

def Handle_StepData_PDescr_Create() -> "opencascade::handle< StepData_PDescr >":
    return _StepData.Handle_StepData_PDescr_Create()
Handle_StepData_PDescr_Create = _StepData.Handle_StepData_PDescr_Create

def Handle_StepData_PDescr_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_PDescr >":
    return _StepData.Handle_StepData_PDescr_DownCast(t)
Handle_StepData_PDescr_DownCast = _StepData.Handle_StepData_PDescr_DownCast

def Handle_StepData_PDescr_IsNull(t: 'opencascade::handle< StepData_PDescr > const &') -> "bool":
    return _StepData.Handle_StepData_PDescr_IsNull(t)
Handle_StepData_PDescr_IsNull = _StepData.Handle_StepData_PDescr_IsNull

def Handle_StepData_Protocol_Create() -> "opencascade::handle< StepData_Protocol >":
    return _StepData.Handle_StepData_Protocol_Create()
Handle_StepData_Protocol_Create = _StepData.Handle_StepData_Protocol_Create

def Handle_StepData_Protocol_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_Protocol >":
    return _StepData.Handle_StepData_Protocol_DownCast(t)
Handle_StepData_Protocol_DownCast = _StepData.Handle_StepData_Protocol_DownCast

def Handle_StepData_Protocol_IsNull(t: 'opencascade::handle< StepData_Protocol > const &') -> "bool":
    return _StepData.Handle_StepData_Protocol_IsNull(t)
Handle_StepData_Protocol_IsNull = _StepData.Handle_StepData_Protocol_IsNull

def Handle_StepData_ReadWriteModule_Create() -> "opencascade::handle< StepData_ReadWriteModule >":
    return _StepData.Handle_StepData_ReadWriteModule_Create()
Handle_StepData_ReadWriteModule_Create = _StepData.Handle_StepData_ReadWriteModule_Create

def Handle_StepData_ReadWriteModule_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_ReadWriteModule >":
    return _StepData.Handle_StepData_ReadWriteModule_DownCast(t)
Handle_StepData_ReadWriteModule_DownCast = _StepData.Handle_StepData_ReadWriteModule_DownCast

def Handle_StepData_ReadWriteModule_IsNull(t: 'opencascade::handle< StepData_ReadWriteModule > const &') -> "bool":
    return _StepData.Handle_StepData_ReadWriteModule_IsNull(t)
Handle_StepData_ReadWriteModule_IsNull = _StepData.Handle_StepData_ReadWriteModule_IsNull

def Handle_StepData_SelectMember_Create() -> "opencascade::handle< StepData_SelectMember >":
    return _StepData.Handle_StepData_SelectMember_Create()
Handle_StepData_SelectMember_Create = _StepData.Handle_StepData_SelectMember_Create

def Handle_StepData_SelectMember_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_SelectMember >":
    return _StepData.Handle_StepData_SelectMember_DownCast(t)
Handle_StepData_SelectMember_DownCast = _StepData.Handle_StepData_SelectMember_DownCast

def Handle_StepData_SelectMember_IsNull(t: 'opencascade::handle< StepData_SelectMember > const &') -> "bool":
    return _StepData.Handle_StepData_SelectMember_IsNull(t)
Handle_StepData_SelectMember_IsNull = _StepData.Handle_StepData_SelectMember_IsNull

def Handle_StepData_StepModel_Create() -> "opencascade::handle< StepData_StepModel >":
    return _StepData.Handle_StepData_StepModel_Create()
Handle_StepData_StepModel_Create = _StepData.Handle_StepData_StepModel_Create

def Handle_StepData_StepModel_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_StepModel >":
    return _StepData.Handle_StepData_StepModel_DownCast(t)
Handle_StepData_StepModel_DownCast = _StepData.Handle_StepData_StepModel_DownCast

def Handle_StepData_StepModel_IsNull(t: 'opencascade::handle< StepData_StepModel > const &') -> "bool":
    return _StepData.Handle_StepData_StepModel_IsNull(t)
Handle_StepData_StepModel_IsNull = _StepData.Handle_StepData_StepModel_IsNull

def Handle_StepData_StepReaderData_Create() -> "opencascade::handle< StepData_StepReaderData >":
    return _StepData.Handle_StepData_StepReaderData_Create()
Handle_StepData_StepReaderData_Create = _StepData.Handle_StepData_StepReaderData_Create

def Handle_StepData_StepReaderData_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_StepReaderData >":
    return _StepData.Handle_StepData_StepReaderData_DownCast(t)
Handle_StepData_StepReaderData_DownCast = _StepData.Handle_StepData_StepReaderData_DownCast

def Handle_StepData_StepReaderData_IsNull(t: 'opencascade::handle< StepData_StepReaderData > const &') -> "bool":
    return _StepData.Handle_StepData_StepReaderData_IsNull(t)
Handle_StepData_StepReaderData_IsNull = _StepData.Handle_StepData_StepReaderData_IsNull

def Handle_StepData_DefaultGeneral_Create() -> "opencascade::handle< StepData_DefaultGeneral >":
    return _StepData.Handle_StepData_DefaultGeneral_Create()
Handle_StepData_DefaultGeneral_Create = _StepData.Handle_StepData_DefaultGeneral_Create

def Handle_StepData_DefaultGeneral_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_DefaultGeneral >":
    return _StepData.Handle_StepData_DefaultGeneral_DownCast(t)
Handle_StepData_DefaultGeneral_DownCast = _StepData.Handle_StepData_DefaultGeneral_DownCast

def Handle_StepData_DefaultGeneral_IsNull(t: 'opencascade::handle< StepData_DefaultGeneral > const &') -> "bool":
    return _StepData.Handle_StepData_DefaultGeneral_IsNull(t)
Handle_StepData_DefaultGeneral_IsNull = _StepData.Handle_StepData_DefaultGeneral_IsNull

def Handle_StepData_ECDescr_Create() -> "opencascade::handle< StepData_ECDescr >":
    return _StepData.Handle_StepData_ECDescr_Create()
Handle_StepData_ECDescr_Create = _StepData.Handle_StepData_ECDescr_Create

def Handle_StepData_ECDescr_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_ECDescr >":
    return _StepData.Handle_StepData_ECDescr_DownCast(t)
Handle_StepData_ECDescr_DownCast = _StepData.Handle_StepData_ECDescr_DownCast

def Handle_StepData_ECDescr_IsNull(t: 'opencascade::handle< StepData_ECDescr > const &') -> "bool":
    return _StepData.Handle_StepData_ECDescr_IsNull(t)
Handle_StepData_ECDescr_IsNull = _StepData.Handle_StepData_ECDescr_IsNull

def Handle_StepData_ESDescr_Create() -> "opencascade::handle< StepData_ESDescr >":
    return _StepData.Handle_StepData_ESDescr_Create()
Handle_StepData_ESDescr_Create = _StepData.Handle_StepData_ESDescr_Create

def Handle_StepData_ESDescr_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_ESDescr >":
    return _StepData.Handle_StepData_ESDescr_DownCast(t)
Handle_StepData_ESDescr_DownCast = _StepData.Handle_StepData_ESDescr_DownCast

def Handle_StepData_ESDescr_IsNull(t: 'opencascade::handle< StepData_ESDescr > const &') -> "bool":
    return _StepData.Handle_StepData_ESDescr_IsNull(t)
Handle_StepData_ESDescr_IsNull = _StepData.Handle_StepData_ESDescr_IsNull

def Handle_StepData_FileProtocol_Create() -> "opencascade::handle< StepData_FileProtocol >":
    return _StepData.Handle_StepData_FileProtocol_Create()
Handle_StepData_FileProtocol_Create = _StepData.Handle_StepData_FileProtocol_Create

def Handle_StepData_FileProtocol_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_FileProtocol >":
    return _StepData.Handle_StepData_FileProtocol_DownCast(t)
Handle_StepData_FileProtocol_DownCast = _StepData.Handle_StepData_FileProtocol_DownCast

def Handle_StepData_FileProtocol_IsNull(t: 'opencascade::handle< StepData_FileProtocol > const &') -> "bool":
    return _StepData.Handle_StepData_FileProtocol_IsNull(t)
Handle_StepData_FileProtocol_IsNull = _StepData.Handle_StepData_FileProtocol_IsNull

def Handle_StepData_Plex_Create() -> "opencascade::handle< StepData_Plex >":
    return _StepData.Handle_StepData_Plex_Create()
Handle_StepData_Plex_Create = _StepData.Handle_StepData_Plex_Create

def Handle_StepData_Plex_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_Plex >":
    return _StepData.Handle_StepData_Plex_DownCast(t)
Handle_StepData_Plex_DownCast = _StepData.Handle_StepData_Plex_DownCast

def Handle_StepData_Plex_IsNull(t: 'opencascade::handle< StepData_Plex > const &') -> "bool":
    return _StepData.Handle_StepData_Plex_IsNull(t)
Handle_StepData_Plex_IsNull = _StepData.Handle_StepData_Plex_IsNull

def Handle_StepData_SelectInt_Create() -> "opencascade::handle< StepData_SelectInt >":
    return _StepData.Handle_StepData_SelectInt_Create()
Handle_StepData_SelectInt_Create = _StepData.Handle_StepData_SelectInt_Create

def Handle_StepData_SelectInt_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_SelectInt >":
    return _StepData.Handle_StepData_SelectInt_DownCast(t)
Handle_StepData_SelectInt_DownCast = _StepData.Handle_StepData_SelectInt_DownCast

def Handle_StepData_SelectInt_IsNull(t: 'opencascade::handle< StepData_SelectInt > const &') -> "bool":
    return _StepData.Handle_StepData_SelectInt_IsNull(t)
Handle_StepData_SelectInt_IsNull = _StepData.Handle_StepData_SelectInt_IsNull

def Handle_StepData_SelectNamed_Create() -> "opencascade::handle< StepData_SelectNamed >":
    return _StepData.Handle_StepData_SelectNamed_Create()
Handle_StepData_SelectNamed_Create = _StepData.Handle_StepData_SelectNamed_Create

def Handle_StepData_SelectNamed_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_SelectNamed >":
    return _StepData.Handle_StepData_SelectNamed_DownCast(t)
Handle_StepData_SelectNamed_DownCast = _StepData.Handle_StepData_SelectNamed_DownCast

def Handle_StepData_SelectNamed_IsNull(t: 'opencascade::handle< StepData_SelectNamed > const &') -> "bool":
    return _StepData.Handle_StepData_SelectNamed_IsNull(t)
Handle_StepData_SelectNamed_IsNull = _StepData.Handle_StepData_SelectNamed_IsNull

def Handle_StepData_SelectReal_Create() -> "opencascade::handle< StepData_SelectReal >":
    return _StepData.Handle_StepData_SelectReal_Create()
Handle_StepData_SelectReal_Create = _StepData.Handle_StepData_SelectReal_Create

def Handle_StepData_SelectReal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_SelectReal >":
    return _StepData.Handle_StepData_SelectReal_DownCast(t)
Handle_StepData_SelectReal_DownCast = _StepData.Handle_StepData_SelectReal_DownCast

def Handle_StepData_SelectReal_IsNull(t: 'opencascade::handle< StepData_SelectReal > const &') -> "bool":
    return _StepData.Handle_StepData_SelectReal_IsNull(t)
Handle_StepData_SelectReal_IsNull = _StepData.Handle_StepData_SelectReal_IsNull

def Handle_StepData_Simple_Create() -> "opencascade::handle< StepData_Simple >":
    return _StepData.Handle_StepData_Simple_Create()
Handle_StepData_Simple_Create = _StepData.Handle_StepData_Simple_Create

def Handle_StepData_Simple_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_Simple >":
    return _StepData.Handle_StepData_Simple_DownCast(t)
Handle_StepData_Simple_DownCast = _StepData.Handle_StepData_Simple_DownCast

def Handle_StepData_Simple_IsNull(t: 'opencascade::handle< StepData_Simple > const &') -> "bool":
    return _StepData.Handle_StepData_Simple_IsNull(t)
Handle_StepData_Simple_IsNull = _StepData.Handle_StepData_Simple_IsNull

def Handle_StepData_SelectArrReal_Create() -> "opencascade::handle< StepData_SelectArrReal >":
    return _StepData.Handle_StepData_SelectArrReal_Create()
Handle_StepData_SelectArrReal_Create = _StepData.Handle_StepData_SelectArrReal_Create

def Handle_StepData_SelectArrReal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_SelectArrReal >":
    return _StepData.Handle_StepData_SelectArrReal_DownCast(t)
Handle_StepData_SelectArrReal_DownCast = _StepData.Handle_StepData_SelectArrReal_DownCast

def Handle_StepData_SelectArrReal_IsNull(t: 'opencascade::handle< StepData_SelectArrReal > const &') -> "bool":
    return _StepData.Handle_StepData_SelectArrReal_IsNull(t)
Handle_StepData_SelectArrReal_IsNull = _StepData.Handle_StepData_SelectArrReal_IsNull

def Handle_StepData_HArray1OfField_Create() -> "opencascade::handle< StepData_HArray1OfField >":
    return _StepData.Handle_StepData_HArray1OfField_Create()
Handle_StepData_HArray1OfField_Create = _StepData.Handle_StepData_HArray1OfField_Create

def Handle_StepData_HArray1OfField_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< StepData_HArray1OfField >":
    return _StepData.Handle_StepData_HArray1OfField_DownCast(t)
Handle_StepData_HArray1OfField_DownCast = _StepData.Handle_StepData_HArray1OfField_DownCast

def Handle_StepData_HArray1OfField_IsNull(t: 'opencascade::handle< StepData_HArray1OfField > const &') -> "bool":
    return _StepData.Handle_StepData_HArray1OfField_IsNull(t)
Handle_StepData_HArray1OfField_IsNull = _StepData.Handle_StepData_HArray1OfField_IsNull
class StepData_Array1OfField(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _StepData.StepData_Array1OfField_swiginit(self, _StepData.new_StepData_Array1OfField(*args))
    __swig_destroy__ = _StepData.delete_StepData_Array1OfField

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

StepData_Array1OfField.begin = new_instancemethod(_StepData.StepData_Array1OfField_begin, None, StepData_Array1OfField)
StepData_Array1OfField.end = new_instancemethod(_StepData.StepData_Array1OfField_end, None, StepData_Array1OfField)
StepData_Array1OfField.cbegin = new_instancemethod(_StepData.StepData_Array1OfField_cbegin, None, StepData_Array1OfField)
StepData_Array1OfField.cend = new_instancemethod(_StepData.StepData_Array1OfField_cend, None, StepData_Array1OfField)
StepData_Array1OfField.Init = new_instancemethod(_StepData.StepData_Array1OfField_Init, None, StepData_Array1OfField)
StepData_Array1OfField.Size = new_instancemethod(_StepData.StepData_Array1OfField_Size, None, StepData_Array1OfField)
StepData_Array1OfField.Length = new_instancemethod(_StepData.StepData_Array1OfField_Length, None, StepData_Array1OfField)
StepData_Array1OfField.IsEmpty = new_instancemethod(_StepData.StepData_Array1OfField_IsEmpty, None, StepData_Array1OfField)
StepData_Array1OfField.Lower = new_instancemethod(_StepData.StepData_Array1OfField_Lower, None, StepData_Array1OfField)
StepData_Array1OfField.Upper = new_instancemethod(_StepData.StepData_Array1OfField_Upper, None, StepData_Array1OfField)
StepData_Array1OfField.IsDeletable = new_instancemethod(_StepData.StepData_Array1OfField_IsDeletable, None, StepData_Array1OfField)
StepData_Array1OfField.IsAllocated = new_instancemethod(_StepData.StepData_Array1OfField_IsAllocated, None, StepData_Array1OfField)
StepData_Array1OfField.Assign = new_instancemethod(_StepData.StepData_Array1OfField_Assign, None, StepData_Array1OfField)
StepData_Array1OfField.Move = new_instancemethod(_StepData.StepData_Array1OfField_Move, None, StepData_Array1OfField)
StepData_Array1OfField.Set = new_instancemethod(_StepData.StepData_Array1OfField_Set, None, StepData_Array1OfField)
StepData_Array1OfField.First = new_instancemethod(_StepData.StepData_Array1OfField_First, None, StepData_Array1OfField)
StepData_Array1OfField.ChangeFirst = new_instancemethod(_StepData.StepData_Array1OfField_ChangeFirst, None, StepData_Array1OfField)
StepData_Array1OfField.Last = new_instancemethod(_StepData.StepData_Array1OfField_Last, None, StepData_Array1OfField)
StepData_Array1OfField.ChangeLast = new_instancemethod(_StepData.StepData_Array1OfField_ChangeLast, None, StepData_Array1OfField)
StepData_Array1OfField.Value = new_instancemethod(_StepData.StepData_Array1OfField_Value, None, StepData_Array1OfField)
StepData_Array1OfField.ChangeValue = new_instancemethod(_StepData.StepData_Array1OfField_ChangeValue, None, StepData_Array1OfField)
StepData_Array1OfField.__call__ = new_instancemethod(_StepData.StepData_Array1OfField___call__, None, StepData_Array1OfField)
StepData_Array1OfField.SetValue = new_instancemethod(_StepData.StepData_Array1OfField_SetValue, None, StepData_Array1OfField)
StepData_Array1OfField.Resize = new_instancemethod(_StepData.StepData_Array1OfField_Resize, None, StepData_Array1OfField)
StepData_Array1OfField_swigregister = _StepData.StepData_Array1OfField_swigregister
StepData_Array1OfField_swigregister(StepData_Array1OfField)

class stepdata(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddHeaderProtocol(*args) -> "void":
        """
        * Adds a new Header Protocol to the Header Definition
        	:param headerproto:
        	:type headerproto: StepData_Protocol
        	:rtype: void
        """
        return _StepData.stepdata_AddHeaderProtocol(*args)

    AddHeaderProtocol = staticmethod(AddHeaderProtocol)

    def HeaderProtocol(*args) -> "opencascade::handle< StepData_Protocol >":
        """
        * Returns the recorded HeaderProtocol, which can be : - a Null Handle if no Header Protocol was yet defined - a simple Protocol if only one was defined - a FileProtocol if more than one Protocol was yet defined
        	:rtype: opencascade::handle<StepData_Protocol>
        """
        return _StepData.stepdata_HeaderProtocol(*args)

    HeaderProtocol = staticmethod(HeaderProtocol)

    def Init(*args) -> "void":
        """
        * Prepares General Data required to work with this package, which are the Protocol and Modules to be loaded into Libraries
        	:rtype: void
        """
        return _StepData.stepdata_Init(*args)

    Init = staticmethod(Init)

    def Protocol(*args) -> "opencascade::handle< StepData_Protocol >":
        """
        * Returns a Protocol from StepData (avoids to create it)
        	:rtype: opencascade::handle<StepData_Protocol>
        """
        return _StepData.stepdata_Protocol(*args)

    Protocol = staticmethod(Protocol)

    __repr__ = _dumps_object


    def __init__(self):
        _StepData.stepdata_swiginit(self, _StepData.new_stepdata())
    __swig_destroy__ = _StepData.delete_stepdata
stepdata_swigregister = _StepData.stepdata_swigregister
stepdata_swigregister(stepdata)

def stepdata_AddHeaderProtocol(*args) -> "void":
    """
    * Adds a new Header Protocol to the Header Definition
    	:param headerproto:
    	:type headerproto: StepData_Protocol
    	:rtype: void
    """
    return _StepData.stepdata_AddHeaderProtocol(*args)

def stepdata_HeaderProtocol(*args) -> "opencascade::handle< StepData_Protocol >":
    """
    * Returns the recorded HeaderProtocol, which can be : - a Null Handle if no Header Protocol was yet defined - a simple Protocol if only one was defined - a FileProtocol if more than one Protocol was yet defined
    	:rtype: opencascade::handle<StepData_Protocol>
    """
    return _StepData.stepdata_HeaderProtocol(*args)

def stepdata_Init(*args) -> "void":
    """
    * Prepares General Data required to work with this package, which are the Protocol and Modules to be loaded into Libraries
    	:rtype: void
    """
    return _StepData.stepdata_Init(*args)

def stepdata_Protocol(*args) -> "opencascade::handle< StepData_Protocol >":
    """
    * Returns a Protocol from StepData (avoids to create it)
    	:rtype: opencascade::handle<StepData_Protocol>
    """
    return _StepData.stepdata_Protocol(*args)

class StepData_Described(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def As(self, *args) -> "opencascade::handle< StepData_Simple >":
        """
        * Returns a Simple Entity which matches with a Type in <self> : For a Simple Entity : me if it matches, else a null handle For a Complex Entity : the member which matches, else null
        	:param steptype:
        	:type steptype: char *
        	:rtype: opencascade::handle<StepData_Simple>
        """
        return _StepData.StepData_Described_As(self, *args)


    def CField(self, *args) -> "StepData_Field &":
        """
        * Returns a Field from its name; read or write
        	:param name:
        	:type name: char *
        	:rtype: StepData_Field
        """
        return _StepData.StepData_Described_CField(self, *args)


    def Check(self, *args) -> "void":
        """
        * Fills a Check by using its Description
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: void
        """
        return _StepData.StepData_Described_Check(self, *args)


    def Description(self, *args) -> "opencascade::handle< StepData_EDescr >":
        """
        * Returns the Description used to define this entity
        	:rtype: opencascade::handle<StepData_EDescr>
        """
        return _StepData.StepData_Described_Description(self, *args)


    def Field(self, *args) -> "StepData_Field const &":
        """
        * Returns a Field from its name; read-only
        	:param name:
        	:type name: char *
        	:rtype: StepData_Field
        """
        return _StepData.StepData_Described_Field(self, *args)


    def HasField(self, *args) -> "Standard_Boolean":
        """
        * Tells if a Field brings a given name
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _StepData.StepData_Described_HasField(self, *args)


    def IsComplex(self, *args) -> "Standard_Boolean":
        """
        * Tells if a described entity is complex
        	:rtype: bool
        """
        return _StepData.StepData_Described_IsComplex(self, *args)


    def Matches(self, *args) -> "Standard_Boolean":
        """
        * Tells if a step type is matched by <self> For a Simple Entity : own type or super type For a Complex Entity : one of the members
        	:param steptype:
        	:type steptype: char *
        	:rtype: bool
        """
        return _StepData.StepData_Described_Matches(self, *args)


    def Shared(self, *args) -> "void":
        """
        * Fills an EntityIterator with entities shared by <self>
        	:param list:
        	:type list: Interface_EntityIterator
        	:rtype: void
        """
        return _StepData.StepData_Described_Shared(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_Described_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_Described
StepData_Described.As = new_instancemethod(_StepData.StepData_Described_As, None, StepData_Described)
StepData_Described.CField = new_instancemethod(_StepData.StepData_Described_CField, None, StepData_Described)
StepData_Described.Check = new_instancemethod(_StepData.StepData_Described_Check, None, StepData_Described)
StepData_Described.Description = new_instancemethod(_StepData.StepData_Described_Description, None, StepData_Described)
StepData_Described.Field = new_instancemethod(_StepData.StepData_Described_Field, None, StepData_Described)
StepData_Described.HasField = new_instancemethod(_StepData.StepData_Described_HasField, None, StepData_Described)
StepData_Described.IsComplex = new_instancemethod(_StepData.StepData_Described_IsComplex, None, StepData_Described)
StepData_Described.Matches = new_instancemethod(_StepData.StepData_Described_Matches, None, StepData_Described)
StepData_Described.Shared = new_instancemethod(_StepData.StepData_Described_Shared, None, StepData_Described)
StepData_Described_swigregister = _StepData.StepData_Described_swigregister
StepData_Described_swigregister(StepData_Described)

class StepData_EDescr(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsComplex(self, *args) -> "Standard_Boolean":
        """
        * Tells if a EDescr is complex (ECDescr) or simple (ESDescr)
        	:rtype: bool
        """
        return _StepData.StepData_EDescr_IsComplex(self, *args)


    def Matches(self, *args) -> "Standard_Boolean":
        """
        * Tells if a ESDescr matches a step type : exact or super type
        	:param steptype:
        	:type steptype: char *
        	:rtype: bool
        """
        return _StepData.StepData_EDescr_Matches(self, *args)


    def NewEntity(self, *args) -> "opencascade::handle< StepData_Described >":
        """
        * Creates a described entity (i.e. a simple one)
        	:rtype: opencascade::handle<StepData_Described>
        """
        return _StepData.StepData_EDescr_NewEntity(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_EDescr_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_EDescr
StepData_EDescr.IsComplex = new_instancemethod(_StepData.StepData_EDescr_IsComplex, None, StepData_EDescr)
StepData_EDescr.Matches = new_instancemethod(_StepData.StepData_EDescr_Matches, None, StepData_EDescr)
StepData_EDescr.NewEntity = new_instancemethod(_StepData.StepData_EDescr_NewEntity, None, StepData_EDescr)
StepData_EDescr_swigregister = _StepData.StepData_EDescr_swigregister
StepData_EDescr_swigregister(StepData_EDescr)

class StepData_EnumTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddDefinition(self, *args) -> "void":
        """
        * Processes a definition, splits it according blanks if any empty definitions are ignored A null definition can be input by given '$' :the corresponding position is attached to 'null/undefined' value (as one particular item of the enumeration list) See also IsSet
        	:param term:
        	:type term: char *
        	:rtype: None
        """
        return _StepData.StepData_EnumTool_AddDefinition(self, *args)


    def IsSet(self, *args) -> "Standard_Boolean":
        """
        * Returns True if at least one definition has been entered after creation time (i.e. by AddDefinition only) //! This allows to build a static description by a first pass : static StepData_EnumTool myenumtool('e0' ...); ... if (!myenumtool.IsSet()) { for further inits myenumtool.AddDefinition('e21'); ... }
        	:rtype: bool
        """
        return _StepData.StepData_EnumTool_IsSet(self, *args)


    def MaxValue(self, *args) -> "Standard_Integer":
        """
        * Returns the maximum integer for a suitable value Remark : while values begin at zero, MaxValue is the count of recorded values minus one
        	:rtype: int
        """
        return _StepData.StepData_EnumTool_MaxValue(self, *args)


    def NullValue(self, *args) -> "Standard_Integer":
        """
        * Returns the value attached to 'null/undefined value' If none is specified or if Optional has been set to False, returns -1 Null Value has been specified by definition '$'
        	:rtype: int
        """
        return _StepData.StepData_EnumTool_NullValue(self, *args)


    def Optional(self, *args) -> "void":
        """
        * Sets or Unsets the EnumTool to accept undefined value (for optional field). Ignored if no null value is defined (by '$') Can be changed during execution (to read each field), Default is True (if a null value is defined)
        	:param mode:
        	:type mode: bool
        	:rtype: None
        """
        return _StepData.StepData_EnumTool_Optional(self, *args)


    def __init__(self, *args):
        """
        * Creates an EnumTool with definitions given by e0 .. e<max> Each definition string can bring one term, or several separated by blanks. Each term corresponds to one value of the enumeration, if dots are not presents they are added //! Such a static constructor allows to build a static description as : static StepData_EnumTool myenumtool('e0','e1'...); then use it without having to initialise it //! A null definition can be input by given '$' :the corresponding position is attached to 'null/undefined' value (as one particular item of the enumeration list)
        	:param e0: default value is 
        	:type e0: char *
        	:param e1: default value is 
        	:type e1: char *
        	:param e2: default value is 
        	:type e2: char *
        	:param e3: default value is 
        	:type e3: char *
        	:param e4: default value is 
        	:type e4: char *
        	:param e5: default value is 
        	:type e5: char *
        	:param e6: default value is 
        	:type e6: char *
        	:param e7: default value is 
        	:type e7: char *
        	:param e8: default value is 
        	:type e8: char *
        	:param e9: default value is 
        	:type e9: char *
        	:param e10: default value is 
        	:type e10: char *
        	:param e11: default value is 
        	:type e11: char *
        	:param e12: default value is 
        	:type e12: char *
        	:param e13: default value is 
        	:type e13: char *
        	:param e14: default value is 
        	:type e14: char *
        	:param e15: default value is 
        	:type e15: char *
        	:param e16: default value is 
        	:type e16: char *
        	:param e17: default value is 
        	:type e17: char *
        	:param e18: default value is 
        	:type e18: char *
        	:param e19: default value is 
        	:type e19: char *
        	:param e20: default value is 
        	:type e20: char *
        	:param e21: default value is 
        	:type e21: char *
        	:param e22: default value is 
        	:type e22: char *
        	:param e23: default value is 
        	:type e23: char *
        	:param e24: default value is 
        	:type e24: char *
        	:param e25: default value is 
        	:type e25: char *
        	:param e26: default value is 
        	:type e26: char *
        	:param e27: default value is 
        	:type e27: char *
        	:param e28: default value is 
        	:type e28: char *
        	:param e29: default value is 
        	:type e29: char *
        	:param e30: default value is 
        	:type e30: char *
        	:param e31: default value is 
        	:type e31: char *
        	:param e32: default value is 
        	:type e32: char *
        	:param e33: default value is 
        	:type e33: char *
        	:param e34: default value is 
        	:type e34: char *
        	:param e35: default value is 
        	:type e35: char *
        	:param e36: default value is 
        	:type e36: char *
        	:param e37: default value is 
        	:type e37: char *
        	:param e38: default value is 
        	:type e38: char *
        	:param e39: default value is 
        	:type e39: char *
        	:rtype: None
        """
        _StepData.StepData_EnumTool_swiginit(self, _StepData.new_StepData_EnumTool(*args))

    def Text(self, *args) -> "TCollection_AsciiString const &":
        """
        * Returns the text which corresponds to a given numeric value It is limited by dots If num is out of range, returns an empty string
        	:param num:
        	:type num: int
        	:rtype: TCollection_AsciiString
        """
        return _StepData.StepData_EnumTool_Text(self, *args)


    def Value(self, *args) -> "Standard_Integer":
        """
        * Returns the numeric value found for a text The text must be in capitals and limited by dots A non-suitable text gives a negative value to be returned
        	:param txt:
        	:type txt: char *
        	:rtype: int
        * Same as above but works on an AsciiString
        	:param txt:
        	:type txt: TCollection_AsciiString
        	:rtype: int
        """
        return _StepData.StepData_EnumTool_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_EnumTool
StepData_EnumTool.AddDefinition = new_instancemethod(_StepData.StepData_EnumTool_AddDefinition, None, StepData_EnumTool)
StepData_EnumTool.IsSet = new_instancemethod(_StepData.StepData_EnumTool_IsSet, None, StepData_EnumTool)
StepData_EnumTool.MaxValue = new_instancemethod(_StepData.StepData_EnumTool_MaxValue, None, StepData_EnumTool)
StepData_EnumTool.NullValue = new_instancemethod(_StepData.StepData_EnumTool_NullValue, None, StepData_EnumTool)
StepData_EnumTool.Optional = new_instancemethod(_StepData.StepData_EnumTool_Optional, None, StepData_EnumTool)
StepData_EnumTool.Text = new_instancemethod(_StepData.StepData_EnumTool_Text, None, StepData_EnumTool)
StepData_EnumTool.Value = new_instancemethod(_StepData.StepData_EnumTool_Value, None, StepData_EnumTool)
StepData_EnumTool_swigregister = _StepData.StepData_EnumTool_swigregister
StepData_EnumTool_swigregister(StepData_EnumTool)

class StepData_Field(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Arity(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _StepData.StepData_Field_Arity(self, *args)


    def Boolean(self, *args) -> "Standard_Boolean":
        """
        :param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: bool
        """
        return _StepData.StepData_Field_Boolean(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears the field, to set it as 'no value defined' Just before SetList, predeclares it as 'any' A Kind can be directly set here to declare a type
        	:param kind: default value is 0
        	:type kind: int
        	:rtype: None
        """
        return _StepData.StepData_Field_Clear(self, *args)


    def ClearItem(self, *args) -> "void":
        """
        * Declares an item of the list as undefined (ignored if list not defined as String,Entity or Any)
        	:param num:
        	:type num: int
        	:rtype: None
        """
        return _StepData.StepData_Field_ClearItem(self, *args)


    def CopyFrom(self, *args) -> "void":
        """
        * Gets the copy of the values of another field
        	:param other:
        	:type other: StepData_Field
        	:rtype: None
        """
        return _StepData.StepData_Field_CopyFrom(self, *args)


    def Entity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        :param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _StepData.StepData_Field_Entity(self, *args)


    def Enum(self, *args) -> "Standard_Integer":
        """
        :param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: int
        """
        return _StepData.StepData_Field_Enum(self, *args)


    def EnumText(self, *args) -> "char const *":
        """
        :param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: char *
        """
        return _StepData.StepData_Field_EnumText(self, *args)


    def Int(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _StepData.StepData_Field_Int(self, *args)


    def Integer(self, *args) -> "Standard_Integer":
        """
        :param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: int
        """
        return _StepData.StepData_Field_Integer(self, *args)


    def IsSet(self, *args) -> "Standard_Boolean":
        """
        :param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: bool
        """
        return _StepData.StepData_Field_IsSet(self, *args)


    def ItemKind(self, *args) -> "Standard_Integer":
        """
        * Returns the kind of an item in a list or double list It is the kind of the list, except if it is 'Any', in such a case the true kind is determined and returned
        	:param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: int
        """
        return _StepData.StepData_Field_ItemKind(self, *args)


    def Kind(self, *args) -> "Standard_Integer":
        """
        * Returns the kind of the field <type> True (D) : returns only the type itself else, returns the complete kind
        	:param type: default value is Standard_True
        	:type type: bool
        	:rtype: int
        """
        return _StepData.StepData_Field_Kind(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        :param index: default value is 1
        	:type index: int
        	:rtype: int
        """
        return _StepData.StepData_Field_Length(self, *args)


    def Logical(self, *args) -> "StepData_Logical":
        """
        :param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: StepData_Logical
        """
        return _StepData.StepData_Field_Logical(self, *args)


    def Lower(self, *args) -> "Standard_Integer":
        """
        :param index: default value is 1
        	:type index: int
        	:rtype: int
        """
        return _StepData.StepData_Field_Lower(self, *args)


    def Real(self, *args) -> "Standard_Real":
        """
        :param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: float
        """
        return _StepData.StepData_Field_Real(self, *args)


    def Set(self, *args) -> "void":
        """
        * Sets an undetermined value : can be String, SelectMember, HArray(1-2) ... else, an Entity In case of an HArray, determines and records its size(s)
        	:param val:
        	:type val: Standard_Transient
        	:rtype: None
        """
        return _StepData.StepData_Field_Set(self, *args)


    def SetBoolean(self, *args) -> "void":
        """
        * Sets a Boolean value (or predeclares a list as boolean)
        	:param val: default value is Standard_False
        	:type val: bool
        	:rtype: None
        :param num:
        	:type num: int
        	:param val:
        	:type val: bool
        	:rtype: None
        """
        return _StepData.StepData_Field_SetBoolean(self, *args)


    def SetDerived(self, *args) -> "void":
        """
        * Codes a Field as derived (no proper value)
        	:rtype: None
        """
        return _StepData.StepData_Field_SetDerived(self, *args)


    def SetEntity(self, *args) -> "void":
        """
        * Sets an Entity Value
        	:param val:
        	:type val: Standard_Transient
        	:rtype: None
        * Predeclares a list as of entity
        	:rtype: None
        :param num:
        	:type num: int
        	:param val:
        	:type val: Standard_Transient
        	:rtype: None
        """
        return _StepData.StepData_Field_SetEntity(self, *args)


    def SetEnum(self, *args) -> "void":
        """
        * Sets an Enum Value (as its integer counterpart) (or predeclares a list as Enum) If <text> is given , also sets its textual expression <val> negative means unknown (known values begin at 0)
        	:param val: default value is -1
        	:type val: int
        	:param text: default value is 
        	:type text: char *
        	:rtype: None
        * Sets an Enum Value (Integer counterpart), also its text expression if known (if list has been set as 'any')
        	:param num:
        	:type num: int
        	:param val:
        	:type val: int
        	:param text: default value is 
        	:type text: char *
        	:rtype: None
        """
        return _StepData.StepData_Field_SetEnum(self, *args)


    def SetInt(self, *args) -> "void":
        """
        * Directly sets the Integer value, if its Kind matches Integer, Boolean, Logical, or Enum (does not change Kind)
        	:param val:
        	:type val: int
        	:rtype: None
        * Internal access to an Integer Value for a list, plus its kind
        	:param num:
        	:type num: int
        	:param val:
        	:type val: int
        	:param kind:
        	:type kind: int
        	:rtype: None
        """
        return _StepData.StepData_Field_SetInt(self, *args)


    def SetInteger(self, *args) -> "void":
        """
        * Sets an Integer value (before SetList* declares it as Integer)
        	:param val: default value is 0
        	:type val: int
        	:rtype: None
        * Sets an Integer Value for a list (rank num) (recognizes a SelectMember)
        	:param num:
        	:type num: int
        	:param val:
        	:type val: int
        	:rtype: None
        """
        return _StepData.StepData_Field_SetInteger(self, *args)


    def SetList(self, *args) -> "void":
        """
        * Declares a field as a list, with an initial size Initial lower is defaulted as 1, can be defined The list starts empty, typed by the last Set* If no Set* before, sets it as 'any' (transient/select)
        	:param size:
        	:type size: int
        	:param first: default value is 1
        	:type first: int
        	:rtype: None
        """
        return _StepData.StepData_Field_SetList(self, *args)


    def SetList2(self, *args) -> "void":
        """
        * Declares a field as an homogeneous square list, with initial sizes, and initial lowers
        	:param siz1:
        	:type siz1: int
        	:param siz2:
        	:type siz2: int
        	:param f1: default value is 1
        	:type f1: int
        	:param f2: default value is 1
        	:type f2: int
        	:rtype: None
        """
        return _StepData.StepData_Field_SetList2(self, *args)


    def SetLogical(self, *args) -> "void":
        """
        * Sets a Logical Value (or predeclares a list as logical)
        	:param val: default value is StepData_LFalse
        	:type val: StepData_Logical
        	:rtype: None
        :param num:
        	:type num: int
        	:param val:
        	:type val: StepData_Logical
        	:rtype: None
        """
        return _StepData.StepData_Field_SetLogical(self, *args)


    def SetReal(self, *args) -> "void":
        """
        * Sets a Real Value (or predeclares a list as Real);
        	:param val: default value is 0.0
        	:type val: float
        	:rtype: None
        :param num:
        	:type num: int
        	:param val:
        	:type val: float
        	:rtype: None
        """
        return _StepData.StepData_Field_SetReal(self, *args)


    def SetSelectMember(self, *args) -> "void":
        """
        * Sets a SelectMember (for Integer,Boolean,Enum,Real,Logical) Hence, the value of the field is accessed through this member
        	:param val:
        	:type val: StepData_SelectMember
        	:rtype: None
        """
        return _StepData.StepData_Field_SetSelectMember(self, *args)


    def SetString(self, *args) -> "void":
        """
        * Sets a String Value (or predeclares a list as String) Does not redefine the Kind if it is alread String or Enum
        	:param val: default value is 
        	:type val: char *
        	:rtype: None
        :param num:
        	:type num: int
        	:param val:
        	:type val: char *
        	:rtype: None
        """
        return _StepData.StepData_Field_SetString(self, *args)


    def __init__(self, *args):
        """
        * Creates a Field, empty ('no value defined')
        	:rtype: None
        * Creates a Field from another one. If <copy> is True, Handled data (Select,String,List, not entities) are copied
        	:param other:
        	:type other: StepData_Field
        	:param copy: default value is Standard_False
        	:type copy: bool
        	:rtype: None
        """
        _StepData.StepData_Field_swiginit(self, _StepData.new_StepData_Field(*args))

    def String(self, *args) -> "char const *":
        """
        :param n1: default value is 1
        	:type n1: int
        	:param n2: default value is 1
        	:type n2: int
        	:rtype: char *
        """
        return _StepData.StepData_Field_String(self, *args)


    def Transient(self, *args) -> "opencascade::handle< Standard_Transient >":
        """:rtype: opencascade::handle<Standard_Transient>"""
        return _StepData.StepData_Field_Transient(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_Field
StepData_Field.Arity = new_instancemethod(_StepData.StepData_Field_Arity, None, StepData_Field)
StepData_Field.Boolean = new_instancemethod(_StepData.StepData_Field_Boolean, None, StepData_Field)
StepData_Field.Clear = new_instancemethod(_StepData.StepData_Field_Clear, None, StepData_Field)
StepData_Field.ClearItem = new_instancemethod(_StepData.StepData_Field_ClearItem, None, StepData_Field)
StepData_Field.CopyFrom = new_instancemethod(_StepData.StepData_Field_CopyFrom, None, StepData_Field)
StepData_Field.Entity = new_instancemethod(_StepData.StepData_Field_Entity, None, StepData_Field)
StepData_Field.Enum = new_instancemethod(_StepData.StepData_Field_Enum, None, StepData_Field)
StepData_Field.EnumText = new_instancemethod(_StepData.StepData_Field_EnumText, None, StepData_Field)
StepData_Field.Int = new_instancemethod(_StepData.StepData_Field_Int, None, StepData_Field)
StepData_Field.Integer = new_instancemethod(_StepData.StepData_Field_Integer, None, StepData_Field)
StepData_Field.IsSet = new_instancemethod(_StepData.StepData_Field_IsSet, None, StepData_Field)
StepData_Field.ItemKind = new_instancemethod(_StepData.StepData_Field_ItemKind, None, StepData_Field)
StepData_Field.Kind = new_instancemethod(_StepData.StepData_Field_Kind, None, StepData_Field)
StepData_Field.Length = new_instancemethod(_StepData.StepData_Field_Length, None, StepData_Field)
StepData_Field.Logical = new_instancemethod(_StepData.StepData_Field_Logical, None, StepData_Field)
StepData_Field.Lower = new_instancemethod(_StepData.StepData_Field_Lower, None, StepData_Field)
StepData_Field.Real = new_instancemethod(_StepData.StepData_Field_Real, None, StepData_Field)
StepData_Field.Set = new_instancemethod(_StepData.StepData_Field_Set, None, StepData_Field)
StepData_Field.SetBoolean = new_instancemethod(_StepData.StepData_Field_SetBoolean, None, StepData_Field)
StepData_Field.SetDerived = new_instancemethod(_StepData.StepData_Field_SetDerived, None, StepData_Field)
StepData_Field.SetEntity = new_instancemethod(_StepData.StepData_Field_SetEntity, None, StepData_Field)
StepData_Field.SetEnum = new_instancemethod(_StepData.StepData_Field_SetEnum, None, StepData_Field)
StepData_Field.SetInt = new_instancemethod(_StepData.StepData_Field_SetInt, None, StepData_Field)
StepData_Field.SetInteger = new_instancemethod(_StepData.StepData_Field_SetInteger, None, StepData_Field)
StepData_Field.SetList = new_instancemethod(_StepData.StepData_Field_SetList, None, StepData_Field)
StepData_Field.SetList2 = new_instancemethod(_StepData.StepData_Field_SetList2, None, StepData_Field)
StepData_Field.SetLogical = new_instancemethod(_StepData.StepData_Field_SetLogical, None, StepData_Field)
StepData_Field.SetReal = new_instancemethod(_StepData.StepData_Field_SetReal, None, StepData_Field)
StepData_Field.SetSelectMember = new_instancemethod(_StepData.StepData_Field_SetSelectMember, None, StepData_Field)
StepData_Field.SetString = new_instancemethod(_StepData.StepData_Field_SetString, None, StepData_Field)
StepData_Field.String = new_instancemethod(_StepData.StepData_Field_String, None, StepData_Field)
StepData_Field.Transient = new_instancemethod(_StepData.StepData_Field_Transient, None, StepData_Field)
StepData_Field_swigregister = _StepData.StepData_Field_swigregister
StepData_Field_swigregister(StepData_Field)

class StepData_FieldList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CField(self, *args) -> "StepData_Field &":
        """
        * Returns the field n0 <num> between 1 and NbFields, in order to modify its content
        	:param num:
        	:type num: int
        	:rtype: StepData_Field
        """
        return _StepData.StepData_FieldList_CField(self, *args)


    def Field(self, *args) -> "StepData_Field const &":
        """
        * Returns the field n0 <num> between 1 and NbFields (read only)
        	:param num:
        	:type num: int
        	:rtype: StepData_Field
        """
        return _StepData.StepData_FieldList_Field(self, *args)


    def FillShared(self, *args) -> "void":
        """
        * Fills an iterator with the entities shared by <self>
        	:param iter:
        	:type iter: Interface_EntityIterator
        	:rtype: None
        """
        return _StepData.StepData_FieldList_FillShared(self, *args)


    def NbFields(self, *args) -> "Standard_Integer":
        """
        * Returns the count of fields. Here, returns 0
        	:rtype: int
        """
        return _StepData.StepData_FieldList_NbFields(self, *args)


    def __init__(self, *args):
        """
        * Creates a FieldList of 0 Field
        	:rtype: None
        """
        _StepData.StepData_FieldList_swiginit(self, _StepData.new_StepData_FieldList(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_FieldList
StepData_FieldList.CField = new_instancemethod(_StepData.StepData_FieldList_CField, None, StepData_FieldList)
StepData_FieldList.Field = new_instancemethod(_StepData.StepData_FieldList_Field, None, StepData_FieldList)
StepData_FieldList.FillShared = new_instancemethod(_StepData.StepData_FieldList_FillShared, None, StepData_FieldList)
StepData_FieldList.NbFields = new_instancemethod(_StepData.StepData_FieldList_NbFields, None, StepData_FieldList)
StepData_FieldList_swigregister = _StepData.StepData_FieldList_swigregister
StepData_FieldList_swigregister(StepData_FieldList)

class StepData_FileRecognizer(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a new Recognizer to the Compound, at the end Several calls to Add work by adding in the order of calls : Hence, when Eval has failed to recognize, Evaluate will call Evaluate from the first added Recognizer if there is one, and to the second if there is still no result, and so on
        	:param reco:
        	:type reco: StepData_FileRecognizer
        	:rtype: None
        """
        return _StepData.StepData_FileRecognizer_Add(self, *args)


    def Evaluate(self, *args) -> "Standard_Boolean":
        """
        * Evaluates if recognition has a result, returns it if yes In case of success, Returns True and puts result in 'res' In case of Failure, simply Returns False Works by calling deferred method Eval, and in case of failure, looks for Added Recognizers to work
        	:param akey:
        	:type akey: TCollection_AsciiString
        	:param res:
        	:type res: Standard_Transient
        	:rtype: bool
        """
        return _StepData.StepData_FileRecognizer_Evaluate(self, *args)


    def Result(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns result of last recognition (call of Evaluate)
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _StepData.StepData_FileRecognizer_Result(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_FileRecognizer_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_FileRecognizer
StepData_FileRecognizer.Add = new_instancemethod(_StepData.StepData_FileRecognizer_Add, None, StepData_FileRecognizer)
StepData_FileRecognizer.Evaluate = new_instancemethod(_StepData.StepData_FileRecognizer_Evaluate, None, StepData_FileRecognizer)
StepData_FileRecognizer.Result = new_instancemethod(_StepData.StepData_FileRecognizer_Result, None, StepData_FileRecognizer)
StepData_FileRecognizer_swigregister = _StepData.StepData_FileRecognizer_swigregister
StepData_FileRecognizer_swigregister(StepData_FileRecognizer)

class StepData_GeneralModule(OCC.Core.Interface.Interface_GeneralModule):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr


    @staticmethod
    def DownCast(t):
      return Handle_StepData_GeneralModule_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_GeneralModule
StepData_GeneralModule_swigregister = _StepData.StepData_GeneralModule_swigregister
StepData_GeneralModule_swigregister(StepData_GeneralModule)

class StepData_GlobalNodeOfWriterLib(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a Module bound with a Protocol to the list : does nothing if already in the list, THAT IS, Same Type (exact match) and Same State (that is, IsEqual is not required) Once added, stores its attached Protocol in correspondance
        	:param amodule:
        	:type amodule: StepData_ReadWriteModule
        	:param aprotocol:
        	:type aprotocol: StepData_Protocol
        	:rtype: None
        """
        return _StepData.StepData_GlobalNodeOfWriterLib_Add(self, *args)


    def Module(self, *args) -> "opencascade::handle< StepData_ReadWriteModule > const &":
        """
        * Returns the Module stored in a given GlobalNode
        	:rtype: opencascade::handle<StepData_ReadWriteModule>
        """
        return _StepData.StepData_GlobalNodeOfWriterLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< StepData_GlobalNodeOfWriterLib > const &":
        """
        * Returns the Next GlobalNode. If none is defined, returned value is a Null Handle
        	:rtype: opencascade::handle<StepData_GlobalNodeOfWriterLib>
        """
        return _StepData.StepData_GlobalNodeOfWriterLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< StepData_Protocol > const &":
        """
        * Returns the attached Protocol stored in a given GlobalNode
        	:rtype: opencascade::handle<StepData_Protocol>
        """
        return _StepData.StepData_GlobalNodeOfWriterLib_Protocol(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty GlobalNode, with no Next
        	:rtype: None
        """
        _StepData.StepData_GlobalNodeOfWriterLib_swiginit(self, _StepData.new_StepData_GlobalNodeOfWriterLib(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_GlobalNodeOfWriterLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_GlobalNodeOfWriterLib
StepData_GlobalNodeOfWriterLib.Add = new_instancemethod(_StepData.StepData_GlobalNodeOfWriterLib_Add, None, StepData_GlobalNodeOfWriterLib)
StepData_GlobalNodeOfWriterLib.Module = new_instancemethod(_StepData.StepData_GlobalNodeOfWriterLib_Module, None, StepData_GlobalNodeOfWriterLib)
StepData_GlobalNodeOfWriterLib.Next = new_instancemethod(_StepData.StepData_GlobalNodeOfWriterLib_Next, None, StepData_GlobalNodeOfWriterLib)
StepData_GlobalNodeOfWriterLib.Protocol = new_instancemethod(_StepData.StepData_GlobalNodeOfWriterLib_Protocol, None, StepData_GlobalNodeOfWriterLib)
StepData_GlobalNodeOfWriterLib_swigregister = _StepData.StepData_GlobalNodeOfWriterLib_swigregister
StepData_GlobalNodeOfWriterLib_swigregister(StepData_GlobalNodeOfWriterLib)

class StepData_NodeOfWriterLib(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddNode(self, *args) -> "void":
        """
        * Adds a couple (Module,Protocol), that is, stores it into itself if not yet done, else creates a Next Node to do it
        	:param anode:
        	:type anode: StepData_GlobalNodeOfWriterLib
        	:rtype: None
        """
        return _StepData.StepData_NodeOfWriterLib_AddNode(self, *args)


    def Module(self, *args) -> "opencascade::handle< StepData_ReadWriteModule > const &":
        """
        * Returns the Module designated by a precise Node
        	:rtype: opencascade::handle<StepData_ReadWriteModule>
        """
        return _StepData.StepData_NodeOfWriterLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< StepData_NodeOfWriterLib > const &":
        """
        * Returns the Next Node. If none was defined, returned value is a Null Handle
        	:rtype: opencascade::handle<StepData_NodeOfWriterLib>
        """
        return _StepData.StepData_NodeOfWriterLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< StepData_Protocol > const &":
        """
        * Returns the Protocol designated by a precise Node
        	:rtype: opencascade::handle<StepData_Protocol>
        """
        return _StepData.StepData_NodeOfWriterLib_Protocol(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty Node, with no Next
        	:rtype: None
        """
        _StepData.StepData_NodeOfWriterLib_swiginit(self, _StepData.new_StepData_NodeOfWriterLib(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_NodeOfWriterLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_NodeOfWriterLib
StepData_NodeOfWriterLib.AddNode = new_instancemethod(_StepData.StepData_NodeOfWriterLib_AddNode, None, StepData_NodeOfWriterLib)
StepData_NodeOfWriterLib.Module = new_instancemethod(_StepData.StepData_NodeOfWriterLib_Module, None, StepData_NodeOfWriterLib)
StepData_NodeOfWriterLib.Next = new_instancemethod(_StepData.StepData_NodeOfWriterLib_Next, None, StepData_NodeOfWriterLib)
StepData_NodeOfWriterLib.Protocol = new_instancemethod(_StepData.StepData_NodeOfWriterLib_Protocol, None, StepData_NodeOfWriterLib)
StepData_NodeOfWriterLib_swigregister = _StepData.StepData_NodeOfWriterLib_swigregister
StepData_NodeOfWriterLib_swigregister(StepData_NodeOfWriterLib)

class StepData_PDescr(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddArity(self, *args) -> "void":
        """
        * Adds an arity count to <self>, by default 1 1 : a simple field passes to a LIST/ARRAY etc or a LIST to a LIST OF LIST 2 : a simple field passes to a LIST OF LIST
        	:param arity: default value is 1
        	:type arity: int
        	:rtype: None
        """
        return _StepData.StepData_PDescr_AddArity(self, *args)


    def AddEnumDef(self, *args) -> "void":
        """
        * Adds an enum value as a string
        	:param enumdef:
        	:type enumdef: char *
        	:rtype: None
        """
        return _StepData.StepData_PDescr_AddEnumDef(self, *args)


    def AddMember(self, *args) -> "void":
        """
        * Adds a member to a SELECT description
        	:param member:
        	:type member: StepData_PDescr
        	:rtype: None
        """
        return _StepData.StepData_PDescr_AddMember(self, *args)


    def Arity(self, *args) -> "Standard_Integer":
        """
        * Returns the arity of <self>
        	:rtype: int
        """
        return _StepData.StepData_PDescr_Arity(self, *args)


    def Check(self, *args) -> "void":
        """
        * Semantic Check of a Field : does it complies with the given description ?
        	:param afild:
        	:type afild: StepData_Field
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: void
        """
        return _StepData.StepData_PDescr_Check(self, *args)


    def DescrName(self, *args) -> "char const *":
        """
        * Returns the description (type name) to match, for a Described (else, empty string)
        	:rtype: char *
        """
        return _StepData.StepData_PDescr_DescrName(self, *args)


    def EnumMax(self, *args) -> "Standard_Integer":
        """
        * Returns the maximum integer for a suitable value (count - 1)
        	:rtype: int
        """
        return _StepData.StepData_PDescr_EnumMax(self, *args)


    def EnumText(self, *args) -> "char const *":
        """
        * Returns the text which corresponds to a numeric value, between 0 and EnumMax. It is limited by dots
        	:param val:
        	:type val: int
        	:rtype: char *
        """
        return _StepData.StepData_PDescr_EnumText(self, *args)


    def EnumValue(self, *args) -> "Standard_Integer":
        """
        * Returns the numeric value found for an enum text The text must be in capitals and limited by dots A non-suitable text gives a negative value to be returned
        	:param name:
        	:type name: char *
        	:rtype: int
        """
        return _StepData.StepData_PDescr_EnumValue(self, *args)


    def FieldName(self, *args) -> "char const *":
        """:rtype: char *"""
        return _StepData.StepData_PDescr_FieldName(self, *args)


    def FieldRank(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _StepData.StepData_PDescr_FieldRank(self, *args)


    def IsBoolean(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for a Boolean value (false,true)
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsBoolean(self, *args)


    def IsDerived(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is Derived
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsDerived(self, *args)


    def IsDescr(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for a Described entity of a given EDescr (does this EDescr match description name ?). For late-bnd (works for <self> + nexts if <self> is a Select)
        	:param descr:
        	:type descr: StepData_EDescr
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsDescr(self, *args)


    def IsEntity(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for an Entity, either Described or CDL Type
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsEntity(self, *args)


    def IsEnum(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for an Enum value Then, call AddEnumDef ordered from the first one (value 0) Managed by an EnumTool
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsEnum(self, *args)


    def IsField(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is a Field. Else it is a Type
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsField(self, *args)


    def IsInteger(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for an Integer
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsInteger(self, *args)


    def IsLogical(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for a Logical value (false,true,unknown)
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsLogical(self, *args)


    def IsOptional(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is Optional
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsOptional(self, *args)


    def IsReal(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for a Real value
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsReal(self, *args)


    def IsSelect(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for a SELECT
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsSelect(self, *args)


    def IsString(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for a String value
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsString(self, *args)


    def IsType(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is for an entity of a given CDL type (early-bnd) (works for <self> + nexts if <self> is a Select)
        	:param atype:
        	:type atype: Standard_Type
        	:rtype: bool
        """
        return _StepData.StepData_PDescr_IsType(self, *args)


    def Member(self, *args) -> "opencascade::handle< StepData_PDescr >":
        """
        * For a SELECT, returns the member whose name matches <name> To this member, the following question can then be asked Null Handle if <name> not matched or <self> not a SELECT //! Remark : not to be asked for an entity type Hence, following IsInteger .. Enum* only apply on <self> and require Member While IsType applies on <self> and all Select Members
        	:param name:
        	:type name: char *
        	:rtype: opencascade::handle<StepData_PDescr>
        """
        return _StepData.StepData_PDescr_Member(self, *args)


    def Name(self, *args) -> "char const *":
        """:rtype: char *"""
        return _StepData.StepData_PDescr_Name(self, *args)


    def SetArity(self, *args) -> "void":
        """
        * Directly sets the arity count 0 : simple field 1 : LIST or ARRAY etc 2 : LIST OF LIST
        	:param arity: default value is 1
        	:type arity: int
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetArity(self, *args)


    def SetBoolean(self, *args) -> "void":
        """
        * Sets <self> for a Boolean value (false,true)
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetBoolean(self, *args)


    def SetDerived(self, *args) -> "void":
        """
        * Sets/Unsets <self> to be for a derived field
        	:param der: default value is Standard_True
        	:type der: bool
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetDerived(self, *args)


    def SetDescr(self, *args) -> "void":
        """
        * Sets <self> for a Described Entity, whose Description must match the type name <dscnam>
        	:param dscnam:
        	:type dscnam: char *
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetDescr(self, *args)


    def SetEnum(self, *args) -> "void":
        """
        * Sets <self> for an Enum value Then, call AddEnumDef ordered from the first one (value 0)
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetEnum(self, *args)


    def SetField(self, *args) -> "void":
        """
        * Sets <self> to describe a field of an entity With a name and a rank
        	:param name:
        	:type name: char *
        	:param rank:
        	:type rank: int
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetField(self, *args)


    def SetFrom(self, *args) -> "void":
        """
        * Sets <self> as <other> but duplicated Hence, some definition may be changed
        	:param other:
        	:type other: StepData_PDescr
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetFrom(self, *args)


    def SetInteger(self, *args) -> "void":
        """
        * Sets <self> for an Integer value
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetInteger(self, *args)


    def SetLogical(self, *args) -> "void":
        """
        * Sets <self> for a Logical value (false,true,unknown)
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetLogical(self, *args)


    def SetMemberName(self, *args) -> "void":
        """
        * Sets a name for SELECT member. To be used if a member is for an immediate type
        	:param memname:
        	:type memname: char *
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetMemberName(self, *args)


    def SetName(self, *args) -> "void":
        """
        :param name:
        	:type name: char *
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetName(self, *args)


    def SetOptional(self, *args) -> "void":
        """
        * Sets/Unsets <self> to accept undefined values
        	:param opt: default value is Standard_True
        	:type opt: bool
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetOptional(self, *args)


    def SetReal(self, *args) -> "void":
        """
        * Sets <self> for a Real value
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetReal(self, *args)


    def SetSelect(self, *args) -> "void":
        """
        * Declares this PDescr to be a Select, hence to have members <self> itself can be the first member
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetSelect(self, *args)


    def SetString(self, *args) -> "void":
        """
        * Sets <self> for a String value
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetString(self, *args)


    def SetType(self, *args) -> "void":
        """
        * Sets <self> for an Entity which must match a Type (early-bound)
        	:param atype:
        	:type atype: Standard_Type
        	:rtype: None
        """
        return _StepData.StepData_PDescr_SetType(self, *args)


    def Simple(self, *args) -> "opencascade::handle< StepData_PDescr >":
        """
        * For a LIST or LIST OF LIST, Returns the PDescr for the simpler PDescr. Else, returns <self> This allows to have different attributes for Optional for instance, on a field, and on the parameter of a LIST : [OPTIONAL] LIST OF [OPTIONAL] ...
        	:rtype: opencascade::handle<StepData_PDescr>
        """
        return _StepData.StepData_PDescr_Simple(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _StepData.StepData_PDescr_swiginit(self, _StepData.new_StepData_PDescr(*args))

    def Type(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns the type to match (IsKind), for a CDL Entity (else, null handle)
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _StepData.StepData_PDescr_Type(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_PDescr_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_PDescr
StepData_PDescr.AddArity = new_instancemethod(_StepData.StepData_PDescr_AddArity, None, StepData_PDescr)
StepData_PDescr.AddEnumDef = new_instancemethod(_StepData.StepData_PDescr_AddEnumDef, None, StepData_PDescr)
StepData_PDescr.AddMember = new_instancemethod(_StepData.StepData_PDescr_AddMember, None, StepData_PDescr)
StepData_PDescr.Arity = new_instancemethod(_StepData.StepData_PDescr_Arity, None, StepData_PDescr)
StepData_PDescr.Check = new_instancemethod(_StepData.StepData_PDescr_Check, None, StepData_PDescr)
StepData_PDescr.DescrName = new_instancemethod(_StepData.StepData_PDescr_DescrName, None, StepData_PDescr)
StepData_PDescr.EnumMax = new_instancemethod(_StepData.StepData_PDescr_EnumMax, None, StepData_PDescr)
StepData_PDescr.EnumText = new_instancemethod(_StepData.StepData_PDescr_EnumText, None, StepData_PDescr)
StepData_PDescr.EnumValue = new_instancemethod(_StepData.StepData_PDescr_EnumValue, None, StepData_PDescr)
StepData_PDescr.FieldName = new_instancemethod(_StepData.StepData_PDescr_FieldName, None, StepData_PDescr)
StepData_PDescr.FieldRank = new_instancemethod(_StepData.StepData_PDescr_FieldRank, None, StepData_PDescr)
StepData_PDescr.IsBoolean = new_instancemethod(_StepData.StepData_PDescr_IsBoolean, None, StepData_PDescr)
StepData_PDescr.IsDerived = new_instancemethod(_StepData.StepData_PDescr_IsDerived, None, StepData_PDescr)
StepData_PDescr.IsDescr = new_instancemethod(_StepData.StepData_PDescr_IsDescr, None, StepData_PDescr)
StepData_PDescr.IsEntity = new_instancemethod(_StepData.StepData_PDescr_IsEntity, None, StepData_PDescr)
StepData_PDescr.IsEnum = new_instancemethod(_StepData.StepData_PDescr_IsEnum, None, StepData_PDescr)
StepData_PDescr.IsField = new_instancemethod(_StepData.StepData_PDescr_IsField, None, StepData_PDescr)
StepData_PDescr.IsInteger = new_instancemethod(_StepData.StepData_PDescr_IsInteger, None, StepData_PDescr)
StepData_PDescr.IsLogical = new_instancemethod(_StepData.StepData_PDescr_IsLogical, None, StepData_PDescr)
StepData_PDescr.IsOptional = new_instancemethod(_StepData.StepData_PDescr_IsOptional, None, StepData_PDescr)
StepData_PDescr.IsReal = new_instancemethod(_StepData.StepData_PDescr_IsReal, None, StepData_PDescr)
StepData_PDescr.IsSelect = new_instancemethod(_StepData.StepData_PDescr_IsSelect, None, StepData_PDescr)
StepData_PDescr.IsString = new_instancemethod(_StepData.StepData_PDescr_IsString, None, StepData_PDescr)
StepData_PDescr.IsType = new_instancemethod(_StepData.StepData_PDescr_IsType, None, StepData_PDescr)
StepData_PDescr.Member = new_instancemethod(_StepData.StepData_PDescr_Member, None, StepData_PDescr)
StepData_PDescr.Name = new_instancemethod(_StepData.StepData_PDescr_Name, None, StepData_PDescr)
StepData_PDescr.SetArity = new_instancemethod(_StepData.StepData_PDescr_SetArity, None, StepData_PDescr)
StepData_PDescr.SetBoolean = new_instancemethod(_StepData.StepData_PDescr_SetBoolean, None, StepData_PDescr)
StepData_PDescr.SetDerived = new_instancemethod(_StepData.StepData_PDescr_SetDerived, None, StepData_PDescr)
StepData_PDescr.SetDescr = new_instancemethod(_StepData.StepData_PDescr_SetDescr, None, StepData_PDescr)
StepData_PDescr.SetEnum = new_instancemethod(_StepData.StepData_PDescr_SetEnum, None, StepData_PDescr)
StepData_PDescr.SetField = new_instancemethod(_StepData.StepData_PDescr_SetField, None, StepData_PDescr)
StepData_PDescr.SetFrom = new_instancemethod(_StepData.StepData_PDescr_SetFrom, None, StepData_PDescr)
StepData_PDescr.SetInteger = new_instancemethod(_StepData.StepData_PDescr_SetInteger, None, StepData_PDescr)
StepData_PDescr.SetLogical = new_instancemethod(_StepData.StepData_PDescr_SetLogical, None, StepData_PDescr)
StepData_PDescr.SetMemberName = new_instancemethod(_StepData.StepData_PDescr_SetMemberName, None, StepData_PDescr)
StepData_PDescr.SetName = new_instancemethod(_StepData.StepData_PDescr_SetName, None, StepData_PDescr)
StepData_PDescr.SetOptional = new_instancemethod(_StepData.StepData_PDescr_SetOptional, None, StepData_PDescr)
StepData_PDescr.SetReal = new_instancemethod(_StepData.StepData_PDescr_SetReal, None, StepData_PDescr)
StepData_PDescr.SetSelect = new_instancemethod(_StepData.StepData_PDescr_SetSelect, None, StepData_PDescr)
StepData_PDescr.SetString = new_instancemethod(_StepData.StepData_PDescr_SetString, None, StepData_PDescr)
StepData_PDescr.SetType = new_instancemethod(_StepData.StepData_PDescr_SetType, None, StepData_PDescr)
StepData_PDescr.Simple = new_instancemethod(_StepData.StepData_PDescr_Simple, None, StepData_PDescr)
StepData_PDescr.Type = new_instancemethod(_StepData.StepData_PDescr_Type, None, StepData_PDescr)
StepData_PDescr_swigregister = _StepData.StepData_PDescr_swigregister
StepData_PDescr_swigregister(StepData_PDescr)

class StepData_Protocol(OCC.Core.Interface.Interface_Protocol):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddBasicDescr(self, *args) -> "void":
        """
        * Records an ESDescr, intended to build complex descriptions
        	:param esdescr:
        	:type esdescr: StepData_ESDescr
        	:rtype: None
        """
        return _StepData.StepData_Protocol_AddBasicDescr(self, *args)


    def AddDescr(self, *args) -> "void":
        """
        * Records an EDescr with its case number Also records its name for an ESDescr (simple type): an ESDescr is then used, for case number, or for type name
        	:param adescr:
        	:type adescr: StepData_EDescr
        	:param CN:
        	:type CN: int
        	:rtype: None
        """
        return _StepData.StepData_Protocol_AddDescr(self, *args)


    def AddPDescr(self, *args) -> "void":
        """
        * Records an PDescr
        	:param pdescr:
        	:type pdescr: StepData_PDescr
        	:rtype: None
        """
        return _StepData.StepData_Protocol_AddPDescr(self, *args)


    def BasicDescr(self, *args) -> "opencascade::handle< StepData_EDescr >":
        """
        * Returns a basic description according to its name <anylevel> True (D) : for <self> and its resources <anylevel> False : for <self> only
        	:param name:
        	:type name: char *
        	:param anylevel: default value is Standard_True
        	:type anylevel: bool
        	:rtype: opencascade::handle<StepData_EDescr>
        """
        return _StepData.StepData_Protocol_BasicDescr(self, *args)


    def Descr(self, *args) -> "opencascade::handle< StepData_EDescr >":
        """
        * Returns the description attached to a case number, or null
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<StepData_EDescr>
        * Returns a description according to its name <anylevel> True (D) : for <self> and its resources <anylevel> False : for <self> only
        	:param name:
        	:type name: char *
        	:param anylevel: default value is Standard_True
        	:type anylevel: bool
        	:rtype: opencascade::handle<StepData_EDescr>
        """
        return _StepData.StepData_Protocol_Descr(self, *args)


    def DescrNumber(self, *args) -> "Standard_Integer":
        """
        * Returns a unique positive CaseNumber for types described by an EDescr (late binding) Warning : TypeNumber and DescrNumber must give together a unique positive case number for each distinct case, type or descr
        	:param adescr:
        	:type adescr: StepData_EDescr
        	:rtype: int
        """
        return _StepData.StepData_Protocol_DescrNumber(self, *args)


    def ECDescr(self, *args) -> "opencascade::handle< StepData_ECDescr >":
        """
        * Returns a complex description according to list of names <anylevel> True (D) : for <self> and its resources <anylevel> False : for <self> only
        	:param names:
        	:type names: TColStd_SequenceOfAsciiString
        	:param anylevel: default value is Standard_True
        	:type anylevel: bool
        	:rtype: opencascade::handle<StepData_ECDescr>
        """
        return _StepData.StepData_Protocol_ECDescr(self, *args)


    def ESDescr(self, *args) -> "opencascade::handle< StepData_ESDescr >":
        """
        * Idem as Descr but cast to simple description
        	:param name:
        	:type name: char *
        	:param anylevel: default value is Standard_True
        	:type anylevel: bool
        	:rtype: opencascade::handle<StepData_ESDescr>
        """
        return _StepData.StepData_Protocol_ESDescr(self, *args)


    def HasDescr(self, *args) -> "Standard_Boolean":
        """
        * Tells if a Protocol brings at least one ESDescr, i.e. if it defines at least one entity description by ESDescr mechanism
        	:rtype: bool
        """
        return _StepData.StepData_Protocol_HasDescr(self, *args)


    def PDescr(self, *args) -> "opencascade::handle< StepData_PDescr >":
        """
        * Returns a parameter description according to its name <anylevel> True (D) : for <self> and its resources <anylevel> False : for <self> only
        	:param name:
        	:type name: char *
        	:param anylevel: default value is Standard_True
        	:type anylevel: bool
        	:rtype: opencascade::handle<StepData_PDescr>
        """
        return _StepData.StepData_Protocol_PDescr(self, *args)


    def SchemaName(self, *args) -> "char const *":
        """
        * Returns the Schema Name attached to each class of Protocol To be redefined by each sub-class Here, SchemaName returns '(DEFAULT)' was C++ : return const
        	:rtype: char *
        """
        return _StepData.StepData_Protocol_SchemaName(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _StepData.StepData_Protocol_swiginit(self, _StepData.new_StepData_Protocol(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_Protocol_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_Protocol
StepData_Protocol.AddBasicDescr = new_instancemethod(_StepData.StepData_Protocol_AddBasicDescr, None, StepData_Protocol)
StepData_Protocol.AddDescr = new_instancemethod(_StepData.StepData_Protocol_AddDescr, None, StepData_Protocol)
StepData_Protocol.AddPDescr = new_instancemethod(_StepData.StepData_Protocol_AddPDescr, None, StepData_Protocol)
StepData_Protocol.BasicDescr = new_instancemethod(_StepData.StepData_Protocol_BasicDescr, None, StepData_Protocol)
StepData_Protocol.Descr = new_instancemethod(_StepData.StepData_Protocol_Descr, None, StepData_Protocol)
StepData_Protocol.DescrNumber = new_instancemethod(_StepData.StepData_Protocol_DescrNumber, None, StepData_Protocol)
StepData_Protocol.ECDescr = new_instancemethod(_StepData.StepData_Protocol_ECDescr, None, StepData_Protocol)
StepData_Protocol.ESDescr = new_instancemethod(_StepData.StepData_Protocol_ESDescr, None, StepData_Protocol)
StepData_Protocol.HasDescr = new_instancemethod(_StepData.StepData_Protocol_HasDescr, None, StepData_Protocol)
StepData_Protocol.PDescr = new_instancemethod(_StepData.StepData_Protocol_PDescr, None, StepData_Protocol)
StepData_Protocol.SchemaName = new_instancemethod(_StepData.StepData_Protocol_SchemaName, None, StepData_Protocol)
StepData_Protocol_swigregister = _StepData.StepData_Protocol_swigregister
StepData_Protocol_swigregister(StepData_Protocol)

class StepData_ReadWriteModule(OCC.Core.Interface.Interface_ReaderModule):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CaseStep(self, *args) -> "Standard_Integer":
        """
        * Defines Case Numbers corresponding to the recognized Types Called by CaseNum (data,num) above for a Simple Type Entity Warning : CaseStep must give the same Value as Protocol does for the Entity type which corresponds to this Type given as a String
        	:param atype:
        	:type atype: TCollection_AsciiString
        	:rtype: int
        * Same a above but for a Complex Type Entity ('Plex') The provided Default recognizes nothing
        	:param types:
        	:type types: TColStd_SequenceOfAsciiString
        	:rtype: int
        """
        return _StepData.StepData_ReadWriteModule_CaseStep(self, *args)


    def ComplexType(self, *args) -> "Standard_Boolean":
        """
        * Function specific to STEP, which delivers the list of types which corresponds to a complex type. If <CN> is not for a complex type, this method returns False. Else it returns True and fills the list in alphabetic order. The default returns False. To be redefined as required.
        	:param CN:
        	:type CN: int
        	:param types:
        	:type types: TColStd_SequenceOfAsciiString
        	:rtype: bool
        """
        return _StepData.StepData_ReadWriteModule_ComplexType(self, *args)


    def IsComplex(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the Case Number corresponds to a Complex Type ('Plex'). Remember that all possible combinations must be aknowledged to be processed Default is False for all cases. For a Protocol which defines possible Plexes, this method must be redefined.
        	:param CN:
        	:type CN: int
        	:rtype: bool
        """
        return _StepData.StepData_ReadWriteModule_IsComplex(self, *args)


    def ReadStep(self, *args) -> "void":
        """
        * Specific Read Function. Works with StepReaderData
        	:param CN:
        	:type CN: int
        	:param data:
        	:type data: StepData_StepReaderData
        	:param num:
        	:type num: int
        	:param ach:
        	:type ach: Interface_Check
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: void
        """
        return _StepData.StepData_ReadWriteModule_ReadStep(self, *args)


    def ShortType(self, *args) -> "TCollection_AsciiString":
        """
        * Function specific to STEP. Some STEP Types have a short form This method can be redefined to fill it By default, returns an empty string, which is then interpreted to take normal form from StepType
        	:param CN:
        	:type CN: int
        	:rtype: TCollection_AsciiString
        """
        return _StepData.StepData_ReadWriteModule_ShortType(self, *args)


    def StepType(self, *args) -> "TCollection_AsciiString const &":
        """
        * Function specific to STEP, which delivers the StepType as it is recorded in and read from a File compliant with STEP. This method is symmetric to the method CaseStep. StepType can be different from Dynamic Type's name, but belongs to the same class of Object. Returns an empty String if <CN> is zero. Warning : For a Complex Type Entity, returns an Empty String (Complex Type must be managed by users)
        	:param CN:
        	:type CN: int
        	:rtype: TCollection_AsciiString
        """
        return _StepData.StepData_ReadWriteModule_StepType(self, *args)


    def WriteStep(self, *args) -> "void":
        """
        * Write Function, switched by CaseNum
        	:param CN:
        	:type CN: int
        	:param SW:
        	:type SW: StepData_StepWriter
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: void
        """
        return _StepData.StepData_ReadWriteModule_WriteStep(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_ReadWriteModule_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_ReadWriteModule
StepData_ReadWriteModule.CaseStep = new_instancemethod(_StepData.StepData_ReadWriteModule_CaseStep, None, StepData_ReadWriteModule)
StepData_ReadWriteModule.ComplexType = new_instancemethod(_StepData.StepData_ReadWriteModule_ComplexType, None, StepData_ReadWriteModule)
StepData_ReadWriteModule.IsComplex = new_instancemethod(_StepData.StepData_ReadWriteModule_IsComplex, None, StepData_ReadWriteModule)
StepData_ReadWriteModule.ReadStep = new_instancemethod(_StepData.StepData_ReadWriteModule_ReadStep, None, StepData_ReadWriteModule)
StepData_ReadWriteModule.ShortType = new_instancemethod(_StepData.StepData_ReadWriteModule_ShortType, None, StepData_ReadWriteModule)
StepData_ReadWriteModule.StepType = new_instancemethod(_StepData.StepData_ReadWriteModule_StepType, None, StepData_ReadWriteModule)
StepData_ReadWriteModule.WriteStep = new_instancemethod(_StepData.StepData_ReadWriteModule_WriteStep, None, StepData_ReadWriteModule)
StepData_ReadWriteModule_swigregister = _StepData.StepData_ReadWriteModule_swigregister
StepData_ReadWriteModule_swigregister(StepData_ReadWriteModule)

class StepData_SelectMember(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Boolean(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _StepData.StepData_SelectMember_Boolean(self, *args)


    def Enum(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _StepData.StepData_SelectMember_Enum(self, *args)


    def EnumText(self, *args) -> "char const *":
        """:rtype: char *"""
        return _StepData.StepData_SelectMember_EnumText(self, *args)


    def HasName(self, *args) -> "Standard_Boolean":
        """
        * Tells if a SelectMember has a name. Default is False
        	:rtype: bool
        """
        return _StepData.StepData_SelectMember_HasName(self, *args)


    def Int(self, *args) -> "Standard_Integer":
        """
        * This internal method gives access to a value implemented by an Integer (to read it)
        	:rtype: int
        """
        return _StepData.StepData_SelectMember_Int(self, *args)


    def Integer(self, *args) -> "Standard_Integer":
        """
        * Gets the value as an Integer
        	:rtype: int
        """
        return _StepData.StepData_SelectMember_Integer(self, *args)


    def Kind(self, *args) -> "Standard_Integer":
        """:rtype: int"""
        return _StepData.StepData_SelectMember_Kind(self, *args)


    def Logical(self, *args) -> "StepData_Logical":
        """:rtype: StepData_Logical"""
        return _StepData.StepData_SelectMember_Logical(self, *args)


    def Matches(self, *args) -> "Standard_Boolean":
        """
        * Tells if the name of a SelectMember matches a given one By default, compares the strings, can be redefined (optimised)
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _StepData.StepData_SelectMember_Matches(self, *args)


    def Name(self, *args) -> "char const *":
        """
        * Returns the name of a SelectMember. Default is empty
        	:rtype: char *
        """
        return _StepData.StepData_SelectMember_Name(self, *args)


    def ParamType(self, *args) -> "Interface_ParamType":
        """
        * Returns the Kind of the SelectMember, under the form of an enum ParamType
        	:rtype: Interface_ParamType
        """
        return _StepData.StepData_SelectMember_ParamType(self, *args)


    def Real(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _StepData.StepData_SelectMember_Real(self, *args)


    def SetBoolean(self, *args) -> "void":
        """
        :param val:
        	:type val: bool
        	:rtype: None
        """
        return _StepData.StepData_SelectMember_SetBoolean(self, *args)


    def SetEnum(self, *args) -> "void":
        """
        :param val:
        	:type val: int
        	:param text: default value is 
        	:type text: char *
        	:rtype: None
        """
        return _StepData.StepData_SelectMember_SetEnum(self, *args)


    def SetEnumText(self, *args) -> "void":
        """
        :param val:
        	:type val: int
        	:param text:
        	:type text: char *
        	:rtype: void
        """
        return _StepData.StepData_SelectMember_SetEnumText(self, *args)


    def SetInt(self, *args) -> "void":
        """
        * This internal method gives access to a value implemented by an Integer (to set it)
        	:param val:
        	:type val: int
        	:rtype: void
        """
        return _StepData.StepData_SelectMember_SetInt(self, *args)


    def SetInteger(self, *args) -> "void":
        """
        :param val:
        	:type val: int
        	:rtype: None
        """
        return _StepData.StepData_SelectMember_SetInteger(self, *args)


    def SetKind(self, *args) -> "void":
        """
        :param kind:
        	:type kind: int
        	:rtype: void
        """
        return _StepData.StepData_SelectMember_SetKind(self, *args)


    def SetLogical(self, *args) -> "void":
        """
        :param val:
        	:type val: StepData_Logical
        	:rtype: None
        """
        return _StepData.StepData_SelectMember_SetLogical(self, *args)


    def SetName(self, *args) -> "Standard_Boolean":
        """
        * Sets the name of a SelectMember, returns True if done, False if no name is allowed Default does nothing and returns False
        	:param name:
        	:type name: char *
        	:rtype: bool
        """
        return _StepData.StepData_SelectMember_SetName(self, *args)


    def SetReal(self, *args) -> "void":
        """
        :param val:
        	:type val: float
        	:rtype: void
        """
        return _StepData.StepData_SelectMember_SetReal(self, *args)


    def SetString(self, *args) -> "void":
        """
        :param val:
        	:type val: char *
        	:rtype: void
        """
        return _StepData.StepData_SelectMember_SetString(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _StepData.StepData_SelectMember_swiginit(self, _StepData.new_StepData_SelectMember(*args))

    def String(self, *args) -> "char const *":
        """:rtype: char *"""
        return _StepData.StepData_SelectMember_String(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_SelectMember_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_SelectMember
StepData_SelectMember.Boolean = new_instancemethod(_StepData.StepData_SelectMember_Boolean, None, StepData_SelectMember)
StepData_SelectMember.Enum = new_instancemethod(_StepData.StepData_SelectMember_Enum, None, StepData_SelectMember)
StepData_SelectMember.EnumText = new_instancemethod(_StepData.StepData_SelectMember_EnumText, None, StepData_SelectMember)
StepData_SelectMember.HasName = new_instancemethod(_StepData.StepData_SelectMember_HasName, None, StepData_SelectMember)
StepData_SelectMember.Int = new_instancemethod(_StepData.StepData_SelectMember_Int, None, StepData_SelectMember)
StepData_SelectMember.Integer = new_instancemethod(_StepData.StepData_SelectMember_Integer, None, StepData_SelectMember)
StepData_SelectMember.Kind = new_instancemethod(_StepData.StepData_SelectMember_Kind, None, StepData_SelectMember)
StepData_SelectMember.Logical = new_instancemethod(_StepData.StepData_SelectMember_Logical, None, StepData_SelectMember)
StepData_SelectMember.Matches = new_instancemethod(_StepData.StepData_SelectMember_Matches, None, StepData_SelectMember)
StepData_SelectMember.Name = new_instancemethod(_StepData.StepData_SelectMember_Name, None, StepData_SelectMember)
StepData_SelectMember.ParamType = new_instancemethod(_StepData.StepData_SelectMember_ParamType, None, StepData_SelectMember)
StepData_SelectMember.Real = new_instancemethod(_StepData.StepData_SelectMember_Real, None, StepData_SelectMember)
StepData_SelectMember.SetBoolean = new_instancemethod(_StepData.StepData_SelectMember_SetBoolean, None, StepData_SelectMember)
StepData_SelectMember.SetEnum = new_instancemethod(_StepData.StepData_SelectMember_SetEnum, None, StepData_SelectMember)
StepData_SelectMember.SetEnumText = new_instancemethod(_StepData.StepData_SelectMember_SetEnumText, None, StepData_SelectMember)
StepData_SelectMember.SetInt = new_instancemethod(_StepData.StepData_SelectMember_SetInt, None, StepData_SelectMember)
StepData_SelectMember.SetInteger = new_instancemethod(_StepData.StepData_SelectMember_SetInteger, None, StepData_SelectMember)
StepData_SelectMember.SetKind = new_instancemethod(_StepData.StepData_SelectMember_SetKind, None, StepData_SelectMember)
StepData_SelectMember.SetLogical = new_instancemethod(_StepData.StepData_SelectMember_SetLogical, None, StepData_SelectMember)
StepData_SelectMember.SetName = new_instancemethod(_StepData.StepData_SelectMember_SetName, None, StepData_SelectMember)
StepData_SelectMember.SetReal = new_instancemethod(_StepData.StepData_SelectMember_SetReal, None, StepData_SelectMember)
StepData_SelectMember.SetString = new_instancemethod(_StepData.StepData_SelectMember_SetString, None, StepData_SelectMember)
StepData_SelectMember.String = new_instancemethod(_StepData.StepData_SelectMember_String, None, StepData_SelectMember)
StepData_SelectMember_swigregister = _StepData.StepData_SelectMember_swigregister
StepData_SelectMember_swigregister(StepData_SelectMember)

class StepData_SelectType(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Boolean(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _StepData.StepData_SelectType_Boolean(self, *args)


    def CaseMem(self, *args) -> "Standard_Integer":
        """
        * Recognize a SelectMember (kind, name). Returns a positive value which identifies the case in the List of immediate cases (distinct from the List of Entity Types). Zero if not recognizes Default returns 0, saying that no immediate value is allowed
        	:param ent:
        	:type ent: StepData_SelectMember
        	:rtype: int
        """
        return _StepData.StepData_SelectType_CaseMem(self, *args)


    def CaseMember(self, *args) -> "Standard_Integer":
        """
        * Returns the Type of the stored SelectMember, or zero if it is Null or Entity. Calls the method CaseMem on Value
        	:rtype: int
        """
        return _StepData.StepData_SelectType_CaseMember(self, *args)


    def CaseNum(self, *args) -> "Standard_Integer":
        """
        * Recognizes the Type of an Entity. Returns a positive Number which identifies the Type in the definition List of the SelectType. Returns Zero if its Type in not in this List.
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: int
        """
        return _StepData.StepData_SelectType_CaseNum(self, *args)


    def CaseNumber(self, *args) -> "Standard_Integer":
        """
        * Recognizes the Type of the stored Entity, or zero if it is Null or SelectMember. Calls the first method CaseNum on Value
        	:rtype: int
        """
        return _StepData.StepData_SelectType_CaseNumber(self, *args)


    def Description(self, *args) -> "opencascade::handle< StepData_PDescr >":
        """
        * Returns the Description which corresponds to <self> Null if no specific description to give. This description is used to control reading an check validity. Default returns a Null Handle, i.e. undefined description It can suffice if CaseNum and CaseMem give enough control
        	:rtype: opencascade::handle<StepData_PDescr>
        """
        return _StepData.StepData_SelectType_Description(self, *args)


    def Int(self, *args) -> "Standard_Integer":
        """
        * This internal method gives access to a value implemented by an Integer (to read it)
        	:rtype: int
        """
        return _StepData.StepData_SelectType_Int(self, *args)


    def Integer(self, *args) -> "Standard_Integer":
        """
        * Gets the value as an Integer
        	:rtype: int
        """
        return _StepData.StepData_SelectType_Integer(self, *args)


    def IsNull(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there is no Stored Entity (i.e. it is Null)
        	:rtype: bool
        """
        return _StepData.StepData_SelectType_IsNull(self, *args)


    def Logical(self, *args) -> "StepData_Logical":
        """:rtype: StepData_Logical"""
        return _StepData.StepData_SelectType_Logical(self, *args)


    def Matches(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the Type of an Entity complies with the definition list of the SelectType. Also checks for a SelectMember Default Implementation looks for CaseNum or CaseMem positive
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: bool
        """
        return _StepData.StepData_SelectType_Matches(self, *args)


    def Member(self, *args) -> "opencascade::handle< StepData_SelectMember >":
        """
        * Returns Value as a SelectMember. Null if not a SelectMember
        	:rtype: opencascade::handle<StepData_SelectMember>
        """
        return _StepData.StepData_SelectType_Member(self, *args)


    def NewMember(self, *args) -> "opencascade::handle< StepData_SelectMember >":
        """
        * Returns a preferred SelectMember. Default returns a Null By default, a SelectMember can be set according to data type and Name : it is a SelectNamed if Name is defined //! This method allows to define, for a specific SelectType, a specific SelectMember than SelectNamed. For instance for a Real plus a Name, a SelectReal plus a case number is a good solution, lighter than SelectNamed which is very multipurpose
        	:rtype: opencascade::handle<StepData_SelectMember>
        """
        return _StepData.StepData_SelectType_NewMember(self, *args)


    def Nullify(self, *args) -> "void":
        """
        * Nullifies the Stored Entity
        	:rtype: None
        """
        return _StepData.StepData_SelectType_Nullify(self, *args)


    def Real(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _StepData.StepData_SelectType_Real(self, *args)


    def SelectName(self, *args) -> "char const *":
        """
        * Returns the type name of SelectMember. If no SelectMember or with no type name, returns an empty string To change it, pass through the SelectMember itself
        	:rtype: char *
        """
        return _StepData.StepData_SelectType_SelectName(self, *args)


    def SetBoolean(self, *args) -> "void":
        """
        :param val:
        	:type val: bool
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _StepData.StepData_SelectType_SetBoolean(self, *args)


    def SetInt(self, *args) -> "void":
        """
        * This internal method gives access to a value implemented by an Integer (to set it) : a SelectMember MUST ALREADY BE THERE !
        	:param val:
        	:type val: int
        	:rtype: None
        """
        return _StepData.StepData_SelectType_SetInt(self, *args)


    def SetInteger(self, *args) -> "void":
        """
        * Sets a new Integer value, with an optional type name Warning : If a SelectMember is already set, works on it : value and name must then be accepted by this SelectMember
        	:param val:
        	:type val: int
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _StepData.StepData_SelectType_SetInteger(self, *args)


    def SetLogical(self, *args) -> "void":
        """
        :param val:
        	:type val: StepData_Logical
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _StepData.StepData_SelectType_SetLogical(self, *args)


    def SetReal(self, *args) -> "void":
        """
        :param val:
        	:type val: float
        	:param name: default value is 
        	:type name: char *
        	:rtype: None
        """
        return _StepData.StepData_SelectType_SetReal(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Stores an Entity. This allows to define a specific SelectType class with one read method per member Type, which returns the Value casted with the good Type.
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _StepData.StepData_SelectType_SetValue(self, *args)


    def Type(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        * Returns the Effective (Dynamic) Type of the Stored Entity If it is Null, returns TYPE(Transient)
        	:rtype: opencascade::handle<Standard_Type>
        """
        return _StepData.StepData_SelectType_Type(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        * Returns the Stored Entity. Can be used to define specific read methods (see above)
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _StepData.StepData_SelectType_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_SelectType
StepData_SelectType.Boolean = new_instancemethod(_StepData.StepData_SelectType_Boolean, None, StepData_SelectType)
StepData_SelectType.CaseMem = new_instancemethod(_StepData.StepData_SelectType_CaseMem, None, StepData_SelectType)
StepData_SelectType.CaseMember = new_instancemethod(_StepData.StepData_SelectType_CaseMember, None, StepData_SelectType)
StepData_SelectType.CaseNum = new_instancemethod(_StepData.StepData_SelectType_CaseNum, None, StepData_SelectType)
StepData_SelectType.CaseNumber = new_instancemethod(_StepData.StepData_SelectType_CaseNumber, None, StepData_SelectType)
StepData_SelectType.Description = new_instancemethod(_StepData.StepData_SelectType_Description, None, StepData_SelectType)
StepData_SelectType.Int = new_instancemethod(_StepData.StepData_SelectType_Int, None, StepData_SelectType)
StepData_SelectType.Integer = new_instancemethod(_StepData.StepData_SelectType_Integer, None, StepData_SelectType)
StepData_SelectType.IsNull = new_instancemethod(_StepData.StepData_SelectType_IsNull, None, StepData_SelectType)
StepData_SelectType.Logical = new_instancemethod(_StepData.StepData_SelectType_Logical, None, StepData_SelectType)
StepData_SelectType.Matches = new_instancemethod(_StepData.StepData_SelectType_Matches, None, StepData_SelectType)
StepData_SelectType.Member = new_instancemethod(_StepData.StepData_SelectType_Member, None, StepData_SelectType)
StepData_SelectType.NewMember = new_instancemethod(_StepData.StepData_SelectType_NewMember, None, StepData_SelectType)
StepData_SelectType.Nullify = new_instancemethod(_StepData.StepData_SelectType_Nullify, None, StepData_SelectType)
StepData_SelectType.Real = new_instancemethod(_StepData.StepData_SelectType_Real, None, StepData_SelectType)
StepData_SelectType.SelectName = new_instancemethod(_StepData.StepData_SelectType_SelectName, None, StepData_SelectType)
StepData_SelectType.SetBoolean = new_instancemethod(_StepData.StepData_SelectType_SetBoolean, None, StepData_SelectType)
StepData_SelectType.SetInt = new_instancemethod(_StepData.StepData_SelectType_SetInt, None, StepData_SelectType)
StepData_SelectType.SetInteger = new_instancemethod(_StepData.StepData_SelectType_SetInteger, None, StepData_SelectType)
StepData_SelectType.SetLogical = new_instancemethod(_StepData.StepData_SelectType_SetLogical, None, StepData_SelectType)
StepData_SelectType.SetReal = new_instancemethod(_StepData.StepData_SelectType_SetReal, None, StepData_SelectType)
StepData_SelectType.SetValue = new_instancemethod(_StepData.StepData_SelectType_SetValue, None, StepData_SelectType)
StepData_SelectType.Type = new_instancemethod(_StepData.StepData_SelectType_Type, None, StepData_SelectType)
StepData_SelectType.Value = new_instancemethod(_StepData.StepData_SelectType_Value, None, StepData_SelectType)
StepData_SelectType_swigregister = _StepData.StepData_SelectType_swigregister
StepData_SelectType_swigregister(StepData_SelectType)

class StepData_StepDumper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dump(self, *args) -> "Standard_Boolean":
        """
        * Dumps a Entity on an Messenger. Returns True if sucess, False, if the entity to dump has not been recognized by the Protocol. <level> can have one of these values : - 0 : prints the TYPE only, as known in STEP Files (StepType) If <ent> has not been regognized by the Protocol, or if its type is Complex, the StepType is replaced by the display of the cdl type. Complex Type are well processed by level 1. - 1 : dumps the entity, completely (whatever it has simple or complex type) but alone. - 2 : dumps the entity completely, plus the item its refers to at first level (a header message designates the starting entity of the dump) <Lists Shared and Implied> - 3 : dumps the entity and its refered items at any levels //! For levels 1,2,3, the numbers displayed (form #nnn) are the numbers of the corresponding entities in the Model
        	:param S:
        	:type S: Message_Messenger
        	:param ent:
        	:type ent: Standard_Transient
        	:param level:
        	:type level: int
        	:rtype: bool
        * Works as Dump with a Transient, but directly takes the entity designated by its number in the Model Returns False, also if <num> is out of range
        	:param S:
        	:type S: Message_Messenger
        	:param num:
        	:type num: int
        	:param level:
        	:type level: int
        	:rtype: bool
        """
        return _StepData.StepData_StepDumper_Dump(self, *args)


    def __init__(self, *args):
        """
        * Creates a StepDumper, able to work on a given StepModel (which defines the total scope for dumping entities) and a given Protocol from Step (which defines the authorized types to be dumped) <mode> commands what is to be displayed (number or label) 0 for number (and corresponding labels are displayed apart) 1 for label (and corresponding numbers are displayed apart) 2 for label without anymore
        	:param amodel:
        	:type amodel: StepData_StepModel
        	:param protocol:
        	:type protocol: StepData_Protocol
        	:param mode: default value is 0
        	:type mode: int
        	:rtype: None
        """
        _StepData.StepData_StepDumper_swiginit(self, _StepData.new_StepData_StepDumper(*args))

    def StepWriter(self, *args) -> "StepData_StepWriter &":
        """
        * Gives an access to the tool which is used to work : this allow to acts on some parameters : Floating Format, Scopes ...
        	:rtype: StepData_StepWriter
        """
        return _StepData.StepData_StepDumper_StepWriter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_StepDumper
StepData_StepDumper.Dump = new_instancemethod(_StepData.StepData_StepDumper_Dump, None, StepData_StepDumper)
StepData_StepDumper.StepWriter = new_instancemethod(_StepData.StepData_StepDumper_StepWriter, None, StepData_StepDumper)
StepData_StepDumper_swigregister = _StepData.StepData_StepDumper_swigregister
StepData_StepDumper_swigregister(StepData_StepDumper)

class StepData_StepModel(OCC.Core.Interface.Interface_InterfaceModel):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddHeaderEntity(self, *args) -> "void":
        """
        * Adds an Entity to the Header
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: None
        """
        return _StepData.StepData_StepModel_AddHeaderEntity(self, *args)


    def Entity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * returns entity given its rank. Same as InterfaceEntity, but with a shorter name
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _StepData.StepData_StepModel_Entity(self, *args)


    def HasHeaderEntity(self, *args) -> "Standard_Boolean":
        """
        * says if a Header entity has a specifed type
        	:param atype:
        	:type atype: Standard_Type
        	:rtype: bool
        """
        return _StepData.StepData_StepModel_HasHeaderEntity(self, *args)


    def Header(self, *args) -> "Interface_EntityIterator":
        """
        * returns Header entities under the form of an iterator
        	:rtype: Interface_EntityIterator
        """
        return _StepData.StepData_StepModel_Header(self, *args)


    def HeaderEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        * Returns Header entity with specified type, if there is
        	:param atype:
        	:type atype: Standard_Type
        	:rtype: opencascade::handle<Standard_Transient>
        """
        return _StepData.StepData_StepModel_HeaderEntity(self, *args)


    def IdentLabel(self, *args) -> "Standard_Integer":
        """
        * returns the label ident attached to an entity, 0 if not in me
        	:param ent:
        	:type ent: Standard_Transient
        	:rtype: int
        """
        return _StepData.StepData_StepModel_IdentLabel(self, *args)


    def SetIdentLabel(self, *args) -> "void":
        """
        * Attaches an ident to an entity to produce a label (does nothing if <ent> is not in <self>)
        	:param ent:
        	:type ent: Standard_Transient
        	:param ident:
        	:type ident: int
        	:rtype: None
        """
        return _StepData.StepData_StepModel_SetIdentLabel(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty STEP model with an empty header.
        	:rtype: None
        """
        _StepData.StepData_StepModel_swiginit(self, _StepData.new_StepData_StepModel(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_StepModel_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_StepModel
StepData_StepModel.AddHeaderEntity = new_instancemethod(_StepData.StepData_StepModel_AddHeaderEntity, None, StepData_StepModel)
StepData_StepModel.Entity = new_instancemethod(_StepData.StepData_StepModel_Entity, None, StepData_StepModel)
StepData_StepModel.HasHeaderEntity = new_instancemethod(_StepData.StepData_StepModel_HasHeaderEntity, None, StepData_StepModel)
StepData_StepModel.Header = new_instancemethod(_StepData.StepData_StepModel_Header, None, StepData_StepModel)
StepData_StepModel.HeaderEntity = new_instancemethod(_StepData.StepData_StepModel_HeaderEntity, None, StepData_StepModel)
StepData_StepModel.IdentLabel = new_instancemethod(_StepData.StepData_StepModel_IdentLabel, None, StepData_StepModel)
StepData_StepModel.SetIdentLabel = new_instancemethod(_StepData.StepData_StepModel_SetIdentLabel, None, StepData_StepModel)
StepData_StepModel_swigregister = _StepData.StepData_StepModel_swigregister
StepData_StepModel_swigregister(StepData_StepModel)

class StepData_StepReaderData(OCC.Core.Interface.Interface_FileReaderData):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddStepParam(self, *args) -> "void":
        """
        * Fills the fields of a parameter of a record. This is a variant of AddParam, Adapted to STEP (optimized for specific values)
        	:param num:
        	:type num: int
        	:param aval:
        	:type aval: char *
        	:param atype:
        	:type atype: Interface_ParamType
        	:param nument: default value is 0
        	:type nument: int
        	:rtype: None
        """
        return _StepData.StepData_StepReaderData_AddStepParam(self, *args)


    def CType(self, *args) -> "char const *":
        """
        * Returns Record Type as a CString was C++ : return const
        	:param num:
        	:type num: int
        	:rtype: char *
        """
        return _StepData.StepData_StepReaderData_CType(self, *args)


    def CheckDerived(self, *args) -> "Standard_Boolean":
        """
        * Checks if parameter <nump> of record <num> is given as Derived If this Check is successful (i.e. Param = '*'), returns True Else, fills <ach> with a Message which contains <mess> and returns False. According to <errstat>, this message is Warning if errstat is False (Default), Fail if errstat is True
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param errstat: default value is Standard_False
        	:type errstat: bool
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_CheckDerived(self, *args)


    def CheckNbParams(self, *args) -> "Standard_Boolean":
        """
        * Checks Count of Parameters of record <num> to equate <nbreq> If this Check is successful, returns True Else, fills <ach> with an Error Message then returns False <mess> is included in the Error message if given non empty
        	:param num:
        	:type num: int
        	:param nbreq:
        	:type nbreq: int
        	:param ach:
        	:type ach: Interface_Check
        	:param mess: default value is 
        	:type mess: char *
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_CheckNbParams(self, *args)


    def ComplexType(self, *args) -> "void":
        """
        * Returns the List of Types which correspond to a Complex Type Entity. If not Complex, there is just one Type in it For a SubList or a Scope mark, <types> remains empty
        	:param num:
        	:type num: int
        	:param types:
        	:type types: TColStd_SequenceOfAsciiString
        	:rtype: None
        """
        return _StepData.StepData_StepReaderData_ComplexType(self, *args)


    def FailEnumValue(self, *args) -> "void":
        """
        * Fills a check with a fail message if enumeration value does match parameter definition Just a help to centralize message definitions
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: None
        """
        return _StepData.StepData_StepReaderData_FailEnumValue(self, *args)


    def FindNextHeaderRecord(self, *args) -> "Standard_Integer":
        """
        * determine first suitable record of Header works as FindNextRecord, but treats only Header records
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _StepData.StepData_StepReaderData_FindNextHeaderRecord(self, *args)


    def GlobalCheck(self, *args) -> "opencascade::handle< Interface_Check > const":
        """
        * Returns the Global Check. It can record Fail messages about Undefined References (detected by SetEntityNumbers)
        	:rtype: opencascade::handle<Interface_Check>
        """
        return _StepData.StepData_StepReaderData_GlobalCheck(self, *args)


    def IsComplex(self, *args) -> "Standard_Boolean":
        """
        * Returns True if <num> corresponds to a Complex Type Entity (as can be defined by ANDOR Express clause)
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_IsComplex(self, *args)


    def NamedForComplex(self, *args) -> "Standard_Boolean":
        """
        * Determines the first component which brings a given name, for a Complex Type Entity <num0> is the very first record of this entity <num> is given the last NextNamedForComplex, starts at zero it is returned as the newly found number Hence, in the normal case, NextNamedForComplex starts by num0 if <num> is zero, else by NextForComplex(num) If the alphabetic order is not respected, it restarts from num0 and loops on NextForComplex until finding <name> In case of 'non-alphabetic order', <ach> is filled with a Warning for this name In case of 'not-found at all', <ach> is filled with a Fail, and <num> is returned as zero //! Returns True if alphabetic order, False else
        	:param name:
        	:type name: char *
        	:param num0:
        	:type num0: int
        	:param num:
        	:type num: int
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: bool
        * Determines the first component which brings a given name, or short name for a Complex Type Entity <num0> is the very first record of this entity <num> is given the last NextNamedForComplex, starts at zero it is returned as the newly found number Hence, in the normal case, NextNamedForComplex starts by num0 if <num> is zero, else by NextForComplex(num) If the alphabetic order is not respected, it restarts from num0 and loops on NextForComplex until finding <name> In case of 'non-alphabetic order', <ach> is filled with a Warning for this name In case of 'not-found at all', <ach> is filled with a Fail, and <num> is returned as zero //! Returns True if alphabetic order, False else
        	:param theName:
        	:type theName: char *
        	:param theShortName:
        	:type theShortName: char *
        	:param num0:
        	:type num0: int
        	:param num:
        	:type num: int
        	:param ach:
        	:type ach: Interface_Check
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_NamedForComplex(self, *args)


    def NextForComplex(self, *args) -> "Standard_Integer":
        """
        * Returns the Next 'Componant' for a Complex Type Entity, of which <num> is already a Componant (the first one or a next one) Returns 0 for a Simple Type or for the last Componant
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _StepData.StepData_StepReaderData_NextForComplex(self, *args)


    def PrepareHeader(self, *args) -> "void":
        """
        * Works as SetEntityNumbers but for Header : more simple because there are no Reference, only Sub-Lists
        	:rtype: None
        """
        return _StepData.StepData_StepReaderData_PrepareHeader(self, *args)


    def ReadAny(self, *args) -> "Standard_Boolean":
        """
        * Reads parameter <nump> of record <num> into a Transient Value according to the type of the parameter : Named for Integer,Boolean,Logical,Enum,Real : SelectNamed Immediate Integer,Boolean,Logical,Enum,Real : SelectInt/Real Text : HAsciiString Ident : the referenced Entity Sub-List not processed, see ReadSub This value is controlled by a Parameter Descriptor (PDescr), which controls its allowed type and value <ach> is filled if the read parameter does not match its description (the select is nevertheless created if possible) //! Warning : val is in out, hence it is possible to predefine a specific SelectMember then to fill it. If <val> is Null or if the result is not a SelectMember, val itself is returned a new ref For a Select with a Name, <val> must then be a SelectNamed
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param descr:
        	:type descr: StepData_PDescr
        	:param val:
        	:type val: Standard_Transient
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadAny(self, *args)


    def ReadBoolean(self, *args) -> "Standard_Boolean":
        """
        * reads parameter <nump> of record <num> as a Boolean Return value and Check managed as by ReadReal (demands a Boolean enum, i.e. text '.T.' for True or '.F.' for False)
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param flag:
        	:type flag: bool
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadBoolean(self, *args)


    def ReadEnum(self, *args) -> "Standard_Boolean":
        """
        * Reads parameter <nump> of record <num> as an Enumeration (text between dots) and converts it to an integer value, by an EnumTool. Returns True if OK, false if : this parameter is not enumeration, or is not recognized by the EnumTool (with fail)
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param enumtool:
        	:type enumtool: StepData_EnumTool
        	:param val:
        	:type val: int
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadEnum(self, *args)


    def ReadEnumParam(self, *args) -> "Standard_Boolean":
        """
        :param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param text:
        	:type text: char *
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadEnumParam(self, *args)


    def ReadField(self, *args) -> "Standard_Boolean":
        """
        * reads parameter <nump> of record <num> into a Field, controlled by a Parameter Descriptor (PDescr), which controls its allowed type(s) and value <ach> is filled if the read parameter does not match its description (but the field is read anyway) If the description is not defined, no control is done Returns True when done
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param descr:
        	:type descr: StepData_PDescr
        	:param fild:
        	:type fild: StepData_Field
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadField(self, *args)


    def ReadInteger(self, *args) -> "Standard_Boolean":
        """
        * reads parameter <nump> of record <num> as a single Integer. Return value & Check managed as by ReadXY (demands an Integer)
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param val:
        	:type val: int
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadInteger(self, *args)


    def ReadList(self, *args) -> "Standard_Boolean":
        """
        * reads a list of fields controlled by an ESDescr
        	:param num:
        	:type num: int
        	:param ach:
        	:type ach: Interface_Check
        	:param descr:
        	:type descr: StepData_ESDescr
        	:param list:
        	:type list: StepData_FieldList
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadList(self, *args)


    def ReadLogical(self, *args) -> "Standard_Boolean":
        """
        * reads parameter <nump> of record <num> as a Logical Return value and Check managed as by ReadBoolean (demands a Logical enum, i.e. text '.T.', '.F.', or '.U.')
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param flag:
        	:type flag: StepData_Logical
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadLogical(self, *args)


    def ReadReal(self, *args) -> "Standard_Boolean":
        """
        * reads parameter <nump> of record <num> as a single Real value. Return value and Check managed as by ReadXY (demands a Real)
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param val:
        	:type val: float
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadReal(self, *args)


    def ReadString(self, *args) -> "Standard_Boolean":
        """
        * reads parameter <nump> of record <num> as a String (text between quotes, quotes are removed by the Read operation) Return value and Check managed as by ReadXY (demands a String)
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param val:
        	:type val: TCollection_HAsciiString
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadString(self, *args)


    def ReadSub(self, *args) -> "Standard_Integer":
        """
        * reads the content of a sub-list into a transient : SelectNamed, or HArray1 of Integer,Real,String,Transient ... recursive call if list of list ... If a sub-list has mixed types, an HArray1OfTransient is produced, it may contain SelectMember Intended to be called by ReadField The returned status is : negative if failed, 0 if empty. Else the kind to be recorded in the field
        	:param numsub:
        	:type numsub: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param descr:
        	:type descr: StepData_PDescr
        	:param val:
        	:type val: Standard_Transient
        	:rtype: int
        """
        return _StepData.StepData_StepReaderData_ReadSub(self, *args)


    def ReadSubList(self, *args) -> "Standard_Boolean":
        """
        * reads parameter <nump> of record <num> as a sub-list (may be typed, see ReadTypedParameter in this case) Returns True if OK. Else (not a LIST), returns false and feeds Check with appropriate check If <optional> is True and Param is not defined, returns True with <ach> not filled and <numsub> returned as 0 Works with SubListNumber with <aslast> false (no specific case for last parameter)
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param numsub:
        	:type numsub: int
        	:param optional: default value is Standard_False
        	:type optional: bool
        	:param lenmin: default value is 0
        	:type lenmin: int
        	:param lenmax: default value is 0
        	:type lenmax: int
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadSubList(self, *args)


    def ReadTypedParam(self, *args) -> "Standard_Boolean":
        """
        * Resolves a parameter which can be enclosed in a type def., as TYPE(val). The parameter must then be read normally according its type. Parameter to be resolved is <nump> of record <num> <mustbetyped> True demands a typed parameter <mustbetyped> False accepts a non-typed parameter as option mess and ach as usual <numr>,<numrp> are the resolved record and parameter numbers = num,nump if no type, else numrp=1 <typ> returns the recorded type, or empty string Remark : a non-typed list is considered as 'non-typed'
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mustbetyped:
        	:type mustbetyped: bool
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param numr:
        	:type numr: int
        	:param numrp:
        	:type numrp: int
        	:param typ:
        	:type typ: TCollection_AsciiString
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadTypedParam(self, *args)


    def ReadXY(self, *args) -> "Standard_Boolean":
        """
        * reads parameter <nump> of record <num> as a sub-list of two Reals X,Y. Returns True if OK. Else, returns false and feeds Check with appropriate Fails (parameter not a sub-list, not two Reals in the sub-list) composed with 'mess' which gives the name of the parameter
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadXY(self, *args)


    def ReadXYZ(self, *args) -> "Standard_Boolean":
        """
        * reads parameter <nump> of record <num> as a sub-list of three Reals X,Y,Z. Return value and Check managed as by ReadXY (demands a sub-list of three Reals)
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param mess:
        	:type mess: char *
        	:param ach:
        	:type ach: Interface_Check
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: bool
        """
        return _StepData.StepData_StepReaderData_ReadXYZ(self, *args)


    def RecordIdent(self, *args) -> "Standard_Integer":
        """
        * Returns record identifier (Positive number) If returned ident is not positive : Sub-List or Scope mark
        	:param num:
        	:type num: int
        	:rtype: int
        """
        return _StepData.StepData_StepReaderData_RecordIdent(self, *args)


    def RecordType(self, *args) -> "TCollection_AsciiString const &":
        """
        * Returns Record Type
        	:param num:
        	:type num: int
        	:rtype: TCollection_AsciiString
        """
        return _StepData.StepData_StepReaderData_RecordType(self, *args)


    def SetEntityNumbers(self, *args) -> "void":
        """
        * determines reference numbers in EntityNumber fields called by Prepare from StepReaderTool to prepare later using by a StepModel. This method is attached to StepReaderData because it needs a massive amount of data accesses to work //! If <withmap> is given False, the basic exploration algorithm is activated, otherwise a map is used as far as it is possible this option can be used only to test this algorithm
        	:param withmap: default value is Standard_True
        	:type withmap: bool
        	:rtype: None
        """
        return _StepData.StepData_StepReaderData_SetEntityNumbers(self, *args)


    def SetRecord(self, *args) -> "void":
        """
        * Fills the fields of a record
        	:param num:
        	:type num: int
        	:param ident:
        	:type ident: char *
        	:param type:
        	:type type: char *
        	:param nbpar:
        	:type nbpar: int
        	:rtype: None
        """
        return _StepData.StepData_StepReaderData_SetRecord(self, *args)


    def __init__(self, *args):
        """
        * creates StepReaderData correctly dimensionned (necessary at creation time, because it contains arrays) nbheader is nb of records for Header, nbtotal for Header+Data and nbpar gives the total count of parameters
        	:param nbheader:
        	:type nbheader: int
        	:param nbtotal:
        	:type nbtotal: int
        	:param nbpar:
        	:type nbpar: int
        	:rtype: None
        """
        _StepData.StepData_StepReaderData_swiginit(self, _StepData.new_StepData_StepReaderData(*args))

    def SubListNumber(self, *args) -> "Standard_Integer":
        """
        * Returns SubList numero designated by a parameter (nump) in a record (num), or zero if the parameter does not exist or is not a SubList address. Zero too If aslast is True and nump is not for the last parameter
        	:param num:
        	:type num: int
        	:param nump:
        	:type nump: int
        	:param aslast:
        	:type aslast: bool
        	:rtype: int
        """
        return _StepData.StepData_StepReaderData_SubListNumber(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_StepReaderData_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_StepReaderData
StepData_StepReaderData.AddStepParam = new_instancemethod(_StepData.StepData_StepReaderData_AddStepParam, None, StepData_StepReaderData)
StepData_StepReaderData.CType = new_instancemethod(_StepData.StepData_StepReaderData_CType, None, StepData_StepReaderData)
StepData_StepReaderData.CheckDerived = new_instancemethod(_StepData.StepData_StepReaderData_CheckDerived, None, StepData_StepReaderData)
StepData_StepReaderData.CheckNbParams = new_instancemethod(_StepData.StepData_StepReaderData_CheckNbParams, None, StepData_StepReaderData)
StepData_StepReaderData.ComplexType = new_instancemethod(_StepData.StepData_StepReaderData_ComplexType, None, StepData_StepReaderData)
StepData_StepReaderData.FailEnumValue = new_instancemethod(_StepData.StepData_StepReaderData_FailEnumValue, None, StepData_StepReaderData)
StepData_StepReaderData.FindNextHeaderRecord = new_instancemethod(_StepData.StepData_StepReaderData_FindNextHeaderRecord, None, StepData_StepReaderData)
StepData_StepReaderData.GlobalCheck = new_instancemethod(_StepData.StepData_StepReaderData_GlobalCheck, None, StepData_StepReaderData)
StepData_StepReaderData.IsComplex = new_instancemethod(_StepData.StepData_StepReaderData_IsComplex, None, StepData_StepReaderData)
StepData_StepReaderData.NamedForComplex = new_instancemethod(_StepData.StepData_StepReaderData_NamedForComplex, None, StepData_StepReaderData)
StepData_StepReaderData.NextForComplex = new_instancemethod(_StepData.StepData_StepReaderData_NextForComplex, None, StepData_StepReaderData)
StepData_StepReaderData.PrepareHeader = new_instancemethod(_StepData.StepData_StepReaderData_PrepareHeader, None, StepData_StepReaderData)
StepData_StepReaderData.ReadAny = new_instancemethod(_StepData.StepData_StepReaderData_ReadAny, None, StepData_StepReaderData)
StepData_StepReaderData.ReadBoolean = new_instancemethod(_StepData.StepData_StepReaderData_ReadBoolean, None, StepData_StepReaderData)
StepData_StepReaderData.ReadEnum = new_instancemethod(_StepData.StepData_StepReaderData_ReadEnum, None, StepData_StepReaderData)
StepData_StepReaderData.ReadEnumParam = new_instancemethod(_StepData.StepData_StepReaderData_ReadEnumParam, None, StepData_StepReaderData)
StepData_StepReaderData.ReadField = new_instancemethod(_StepData.StepData_StepReaderData_ReadField, None, StepData_StepReaderData)
StepData_StepReaderData.ReadInteger = new_instancemethod(_StepData.StepData_StepReaderData_ReadInteger, None, StepData_StepReaderData)
StepData_StepReaderData.ReadList = new_instancemethod(_StepData.StepData_StepReaderData_ReadList, None, StepData_StepReaderData)
StepData_StepReaderData.ReadLogical = new_instancemethod(_StepData.StepData_StepReaderData_ReadLogical, None, StepData_StepReaderData)
StepData_StepReaderData.ReadReal = new_instancemethod(_StepData.StepData_StepReaderData_ReadReal, None, StepData_StepReaderData)
StepData_StepReaderData.ReadString = new_instancemethod(_StepData.StepData_StepReaderData_ReadString, None, StepData_StepReaderData)
StepData_StepReaderData.ReadSub = new_instancemethod(_StepData.StepData_StepReaderData_ReadSub, None, StepData_StepReaderData)
StepData_StepReaderData.ReadSubList = new_instancemethod(_StepData.StepData_StepReaderData_ReadSubList, None, StepData_StepReaderData)
StepData_StepReaderData.ReadTypedParam = new_instancemethod(_StepData.StepData_StepReaderData_ReadTypedParam, None, StepData_StepReaderData)
StepData_StepReaderData.ReadXY = new_instancemethod(_StepData.StepData_StepReaderData_ReadXY, None, StepData_StepReaderData)
StepData_StepReaderData.ReadXYZ = new_instancemethod(_StepData.StepData_StepReaderData_ReadXYZ, None, StepData_StepReaderData)
StepData_StepReaderData.RecordIdent = new_instancemethod(_StepData.StepData_StepReaderData_RecordIdent, None, StepData_StepReaderData)
StepData_StepReaderData.RecordType = new_instancemethod(_StepData.StepData_StepReaderData_RecordType, None, StepData_StepReaderData)
StepData_StepReaderData.SetEntityNumbers = new_instancemethod(_StepData.StepData_StepReaderData_SetEntityNumbers, None, StepData_StepReaderData)
StepData_StepReaderData.SetRecord = new_instancemethod(_StepData.StepData_StepReaderData_SetRecord, None, StepData_StepReaderData)
StepData_StepReaderData.SubListNumber = new_instancemethod(_StepData.StepData_StepReaderData_SubListNumber, None, StepData_StepReaderData)
StepData_StepReaderData_swigregister = _StepData.StepData_StepReaderData_swigregister
StepData_StepReaderData_swigregister(StepData_StepReaderData)

class StepData_StepReaderTool(OCC.Core.Interface.Interface_FileReaderTool):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Prepare(self, *args) -> "void":
        """
        * Bounds empty entities to records, uses default Recognition provided by ReaderLib and ReaderModule. Also calls computation of references (SetEntityNumbers from StepReaderData) Works only on data entities (skips header) <optimize> given False allows to test some internal algorithms which are normally avoided (see also StepReaderData)
        	:param optimize: default value is Standard_True
        	:type optimize: bool
        	:rtype: None
        * Bounds empty entities to records, works with a specific FileRecognizer, stored and later used in Recognize Works only on data entities (skips header) <optimize : same as above
        	:param reco:
        	:type reco: StepData_FileRecognizer
        	:param optimize: default value is Standard_True
        	:type optimize: bool
        	:rtype: None
        """
        return _StepData.StepData_StepReaderTool_Prepare(self, *args)


    def PrepareHeader(self, *args) -> "void":
        """
        * bounds empty entities and sub-lists to header records works like Prepare + SetEntityNumbers, but for header (N.B.: in Header, no Ident and no reference) FileRecognizer is to specify Entities which are allowed to be defined in the Header (not every type can be)
        	:param reco:
        	:type reco: StepData_FileRecognizer
        	:rtype: None
        """
        return _StepData.StepData_StepReaderTool_PrepareHeader(self, *args)


    def __init__(self, *args):
        """
        * creates StepReaderTool to work with a StepReaderData according to a Step Protocol. Defines the ReaderLib at this time
        	:param reader:
        	:type reader: StepData_StepReaderData
        	:param protocol:
        	:type protocol: StepData_Protocol
        	:rtype: None
        """
        _StepData.StepData_StepReaderTool_swiginit(self, _StepData.new_StepData_StepReaderTool(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_StepReaderTool
StepData_StepReaderTool.Prepare = new_instancemethod(_StepData.StepData_StepReaderTool_Prepare, None, StepData_StepReaderTool)
StepData_StepReaderTool.PrepareHeader = new_instancemethod(_StepData.StepData_StepReaderTool_PrepareHeader, None, StepData_StepReaderTool)
StepData_StepReaderTool_swigregister = _StepData.StepData_StepReaderTool_swigregister
StepData_StepReaderTool_swigregister(StepData_StepReaderTool)

class StepData_StepWriter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddParam(self, *args) -> "void":
        """
        * prepares adding a parameter (that is, adds ',' except for first one); normally for internal use; can be used to send a totally empty parameter (with no litteral value)
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_AddParam(self, *args)


    def CheckList(self, *args) -> "Interface_CheckIterator":
        """
        * Returns the check-list, which has received possible checks : for unknown entities, badly loaded ones, null or unknown references
        	:rtype: Interface_CheckIterator
        """
        return _StepData.StepData_StepWriter_CheckList(self, *args)


    def CloseSub(self, *args) -> "void":
        """
        * closes a sublist by a ')'
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_CloseSub(self, *args)


    def Comment(self, *args) -> "void":
        """
        * sets a comment mark : if mode is True, begins Comment zone, if mode is False, ends Comment zone (if one is begun)
        	:param mode:
        	:type mode: bool
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_Comment(self, *args)


    def EndComplex(self, *args) -> "void":
        """
        * sends the end of a complex entity : a simple closed bracket It must be called AFTER sending all the componants and BEFORE the final call to EndEntity
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_EndComplex(self, *args)


    def EndEntity(self, *args) -> "void":
        """
        * sends end of entity (closing bracket plus ';') Error if count of opened-closed brackets is not null
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_EndEntity(self, *args)


    def EndFile(self, *args) -> "void":
        """
        * sets end of file; error is EndSec was not set
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_EndFile(self, *args)


    def EndSec(self, *args) -> "void":
        """
        * sets end of section; to be done before passing to next one
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_EndSec(self, *args)


    def FloatWriter(self, *args) -> "Interface_FloatWriter &":
        """
        * Returns the embedded FloatWriter, which controls sending Reals Use this method to access FloatWriter in order to consult or change its options (MainFormat, FormatForRange,ZeroSuppress), because it is returned as the address of its field
        	:rtype: Interface_FloatWriter
        """
        return _StepData.StepData_StepWriter_FloatWriter(self, *args)


    def Indent(self, *args) -> "void":
        """
        * asks that further indentations will begin at position of entity first opening bracket; else they begin at zero (def) for each sublist level, two more blancks are added at beginning (except for text continuation, which must begin at true zero)
        	:param onent:
        	:type onent: bool
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_Indent(self, *args)


    def IsInScope(self, *args) -> "Standard_Boolean":
        """
        * Returns True if an Entity identified by its Number is in a Scope
        	:param num:
        	:type num: int
        	:rtype: bool
        """
        return _StepData.StepData_StepWriter_IsInScope(self, *args)


    def JoinLast(self, *args) -> "void":
        """
        * joins current line to last one, only if new length is 72 max if newline is True, a new current line begins; else, current line is set to the last line (once joined) itself an can be completed
        	:param newline:
        	:type newline: bool
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_JoinLast(self, *args)


    def GetLabelMode(self) -> "Standard_Integer":
        """GetLabelMode(StepData_StepWriter self) -> Standard_Integer"""
        return _StepData.StepData_StepWriter_GetLabelMode(self)


    def SetLabelMode(self, value: 'Standard_Integer') -> "void":
        """SetLabelMode(StepData_StepWriter self, Standard_Integer value)"""
        return _StepData.StepData_StepWriter_SetLabelMode(self, value)


    def Line(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        * Returns a Line given its rank in the File
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<TCollection_HAsciiString>
        """
        return _StepData.StepData_StepWriter_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        * Returns count of Lines
        	:rtype: int
        """
        return _StepData.StepData_StepWriter_NbLines(self, *args)


    def NewLine(self, *args) -> "void":
        """
        * flushes current line; if empty, flushes it (defines a new empty line) if evenempty is True; else, skips it
        	:param evenempty:
        	:type evenempty: bool
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_NewLine(self, *args)


    def OpenSub(self, *args) -> "void":
        """
        * open a sublist by a '('
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_OpenSub(self, *args)


    def OpenTypedSub(self, *args) -> "void":
        """
        * open a sublist with its type then a '('
        	:param subtype:
        	:type subtype: char *
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_OpenTypedSub(self, *args)


    def PrintToString(self) -> "std::string":
        """PrintToString(StepData_StepWriter self) -> std::string"""
        return _StepData.StepData_StepWriter_PrintToString(self)


    def Send(self, *args) -> "void":
        """
        * sends an integer parameter
        	:param val:
        	:type val: int
        	:rtype: None
        * sends a real parameter (wroks with FloatWriter)
        	:param val:
        	:type val: float
        	:rtype: None
        * sends a text given as string (it will be set between '...')
        	:param val:
        	:type val: TCollection_AsciiString
        	:rtype: None
        * sends a reference to an entity (its identifier with '#') REMARK 1 : a Null <val> is interpreted as 'Undefined' REMARK 2 : for an HAsciiString which is not recorded in the Model, it is send as its String Content, between quotes
        	:param val:
        	:type val: Standard_Transient
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_Send(self, *args)


    def SendArrReal(self, *args) -> "void":
        """
        * sends an array of real
        	:param anArr:
        	:type anArr: TColStd_HArray1OfReal
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendArrReal(self, *args)


    def SendBoolean(self, *args) -> "void":
        """
        * sends a Boolean as .T. for True or .F. for False (it is an useful case of Enum, which is built-in)
        	:param val:
        	:type val: bool
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendBoolean(self, *args)


    def SendComment(self, *args) -> "void":
        """
        * sends a comment. Error if we are not inside a comment zone
        	:param text:
        	:type text: TCollection_HAsciiString
        	:rtype: None
        * same as above but accepts a CString (ex.: '...' directly)
        	:param text:
        	:type text: char *
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendComment(self, *args)


    def SendData(self, *args) -> "void":
        """
        * Begins data section; error if EndSec was not set
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendData(self, *args)


    def SendDerived(self, *args) -> "void":
        """
        * sends a 'Derived' parameter (by '*'). A Derived Parameter has been inherited from a Super-Type then redefined as being computed by a function. Hence its value in file is senseless.
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendDerived(self, *args)


    def SendEndscope(self, *args) -> "void":
        """
        * sets an end of Scope (on a separate line)
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendEndscope(self, *args)


    def SendEntity(self, *args) -> "void":
        """
        * Send an Entity of the Data Section. If it corresponds to a Scope, also Sends the Scope informations and contained Items
        	:param nument:
        	:type nument: int
        	:param lib:
        	:type lib: StepData_WriterLib
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendEntity(self, *args)


    def SendEnum(self, *args) -> "void":
        """
        * sends an enum given by String (litteral expression) adds '.' around it if not done Remark : val can be computed by class EnumTool from StepData: StepWriter.SendEnum (myenum.Text(enumval));
        	:param val:
        	:type val: TCollection_AsciiString
        	:rtype: None
        * sends an enum given by String (litteral expression) adds '.' around it if not done
        	:param val:
        	:type val: char *
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendEnum(self, *args)


    def SendField(self, *args) -> "void":
        """
        * Sends the content of a field, controlled by its descriptor If the descriptor is not defined, follows the description detained by the field itself
        	:param fild:
        	:type fild: StepData_Field
        	:param descr:
        	:type descr: StepData_PDescr
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendField(self, *args)


    def SendHeader(self, *args) -> "void":
        """
        * Begins model header
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendHeader(self, *args)


    def SendIdent(self, *args) -> "void":
        """
        * begins an entity with an ident plus '=' (at beginning of line) entity ident is its Number given by the containing Model Warning : <ident> must be, either Number or Label, according LabelMode
        	:param ident:
        	:type ident: int
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendIdent(self, *args)


    def SendList(self, *args) -> "void":
        """
        * Send the content of an entity as being a FieldList controlled by its descriptor. This includes start and end brackets but not the entity type
        	:param list:
        	:type list: StepData_FieldList
        	:param descr:
        	:type descr: StepData_ESDescr
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendList(self, *args)


    def SendLogical(self, *args) -> "void":
        """
        * sends a Logical as .T. or .F. or .U. according its Value (it is a standard case of Enum for Step, and is built-in)
        	:param val:
        	:type val: StepData_Logical
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendLogical(self, *args)


    def SendModel(self, *args) -> "void":
        """
        * Sends the complete Model, included HEADER and DATA Sections Works with a WriterLib defined through a Protocol If <headeronly> is given True, only the HEADER Section is sent (used to Dump the Header of a StepModel)
        	:param protocol:
        	:type protocol: StepData_Protocol
        	:param headeronly: default value is Standard_False
        	:type headeronly: bool
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendModel(self, *args)


    def SendScope(self, *args) -> "void":
        """
        * sets a begin of Scope (ends this line)
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendScope(self, *args)


    def SendSelect(self, *args) -> "void":
        """
        * Sends a SelectMember, which cab be named or not
        	:param sm:
        	:type sm: StepData_SelectMember
        	:param descr:
        	:type descr: StepData_PDescr
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendSelect(self, *args)


    def SendString(self, *args) -> "void":
        """
        * sends a string exactly as it is given
        	:param val:
        	:type val: TCollection_AsciiString
        	:rtype: None
        * sends a string exactly as it is given
        	:param val:
        	:type val: char *
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendString(self, *args)


    def SendUndef(self, *args) -> "void":
        """
        * sends an undefined (optionnal absent) parameter (by '$')
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SendUndef(self, *args)


    def SetScope(self, *args) -> "void":
        """
        * Declares the Entity Number <numscope> to correspond to a Scope which contains the Entity Number <numin>. Several calls to the same <numscope> add Entities in this Scope, in this order. Error if <numin> is already declared in the Scope Warning : the declaration of the Scopes is assumed to be consistent, i.e. <numin> is not referenced from outside this Scope (not checked here)
        	:param numscope:
        	:type numscope: int
        	:param numin:
        	:type numin: int
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_SetScope(self, *args)


    def StartComplex(self, *args) -> "void":
        """
        * sends the start of a complex entity, which is a simple open bracket (without increasing braket level) It must be called JUST AFTER SendEntity and BEFORE sending componants, each one begins by StartEntity
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_StartComplex(self, *args)


    def StartEntity(self, *args) -> "void":
        """
        * sets entity's StepType, opens brakets, starts param no to 0 params are separated by comma Remark : for a Multiple Type Entity (see Express ANDOR clause) StartComplex must be called before sending componants, then each 'Componant' must be send separately (one call to StartEntity for each one) : the Type which preceeds is then automaticaly closed. Once all the componants have been sent, EndComplex must be called, then and only then EndEntity
        	:param atype:
        	:type atype: TCollection_AsciiString
        	:rtype: None
        """
        return _StepData.StepData_StepWriter_StartEntity(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty StepWriter from a StepModel. The StepModel provides the Number of Entities, as identifiers for File
        	:param amodel:
        	:type amodel: StepData_StepModel
        	:rtype: None
        """
        _StepData.StepData_StepWriter_swiginit(self, _StepData.new_StepData_StepWriter(*args))

    def GetTypeMode(self) -> "Standard_Integer":
        """GetTypeMode(StepData_StepWriter self) -> Standard_Integer"""
        return _StepData.StepData_StepWriter_GetTypeMode(self)


    def SetTypeMode(self, value: 'Standard_Integer') -> "void":
        """SetTypeMode(StepData_StepWriter self, Standard_Integer value)"""
        return _StepData.StepData_StepWriter_SetTypeMode(self, value)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_StepWriter
StepData_StepWriter.AddParam = new_instancemethod(_StepData.StepData_StepWriter_AddParam, None, StepData_StepWriter)
StepData_StepWriter.CheckList = new_instancemethod(_StepData.StepData_StepWriter_CheckList, None, StepData_StepWriter)
StepData_StepWriter.CloseSub = new_instancemethod(_StepData.StepData_StepWriter_CloseSub, None, StepData_StepWriter)
StepData_StepWriter.Comment = new_instancemethod(_StepData.StepData_StepWriter_Comment, None, StepData_StepWriter)
StepData_StepWriter.EndComplex = new_instancemethod(_StepData.StepData_StepWriter_EndComplex, None, StepData_StepWriter)
StepData_StepWriter.EndEntity = new_instancemethod(_StepData.StepData_StepWriter_EndEntity, None, StepData_StepWriter)
StepData_StepWriter.EndFile = new_instancemethod(_StepData.StepData_StepWriter_EndFile, None, StepData_StepWriter)
StepData_StepWriter.EndSec = new_instancemethod(_StepData.StepData_StepWriter_EndSec, None, StepData_StepWriter)
StepData_StepWriter.FloatWriter = new_instancemethod(_StepData.StepData_StepWriter_FloatWriter, None, StepData_StepWriter)
StepData_StepWriter.Indent = new_instancemethod(_StepData.StepData_StepWriter_Indent, None, StepData_StepWriter)
StepData_StepWriter.IsInScope = new_instancemethod(_StepData.StepData_StepWriter_IsInScope, None, StepData_StepWriter)
StepData_StepWriter.JoinLast = new_instancemethod(_StepData.StepData_StepWriter_JoinLast, None, StepData_StepWriter)
StepData_StepWriter.GetLabelMode = new_instancemethod(_StepData.StepData_StepWriter_GetLabelMode, None, StepData_StepWriter)
StepData_StepWriter.SetLabelMode = new_instancemethod(_StepData.StepData_StepWriter_SetLabelMode, None, StepData_StepWriter)
StepData_StepWriter.Line = new_instancemethod(_StepData.StepData_StepWriter_Line, None, StepData_StepWriter)
StepData_StepWriter.NbLines = new_instancemethod(_StepData.StepData_StepWriter_NbLines, None, StepData_StepWriter)
StepData_StepWriter.NewLine = new_instancemethod(_StepData.StepData_StepWriter_NewLine, None, StepData_StepWriter)
StepData_StepWriter.OpenSub = new_instancemethod(_StepData.StepData_StepWriter_OpenSub, None, StepData_StepWriter)
StepData_StepWriter.OpenTypedSub = new_instancemethod(_StepData.StepData_StepWriter_OpenTypedSub, None, StepData_StepWriter)
StepData_StepWriter.PrintToString = new_instancemethod(_StepData.StepData_StepWriter_PrintToString, None, StepData_StepWriter)
StepData_StepWriter.Send = new_instancemethod(_StepData.StepData_StepWriter_Send, None, StepData_StepWriter)
StepData_StepWriter.SendArrReal = new_instancemethod(_StepData.StepData_StepWriter_SendArrReal, None, StepData_StepWriter)
StepData_StepWriter.SendBoolean = new_instancemethod(_StepData.StepData_StepWriter_SendBoolean, None, StepData_StepWriter)
StepData_StepWriter.SendComment = new_instancemethod(_StepData.StepData_StepWriter_SendComment, None, StepData_StepWriter)
StepData_StepWriter.SendData = new_instancemethod(_StepData.StepData_StepWriter_SendData, None, StepData_StepWriter)
StepData_StepWriter.SendDerived = new_instancemethod(_StepData.StepData_StepWriter_SendDerived, None, StepData_StepWriter)
StepData_StepWriter.SendEndscope = new_instancemethod(_StepData.StepData_StepWriter_SendEndscope, None, StepData_StepWriter)
StepData_StepWriter.SendEntity = new_instancemethod(_StepData.StepData_StepWriter_SendEntity, None, StepData_StepWriter)
StepData_StepWriter.SendEnum = new_instancemethod(_StepData.StepData_StepWriter_SendEnum, None, StepData_StepWriter)
StepData_StepWriter.SendField = new_instancemethod(_StepData.StepData_StepWriter_SendField, None, StepData_StepWriter)
StepData_StepWriter.SendHeader = new_instancemethod(_StepData.StepData_StepWriter_SendHeader, None, StepData_StepWriter)
StepData_StepWriter.SendIdent = new_instancemethod(_StepData.StepData_StepWriter_SendIdent, None, StepData_StepWriter)
StepData_StepWriter.SendList = new_instancemethod(_StepData.StepData_StepWriter_SendList, None, StepData_StepWriter)
StepData_StepWriter.SendLogical = new_instancemethod(_StepData.StepData_StepWriter_SendLogical, None, StepData_StepWriter)
StepData_StepWriter.SendModel = new_instancemethod(_StepData.StepData_StepWriter_SendModel, None, StepData_StepWriter)
StepData_StepWriter.SendScope = new_instancemethod(_StepData.StepData_StepWriter_SendScope, None, StepData_StepWriter)
StepData_StepWriter.SendSelect = new_instancemethod(_StepData.StepData_StepWriter_SendSelect, None, StepData_StepWriter)
StepData_StepWriter.SendString = new_instancemethod(_StepData.StepData_StepWriter_SendString, None, StepData_StepWriter)
StepData_StepWriter.SendUndef = new_instancemethod(_StepData.StepData_StepWriter_SendUndef, None, StepData_StepWriter)
StepData_StepWriter.SetScope = new_instancemethod(_StepData.StepData_StepWriter_SetScope, None, StepData_StepWriter)
StepData_StepWriter.StartComplex = new_instancemethod(_StepData.StepData_StepWriter_StartComplex, None, StepData_StepWriter)
StepData_StepWriter.StartEntity = new_instancemethod(_StepData.StepData_StepWriter_StartEntity, None, StepData_StepWriter)
StepData_StepWriter.GetTypeMode = new_instancemethod(_StepData.StepData_StepWriter_GetTypeMode, None, StepData_StepWriter)
StepData_StepWriter.SetTypeMode = new_instancemethod(_StepData.StepData_StepWriter_SetTypeMode, None, StepData_StepWriter)
StepData_StepWriter_swigregister = _StepData.StepData_StepWriter_swigregister
StepData_StepWriter_swigregister(StepData_StepWriter)

class StepData_WriterLib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddProtocol(self, *args) -> "void":
        """
        * Adds a couple (Module-Protocol) to the Library, given the class of a Protocol. Takes Resources into account. (if <aprotocol> is not of type TheProtocol, it is not added)
        	:param aprotocol:
        	:type aprotocol: Standard_Transient
        	:rtype: None
        """
        return _StepData.StepData_WriterLib_AddProtocol(self, *args)


    def Clear(self, *args) -> "void":
        """
        * Clears the list of Modules of a library (can be used to redefine the order of Modules before action : Clear then refill the Library by calls to AddProtocol)
        	:rtype: None
        """
        return _StepData.StepData_WriterLib_Clear(self, *args)


    def Module(self, *args) -> "opencascade::handle< StepData_ReadWriteModule > const &":
        """
        * Returns the current Module in the Iteration
        	:rtype: opencascade::handle<StepData_ReadWriteModule>
        """
        return _StepData.StepData_WriterLib_Module(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        * Returns True if there are more Modules to iterate on
        	:rtype: bool
        """
        return _StepData.StepData_WriterLib_More(self, *args)


    def Next(self, *args) -> "void":
        """
        * Iterates by getting the next Module in the list If there is none, the exception will be raised by Value
        	:rtype: None
        """
        return _StepData.StepData_WriterLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< StepData_Protocol > const &":
        """
        * Returns the current Protocol in the Iteration
        	:rtype: opencascade::handle<StepData_Protocol>
        """
        return _StepData.StepData_WriterLib_Protocol(self, *args)


    def Select(self, *args) -> "Standard_Boolean":
        """
        * Selects a Module from the Library, given an Object. Returns True if Select has succeeded, False else. Also Returns (as arguments) the selected Module and the Case Number determined by the associated Protocol. If Select has failed, <module> is Null Handle and CN is zero. (Select can work on any criterium, such as Object DynamicType)
        	:param obj:
        	:type obj: Standard_Transient
        	:param module:
        	:type module: StepData_ReadWriteModule
        	:param CN:
        	:type CN: int
        	:rtype: bool
        """
        return _StepData.StepData_WriterLib_Select(self, *args)


    def SetComplete(self, *args) -> "void":
        """
        * Sets a library to be defined with the complete Global list (all the couples Protocol/Modules recorded in it)
        	:rtype: None
        """
        return _StepData.StepData_WriterLib_SetComplete(self, *args)


    def SetGlobal(*args) -> "void":
        """
        * Adds a couple (Module-Protocol) into the global definition set for this class of Library.
        	:param amodule:
        	:type amodule: StepData_ReadWriteModule
        	:param aprotocol:
        	:type aprotocol: StepData_Protocol
        	:rtype: void
        """
        return _StepData.StepData_WriterLib_SetGlobal(*args)

    SetGlobal = staticmethod(SetGlobal)

    def Start(self, *args) -> "void":
        """
        * Starts Iteration on the Modules (sets it on the first one)
        	:rtype: None
        """
        return _StepData.StepData_WriterLib_Start(self, *args)


    def __init__(self, *args):
        """
        * Creates a Library which complies with a Protocol, that is : Same class (criterium IsInstance) This creation gets the Modules from the global set, those which are bound to the given Protocol and its Resources
        	:param aprotocol:
        	:type aprotocol: StepData_Protocol
        	:rtype: None
        * Creates an empty Library : it will later by filled by method AddProtocol
        	:rtype: None
        """
        _StepData.StepData_WriterLib_swiginit(self, _StepData.new_StepData_WriterLib(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_WriterLib
StepData_WriterLib.AddProtocol = new_instancemethod(_StepData.StepData_WriterLib_AddProtocol, None, StepData_WriterLib)
StepData_WriterLib.Clear = new_instancemethod(_StepData.StepData_WriterLib_Clear, None, StepData_WriterLib)
StepData_WriterLib.Module = new_instancemethod(_StepData.StepData_WriterLib_Module, None, StepData_WriterLib)
StepData_WriterLib.More = new_instancemethod(_StepData.StepData_WriterLib_More, None, StepData_WriterLib)
StepData_WriterLib.Next = new_instancemethod(_StepData.StepData_WriterLib_Next, None, StepData_WriterLib)
StepData_WriterLib.Protocol = new_instancemethod(_StepData.StepData_WriterLib_Protocol, None, StepData_WriterLib)
StepData_WriterLib.Select = new_instancemethod(_StepData.StepData_WriterLib_Select, None, StepData_WriterLib)
StepData_WriterLib.SetComplete = new_instancemethod(_StepData.StepData_WriterLib_SetComplete, None, StepData_WriterLib)
StepData_WriterLib.Start = new_instancemethod(_StepData.StepData_WriterLib_Start, None, StepData_WriterLib)
StepData_WriterLib_swigregister = _StepData.StepData_WriterLib_swigregister
StepData_WriterLib_swigregister(StepData_WriterLib)

def StepData_WriterLib_SetGlobal(*args) -> "void":
    """
    * Adds a couple (Module-Protocol) into the global definition set for this class of Library.
    	:param amodule:
    	:type amodule: StepData_ReadWriteModule
    	:param aprotocol:
    	:type aprotocol: StepData_Protocol
    	:rtype: void
    """
    return _StepData.StepData_WriterLib_SetGlobal(*args)

class StepData_DefaultGeneral(StepData_GeneralModule):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a Default General Module
        	:rtype: None
        """
        _StepData.StepData_DefaultGeneral_swiginit(self, _StepData.new_StepData_DefaultGeneral(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_DefaultGeneral_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_DefaultGeneral
StepData_DefaultGeneral_swigregister = _StepData.StepData_DefaultGeneral_swigregister
StepData_DefaultGeneral_swigregister(StepData_DefaultGeneral)

class StepData_ECDescr(StepData_EDescr):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a member Warning : members are added in alphabetic order
        	:param member:
        	:type member: StepData_ESDescr
        	:rtype: None
        """
        return _StepData.StepData_ECDescr_Add(self, *args)


    def Member(self, *args) -> "opencascade::handle< StepData_ESDescr >":
        """
        * Returns a Member from its rank
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<StepData_ESDescr>
        """
        return _StepData.StepData_ECDescr_Member(self, *args)


    def NbMembers(self, *args) -> "Standard_Integer":
        """
        * Returns the count of members
        	:rtype: int
        """
        return _StepData.StepData_ECDescr_NbMembers(self, *args)


    def __init__(self, *args):
        """
        * Creates an ECDescr, empty
        	:rtype: None
        """
        _StepData.StepData_ECDescr_swiginit(self, _StepData.new_StepData_ECDescr(*args))

    def TypeList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfAsciiString >":
        """
        * Returns the ordered list of types
        	:rtype: opencascade::handle<TColStd_HSequenceOfAsciiString>
        """
        return _StepData.StepData_ECDescr_TypeList(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_ECDescr_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_ECDescr
StepData_ECDescr.Add = new_instancemethod(_StepData.StepData_ECDescr_Add, None, StepData_ECDescr)
StepData_ECDescr.Member = new_instancemethod(_StepData.StepData_ECDescr_Member, None, StepData_ECDescr)
StepData_ECDescr.NbMembers = new_instancemethod(_StepData.StepData_ECDescr_NbMembers, None, StepData_ECDescr)
StepData_ECDescr.TypeList = new_instancemethod(_StepData.StepData_ECDescr_TypeList, None, StepData_ECDescr)
StepData_ECDescr_swigregister = _StepData.StepData_ECDescr_swigregister
StepData_ECDescr_swigregister(StepData_ECDescr)

class StepData_ESDescr(StepData_EDescr):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Base(self, *args) -> "opencascade::handle< StepData_ESDescr >":
        """
        * Returns the basic ESDescr, null if <self> is not derived
        	:rtype: opencascade::handle<StepData_ESDescr>
        """
        return _StepData.StepData_ESDescr_Base(self, *args)


    def Field(self, *args) -> "opencascade::handle< StepData_PDescr >":
        """
        * Returns the PDescr for the field <num> (or Null)
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<StepData_PDescr>
        """
        return _StepData.StepData_ESDescr_Field(self, *args)


    def IsSub(self, *args) -> "Standard_Boolean":
        """
        * Tells if <self> is sub-type of (or equal to) another one
        	:param other:
        	:type other: StepData_ESDescr
        	:rtype: bool
        """
        return _StepData.StepData_ESDescr_IsSub(self, *args)


    def Name(self, *args) -> "char const *":
        """
        * Returns the name of a field from its rank. empty if outofrange
        	:param num:
        	:type num: int
        	:rtype: char *
        """
        return _StepData.StepData_ESDescr_Name(self, *args)


    def NamedField(self, *args) -> "opencascade::handle< StepData_PDescr >":
        """
        * Returns the PDescr for the field named <name> (or Null)
        	:param name:
        	:type name: char *
        	:rtype: opencascade::handle<StepData_PDescr>
        """
        return _StepData.StepData_ESDescr_NamedField(self, *args)


    def NbFields(self, *args) -> "Standard_Integer":
        """
        * Returns the count of fields
        	:rtype: int
        """
        return _StepData.StepData_ESDescr_NbFields(self, *args)


    def Rank(self, *args) -> "Standard_Integer":
        """
        * Returns the rank of a field from its name. 0 if unknown
        	:param name:
        	:type name: char *
        	:rtype: int
        """
        return _StepData.StepData_ESDescr_Rank(self, *args)


    def SetBase(self, *args) -> "void":
        """
        * Sets an ESDescr as based on another one Hence, if there are inherited fields, the derived ESDescr cumulates all them, while the base just records its own ones
        	:param base:
        	:type base: StepData_ESDescr
        	:rtype: None
        """
        return _StepData.StepData_ESDescr_SetBase(self, *args)


    def SetField(self, *args) -> "void":
        """
        * Sets a PDescr to describe a field A Field is designated by its rank and name
        	:param num:
        	:type num: int
        	:param name:
        	:type name: char *
        	:param descr:
        	:type descr: StepData_PDescr
        	:rtype: None
        """
        return _StepData.StepData_ESDescr_SetField(self, *args)


    def SetNbFields(self, *args) -> "void":
        """
        * Sets a new count of fields Each one is described by a PDescr
        	:param nb:
        	:type nb: int
        	:rtype: None
        """
        return _StepData.StepData_ESDescr_SetNbFields(self, *args)


    def SetSuper(self, *args) -> "void":
        """
        * Sets an ESDescr as 'super-type'. Applies an a base (non derived) ESDescr
        	:param super:
        	:type super: StepData_ESDescr
        	:rtype: None
        """
        return _StepData.StepData_ESDescr_SetSuper(self, *args)


    def __init__(self, *args):
        """
        * Creates an ESDescr with a type name
        	:param name:
        	:type name: char *
        	:rtype: None
        """
        _StepData.StepData_ESDescr_swiginit(self, _StepData.new_StepData_ESDescr(*args))

    def StepType(self, *args) -> "TCollection_AsciiString const &":
        """
        * Returns the type name as an AsciiString
        	:rtype: TCollection_AsciiString
        """
        return _StepData.StepData_ESDescr_StepType(self, *args)


    def Super(self, *args) -> "opencascade::handle< StepData_ESDescr >":
        """
        * Returns the super-type ESDescr, null if <self> is root
        	:rtype: opencascade::handle<StepData_ESDescr>
        """
        return _StepData.StepData_ESDescr_Super(self, *args)


    def TypeName(self, *args) -> "char const *":
        """
        * Returns the type name given at creation time
        	:rtype: char *
        """
        return _StepData.StepData_ESDescr_TypeName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_ESDescr_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_ESDescr
StepData_ESDescr.Base = new_instancemethod(_StepData.StepData_ESDescr_Base, None, StepData_ESDescr)
StepData_ESDescr.Field = new_instancemethod(_StepData.StepData_ESDescr_Field, None, StepData_ESDescr)
StepData_ESDescr.IsSub = new_instancemethod(_StepData.StepData_ESDescr_IsSub, None, StepData_ESDescr)
StepData_ESDescr.Name = new_instancemethod(_StepData.StepData_ESDescr_Name, None, StepData_ESDescr)
StepData_ESDescr.NamedField = new_instancemethod(_StepData.StepData_ESDescr_NamedField, None, StepData_ESDescr)
StepData_ESDescr.NbFields = new_instancemethod(_StepData.StepData_ESDescr_NbFields, None, StepData_ESDescr)
StepData_ESDescr.Rank = new_instancemethod(_StepData.StepData_ESDescr_Rank, None, StepData_ESDescr)
StepData_ESDescr.SetBase = new_instancemethod(_StepData.StepData_ESDescr_SetBase, None, StepData_ESDescr)
StepData_ESDescr.SetField = new_instancemethod(_StepData.StepData_ESDescr_SetField, None, StepData_ESDescr)
StepData_ESDescr.SetNbFields = new_instancemethod(_StepData.StepData_ESDescr_SetNbFields, None, StepData_ESDescr)
StepData_ESDescr.SetSuper = new_instancemethod(_StepData.StepData_ESDescr_SetSuper, None, StepData_ESDescr)
StepData_ESDescr.StepType = new_instancemethod(_StepData.StepData_ESDescr_StepType, None, StepData_ESDescr)
StepData_ESDescr.Super = new_instancemethod(_StepData.StepData_ESDescr_Super, None, StepData_ESDescr)
StepData_ESDescr.TypeName = new_instancemethod(_StepData.StepData_ESDescr_TypeName, None, StepData_ESDescr)
StepData_ESDescr_swigregister = _StepData.StepData_ESDescr_swigregister
StepData_ESDescr_swigregister(StepData_ESDescr)

class StepData_FieldList1(StepData_FieldList):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a FieldList of 1 Field
        	:rtype: None
        """
        _StepData.StepData_FieldList1_swiginit(self, _StepData.new_StepData_FieldList1(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_FieldList1
StepData_FieldList1_swigregister = _StepData.StepData_FieldList1_swigregister
StepData_FieldList1_swigregister(StepData_FieldList1)

class StepData_FieldListD(StepData_FieldList):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetNb(self, *args) -> "void":
        """
        * Sets a new count of Fields. Former contents are lost
        	:param nb:
        	:type nb: int
        	:rtype: None
        """
        return _StepData.StepData_FieldListD_SetNb(self, *args)


    def __init__(self, *args):
        """
        * Creates a FieldListD of <nb> Fields
        	:param nb:
        	:type nb: int
        	:rtype: None
        """
        _StepData.StepData_FieldListD_swiginit(self, _StepData.new_StepData_FieldListD(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_FieldListD
StepData_FieldListD.SetNb = new_instancemethod(_StepData.StepData_FieldListD_SetNb, None, StepData_FieldListD)
StepData_FieldListD_swigregister = _StepData.StepData_FieldListD_swigregister
StepData_FieldListD_swigregister(StepData_FieldListD)

class StepData_FieldListN(StepData_FieldList):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        * Creates a FieldListN of <nb> Fields
        	:param nb:
        	:type nb: int
        	:rtype: None
        """
        _StepData.StepData_FieldListN_swiginit(self, _StepData.new_StepData_FieldListN(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_FieldListN
StepData_FieldListN_swigregister = _StepData.StepData_FieldListN_swigregister
StepData_FieldListN_swigregister(StepData_FieldListN)

class StepData_FileProtocol(StepData_Protocol):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a Protocol to the definition list of the FileProtocol But ensures that each class of Protocol is present only once in this list
        	:param protocol:
        	:type protocol: StepData_Protocol
        	:rtype: None
        """
        return _StepData.StepData_FileProtocol_Add(self, *args)


    def __init__(self, *args):
        """
        * Creates an empty FileProtocol
        	:rtype: None
        """
        _StepData.StepData_FileProtocol_swiginit(self, _StepData.new_StepData_FileProtocol(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_FileProtocol_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_FileProtocol
StepData_FileProtocol.Add = new_instancemethod(_StepData.StepData_FileProtocol_Add, None, StepData_FileProtocol)
StepData_FileProtocol_swigregister = _StepData.StepData_FileProtocol_swigregister
StepData_FileProtocol_swigregister(StepData_FileProtocol)

class StepData_Plex(StepData_Described):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds a member to <self>
        	:param member:
        	:type member: StepData_Simple
        	:rtype: None
        """
        return _StepData.StepData_Plex_Add(self, *args)


    def ECDescr(self, *args) -> "opencascade::handle< StepData_ECDescr >":
        """
        * Returns the Description as for a Plex
        	:rtype: opencascade::handle<StepData_ECDescr>
        """
        return _StepData.StepData_Plex_ECDescr(self, *args)


    def Member(self, *args) -> "opencascade::handle< StepData_Simple >":
        """
        * Returns a simple member from its rank
        	:param num:
        	:type num: int
        	:rtype: opencascade::handle<StepData_Simple>
        """
        return _StepData.StepData_Plex_Member(self, *args)


    def NbMembers(self, *args) -> "Standard_Integer":
        """
        * Returns the count of simple members
        	:rtype: int
        """
        return _StepData.StepData_Plex_NbMembers(self, *args)


    def __init__(self, *args):
        """
        * Creates a Plex (empty). The complete creation is made by the ECDescr itself, by calling Add
        	:param descr:
        	:type descr: StepData_ECDescr
        	:rtype: None
        """
        _StepData.StepData_Plex_swiginit(self, _StepData.new_StepData_Plex(*args))

    def TypeList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfAsciiString >":
        """
        * Returns the actual list of members types
        	:rtype: opencascade::handle<TColStd_HSequenceOfAsciiString>
        """
        return _StepData.StepData_Plex_TypeList(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_Plex_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_Plex
StepData_Plex.Add = new_instancemethod(_StepData.StepData_Plex_Add, None, StepData_Plex)
StepData_Plex.ECDescr = new_instancemethod(_StepData.StepData_Plex_ECDescr, None, StepData_Plex)
StepData_Plex.Member = new_instancemethod(_StepData.StepData_Plex_Member, None, StepData_Plex)
StepData_Plex.NbMembers = new_instancemethod(_StepData.StepData_Plex_NbMembers, None, StepData_Plex)
StepData_Plex.TypeList = new_instancemethod(_StepData.StepData_Plex_TypeList, None, StepData_Plex)
StepData_Plex_swigregister = _StepData.StepData_Plex_swigregister
StepData_Plex_swigregister(StepData_Plex)

class StepData_SelectInt(StepData_SelectMember):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _StepData.StepData_SelectInt_swiginit(self, _StepData.new_StepData_SelectInt(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_SelectInt_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_SelectInt
StepData_SelectInt_swigregister = _StepData.StepData_SelectInt_swigregister
StepData_SelectInt_swigregister(StepData_SelectInt)

class StepData_SelectNamed(StepData_SelectMember):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CField(self, *args) -> "StepData_Field &":
        """:rtype: StepData_Field"""
        return _StepData.StepData_SelectNamed_CField(self, *args)


    def Field(self, *args) -> "StepData_Field const &":
        """:rtype: StepData_Field"""
        return _StepData.StepData_SelectNamed_Field(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _StepData.StepData_SelectNamed_swiginit(self, _StepData.new_StepData_SelectNamed(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_SelectNamed_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_SelectNamed
StepData_SelectNamed.CField = new_instancemethod(_StepData.StepData_SelectNamed_CField, None, StepData_SelectNamed)
StepData_SelectNamed.Field = new_instancemethod(_StepData.StepData_SelectNamed_Field, None, StepData_SelectNamed)
StepData_SelectNamed_swigregister = _StepData.StepData_SelectNamed_swigregister
StepData_SelectNamed_swigregister(StepData_SelectNamed)

class StepData_SelectReal(StepData_SelectMember):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """:rtype: None"""
        _StepData.StepData_SelectReal_swiginit(self, _StepData.new_StepData_SelectReal(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_SelectReal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_SelectReal
StepData_SelectReal_swigregister = _StepData.StepData_SelectReal_swigregister
StepData_SelectReal_swigregister(StepData_SelectReal)

class StepData_Simple(StepData_Described):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CFieldNum(self, *args) -> "StepData_Field &":
        """
        * Returns a field from its rank, in order to modify it
        	:param num:
        	:type num: int
        	:rtype: StepData_Field
        """
        return _StepData.StepData_Simple_CFieldNum(self, *args)


    def CFields(self, *args) -> "StepData_FieldListN &":
        """
        * Returns the entire field list, read or write
        	:rtype: StepData_FieldListN
        """
        return _StepData.StepData_Simple_CFields(self, *args)


    def ESDescr(self, *args) -> "opencascade::handle< StepData_ESDescr >":
        """
        * Returns description, as for simple
        	:rtype: opencascade::handle<StepData_ESDescr>
        """
        return _StepData.StepData_Simple_ESDescr(self, *args)


    def FieldNum(self, *args) -> "StepData_Field const &":
        """
        * Returns a field from its rank, for read-only use
        	:param num:
        	:type num: int
        	:rtype: StepData_Field
        """
        return _StepData.StepData_Simple_FieldNum(self, *args)


    def Fields(self, *args) -> "StepData_FieldListN const &":
        """
        * Returns the entire field list, read-only
        	:rtype: StepData_FieldListN
        """
        return _StepData.StepData_Simple_Fields(self, *args)


    def NbFields(self, *args) -> "Standard_Integer":
        """
        * Returns the count of fields
        	:rtype: int
        """
        return _StepData.StepData_Simple_NbFields(self, *args)


    def __init__(self, *args):
        """
        * Creates a Simple Entity
        	:param descr:
        	:type descr: StepData_ESDescr
        	:rtype: None
        """
        _StepData.StepData_Simple_swiginit(self, _StepData.new_StepData_Simple(*args))

    def StepType(self, *args) -> "char const *":
        """
        * Returns the recorded StepType (TypeName of its ESDescr)
        	:rtype: char *
        """
        return _StepData.StepData_Simple_StepType(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_StepData_Simple_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_Simple
StepData_Simple.CFieldNum = new_instancemethod(_StepData.StepData_Simple_CFieldNum, None, StepData_Simple)
StepData_Simple.CFields = new_instancemethod(_StepData.StepData_Simple_CFields, None, StepData_Simple)
StepData_Simple.ESDescr = new_instancemethod(_StepData.StepData_Simple_ESDescr, None, StepData_Simple)
StepData_Simple.FieldNum = new_instancemethod(_StepData.StepData_Simple_FieldNum, None, StepData_Simple)
StepData_Simple.Fields = new_instancemethod(_StepData.StepData_Simple_Fields, None, StepData_Simple)
StepData_Simple.NbFields = new_instancemethod(_StepData.StepData_Simple_NbFields, None, StepData_Simple)
StepData_Simple.StepType = new_instancemethod(_StepData.StepData_Simple_StepType, None, StepData_Simple)
StepData_Simple_swigregister = _StepData.StepData_Simple_swigregister
StepData_Simple_swigregister(StepData_Simple)

class StepData_SelectArrReal(StepData_SelectNamed):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ArrReal(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal >":
        """:rtype: opencascade::handle<TColStd_HArray1OfReal>"""
        return _StepData.StepData_SelectArrReal_ArrReal(self, *args)


    def SetArrReal(self, *args) -> "void":
        """
        :param arr:
        	:type arr: TColStd_HArray1OfReal
        	:rtype: None
        """
        return _StepData.StepData_SelectArrReal_SetArrReal(self, *args)


    def __init__(self, *args):
        """:rtype: None"""
        _StepData.StepData_SelectArrReal_swiginit(self, _StepData.new_StepData_SelectArrReal(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_SelectArrReal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _StepData.delete_StepData_SelectArrReal
StepData_SelectArrReal.ArrReal = new_instancemethod(_StepData.StepData_SelectArrReal_ArrReal, None, StepData_SelectArrReal)
StepData_SelectArrReal.SetArrReal = new_instancemethod(_StepData.StepData_SelectArrReal_SetArrReal, None, StepData_SelectArrReal)
StepData_SelectArrReal_swigregister = _StepData.StepData_SelectArrReal_swigregister
StepData_SelectArrReal_swigregister(StepData_SelectArrReal)

class StepData_HArray1OfField(StepData_Array1OfField, OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _StepData.StepData_HArray1OfField_swiginit(self, _StepData.new_StepData_HArray1OfField(*args))


    @staticmethod
    def DownCast(t):
      return Handle_StepData_HArray1OfField_DownCast(t)

    __swig_destroy__ = _StepData.delete_StepData_HArray1OfField
StepData_HArray1OfField.Array1 = new_instancemethod(_StepData.StepData_HArray1OfField_Array1, None, StepData_HArray1OfField)
StepData_HArray1OfField.ChangeArray1 = new_instancemethod(_StepData.StepData_HArray1OfField_ChangeArray1, None, StepData_HArray1OfField)
StepData_HArray1OfField_swigregister = _StepData.StepData_HArray1OfField_swigregister
StepData_HArray1OfField_swigregister(StepData_HArray1OfField)



