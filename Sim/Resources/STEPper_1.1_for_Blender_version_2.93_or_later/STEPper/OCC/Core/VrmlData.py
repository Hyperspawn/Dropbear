# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
VrmlData module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_vrmldata.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _VrmlData.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_VrmlData')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_VrmlData')
    _VrmlData = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_VrmlData', [dirname(__file__)])
        except ImportError:
            import _VrmlData
            return _VrmlData
        try:
            _mod = imp.load_module('_VrmlData', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _VrmlData = swig_import_helper()
    del swig_import_helper
else:
    import _VrmlData
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _VrmlData.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_VrmlData.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_VrmlData.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_VrmlData.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_VrmlData.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_VrmlData.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_VrmlData.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_VrmlData.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_VrmlData.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_VrmlData.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_VrmlData.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_VrmlData.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_VrmlData.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_VrmlData.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_VrmlData.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_VrmlData.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_VrmlData.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _VrmlData.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _VrmlData.process_exception(error, method_name, class_name)
process_exception = _VrmlData.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TCollection
import OCC.Core.gp
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.TDocStd
import OCC.Core.TDF
import OCC.Core.TColStd
import OCC.Core.CDF
import OCC.Core.CDM
import OCC.Core.Resource
import OCC.Core.PCDM
import OCC.Core.Storage
import OCC.Core.Bnd
import OCC.Core.TColgp
import OCC.Core.BVH
import OCC.Core.Quantity
VrmlData_StatusOK = _VrmlData.VrmlData_StatusOK
VrmlData_EmptyData = _VrmlData.VrmlData_EmptyData
VrmlData_UnrecoverableError = _VrmlData.VrmlData_UnrecoverableError
VrmlData_GeneralError = _VrmlData.VrmlData_GeneralError
VrmlData_EndOfFile = _VrmlData.VrmlData_EndOfFile
VrmlData_NotVrmlFile = _VrmlData.VrmlData_NotVrmlFile
VrmlData_CannotOpenFile = _VrmlData.VrmlData_CannotOpenFile
VrmlData_VrmlFormatError = _VrmlData.VrmlData_VrmlFormatError
VrmlData_NumericInputError = _VrmlData.VrmlData_NumericInputError
VrmlData_IrrelevantNumber = _VrmlData.VrmlData_IrrelevantNumber
VrmlData_BooleanInputError = _VrmlData.VrmlData_BooleanInputError
VrmlData_StringInputError = _VrmlData.VrmlData_StringInputError
VrmlData_NodeNameUnknown = _VrmlData.VrmlData_NodeNameUnknown
VrmlData_NonPositiveSize = _VrmlData.VrmlData_NonPositiveSize
VrmlData_ReadUnknownNode = _VrmlData.VrmlData_ReadUnknownNode
VrmlData_NonSupportedFeature = _VrmlData.VrmlData_NonSupportedFeature
VrmlData_OutputStreamUndefined = _VrmlData.VrmlData_OutputStreamUndefined
VrmlData_NotImplemented = _VrmlData.VrmlData_NotImplemented

def Handle_VrmlData_Node_Create() -> "opencascade::handle< VrmlData_Node >":
    return _VrmlData.Handle_VrmlData_Node_Create()
Handle_VrmlData_Node_Create = _VrmlData.Handle_VrmlData_Node_Create

def Handle_VrmlData_Node_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Node >":
    return _VrmlData.Handle_VrmlData_Node_DownCast(t)
Handle_VrmlData_Node_DownCast = _VrmlData.Handle_VrmlData_Node_DownCast

def Handle_VrmlData_Node_IsNull(t: 'opencascade::handle< VrmlData_Node > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Node_IsNull(t)
Handle_VrmlData_Node_IsNull = _VrmlData.Handle_VrmlData_Node_IsNull

def Handle_VrmlData_Appearance_Create() -> "opencascade::handle< VrmlData_Appearance >":
    return _VrmlData.Handle_VrmlData_Appearance_Create()
Handle_VrmlData_Appearance_Create = _VrmlData.Handle_VrmlData_Appearance_Create

def Handle_VrmlData_Appearance_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Appearance >":
    return _VrmlData.Handle_VrmlData_Appearance_DownCast(t)
Handle_VrmlData_Appearance_DownCast = _VrmlData.Handle_VrmlData_Appearance_DownCast

def Handle_VrmlData_Appearance_IsNull(t: 'opencascade::handle< VrmlData_Appearance > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Appearance_IsNull(t)
Handle_VrmlData_Appearance_IsNull = _VrmlData.Handle_VrmlData_Appearance_IsNull

def Handle_VrmlData_Geometry_Create() -> "opencascade::handle< VrmlData_Geometry >":
    return _VrmlData.Handle_VrmlData_Geometry_Create()
Handle_VrmlData_Geometry_Create = _VrmlData.Handle_VrmlData_Geometry_Create

def Handle_VrmlData_Geometry_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Geometry >":
    return _VrmlData.Handle_VrmlData_Geometry_DownCast(t)
Handle_VrmlData_Geometry_DownCast = _VrmlData.Handle_VrmlData_Geometry_DownCast

def Handle_VrmlData_Geometry_IsNull(t: 'opencascade::handle< VrmlData_Geometry > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Geometry_IsNull(t)
Handle_VrmlData_Geometry_IsNull = _VrmlData.Handle_VrmlData_Geometry_IsNull

def Handle_VrmlData_Group_Create() -> "opencascade::handle< VrmlData_Group >":
    return _VrmlData.Handle_VrmlData_Group_Create()
Handle_VrmlData_Group_Create = _VrmlData.Handle_VrmlData_Group_Create

def Handle_VrmlData_Group_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Group >":
    return _VrmlData.Handle_VrmlData_Group_DownCast(t)
Handle_VrmlData_Group_DownCast = _VrmlData.Handle_VrmlData_Group_DownCast

def Handle_VrmlData_Group_IsNull(t: 'opencascade::handle< VrmlData_Group > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Group_IsNull(t)
Handle_VrmlData_Group_IsNull = _VrmlData.Handle_VrmlData_Group_IsNull

def Handle_VrmlData_Material_Create() -> "opencascade::handle< VrmlData_Material >":
    return _VrmlData.Handle_VrmlData_Material_Create()
Handle_VrmlData_Material_Create = _VrmlData.Handle_VrmlData_Material_Create

def Handle_VrmlData_Material_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Material >":
    return _VrmlData.Handle_VrmlData_Material_DownCast(t)
Handle_VrmlData_Material_DownCast = _VrmlData.Handle_VrmlData_Material_DownCast

def Handle_VrmlData_Material_IsNull(t: 'opencascade::handle< VrmlData_Material > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Material_IsNull(t)
Handle_VrmlData_Material_IsNull = _VrmlData.Handle_VrmlData_Material_IsNull

def Handle_VrmlData_ShapeNode_Create() -> "opencascade::handle< VrmlData_ShapeNode >":
    return _VrmlData.Handle_VrmlData_ShapeNode_Create()
Handle_VrmlData_ShapeNode_Create = _VrmlData.Handle_VrmlData_ShapeNode_Create

def Handle_VrmlData_ShapeNode_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_ShapeNode >":
    return _VrmlData.Handle_VrmlData_ShapeNode_DownCast(t)
Handle_VrmlData_ShapeNode_DownCast = _VrmlData.Handle_VrmlData_ShapeNode_DownCast

def Handle_VrmlData_ShapeNode_IsNull(t: 'opencascade::handle< VrmlData_ShapeNode > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_ShapeNode_IsNull(t)
Handle_VrmlData_ShapeNode_IsNull = _VrmlData.Handle_VrmlData_ShapeNode_IsNull

def Handle_VrmlData_TextureCoordinate_Create() -> "opencascade::handle< VrmlData_TextureCoordinate >":
    return _VrmlData.Handle_VrmlData_TextureCoordinate_Create()
Handle_VrmlData_TextureCoordinate_Create = _VrmlData.Handle_VrmlData_TextureCoordinate_Create

def Handle_VrmlData_TextureCoordinate_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_TextureCoordinate >":
    return _VrmlData.Handle_VrmlData_TextureCoordinate_DownCast(t)
Handle_VrmlData_TextureCoordinate_DownCast = _VrmlData.Handle_VrmlData_TextureCoordinate_DownCast

def Handle_VrmlData_TextureCoordinate_IsNull(t: 'opencascade::handle< VrmlData_TextureCoordinate > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_TextureCoordinate_IsNull(t)
Handle_VrmlData_TextureCoordinate_IsNull = _VrmlData.Handle_VrmlData_TextureCoordinate_IsNull

def Handle_VrmlData_UnknownNode_Create() -> "opencascade::handle< VrmlData_UnknownNode >":
    return _VrmlData.Handle_VrmlData_UnknownNode_Create()
Handle_VrmlData_UnknownNode_Create = _VrmlData.Handle_VrmlData_UnknownNode_Create

def Handle_VrmlData_UnknownNode_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_UnknownNode >":
    return _VrmlData.Handle_VrmlData_UnknownNode_DownCast(t)
Handle_VrmlData_UnknownNode_DownCast = _VrmlData.Handle_VrmlData_UnknownNode_DownCast

def Handle_VrmlData_UnknownNode_IsNull(t: 'opencascade::handle< VrmlData_UnknownNode > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_UnknownNode_IsNull(t)
Handle_VrmlData_UnknownNode_IsNull = _VrmlData.Handle_VrmlData_UnknownNode_IsNull

def Handle_VrmlData_WorldInfo_Create() -> "opencascade::handle< VrmlData_WorldInfo >":
    return _VrmlData.Handle_VrmlData_WorldInfo_Create()
Handle_VrmlData_WorldInfo_Create = _VrmlData.Handle_VrmlData_WorldInfo_Create

def Handle_VrmlData_WorldInfo_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_WorldInfo >":
    return _VrmlData.Handle_VrmlData_WorldInfo_DownCast(t)
Handle_VrmlData_WorldInfo_DownCast = _VrmlData.Handle_VrmlData_WorldInfo_DownCast

def Handle_VrmlData_WorldInfo_IsNull(t: 'opencascade::handle< VrmlData_WorldInfo > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_WorldInfo_IsNull(t)
Handle_VrmlData_WorldInfo_IsNull = _VrmlData.Handle_VrmlData_WorldInfo_IsNull

def Handle_VrmlData_Box_Create() -> "opencascade::handle< VrmlData_Box >":
    return _VrmlData.Handle_VrmlData_Box_Create()
Handle_VrmlData_Box_Create = _VrmlData.Handle_VrmlData_Box_Create

def Handle_VrmlData_Box_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Box >":
    return _VrmlData.Handle_VrmlData_Box_DownCast(t)
Handle_VrmlData_Box_DownCast = _VrmlData.Handle_VrmlData_Box_DownCast

def Handle_VrmlData_Box_IsNull(t: 'opencascade::handle< VrmlData_Box > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Box_IsNull(t)
Handle_VrmlData_Box_IsNull = _VrmlData.Handle_VrmlData_Box_IsNull

def Handle_VrmlData_Color_Create() -> "opencascade::handle< VrmlData_Color >":
    return _VrmlData.Handle_VrmlData_Color_Create()
Handle_VrmlData_Color_Create = _VrmlData.Handle_VrmlData_Color_Create

def Handle_VrmlData_Color_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Color >":
    return _VrmlData.Handle_VrmlData_Color_DownCast(t)
Handle_VrmlData_Color_DownCast = _VrmlData.Handle_VrmlData_Color_DownCast

def Handle_VrmlData_Color_IsNull(t: 'opencascade::handle< VrmlData_Color > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Color_IsNull(t)
Handle_VrmlData_Color_IsNull = _VrmlData.Handle_VrmlData_Color_IsNull

def Handle_VrmlData_Cone_Create() -> "opencascade::handle< VrmlData_Cone >":
    return _VrmlData.Handle_VrmlData_Cone_Create()
Handle_VrmlData_Cone_Create = _VrmlData.Handle_VrmlData_Cone_Create

def Handle_VrmlData_Cone_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Cone >":
    return _VrmlData.Handle_VrmlData_Cone_DownCast(t)
Handle_VrmlData_Cone_DownCast = _VrmlData.Handle_VrmlData_Cone_DownCast

def Handle_VrmlData_Cone_IsNull(t: 'opencascade::handle< VrmlData_Cone > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Cone_IsNull(t)
Handle_VrmlData_Cone_IsNull = _VrmlData.Handle_VrmlData_Cone_IsNull

def Handle_VrmlData_Coordinate_Create() -> "opencascade::handle< VrmlData_Coordinate >":
    return _VrmlData.Handle_VrmlData_Coordinate_Create()
Handle_VrmlData_Coordinate_Create = _VrmlData.Handle_VrmlData_Coordinate_Create

def Handle_VrmlData_Coordinate_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Coordinate >":
    return _VrmlData.Handle_VrmlData_Coordinate_DownCast(t)
Handle_VrmlData_Coordinate_DownCast = _VrmlData.Handle_VrmlData_Coordinate_DownCast

def Handle_VrmlData_Coordinate_IsNull(t: 'opencascade::handle< VrmlData_Coordinate > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Coordinate_IsNull(t)
Handle_VrmlData_Coordinate_IsNull = _VrmlData.Handle_VrmlData_Coordinate_IsNull

def Handle_VrmlData_Cylinder_Create() -> "opencascade::handle< VrmlData_Cylinder >":
    return _VrmlData.Handle_VrmlData_Cylinder_Create()
Handle_VrmlData_Cylinder_Create = _VrmlData.Handle_VrmlData_Cylinder_Create

def Handle_VrmlData_Cylinder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Cylinder >":
    return _VrmlData.Handle_VrmlData_Cylinder_DownCast(t)
Handle_VrmlData_Cylinder_DownCast = _VrmlData.Handle_VrmlData_Cylinder_DownCast

def Handle_VrmlData_Cylinder_IsNull(t: 'opencascade::handle< VrmlData_Cylinder > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Cylinder_IsNull(t)
Handle_VrmlData_Cylinder_IsNull = _VrmlData.Handle_VrmlData_Cylinder_IsNull

def Handle_VrmlData_ImageTexture_Create() -> "opencascade::handle< VrmlData_ImageTexture >":
    return _VrmlData.Handle_VrmlData_ImageTexture_Create()
Handle_VrmlData_ImageTexture_Create = _VrmlData.Handle_VrmlData_ImageTexture_Create

def Handle_VrmlData_ImageTexture_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_ImageTexture >":
    return _VrmlData.Handle_VrmlData_ImageTexture_DownCast(t)
Handle_VrmlData_ImageTexture_DownCast = _VrmlData.Handle_VrmlData_ImageTexture_DownCast

def Handle_VrmlData_ImageTexture_IsNull(t: 'opencascade::handle< VrmlData_ImageTexture > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_ImageTexture_IsNull(t)
Handle_VrmlData_ImageTexture_IsNull = _VrmlData.Handle_VrmlData_ImageTexture_IsNull

def Handle_VrmlData_IndexedLineSet_Create() -> "opencascade::handle< VrmlData_IndexedLineSet >":
    return _VrmlData.Handle_VrmlData_IndexedLineSet_Create()
Handle_VrmlData_IndexedLineSet_Create = _VrmlData.Handle_VrmlData_IndexedLineSet_Create

def Handle_VrmlData_IndexedLineSet_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_IndexedLineSet >":
    return _VrmlData.Handle_VrmlData_IndexedLineSet_DownCast(t)
Handle_VrmlData_IndexedLineSet_DownCast = _VrmlData.Handle_VrmlData_IndexedLineSet_DownCast

def Handle_VrmlData_IndexedLineSet_IsNull(t: 'opencascade::handle< VrmlData_IndexedLineSet > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_IndexedLineSet_IsNull(t)
Handle_VrmlData_IndexedLineSet_IsNull = _VrmlData.Handle_VrmlData_IndexedLineSet_IsNull

def Handle_VrmlData_Normal_Create() -> "opencascade::handle< VrmlData_Normal >":
    return _VrmlData.Handle_VrmlData_Normal_Create()
Handle_VrmlData_Normal_Create = _VrmlData.Handle_VrmlData_Normal_Create

def Handle_VrmlData_Normal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Normal >":
    return _VrmlData.Handle_VrmlData_Normal_DownCast(t)
Handle_VrmlData_Normal_DownCast = _VrmlData.Handle_VrmlData_Normal_DownCast

def Handle_VrmlData_Normal_IsNull(t: 'opencascade::handle< VrmlData_Normal > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Normal_IsNull(t)
Handle_VrmlData_Normal_IsNull = _VrmlData.Handle_VrmlData_Normal_IsNull

def Handle_VrmlData_Sphere_Create() -> "opencascade::handle< VrmlData_Sphere >":
    return _VrmlData.Handle_VrmlData_Sphere_Create()
Handle_VrmlData_Sphere_Create = _VrmlData.Handle_VrmlData_Sphere_Create

def Handle_VrmlData_Sphere_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_Sphere >":
    return _VrmlData.Handle_VrmlData_Sphere_DownCast(t)
Handle_VrmlData_Sphere_DownCast = _VrmlData.Handle_VrmlData_Sphere_DownCast

def Handle_VrmlData_Sphere_IsNull(t: 'opencascade::handle< VrmlData_Sphere > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_Sphere_IsNull(t)
Handle_VrmlData_Sphere_IsNull = _VrmlData.Handle_VrmlData_Sphere_IsNull

def Handle_VrmlData_IndexedFaceSet_Create() -> "opencascade::handle< VrmlData_IndexedFaceSet >":
    return _VrmlData.Handle_VrmlData_IndexedFaceSet_Create()
Handle_VrmlData_IndexedFaceSet_Create = _VrmlData.Handle_VrmlData_IndexedFaceSet_Create

def Handle_VrmlData_IndexedFaceSet_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< VrmlData_IndexedFaceSet >":
    return _VrmlData.Handle_VrmlData_IndexedFaceSet_DownCast(t)
Handle_VrmlData_IndexedFaceSet_DownCast = _VrmlData.Handle_VrmlData_IndexedFaceSet_DownCast

def Handle_VrmlData_IndexedFaceSet_IsNull(t: 'opencascade::handle< VrmlData_IndexedFaceSet > const &') -> "bool":
    return _VrmlData.Handle_VrmlData_IndexedFaceSet_IsNull(t)
Handle_VrmlData_IndexedFaceSet_IsNull = _VrmlData.Handle_VrmlData_IndexedFaceSet_IsNull
class VrmlData_DataMapOfShapeAppearance(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _VrmlData.VrmlData_DataMapOfShapeAppearance_swiginit(self, _VrmlData.new_VrmlData_DataMapOfShapeAppearance(*args))
    __swig_destroy__ = _VrmlData.delete_VrmlData_DataMapOfShapeAppearance
VrmlData_DataMapOfShapeAppearance.begin = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_begin, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.end = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_end, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.cbegin = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_cbegin, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.cend = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_cend, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.Exchange = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_Exchange, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.Assign = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_Assign, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.Set = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_Set, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.ReSize = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_ReSize, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.Bind = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_Bind, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.Bound = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_Bound, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.IsBound = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_IsBound, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.UnBind = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_UnBind, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.Seek = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_Seek, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.Find = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_Find, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.ChangeSeek = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_ChangeSeek, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.ChangeFind = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_ChangeFind, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.__call__ = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance___call__, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.Clear = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_Clear, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance.Size = new_instancemethod(_VrmlData.VrmlData_DataMapOfShapeAppearance_Size, None, VrmlData_DataMapOfShapeAppearance)
VrmlData_DataMapOfShapeAppearance_swigregister = _VrmlData.VrmlData_DataMapOfShapeAppearance_swigregister
VrmlData_DataMapOfShapeAppearance_swigregister(VrmlData_DataMapOfShapeAppearance)

class VrmlData_MapOfNode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _VrmlData.VrmlData_MapOfNode_swiginit(self, _VrmlData.new_VrmlData_MapOfNode(*args))
    __swig_destroy__ = _VrmlData.delete_VrmlData_MapOfNode
VrmlData_MapOfNode.cbegin = new_instancemethod(_VrmlData.VrmlData_MapOfNode_cbegin, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.cend = new_instancemethod(_VrmlData.VrmlData_MapOfNode_cend, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Exchange = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Exchange, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Assign = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Assign, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Set = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Set, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.ReSize = new_instancemethod(_VrmlData.VrmlData_MapOfNode_ReSize, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Add = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Add, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Added = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Added, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Remove = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Remove, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Clear = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Clear, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Size = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Size, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.IsEqual = new_instancemethod(_VrmlData.VrmlData_MapOfNode_IsEqual, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Contains = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Contains, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Union = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Union, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Unite = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Unite, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.HasIntersection = new_instancemethod(_VrmlData.VrmlData_MapOfNode_HasIntersection, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Intersection = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Intersection, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Intersect = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Intersect, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Subtraction = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Subtraction, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Subtract = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Subtract, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Difference = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Difference, None, VrmlData_MapOfNode)
VrmlData_MapOfNode.Differ = new_instancemethod(_VrmlData.VrmlData_MapOfNode_Differ, None, VrmlData_MapOfNode)
VrmlData_MapOfNode_swigregister = _VrmlData.VrmlData_MapOfNode_swigregister
VrmlData_MapOfNode_swigregister(VrmlData_MapOfNode)

class VrmlData_ListOfNode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _VrmlData.VrmlData_ListOfNode_swiginit(self, _VrmlData.new_VrmlData_ListOfNode(*args))
    __swig_destroy__ = _VrmlData.delete_VrmlData_ListOfNode
VrmlData_ListOfNode.begin = new_instancemethod(_VrmlData.VrmlData_ListOfNode_begin, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.end = new_instancemethod(_VrmlData.VrmlData_ListOfNode_end, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.cbegin = new_instancemethod(_VrmlData.VrmlData_ListOfNode_cbegin, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.cend = new_instancemethod(_VrmlData.VrmlData_ListOfNode_cend, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.Size = new_instancemethod(_VrmlData.VrmlData_ListOfNode_Size, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.Assign = new_instancemethod(_VrmlData.VrmlData_ListOfNode_Assign, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.Set = new_instancemethod(_VrmlData.VrmlData_ListOfNode_Set, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.Clear = new_instancemethod(_VrmlData.VrmlData_ListOfNode_Clear, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.First = new_instancemethod(_VrmlData.VrmlData_ListOfNode_First, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.Last = new_instancemethod(_VrmlData.VrmlData_ListOfNode_Last, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.Append = new_instancemethod(_VrmlData.VrmlData_ListOfNode_Append, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.Prepend = new_instancemethod(_VrmlData.VrmlData_ListOfNode_Prepend, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.RemoveFirst = new_instancemethod(_VrmlData.VrmlData_ListOfNode_RemoveFirst, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.Remove = new_instancemethod(_VrmlData.VrmlData_ListOfNode_Remove, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.InsertBefore = new_instancemethod(_VrmlData.VrmlData_ListOfNode_InsertBefore, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.InsertAfter = new_instancemethod(_VrmlData.VrmlData_ListOfNode_InsertAfter, None, VrmlData_ListOfNode)
VrmlData_ListOfNode.Reverse = new_instancemethod(_VrmlData.VrmlData_ListOfNode_Reverse, None, VrmlData_ListOfNode)
VrmlData_ListOfNode_swigregister = _VrmlData.VrmlData_ListOfNode_swigregister
VrmlData_ListOfNode_swigregister(VrmlData_ListOfNode)

class VrmlData_Node(OCC.Core.Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clone(self, *args) -> "opencascade::handle< VrmlData_Node >":
        """
        * /** * Create a copy of this node. * If the parameter is null, a new copied node is created. Otherwise new node * is not created, but rather the given one is modified.<p> * This method nullifies the argument node if its member myScene differs * from that one of the current instance. */
        	:param &:
        	:type &: VrmlData_Node
        	:rtype: opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_Node_Clone(self, *args)


    def GlobalIndent(*args) -> "Standard_Integer":
        """
        * /** * Define the common Indent in spaces, for writing all nodes. */
        	:rtype: inline int
        """
        return _VrmlData.VrmlData_Node_GlobalIndent(*args)

    GlobalIndent = staticmethod(GlobalIndent)

    def IsDefault(self, *args) -> "Standard_Boolean":
        """
        * /** * Returns True if the node is default, then it would not be written. */
        	:rtype: bool
        """
        return _VrmlData.VrmlData_Node_IsDefault(self, *args)


    def Name(self, *args) -> "char const *":
        """
        * /** * Query the name */
        	:rtype: inline  char *
        """
        return _VrmlData.VrmlData_Node_Name(self, *args)


    def OK(*args) -> "Standard_Boolean":
        """
        :param theStat:
        	:type theStat: VrmlData_ErrorStatus
        	:rtype: inline bool
        :param outStat:
        	:type outStat: VrmlData_ErrorStatus
        	:param theStat:
        	:type theStat: VrmlData_ErrorStatus
        	:rtype: inline bool
        """
        return _VrmlData.VrmlData_Node_OK(*args)

    OK = staticmethod(OK)

    def Read(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read the Node from input stream. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Node_Read(self, *args)


    def ReadBoolean(*args) -> "Standard_Boolean &":
        """
        * /** * Read one boolean value (True or False). */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theResult:
        	:type theResult: bool
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Node_ReadBoolean(*args)

    ReadBoolean = staticmethod(ReadBoolean)

    def ReadInteger(*args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read one integer value. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theResult:
        	:type theResult: long
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Node_ReadInteger(*args)

    ReadInteger = staticmethod(ReadInteger)

    def ReadMultiString(*args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read one quoted string, the quotes are removed. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theRes:
        	:type theRes: NCollection_List<TCollection_AsciiString>
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Node_ReadMultiString(*args)

    ReadMultiString = staticmethod(ReadMultiString)

    def ReadNode(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read a complete node definition from VRML stream * @param theBuffer * Buffer receiving the input data. * @param theNode * <tt>[out]</tt> Node restored from the buffer data * @param Type * Node type to be checked. If it is NULL(default) no type checking is done. * Otherwise the created node is matched and an error is returned if * no match detected. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theNode:
        	:type theNode: VrmlData_Node
        	:param Type: default value is NULL
        	:type Type: Standard_Type
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Node_ReadNode(self, *args)


    def ReadString(*args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read one quoted string, the quotes are removed. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theRes:
        	:type theRes: TCollection_AsciiString
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Node_ReadString(*args)

    ReadString = staticmethod(ReadString)

    def Scene(self, *args) -> "VrmlData_Scene const &":
        """
        * /** * Query the Scene that contains this Node */
        	:rtype: inline  VrmlData_Scene
        """
        return _VrmlData.VrmlData_Node_Scene(self, *args)


    def Write(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write the Node to output stream. */
        	:param thePrefix:
        	:type thePrefix: char *
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Node_Write(self, *args)


    def WriteClosing(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write the closing brace in the end of a node output. */
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Node_WriteClosing(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Node_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Node
VrmlData_Node.Clone = new_instancemethod(_VrmlData.VrmlData_Node_Clone, None, VrmlData_Node)
VrmlData_Node.IsDefault = new_instancemethod(_VrmlData.VrmlData_Node_IsDefault, None, VrmlData_Node)
VrmlData_Node.Name = new_instancemethod(_VrmlData.VrmlData_Node_Name, None, VrmlData_Node)
VrmlData_Node.Read = new_instancemethod(_VrmlData.VrmlData_Node_Read, None, VrmlData_Node)
VrmlData_Node.ReadNode = new_instancemethod(_VrmlData.VrmlData_Node_ReadNode, None, VrmlData_Node)
VrmlData_Node.Scene = new_instancemethod(_VrmlData.VrmlData_Node_Scene, None, VrmlData_Node)
VrmlData_Node.Write = new_instancemethod(_VrmlData.VrmlData_Node_Write, None, VrmlData_Node)
VrmlData_Node.WriteClosing = new_instancemethod(_VrmlData.VrmlData_Node_WriteClosing, None, VrmlData_Node)
VrmlData_Node_swigregister = _VrmlData.VrmlData_Node_swigregister
VrmlData_Node_swigregister(VrmlData_Node)

def VrmlData_Node_GlobalIndent(*args) -> "Standard_Integer":
    """
    * /** * Define the common Indent in spaces, for writing all nodes. */
    	:rtype: inline int
    """
    return _VrmlData.VrmlData_Node_GlobalIndent(*args)

def VrmlData_Node_OK(*args) -> "Standard_Boolean":
    """
    :param theStat:
    	:type theStat: VrmlData_ErrorStatus
    	:rtype: inline bool
    :param outStat:
    	:type outStat: VrmlData_ErrorStatus
    	:param theStat:
    	:type theStat: VrmlData_ErrorStatus
    	:rtype: inline bool
    """
    return _VrmlData.VrmlData_Node_OK(*args)

def VrmlData_Node_ReadBoolean(*args) -> "Standard_Boolean &":
    """
    * /** * Read one boolean value (True or False). */
    	:param theBuffer:
    	:type theBuffer: VrmlData_InBuffer
    	:param theResult:
    	:type theResult: bool
    	:rtype: VrmlData_ErrorStatus
    """
    return _VrmlData.VrmlData_Node_ReadBoolean(*args)

def VrmlData_Node_ReadInteger(*args) -> "VrmlData_ErrorStatus":
    """
    * /** * Read one integer value. */
    	:param theBuffer:
    	:type theBuffer: VrmlData_InBuffer
    	:param theResult:
    	:type theResult: long
    	:rtype: VrmlData_ErrorStatus
    """
    return _VrmlData.VrmlData_Node_ReadInteger(*args)

def VrmlData_Node_ReadMultiString(*args) -> "VrmlData_ErrorStatus":
    """
    * /** * Read one quoted string, the quotes are removed. */
    	:param theBuffer:
    	:type theBuffer: VrmlData_InBuffer
    	:param theRes:
    	:type theRes: NCollection_List<TCollection_AsciiString>
    	:rtype: VrmlData_ErrorStatus
    """
    return _VrmlData.VrmlData_Node_ReadMultiString(*args)

def VrmlData_Node_ReadString(*args) -> "VrmlData_ErrorStatus":
    """
    * /** * Read one quoted string, the quotes are removed. */
    	:param theBuffer:
    	:type theBuffer: VrmlData_InBuffer
    	:param theRes:
    	:type theRes: TCollection_AsciiString
    	:rtype: VrmlData_ErrorStatus
    """
    return _VrmlData.VrmlData_Node_ReadString(*args)

class VrmlData_Scene(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddNode(self, *args) -> "opencascade::handle< VrmlData_Node > const &":
        """
        * /** * Add a Node. If theN belongs to another Scene, it is cloned. * <p>VrmlData_WorldInfo cannot be added, in this case the method * returns a NULL handle. */
        	:param theN:
        	:type theN: VrmlData_Node
        	:param isTopLevel: default value is Standard_True
        	:type isTopLevel: bool
        	:rtype: opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_Scene_AddNode(self, *args)


    def Allocator(self, *args) -> "opencascade::handle< NCollection_IncAllocator > const &":
        """
        * /** * Allocator used by all nodes contained in the Scene. */
        	:rtype: inline  opencascade::handle<NCollection_IncAllocator>
        """
        return _VrmlData.VrmlData_Scene_Allocator(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(VrmlData_Scene self) -> std::string"""
        return _VrmlData.VrmlData_Scene_DumpToString(self)


    def FindNode(self, *args) -> "opencascade::handle< VrmlData_Node >":
        """
        * /** * Find a node by its name. * @param theName * Name of the node to find. * @param theType * Type to match. If this value is NULL, the first found node with the * given name is returned. If theType is given, only the node that has * that type is returned. */
        	:param theName:
        	:type theName: char *
        	:param theType: default value is 0L
        	:type theType: Standard_Type
        	:rtype: opencascade::handle<VrmlData_Node>
        * /** * Find a node by its name. * @param theName * Name of the node to search for. * @param theLocation * Location of the found node with respect to the whole VRML shape. */
        	:param theName:
        	:type theName: char *
        	:param theLocation:
        	:type theLocation: gp_Trsf
        	:rtype: opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_Scene_FindNode(self, *args)


    def GetIterator(self, *args) -> "VrmlData_Scene::Iterator":
        """
        * /** * Iterator of Nodes */
        	:rtype: inline Iterator
        """
        return _VrmlData.VrmlData_Scene_GetIterator(self, *args)


    def GetLineError(self, *args) -> "Standard_Integer":
        """
        * /** * Query the line where the error occurred (if the status is not OK) */
        	:rtype: inline int
        """
        return _VrmlData.VrmlData_Scene_GetLineError(self, *args)


    def GetShape(self, *args) -> "TopoDS_Shape":
        """
        * /** * Convert the scene to a Shape, with the information on materials defined * for each sub-shape. This method should be used instead of TopoDS_Shape * explicit conversion operator when you need to retrieve the material * aspect for each face or edge in the returned topological object. * @param M * Data Map that binds an Appearance instance to each created TFace or * TEdge if the Appearance node is defined in VRML scene for that geometry. * returns * TopoDS_Shape (Compound) holding all the scene, similar to the result of * explicit TopoDS_Shape conversion operator. */
        	:param M:
        	:type M: VrmlData_DataMapOfShapeAppearance
        	:rtype: TopoDS_Shape
        """
        return _VrmlData.VrmlData_Scene_GetShape(self, *args)


    def IsDummyWrite(self, *args) -> "Standard_Boolean":
        """
        * /** * Query if the current write operation is dummy, i.e., for the purpose of * collecting information before the real write is commenced. */
        	:rtype: inline bool
        """
        return _VrmlData.VrmlData_Scene_IsDummyWrite(self, *args)


    def NamedNodesIterator(self, *args) -> "VrmlData_MapOfNode::Iterator":
        """
        * /** * Get the iterator of named nodes. */
        	:rtype: inline VrmlData_MapOfNode::Iterator
        """
        return _VrmlData.VrmlData_Scene_NamedNodesIterator(self, *args)


    def ReadArrIndex(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read an array of integer indices, for IndexedfaceSet and IndexedLineSet. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theArr:
        	:type theArr: int * *
        	:param theNBl:
        	:type theNBl: Standard_Size
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_ReadArrIndex(self, *args)


    def ReadLine(*args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read a VRML line. Empty lines and comments are skipped. * The processing starts here from theBuffer.LinePtr; if there is at least * one non-empty character (neither space nor comment), this line is used * without reading the next one. * @param theLine * Buffer receiving the input line * @param theInput * Input stream * @param theLen * Length of the input buffer (maximal line length) */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_ReadLine(*args)

    ReadLine = staticmethod(ReadLine)

    def ReadReal(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read one real value. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theResult:
        	:type theResult: float
        	:param isApplyScale:
        	:type isApplyScale: bool
        	:param isOnlyPositive:
        	:type isOnlyPositive: bool
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_ReadReal(self, *args)


    def ReadWord(*args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read a singel word from the input stream, delimited by whitespace. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theStr:
        	:type theStr: TCollection_AsciiString
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_ReadWord(*args)

    ReadWord = staticmethod(ReadWord)

    def ReadXY(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read one doublet of real values. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theXYZ:
        	:type theXYZ: gp_XY
        	:param isApplyScale:
        	:type isApplyScale: bool
        	:param isOnlyPositive:
        	:type isOnlyPositive: bool
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_ReadXY(self, *args)


    def ReadXYZ(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read one triplet of real values. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:param theXYZ:
        	:type theXYZ: gp_XYZ
        	:param isApplyScale:
        	:type isApplyScale: bool
        	:param isOnlyPositive:
        	:type isOnlyPositive: bool
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_ReadXYZ(self, *args)


    def SetIndent(self, *args) -> "void":
        """
        * /** * Store the indentation for VRML output. * @param nSpc * number of spaces to insert at every indentation level */
        	:param nSpc:
        	:type nSpc: int
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Scene_SetIndent(self, *args)


    def SetLinearScale(self, *args) -> "void":
        """
        * /** * Set the scale factor that would be further used in methods * ReadReal, ReadXYZ and ReadXY. All coordinates, distances and sized are * multiplied by this factor during reading the data. */
        	:param theScale:
        	:type theScale: float
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Scene_SetLinearScale(self, *args)


    def SetVrmlDir(self, *args) -> "void":
        """
        * /** * Add the given directory path to the list of VRML file search directories. * This method forms the list of directories ordered according to the * sequence of this method calls. When an Inline node is found, the URLs * in that node are matched with these directories. * The last (implicit) search directory is the current process directory * ('.'). It takes effect if the list is empty or if there is no match with * exisiting directories. */
        	:param &:
        	:type &: TCollection_ExtendedString
        	:rtype: None
        """
        return _VrmlData.VrmlData_Scene_SetVrmlDir(self, *args)


    def Status(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Query the status of the previous operation. * Normally it should be equal to VrmlData_StatusOK (no error). */
        	:rtype: inline VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_Status(self, *args)


    def __init__(self, *args):
        """
        * /** * Constructor. */
        	:param &: default value is 0L
        	:type &: NCollection_IncAllocator
        	:rtype: None
        """
        _VrmlData.VrmlData_Scene_swiginit(self, _VrmlData.new_VrmlData_Scene(*args))

    def VrmlDirIterator(self, *args) -> "NCollection_List< TCollection_ExtendedString >::Iterator":
        """
        * /** * Returns the directory iterator, to check the presence of requested VRML * file in each iterated directory. */
        	:rtype: inline NCollection_List<TCollection_ExtendedString>::Iterator
        """
        return _VrmlData.VrmlData_Scene_VrmlDirIterator(self, *args)


    def WorldInfo(self, *args) -> "opencascade::handle< VrmlData_WorldInfo > const &":
        """
        * /** * Query the WorldInfo member. */
        	:rtype: opencascade::handle<VrmlData_WorldInfo>
        """
        return _VrmlData.VrmlData_Scene_WorldInfo(self, *args)


    def WriteArrIndex(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write an array of integer indices, for IndexedFaceSet and IndexedLineSet. */
        	:param thePrefix:
        	:type thePrefix: char *
        	:param theArr:
        	:type theArr: int * *
        	:param theNbBl:
        	:type theNbBl: Standard_Size
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_WriteArrIndex(self, *args)


    def WriteLine(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write a string to the output stream respecting the indentation. The string * can be defined as two substrings that will be separated by a space. * Each of the substrings can be NULL, then it is ignored. If both * are NULL, then a single newline is output (without indent). * @param theLine0 * The first part of string to output * @param theLine1 * The second part of string to output * @param theIndent * - 0 value ignored. * - negative decreases the current indent and then outputs. * - positive outputs and then increases the current indent. * returns * Error status of the stream, or a special error if myOutput == NULL. */
        	:param theLine0:
        	:type theLine0: char *
        	:param theLine1: default value is 0L
        	:type theLine1: char *
        	:param theIndent: default value is 0
        	:type theIndent: int
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_WriteLine(self, *args)


    def WriteNode(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write the given node to output stream 'myOutput'. */
        	:param thePrefix:
        	:type thePrefix: char *
        	:param &:
        	:type &: VrmlData_Node
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_WriteNode(self, *args)


    def WriteXYZ(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write a triplet of real values on a separate line. * @param theXYZ * The value to be output. * @param isScale * If True, then each component is divided by myLinearScale. * @param thePostfix * Optional string that is added before the end of the line. */
        	:param theXYZ:
        	:type theXYZ: gp_XYZ
        	:param isScale:
        	:type isScale: bool
        	:param thePostfix: default value is 0L
        	:type thePostfix: char *
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Scene_WriteXYZ(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Scene
VrmlData_Scene.AddNode = new_instancemethod(_VrmlData.VrmlData_Scene_AddNode, None, VrmlData_Scene)
VrmlData_Scene.Allocator = new_instancemethod(_VrmlData.VrmlData_Scene_Allocator, None, VrmlData_Scene)
VrmlData_Scene.DumpToString = new_instancemethod(_VrmlData.VrmlData_Scene_DumpToString, None, VrmlData_Scene)
VrmlData_Scene.FindNode = new_instancemethod(_VrmlData.VrmlData_Scene_FindNode, None, VrmlData_Scene)
VrmlData_Scene.GetIterator = new_instancemethod(_VrmlData.VrmlData_Scene_GetIterator, None, VrmlData_Scene)
VrmlData_Scene.GetLineError = new_instancemethod(_VrmlData.VrmlData_Scene_GetLineError, None, VrmlData_Scene)
VrmlData_Scene.GetShape = new_instancemethod(_VrmlData.VrmlData_Scene_GetShape, None, VrmlData_Scene)
VrmlData_Scene.IsDummyWrite = new_instancemethod(_VrmlData.VrmlData_Scene_IsDummyWrite, None, VrmlData_Scene)
VrmlData_Scene.NamedNodesIterator = new_instancemethod(_VrmlData.VrmlData_Scene_NamedNodesIterator, None, VrmlData_Scene)
VrmlData_Scene.ReadArrIndex = new_instancemethod(_VrmlData.VrmlData_Scene_ReadArrIndex, None, VrmlData_Scene)
VrmlData_Scene.ReadReal = new_instancemethod(_VrmlData.VrmlData_Scene_ReadReal, None, VrmlData_Scene)
VrmlData_Scene.ReadXY = new_instancemethod(_VrmlData.VrmlData_Scene_ReadXY, None, VrmlData_Scene)
VrmlData_Scene.ReadXYZ = new_instancemethod(_VrmlData.VrmlData_Scene_ReadXYZ, None, VrmlData_Scene)
VrmlData_Scene.SetIndent = new_instancemethod(_VrmlData.VrmlData_Scene_SetIndent, None, VrmlData_Scene)
VrmlData_Scene.SetLinearScale = new_instancemethod(_VrmlData.VrmlData_Scene_SetLinearScale, None, VrmlData_Scene)
VrmlData_Scene.SetVrmlDir = new_instancemethod(_VrmlData.VrmlData_Scene_SetVrmlDir, None, VrmlData_Scene)
VrmlData_Scene.Status = new_instancemethod(_VrmlData.VrmlData_Scene_Status, None, VrmlData_Scene)
VrmlData_Scene.VrmlDirIterator = new_instancemethod(_VrmlData.VrmlData_Scene_VrmlDirIterator, None, VrmlData_Scene)
VrmlData_Scene.WorldInfo = new_instancemethod(_VrmlData.VrmlData_Scene_WorldInfo, None, VrmlData_Scene)
VrmlData_Scene.WriteArrIndex = new_instancemethod(_VrmlData.VrmlData_Scene_WriteArrIndex, None, VrmlData_Scene)
VrmlData_Scene.WriteLine = new_instancemethod(_VrmlData.VrmlData_Scene_WriteLine, None, VrmlData_Scene)
VrmlData_Scene.WriteNode = new_instancemethod(_VrmlData.VrmlData_Scene_WriteNode, None, VrmlData_Scene)
VrmlData_Scene.WriteXYZ = new_instancemethod(_VrmlData.VrmlData_Scene_WriteXYZ, None, VrmlData_Scene)
VrmlData_Scene_swigregister = _VrmlData.VrmlData_Scene_swigregister
VrmlData_Scene_swigregister(VrmlData_Scene)

def VrmlData_Scene_ReadLine(*args) -> "VrmlData_ErrorStatus":
    """
    * /** * Read a VRML line. Empty lines and comments are skipped. * The processing starts here from theBuffer.LinePtr; if there is at least * one non-empty character (neither space nor comment), this line is used * without reading the next one. * @param theLine * Buffer receiving the input line * @param theInput * Input stream * @param theLen * Length of the input buffer (maximal line length) */
    	:param theBuffer:
    	:type theBuffer: VrmlData_InBuffer
    	:rtype: VrmlData_ErrorStatus
    """
    return _VrmlData.VrmlData_Scene_ReadLine(*args)

def VrmlData_Scene_ReadWord(*args) -> "VrmlData_ErrorStatus":
    """
    * /** * Read a singel word from the input stream, delimited by whitespace. */
    	:param theBuffer:
    	:type theBuffer: VrmlData_InBuffer
    	:param theStr:
    	:type theStr: TCollection_AsciiString
    	:rtype: VrmlData_ErrorStatus
    """
    return _VrmlData.VrmlData_Scene_ReadWord(*args)

class VrmlData_ShapeConvert(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddShape(self, *args) -> "void":
        """
        * /** * Add one shape to the internal list, may be called several times with * different shapes. */
        	:param theShape:
        	:type theShape: TopoDS_Shape
        	:param theName: default value is 0L
        	:type theName: char *
        	:rtype: None
        """
        return _VrmlData.VrmlData_ShapeConvert_AddShape(self, *args)


    def Convert(self, *args) -> "void":
        """
        * /** * Convert all accumulated shapes and store them in myScene. * The internal data structures are cleared in the end of convertion. * @param theExtractFaces * If True, converter extracst faces from the shapes. * @param theExtractEdges * If True, converter extracts edges from the shapes. * @param theDeflection * Deflection for tessellation of geometrical lines/surfaces. Existing mesh * is used if its deflection is smaller than the one given by this * parameter. * @param theDeflAngle * Angular deflection for tessellation of geometrical lines. */
        	:param theExtractFaces:
        	:type theExtractFaces: bool
        	:param theExtractEdges:
        	:type theExtractEdges: bool
        	:param theDeflection: default value is 0.01
        	:type theDeflection: float
        	:param theDeflAngle: default value is 20*M_PI/180
        	:type theDeflAngle: float
        	:rtype: None
        """
        return _VrmlData.VrmlData_ShapeConvert_Convert(self, *args)


    def ConvertDocument(self, *args) -> "void":
        """
        * /** * Add all shapes start from given document with colors and names to the internal structure */
        	:param theDoc:
        	:type theDoc: TDocStd_Document
        	:rtype: None
        """
        return _VrmlData.VrmlData_ShapeConvert_ConvertDocument(self, *args)


    def __init__(self, *args):
        """
        * /** * Constructor. * @param theScene * Scene receiving all Vrml data. * @param theScale * Scale factor, considering that VRML standard specifies coordinates in * meters. So if your data are in mm, you should provide theScale=0.001 */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theScale: default value is 1
        	:type theScale: float
        	:rtype: None
        """
        _VrmlData.VrmlData_ShapeConvert_swiginit(self, _VrmlData.new_VrmlData_ShapeConvert(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_ShapeConvert
VrmlData_ShapeConvert.AddShape = new_instancemethod(_VrmlData.VrmlData_ShapeConvert_AddShape, None, VrmlData_ShapeConvert)
VrmlData_ShapeConvert.Convert = new_instancemethod(_VrmlData.VrmlData_ShapeConvert_Convert, None, VrmlData_ShapeConvert)
VrmlData_ShapeConvert.ConvertDocument = new_instancemethod(_VrmlData.VrmlData_ShapeConvert_ConvertDocument, None, VrmlData_ShapeConvert)
VrmlData_ShapeConvert_swigregister = _VrmlData.VrmlData_ShapeConvert_swigregister
VrmlData_ShapeConvert_swigregister(VrmlData_ShapeConvert)

class VrmlData_Appearance(VrmlData_Node):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Material(self, *args) -> "opencascade::handle< VrmlData_Material > const &":
        """
        * /** * Query the Material */
        	:rtype: inline  opencascade::handle<VrmlData_Material>
        """
        return _VrmlData.VrmlData_Appearance_Material(self, *args)


    def SetMaterial(self, *args) -> "void":
        """
        * /** * Set the Material */
        	:param theMat:
        	:type theMat: VrmlData_Material
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Appearance_SetMaterial(self, *args)


    def SetTexture(self, *args) -> "void":
        """
        * /** * Set the Texture */
        	:param theTexture:
        	:type theTexture: VrmlData_Texture
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Appearance_SetTexture(self, *args)


    def SetTextureTransform(self, *args) -> "void":
        """
        * /** * Set the Texture Transform */
        	:param theTT:
        	:type theTT: VrmlData_TextureTransform
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Appearance_SetTextureTransform(self, *args)


    def Texture(self, *args) -> "opencascade::handle< VrmlData_Texture > const &":
        """
        * /** * Query the Texture */
        	:rtype: inline  opencascade::handle<VrmlData_Texture>
        """
        return _VrmlData.VrmlData_Appearance_Texture(self, *args)


    def TextureTransform(self, *args) -> "opencascade::handle< VrmlData_TextureTransform > const &":
        """
        * /** * Query the TextureTransform */
        	:rtype: inline  opencascade::handle<VrmlData_TextureTransform>
        """
        return _VrmlData.VrmlData_Appearance_TextureTransform(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:rtype: None
        """
        _VrmlData.VrmlData_Appearance_swiginit(self, _VrmlData.new_VrmlData_Appearance(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Appearance_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Appearance
VrmlData_Appearance.Material = new_instancemethod(_VrmlData.VrmlData_Appearance_Material, None, VrmlData_Appearance)
VrmlData_Appearance.SetMaterial = new_instancemethod(_VrmlData.VrmlData_Appearance_SetMaterial, None, VrmlData_Appearance)
VrmlData_Appearance.SetTexture = new_instancemethod(_VrmlData.VrmlData_Appearance_SetTexture, None, VrmlData_Appearance)
VrmlData_Appearance.SetTextureTransform = new_instancemethod(_VrmlData.VrmlData_Appearance_SetTextureTransform, None, VrmlData_Appearance)
VrmlData_Appearance.Texture = new_instancemethod(_VrmlData.VrmlData_Appearance_Texture, None, VrmlData_Appearance)
VrmlData_Appearance.TextureTransform = new_instancemethod(_VrmlData.VrmlData_Appearance_TextureTransform, None, VrmlData_Appearance)
VrmlData_Appearance_swigregister = _VrmlData.VrmlData_Appearance_swigregister
VrmlData_Appearance_swigregister(VrmlData_Appearance)

class VrmlData_Geometry(VrmlData_Node):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TShape(self, *args) -> "opencascade::handle< TopoDS_TShape > const":
        """
        * /** * Query the shape. This method checks the flag myIsModified; if True it * should rebuild the shape presentation. */
        	:rtype: opencascade::handle<TopoDS_TShape>
        """
        return _VrmlData.VrmlData_Geometry_TShape(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Geometry_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Geometry
VrmlData_Geometry.TShape = new_instancemethod(_VrmlData.VrmlData_Geometry_TShape, None, VrmlData_Geometry)
VrmlData_Geometry_swigregister = _VrmlData.VrmlData_Geometry_swigregister
VrmlData_Geometry_swigregister(VrmlData_Geometry)

class VrmlData_Group(VrmlData_Node):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddNode(self, *args) -> "opencascade::handle< VrmlData_Node > &":
        """
        * /** * Add one node to the Group. */
        	:param theNode:
        	:type theNode: VrmlData_Node
        	:rtype: inline opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_Group_AddNode(self, *args)


    def Box(self, *args) -> "Bnd_B3f const &":
        """
        * /** * Query the bounding box. */
        	:rtype: inline  Bnd_B3f
        """
        return _VrmlData.VrmlData_Group_Box(self, *args)


    def FindNode(self, *args) -> "opencascade::handle< VrmlData_Node >":
        """
        * /** * Find a node by its name, inside this Group * @param theName * Name of the node to search for. * @param theLocation * Location of the found node with respect to this Group. */
        	:param theName:
        	:type theName: char *
        	:param theLocation:
        	:type theLocation: gp_Trsf
        	:rtype: opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_Group_FindNode(self, *args)


    def GetTransform(self, *args) -> "gp_Trsf const":
        """
        * /** * Query the transform value. * For group without transformation this always returns Identity */
        	:rtype: inline  gp_Trsf
        """
        return _VrmlData.VrmlData_Group_GetTransform(self, *args)


    def IsTransform(self, *args) -> "Standard_Boolean":
        """
        * /** * Query if the node is Transform type. */
        	:rtype: inline bool
        """
        return _VrmlData.VrmlData_Group_IsTransform(self, *args)


    def NodeIterator(self, *args) -> "VrmlData_Group::Iterator":
        """
        * /** * Create iterator on nodes belonging to the Group. */
        	:rtype: inline Iterator
        """
        return _VrmlData.VrmlData_Group_NodeIterator(self, *args)


    def RemoveNode(self, *args) -> "Standard_Boolean":
        """
        * /** * Remove one node from the Group. * returns * True if the node was located and removed, False if none removed. */
        	:param theNode:
        	:type theNode: VrmlData_Node
        	:rtype: bool
        """
        return _VrmlData.VrmlData_Group_RemoveNode(self, *args)


    def SetBox(self, *args) -> "void":
        """
        * /** * Set the bounding box. */
        	:param theBox:
        	:type theBox: Bnd_B3f
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Group_SetBox(self, *args)


    def SetTransform(self, *args) -> "Standard_Boolean":
        """
        * /** * Set the transformation. Returns True if the group is Transform type, * otherwise do nothing and return False. */
        	:param theTrsf:
        	:type theTrsf: gp_Trsf
        	:rtype: bool
        """
        return _VrmlData.VrmlData_Group_SetTransform(self, *args)


    def Shape(self, *args) -> "void":
        """
        * /** * Get the shape representing the group geometry. */
        	:param theShape:
        	:type theShape: TopoDS_Shape
        	:param pMapApp:
        	:type pMapApp: VrmlData_DataMapOfShapeAppearance *
        	:rtype: None
        """
        return _VrmlData.VrmlData_Group_Shape(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor. * @param isTransform * True if the group of type Transform is defined * @param theAlloc * Allocator used for the list of children */
        	:param isTransform: default value is Standard_False
        	:type isTransform: bool
        	:rtype: None
        * /** * Constructor. * @param theName * Name of the Group node * @param isTransform * True if the group of type Transform is defined * @param theAlloc * Allocator used for the list of children */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param isTransform: default value is Standard_False
        	:type isTransform: bool
        	:rtype: None
        """
        _VrmlData.VrmlData_Group_swiginit(self, _VrmlData.new_VrmlData_Group(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Group_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Group
VrmlData_Group.AddNode = new_instancemethod(_VrmlData.VrmlData_Group_AddNode, None, VrmlData_Group)
VrmlData_Group.Box = new_instancemethod(_VrmlData.VrmlData_Group_Box, None, VrmlData_Group)
VrmlData_Group.FindNode = new_instancemethod(_VrmlData.VrmlData_Group_FindNode, None, VrmlData_Group)
VrmlData_Group.GetTransform = new_instancemethod(_VrmlData.VrmlData_Group_GetTransform, None, VrmlData_Group)
VrmlData_Group.IsTransform = new_instancemethod(_VrmlData.VrmlData_Group_IsTransform, None, VrmlData_Group)
VrmlData_Group.NodeIterator = new_instancemethod(_VrmlData.VrmlData_Group_NodeIterator, None, VrmlData_Group)
VrmlData_Group.RemoveNode = new_instancemethod(_VrmlData.VrmlData_Group_RemoveNode, None, VrmlData_Group)
VrmlData_Group.SetBox = new_instancemethod(_VrmlData.VrmlData_Group_SetBox, None, VrmlData_Group)
VrmlData_Group.SetTransform = new_instancemethod(_VrmlData.VrmlData_Group_SetTransform, None, VrmlData_Group)
VrmlData_Group.Shape = new_instancemethod(_VrmlData.VrmlData_Group_Shape, None, VrmlData_Group)
VrmlData_Group_swigregister = _VrmlData.VrmlData_Group_swigregister
VrmlData_Group_swigregister(VrmlData_Group)

class VrmlData_Material(VrmlData_Node):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AmbientIntensity(self, *args) -> "Standard_Real":
        """
        * /** * Query the Ambient Intensity value */
        	:rtype: inline float
        """
        return _VrmlData.VrmlData_Material_AmbientIntensity(self, *args)


    def DiffuseColor(self, *args) -> "Quantity_Color const &":
        """
        * /** * Query the Diffuse color */
        	:rtype: inline  Quantity_Color
        """
        return _VrmlData.VrmlData_Material_DiffuseColor(self, *args)


    def EmissiveColor(self, *args) -> "Quantity_Color const &":
        """
        * /** * Query the Emissive color */
        	:rtype: inline  Quantity_Color
        """
        return _VrmlData.VrmlData_Material_EmissiveColor(self, *args)


    def SetAmbientIntensity(self, *args) -> "void":
        """
        * /** * Set the Ambient Intensity value */
        	:param theAmbientIntensity:
        	:type theAmbientIntensity: float
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Material_SetAmbientIntensity(self, *args)


    def SetDiffuseColor(self, *args) -> "void":
        """
        * /** * Query the Diffuse color */
        	:param theColor:
        	:type theColor: Quantity_Color
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Material_SetDiffuseColor(self, *args)


    def SetEmissiveColor(self, *args) -> "void":
        """
        * /** * Query the Emissive color */
        	:param theColor:
        	:type theColor: Quantity_Color
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Material_SetEmissiveColor(self, *args)


    def SetShininess(self, *args) -> "void":
        """
        * /** * Set the Shininess value */
        	:param theShininess:
        	:type theShininess: float
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Material_SetShininess(self, *args)


    def SetSpecularColor(self, *args) -> "void":
        """
        * /** * Query the Specular color */
        	:param theColor:
        	:type theColor: Quantity_Color
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Material_SetSpecularColor(self, *args)


    def SetTransparency(self, *args) -> "void":
        """
        * /** * Set the Transparency value */
        	:param theTransparency:
        	:type theTransparency: float
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Material_SetTransparency(self, *args)


    def Shininess(self, *args) -> "Standard_Real":
        """
        * /** * Query the Shininess value */
        	:rtype: inline float
        """
        return _VrmlData.VrmlData_Material_Shininess(self, *args)


    def SpecularColor(self, *args) -> "Quantity_Color const &":
        """
        * /** * Query the Specular color */
        	:rtype: inline  Quantity_Color
        """
        return _VrmlData.VrmlData_Material_SpecularColor(self, *args)


    def Transparency(self, *args) -> "Standard_Real":
        """
        * /** * Query the Transparency value */
        	:rtype: inline float
        """
        return _VrmlData.VrmlData_Material_Transparency(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param theAmbientIntensity: default value is -1
        	:type theAmbientIntensity: float
        	:param theShininess: default value is -1
        	:type theShininess: float
        	:param theTransparency: default value is -1
        	:type theTransparency: float
        	:rtype: None
        """
        _VrmlData.VrmlData_Material_swiginit(self, _VrmlData.new_VrmlData_Material(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Material_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Material
VrmlData_Material.AmbientIntensity = new_instancemethod(_VrmlData.VrmlData_Material_AmbientIntensity, None, VrmlData_Material)
VrmlData_Material.DiffuseColor = new_instancemethod(_VrmlData.VrmlData_Material_DiffuseColor, None, VrmlData_Material)
VrmlData_Material.EmissiveColor = new_instancemethod(_VrmlData.VrmlData_Material_EmissiveColor, None, VrmlData_Material)
VrmlData_Material.SetAmbientIntensity = new_instancemethod(_VrmlData.VrmlData_Material_SetAmbientIntensity, None, VrmlData_Material)
VrmlData_Material.SetDiffuseColor = new_instancemethod(_VrmlData.VrmlData_Material_SetDiffuseColor, None, VrmlData_Material)
VrmlData_Material.SetEmissiveColor = new_instancemethod(_VrmlData.VrmlData_Material_SetEmissiveColor, None, VrmlData_Material)
VrmlData_Material.SetShininess = new_instancemethod(_VrmlData.VrmlData_Material_SetShininess, None, VrmlData_Material)
VrmlData_Material.SetSpecularColor = new_instancemethod(_VrmlData.VrmlData_Material_SetSpecularColor, None, VrmlData_Material)
VrmlData_Material.SetTransparency = new_instancemethod(_VrmlData.VrmlData_Material_SetTransparency, None, VrmlData_Material)
VrmlData_Material.Shininess = new_instancemethod(_VrmlData.VrmlData_Material_Shininess, None, VrmlData_Material)
VrmlData_Material.SpecularColor = new_instancemethod(_VrmlData.VrmlData_Material_SpecularColor, None, VrmlData_Material)
VrmlData_Material.Transparency = new_instancemethod(_VrmlData.VrmlData_Material_Transparency, None, VrmlData_Material)
VrmlData_Material_swigregister = _VrmlData.VrmlData_Material_swigregister
VrmlData_Material_swigregister(VrmlData_Material)

class VrmlData_ShapeNode(VrmlData_Node):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Appearance(self, *args) -> "opencascade::handle< VrmlData_Appearance > const &":
        """
        * /** * Query the Appearance. */
        	:rtype: inline  opencascade::handle<VrmlData_Appearance>
        """
        return _VrmlData.VrmlData_ShapeNode_Appearance(self, *args)


    def Geometry(self, *args) -> "opencascade::handle< VrmlData_Geometry > const &":
        """
        * /** * Query the Geometry. */
        	:rtype: inline  opencascade::handle<VrmlData_Geometry>
        """
        return _VrmlData.VrmlData_ShapeNode_Geometry(self, *args)


    def SetAppearance(self, *args) -> "void":
        """
        * /** * Set the Appearance */
        	:param theAppear:
        	:type theAppear: VrmlData_Appearance
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_ShapeNode_SetAppearance(self, *args)


    def SetGeometry(self, *args) -> "void":
        """
        * /** * Set the Geometry */
        	:param theGeometry:
        	:type theGeometry: VrmlData_Geometry
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_ShapeNode_SetGeometry(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:rtype: None
        """
        _VrmlData.VrmlData_ShapeNode_swiginit(self, _VrmlData.new_VrmlData_ShapeNode(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_ShapeNode_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_ShapeNode
VrmlData_ShapeNode.Appearance = new_instancemethod(_VrmlData.VrmlData_ShapeNode_Appearance, None, VrmlData_ShapeNode)
VrmlData_ShapeNode.Geometry = new_instancemethod(_VrmlData.VrmlData_ShapeNode_Geometry, None, VrmlData_ShapeNode)
VrmlData_ShapeNode.SetAppearance = new_instancemethod(_VrmlData.VrmlData_ShapeNode_SetAppearance, None, VrmlData_ShapeNode)
VrmlData_ShapeNode.SetGeometry = new_instancemethod(_VrmlData.VrmlData_ShapeNode_SetGeometry, None, VrmlData_ShapeNode)
VrmlData_ShapeNode_swigregister = _VrmlData.VrmlData_ShapeNode_swigregister
VrmlData_ShapeNode_swigregister(VrmlData_ShapeNode)

class VrmlData_TextureCoordinate(VrmlData_Node):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AllocateValues(self, *args) -> "Standard_Boolean":
        """
        * /** * Create a data array and assign the field myArray. * returns * True if allocation was successful. */
        	:param theLength:
        	:type theLength: Standard_Size
        	:rtype: bool
        """
        return _VrmlData.VrmlData_TextureCoordinate_AllocateValues(self, *args)


    def Length(self, *args) -> "size_t":
        """
        * /** * Query the number of points */
        	:rtype: inline size_t
        """
        return _VrmlData.VrmlData_TextureCoordinate_Length(self, *args)


    def Points(self, *args) -> "gp_XY const *":
        """
        * /** * Query the points */
        	:rtype: inline  gp_XY *
        """
        return _VrmlData.VrmlData_TextureCoordinate_Points(self, *args)


    def SetPoints(self, *args) -> "void":
        """
        * /** * Set the points array */
        	:param nPoints:
        	:type nPoints: size_t
        	:param arrPoints:
        	:type arrPoints: gp_XY *
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_TextureCoordinate_SetPoints(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param nPoints: default value is 0
        	:type nPoints: size_t
        	:param arrPoints: default value is 0L
        	:type arrPoints: gp_XY *
        	:rtype: None
        """
        _VrmlData.VrmlData_TextureCoordinate_swiginit(self, _VrmlData.new_VrmlData_TextureCoordinate(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_TextureCoordinate_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_TextureCoordinate
VrmlData_TextureCoordinate.AllocateValues = new_instancemethod(_VrmlData.VrmlData_TextureCoordinate_AllocateValues, None, VrmlData_TextureCoordinate)
VrmlData_TextureCoordinate.Length = new_instancemethod(_VrmlData.VrmlData_TextureCoordinate_Length, None, VrmlData_TextureCoordinate)
VrmlData_TextureCoordinate.Points = new_instancemethod(_VrmlData.VrmlData_TextureCoordinate_Points, None, VrmlData_TextureCoordinate)
VrmlData_TextureCoordinate.SetPoints = new_instancemethod(_VrmlData.VrmlData_TextureCoordinate_SetPoints, None, VrmlData_TextureCoordinate)
VrmlData_TextureCoordinate_swigregister = _VrmlData.VrmlData_TextureCoordinate_swigregister
VrmlData_TextureCoordinate_swigregister(VrmlData_TextureCoordinate)

class VrmlData_UnknownNode(VrmlData_Node):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetTitle(self, *args) -> "TCollection_AsciiString const &":
        """
        * /** * Query the title of the unknown node. */
        	:rtype: inline  TCollection_AsciiString
        """
        return _VrmlData.VrmlData_UnknownNode_GetTitle(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty Constructor. */
        	:rtype: None
        * /** * Constructor. */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName: default value is 0L
        	:type theName: char *
        	:param theTitle: default value is 0L
        	:type theTitle: char *
        	:rtype: None
        """
        _VrmlData.VrmlData_UnknownNode_swiginit(self, _VrmlData.new_VrmlData_UnknownNode(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_UnknownNode_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_UnknownNode
VrmlData_UnknownNode.GetTitle = new_instancemethod(_VrmlData.VrmlData_UnknownNode_GetTitle, None, VrmlData_UnknownNode)
VrmlData_UnknownNode_swigregister = _VrmlData.VrmlData_UnknownNode_swigregister
VrmlData_UnknownNode_swigregister(VrmlData_UnknownNode)

class VrmlData_WorldInfo(VrmlData_Node):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddInfo(self, *args) -> "void":
        """
        * /** * Add a string to the list of info strings. */
        	:param theString:
        	:type theString: char *
        	:rtype: None
        """
        return _VrmlData.VrmlData_WorldInfo_AddInfo(self, *args)


    def InfoIterator(self, *args) -> "NCollection_List< char const * >::Iterator":
        """
        * /** * Return the iterator of Info strings. */
        	:rtype: inline NCollection_List< char *>::Iterator
        """
        return _VrmlData.VrmlData_WorldInfo_InfoIterator(self, *args)


    def SetTitle(self, *args) -> "void":
        """
        * /** * Set or modify the title. */
        	:param theString:
        	:type theString: char *
        	:rtype: None
        """
        return _VrmlData.VrmlData_WorldInfo_SetTitle(self, *args)


    def Title(self, *args) -> "char const *":
        """
        * /** * Query the title string. */
        	:rtype: inline  char *
        """
        return _VrmlData.VrmlData_WorldInfo_Title(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty Constructor. */
        	:rtype: None
        * /** * Constructor. */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName: default value is 0L
        	:type theName: char *
        	:param theTitle: default value is 0L
        	:type theTitle: char *
        	:rtype: None
        """
        _VrmlData.VrmlData_WorldInfo_swiginit(self, _VrmlData.new_VrmlData_WorldInfo(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_WorldInfo_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_WorldInfo
VrmlData_WorldInfo.AddInfo = new_instancemethod(_VrmlData.VrmlData_WorldInfo_AddInfo, None, VrmlData_WorldInfo)
VrmlData_WorldInfo.InfoIterator = new_instancemethod(_VrmlData.VrmlData_WorldInfo_InfoIterator, None, VrmlData_WorldInfo)
VrmlData_WorldInfo.SetTitle = new_instancemethod(_VrmlData.VrmlData_WorldInfo_SetTitle, None, VrmlData_WorldInfo)
VrmlData_WorldInfo.Title = new_instancemethod(_VrmlData.VrmlData_WorldInfo_Title, None, VrmlData_WorldInfo)
VrmlData_WorldInfo_swigregister = _VrmlData.VrmlData_WorldInfo_swigregister
VrmlData_WorldInfo_swigregister(VrmlData_WorldInfo)

class VrmlData_Box(VrmlData_Geometry):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetSize(self, *args) -> "void":
        """
        * /** * Set the Box Size */
        	:param theSize:
        	:type theSize: gp_XYZ
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Box_SetSize(self, *args)


    def Size(self, *args) -> "gp_XYZ const":
        """
        * /** * Query the Box size */
        	:rtype: inline  gp_XYZ
        """
        return _VrmlData.VrmlData_Box_Size(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param sizeX: default value is 2
        	:type sizeX: float
        	:param sizeY: default value is 2
        	:type sizeY: float
        	:param sizeZ: default value is 2
        	:type sizeZ: float
        	:rtype: None
        """
        _VrmlData.VrmlData_Box_swiginit(self, _VrmlData.new_VrmlData_Box(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Box_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Box
VrmlData_Box.SetSize = new_instancemethod(_VrmlData.VrmlData_Box_SetSize, None, VrmlData_Box)
VrmlData_Box.Size = new_instancemethod(_VrmlData.VrmlData_Box_Size, None, VrmlData_Box)
VrmlData_Box_swigregister = _VrmlData.VrmlData_Box_swigregister
VrmlData_Box_swigregister(VrmlData_Box)

class VrmlData_Color(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Clone(self, *args) -> "opencascade::handle< VrmlData_Node >":
        """
        * /** * Create a copy of this node. * If the parameter is null, a new copied node is created. Otherwise new node * is not created, but rather the given one is modified.<p> */
        	:param theOther:
        	:type theOther: VrmlData_Node
        	:rtype: opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_Color_Clone(self, *args)


    def Color(self, *args) -> "Quantity_Color const":
        """
        * /** * Query one color * @param i * index in the array of colors [0 .. N-1] * returns * the color value for the index. If index irrelevant, returns (0., 0., 0.) */
        	:param i:
        	:type i: int
        	:rtype: inline  Quantity_Color
        """
        return _VrmlData.VrmlData_Color_Color(self, *args)


    def Read(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read the Node from input stream. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Color_Read(self, *args)


    def SetColors(self, *args) -> "void":
        """
        * /** * Set the array data */
        	:param nColors:
        	:type nColors: size_t
        	:param arrColors:
        	:type arrColors: gp_XYZ *
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Color_SetColors(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor. */
        	:rtype: None
        * /** * Constructor. */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param nColors: default value is 0
        	:type nColors: size_t
        	:param arrColors: default value is 0L
        	:type arrColors: gp_XYZ *
        	:rtype: None
        """
        _VrmlData.VrmlData_Color_swiginit(self, _VrmlData.new_VrmlData_Color(*args))

    def Write(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write the Node to the Scene output. */
        	:param thePrefix:
        	:type thePrefix: char *
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Color_Write(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Color_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Color
VrmlData_Color.Clone = new_instancemethod(_VrmlData.VrmlData_Color_Clone, None, VrmlData_Color)
VrmlData_Color.Color = new_instancemethod(_VrmlData.VrmlData_Color_Color, None, VrmlData_Color)
VrmlData_Color.Read = new_instancemethod(_VrmlData.VrmlData_Color_Read, None, VrmlData_Color)
VrmlData_Color.SetColors = new_instancemethod(_VrmlData.VrmlData_Color_SetColors, None, VrmlData_Color)
VrmlData_Color.Write = new_instancemethod(_VrmlData.VrmlData_Color_Write, None, VrmlData_Color)
VrmlData_Color_swigregister = _VrmlData.VrmlData_Color_swigregister
VrmlData_Color_swigregister(VrmlData_Color)

class VrmlData_Cone(VrmlData_Geometry):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BottomRadius(self, *args) -> "Standard_Real":
        """
        * /** * Query the Bottom Radius */
        	:rtype: inline float
        """
        return _VrmlData.VrmlData_Cone_BottomRadius(self, *args)


    def HasBottom(self, *args) -> "Standard_Boolean":
        """
        * /** * Query if the bottom circle is included */
        	:rtype: inline bool
        """
        return _VrmlData.VrmlData_Cone_HasBottom(self, *args)


    def HasSide(self, *args) -> "Standard_Boolean":
        """
        * /** * Query if the side surface is included */
        	:rtype: inline bool
        """
        return _VrmlData.VrmlData_Cone_HasSide(self, *args)


    def Height(self, *args) -> "Standard_Real":
        """
        * /** * Query the Height */
        	:rtype: inline float
        """
        return _VrmlData.VrmlData_Cone_Height(self, *args)


    def SetBottomRadius(self, *args) -> "void":
        """
        * /** * Set the Bottom Radius */
        	:param theRadius:
        	:type theRadius: float
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Cone_SetBottomRadius(self, *args)


    def SetFaces(self, *args) -> "void":
        """
        * /** * Set which faces are included */
        	:param hasBottom:
        	:type hasBottom: bool
        	:param hasSide:
        	:type hasSide: bool
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Cone_SetFaces(self, *args)


    def SetHeight(self, *args) -> "void":
        """
        * /** * Set the Height */
        	:param theHeight:
        	:type theHeight: float
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Cone_SetHeight(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param theBottomRadius: default value is 1
        	:type theBottomRadius: float
        	:param theHeight: default value is 2
        	:type theHeight: float
        	:rtype: None
        """
        _VrmlData.VrmlData_Cone_swiginit(self, _VrmlData.new_VrmlData_Cone(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Cone_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Cone
VrmlData_Cone.BottomRadius = new_instancemethod(_VrmlData.VrmlData_Cone_BottomRadius, None, VrmlData_Cone)
VrmlData_Cone.HasBottom = new_instancemethod(_VrmlData.VrmlData_Cone_HasBottom, None, VrmlData_Cone)
VrmlData_Cone.HasSide = new_instancemethod(_VrmlData.VrmlData_Cone_HasSide, None, VrmlData_Cone)
VrmlData_Cone.Height = new_instancemethod(_VrmlData.VrmlData_Cone_Height, None, VrmlData_Cone)
VrmlData_Cone.SetBottomRadius = new_instancemethod(_VrmlData.VrmlData_Cone_SetBottomRadius, None, VrmlData_Cone)
VrmlData_Cone.SetFaces = new_instancemethod(_VrmlData.VrmlData_Cone_SetFaces, None, VrmlData_Cone)
VrmlData_Cone.SetHeight = new_instancemethod(_VrmlData.VrmlData_Cone_SetHeight, None, VrmlData_Cone)
VrmlData_Cone_swigregister = _VrmlData.VrmlData_Cone_swigregister
VrmlData_Cone_swigregister(VrmlData_Cone)

class VrmlData_Coordinate(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Clone(self, *args) -> "opencascade::handle< VrmlData_Node >":
        """
        * /** * Create a copy of this node. * If the parameter is null, a new copied node is created. Otherwise new node * is not created, but rather the given one is modified. */
        	:param theOther:
        	:type theOther: VrmlData_Node
        	:rtype: opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_Coordinate_Clone(self, *args)


    def Coordinate(self, *args) -> "gp_XYZ const":
        """
        * /** * Query one point * @param i * index in the array of points [0 .. N-1] * returns * the coordinate for the index. If index irrelevant, returns (0., 0., 0.) */
        	:param i:
        	:type i: int
        	:rtype: inline  gp_XYZ
        """
        return _VrmlData.VrmlData_Coordinate_Coordinate(self, *args)


    def Read(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read the Node from input stream. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Coordinate_Read(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty Constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param nPoints: default value is 0
        	:type nPoints: size_t
        	:param arrPoints: default value is 0L
        	:type arrPoints: gp_XYZ *
        	:rtype: None
        """
        _VrmlData.VrmlData_Coordinate_swiginit(self, _VrmlData.new_VrmlData_Coordinate(*args))

    def Write(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write the Node to the Scene output. */
        	:param thePrefix:
        	:type thePrefix: char *
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Coordinate_Write(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Coordinate_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Coordinate
VrmlData_Coordinate.Clone = new_instancemethod(_VrmlData.VrmlData_Coordinate_Clone, None, VrmlData_Coordinate)
VrmlData_Coordinate.Coordinate = new_instancemethod(_VrmlData.VrmlData_Coordinate_Coordinate, None, VrmlData_Coordinate)
VrmlData_Coordinate.Read = new_instancemethod(_VrmlData.VrmlData_Coordinate_Read, None, VrmlData_Coordinate)
VrmlData_Coordinate.Write = new_instancemethod(_VrmlData.VrmlData_Coordinate_Write, None, VrmlData_Coordinate)
VrmlData_Coordinate_swigregister = _VrmlData.VrmlData_Coordinate_swigregister
VrmlData_Coordinate_swigregister(VrmlData_Coordinate)

class VrmlData_Cylinder(VrmlData_Geometry):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HasBottom(self, *args) -> "Standard_Boolean":
        """
        * /** * Query if the bottom circle is included */
        	:rtype: inline bool
        """
        return _VrmlData.VrmlData_Cylinder_HasBottom(self, *args)


    def HasSide(self, *args) -> "Standard_Boolean":
        """
        * /** * Query if the side surface is included */
        	:rtype: inline bool
        """
        return _VrmlData.VrmlData_Cylinder_HasSide(self, *args)


    def HasTop(self, *args) -> "Standard_Boolean":
        """
        * /** * Query if the top surface is included */
        	:rtype: inline bool
        """
        return _VrmlData.VrmlData_Cylinder_HasTop(self, *args)


    def Height(self, *args) -> "Standard_Real":
        """
        * /** * Query the Height */
        	:rtype: inline float
        """
        return _VrmlData.VrmlData_Cylinder_Height(self, *args)


    def Radius(self, *args) -> "Standard_Real":
        """
        * /** * Query the Radius */
        	:rtype: inline float
        """
        return _VrmlData.VrmlData_Cylinder_Radius(self, *args)


    def SetFaces(self, *args) -> "void":
        """
        * /** * Set which faces are included */
        	:param hasBottom:
        	:type hasBottom: bool
        	:param hasSide:
        	:type hasSide: bool
        	:param hasTop:
        	:type hasTop: bool
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Cylinder_SetFaces(self, *args)


    def SetHeight(self, *args) -> "void":
        """
        * /** * Set the Height */
        	:param theHeight:
        	:type theHeight: float
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Cylinder_SetHeight(self, *args)


    def SetRadius(self, *args) -> "void":
        """
        * /** * Set the Radius */
        	:param theRadius:
        	:type theRadius: float
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Cylinder_SetRadius(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param theRadius: default value is 1
        	:type theRadius: float
        	:param theHeight: default value is 2
        	:type theHeight: float
        	:rtype: None
        """
        _VrmlData.VrmlData_Cylinder_swiginit(self, _VrmlData.new_VrmlData_Cylinder(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Cylinder_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Cylinder
VrmlData_Cylinder.HasBottom = new_instancemethod(_VrmlData.VrmlData_Cylinder_HasBottom, None, VrmlData_Cylinder)
VrmlData_Cylinder.HasSide = new_instancemethod(_VrmlData.VrmlData_Cylinder_HasSide, None, VrmlData_Cylinder)
VrmlData_Cylinder.HasTop = new_instancemethod(_VrmlData.VrmlData_Cylinder_HasTop, None, VrmlData_Cylinder)
VrmlData_Cylinder.Height = new_instancemethod(_VrmlData.VrmlData_Cylinder_Height, None, VrmlData_Cylinder)
VrmlData_Cylinder.Radius = new_instancemethod(_VrmlData.VrmlData_Cylinder_Radius, None, VrmlData_Cylinder)
VrmlData_Cylinder.SetFaces = new_instancemethod(_VrmlData.VrmlData_Cylinder_SetFaces, None, VrmlData_Cylinder)
VrmlData_Cylinder.SetHeight = new_instancemethod(_VrmlData.VrmlData_Cylinder_SetHeight, None, VrmlData_Cylinder)
VrmlData_Cylinder.SetRadius = new_instancemethod(_VrmlData.VrmlData_Cylinder_SetRadius, None, VrmlData_Cylinder)
VrmlData_Cylinder_swigregister = _VrmlData.VrmlData_Cylinder_swigregister
VrmlData_Cylinder_swigregister(VrmlData_Cylinder)

class VrmlData_ImageTexture(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Clone(self, *args) -> "opencascade::handle< VrmlData_Node >":
        """
        * /** * Create a copy of this node. * If the parameter is null, a new copied node is created. Otherwise new node * is not created, but rather the given one is modified. */
        	:param theOther:
        	:type theOther: VrmlData_Node
        	:rtype: opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_ImageTexture_Clone(self, *args)


    def Read(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read the Node from input stream. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_ImageTexture_Read(self, *args)


    def URL(self, *args) -> "NCollection_List< TCollection_AsciiString > const &":
        """
        * /** * Query the associated URL. */
        	:rtype: inline  NCollection_List<TCollection_AsciiString>
        """
        return _VrmlData.VrmlData_ImageTexture_URL(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param theURL: default value is 0L
        	:type theURL: char *
        	:param theRepS: default value is Standard_False
        	:type theRepS: bool
        	:param theRepT: default value is Standard_False
        	:type theRepT: bool
        	:rtype: None
        """
        _VrmlData.VrmlData_ImageTexture_swiginit(self, _VrmlData.new_VrmlData_ImageTexture(*args))

    def Write(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write the Node to output stream. */
        	:param thePrefix:
        	:type thePrefix: char *
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_ImageTexture_Write(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_ImageTexture_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_ImageTexture
VrmlData_ImageTexture.Clone = new_instancemethod(_VrmlData.VrmlData_ImageTexture_Clone, None, VrmlData_ImageTexture)
VrmlData_ImageTexture.Read = new_instancemethod(_VrmlData.VrmlData_ImageTexture_Read, None, VrmlData_ImageTexture)
VrmlData_ImageTexture.URL = new_instancemethod(_VrmlData.VrmlData_ImageTexture_URL, None, VrmlData_ImageTexture)
VrmlData_ImageTexture.Write = new_instancemethod(_VrmlData.VrmlData_ImageTexture_Write, None, VrmlData_ImageTexture)
VrmlData_ImageTexture_swigregister = _VrmlData.VrmlData_ImageTexture_swigregister
VrmlData_ImageTexture_swigregister(VrmlData_ImageTexture)

class VrmlData_IndexedLineSet(VrmlData_Geometry):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ArrayColorInd(self, *args) -> "size_t":
        """
        * /** * Query the array of color indice * @param arrColorInd * <tt>[out]</tt> array of colorIndex as it is described in VRML2.0 spec * returns * Number of integers in the array arrColorInd. */
        	:param arrColorInd:
        	:type arrColorInd: int * *
        	:rtype: inline size_t
        """
        return _VrmlData.VrmlData_IndexedLineSet_ArrayColorInd(self, *args)


    def Colors(self, *args) -> "opencascade::handle< VrmlData_Color > const &":
        """
        * /** * Query the Colors. */
        	:rtype: inline  opencascade::handle<VrmlData_Color>
        """
        return _VrmlData.VrmlData_IndexedLineSet_Colors(self, *args)


    def Coordinates(self, *args) -> "opencascade::handle< VrmlData_Coordinate > const &":
        """
        * /** * Query the Coordinates. */
        	:rtype: inline  opencascade::handle<VrmlData_Coordinate>
        """
        return _VrmlData.VrmlData_IndexedLineSet_Coordinates(self, *args)


    def GetColor(self, *args) -> "Quantity_Color":
        """
        * /** * Query a color for one node in the given element. The color is * interpreted according to fields myColors, myArrColorInd, * myColorPerVertex, as defined in VRML 2.0. * @param iFace * rank of the polygon [0 .. N-1] * @param iVertex * rank of the vertex in the polygon [0 .. M-1]. This parameter is ignored * if (myColorPerVertex == False) * returns * Color value (RGB); if the color is indefinite then returns (0., 0., 0.) */
        	:param iFace:
        	:type iFace: int
        	:param iVertex:
        	:type iVertex: int
        	:rtype: Quantity_Color
        """
        return _VrmlData.VrmlData_IndexedLineSet_GetColor(self, *args)


    def Polygon(self, *args) -> "Standard_Integer":
        """
        * /** * Query one polygon. * @param iPolygon * rank of the polygon [0 .. N-1] * @param outIndice * <tt>[out]</tt> array of vertex indice * returns * number of vertice in the polygon - the dimension of outIndice array */
        	:param iPolygon:
        	:type iPolygon: int
        	:param outIndice:
        	:type outIndice: int *
        	:rtype: inline int
        """
        return _VrmlData.VrmlData_IndexedLineSet_Polygon(self, *args)


    def Polygons(self, *args) -> "size_t":
        """
        * /** * Query the array of polygons */
        	:param arrPolygons:
        	:type arrPolygons: int * *
        	:rtype: inline size_t
        """
        return _VrmlData.VrmlData_IndexedLineSet_Polygons(self, *args)


    def SetColorInd(self, *args) -> "void":
        """
        * /** * Set the colors array of indice */
        	:param nIndice:
        	:type nIndice: Standard_Size
        	:param theIndice:
        	:type theIndice: int * *
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedLineSet_SetColorInd(self, *args)


    def SetColorPerVertex(self, *args) -> "void":
        """
        * /** * Set the boolean value 'colorPerVertex' */
        	:param isColorPerVertex:
        	:type isColorPerVertex: bool
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedLineSet_SetColorPerVertex(self, *args)


    def SetColors(self, *args) -> "void":
        """
        * /** * Set the Color node */
        	:param theColors:
        	:type theColors: VrmlData_Color
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedLineSet_SetColors(self, *args)


    def SetCoordinates(self, *args) -> "void":
        """
        * /** * Set the nodes */
        	:param theCoord:
        	:type theCoord: VrmlData_Coordinate
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedLineSet_SetCoordinates(self, *args)


    def SetPolygons(self, *args) -> "void":
        """
        * /** * Set the polygons */
        	:param nPolygons:
        	:type nPolygons: Standard_Size
        	:param thePolygons:
        	:type thePolygons: int * *
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedLineSet_SetPolygons(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor. */
        	:rtype: None
        * /** * Constructor. */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param isColorPerVertex: default value is Standard_True
        	:type isColorPerVertex: bool
        	:rtype: None
        """
        _VrmlData.VrmlData_IndexedLineSet_swiginit(self, _VrmlData.new_VrmlData_IndexedLineSet(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_IndexedLineSet_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_IndexedLineSet
VrmlData_IndexedLineSet.ArrayColorInd = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_ArrayColorInd, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.Colors = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_Colors, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.Coordinates = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_Coordinates, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.GetColor = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_GetColor, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.Polygon = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_Polygon, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.Polygons = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_Polygons, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.SetColorInd = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_SetColorInd, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.SetColorPerVertex = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_SetColorPerVertex, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.SetColors = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_SetColors, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.SetCoordinates = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_SetCoordinates, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet.SetPolygons = new_instancemethod(_VrmlData.VrmlData_IndexedLineSet_SetPolygons, None, VrmlData_IndexedLineSet)
VrmlData_IndexedLineSet_swigregister = _VrmlData.VrmlData_IndexedLineSet_swigregister
VrmlData_IndexedLineSet_swigregister(VrmlData_IndexedLineSet)

class VrmlData_Normal(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Clone(self, *args) -> "opencascade::handle< VrmlData_Node >":
        """
        * /** * Create a copy of this node. * If the parameter is null, a new copied node is created. Otherwise new node * is not created, but rather the given one is modified. */
        	:param theOther:
        	:type theOther: VrmlData_Node
        	:rtype: opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_Normal_Clone(self, *args)


    def Normal(self, *args) -> "gp_XYZ const":
        """
        * /** * Query one normal * @param i * index in the array of normals [0 .. N-1] * returns * the normal value for the index. If index irrelevant, returns (0., 0., 0.) */
        	:param i:
        	:type i: int
        	:rtype: inline  gp_XYZ
        """
        return _VrmlData.VrmlData_Normal_Normal(self, *args)


    def Read(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read the Node from input stream. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Normal_Read(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param nVec: default value is 0
        	:type nVec: size_t
        	:param arrVec: default value is 0L
        	:type arrVec: gp_XYZ *
        	:rtype: None
        """
        _VrmlData.VrmlData_Normal_swiginit(self, _VrmlData.new_VrmlData_Normal(*args))

    def Write(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write the Node to the Scene output. */
        	:param thePrefix:
        	:type thePrefix: char *
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_Normal_Write(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Normal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Normal
VrmlData_Normal.Clone = new_instancemethod(_VrmlData.VrmlData_Normal_Clone, None, VrmlData_Normal)
VrmlData_Normal.Normal = new_instancemethod(_VrmlData.VrmlData_Normal_Normal, None, VrmlData_Normal)
VrmlData_Normal.Read = new_instancemethod(_VrmlData.VrmlData_Normal_Read, None, VrmlData_Normal)
VrmlData_Normal.Write = new_instancemethod(_VrmlData.VrmlData_Normal_Write, None, VrmlData_Normal)
VrmlData_Normal_swigregister = _VrmlData.VrmlData_Normal_swigregister
VrmlData_Normal_swigregister(VrmlData_Normal)

class VrmlData_Sphere(VrmlData_Geometry):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Radius(self, *args) -> "Standard_Real":
        """
        * /** * Query the sphere radius */
        	:rtype: inline float
        """
        return _VrmlData.VrmlData_Sphere_Radius(self, *args)


    def SetRadius(self, *args) -> "void":
        """
        * /** * Set the spere radius */
        	:param theRadius:
        	:type theRadius: float
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_Sphere_SetRadius(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param theRadius: default value is 1
        	:type theRadius: float
        	:rtype: None
        """
        _VrmlData.VrmlData_Sphere_swiginit(self, _VrmlData.new_VrmlData_Sphere(*args))


    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_Sphere_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_Sphere
VrmlData_Sphere.Radius = new_instancemethod(_VrmlData.VrmlData_Sphere_Radius, None, VrmlData_Sphere)
VrmlData_Sphere.SetRadius = new_instancemethod(_VrmlData.VrmlData_Sphere_SetRadius, None, VrmlData_Sphere)
VrmlData_Sphere_swigregister = _VrmlData.VrmlData_Sphere_swigregister
VrmlData_Sphere_swigregister(VrmlData_Sphere)

class VrmlData_IndexedFaceSet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ArrayColorInd(self, *args) -> "size_t":
        """
        * /** * Query the array of color indice * @param arrColorInd * <tt>[out]</tt> array of colorIndex as it is described in VRML2.0 spec * returns * Number of integers in the array arrColorInd. */
        	:param arrColorInd:
        	:type arrColorInd: int * *
        	:rtype: inline size_t
        """
        return _VrmlData.VrmlData_IndexedFaceSet_ArrayColorInd(self, *args)


    def ArrayNormalInd(self, *args) -> "size_t":
        """
        * /** * Query the array of normal indice * @param arrNormalInd * <tt>[out]</tt> array of normalIndex as it is described in VRML2.0 spec * returns * Number of integers in the array arrNormalInd. */
        	:param arrNormalInd:
        	:type arrNormalInd: int * *
        	:rtype: inline size_t
        """
        return _VrmlData.VrmlData_IndexedFaceSet_ArrayNormalInd(self, *args)


    def ArrayTextureCoordInd(self, *args) -> "size_t":
        """
        * /** * Query the array of texture coordinate indice * @param arrTextureCoordInd * <tt>[out]</tt> array of texCoordIndex as it is described in VRML2.0 spec * returns * Number of integers in the array texCoordIndex. */
        	:param arrTextureCoordInd:
        	:type arrTextureCoordInd: int * *
        	:rtype: inline size_t
        """
        return _VrmlData.VrmlData_IndexedFaceSet_ArrayTextureCoordInd(self, *args)


    def Clone(self, *args) -> "opencascade::handle< VrmlData_Node >":
        """
        * /** * Create a copy of this node. * If the parameter is null, a new copied node is created. Otherwise new node * is not created, but rather the given one is modified. */
        	:param theOther:
        	:type theOther: VrmlData_Node
        	:rtype: opencascade::handle<VrmlData_Node>
        """
        return _VrmlData.VrmlData_IndexedFaceSet_Clone(self, *args)


    def Colors(self, *args) -> "opencascade::handle< VrmlData_Color > const &":
        """
        * /** * Query the Colors. */
        	:rtype: inline  opencascade::handle<VrmlData_Color>
        """
        return _VrmlData.VrmlData_IndexedFaceSet_Colors(self, *args)


    def Coordinates(self, *args) -> "opencascade::handle< VrmlData_Coordinate > const &":
        """
        * /** * Query the Coordinates. */
        	:rtype: inline  opencascade::handle<VrmlData_Coordinate>
        """
        return _VrmlData.VrmlData_IndexedFaceSet_Coordinates(self, *args)


    def GetColor(self, *args) -> "Quantity_Color":
        """
        * /** * Query a color for one node in the given element. The color is * interpreted according to fields myColors, myArrColorInd, * myColorPerVertex, as defined in VRML 2.0. * @param iFace * rank of the polygon [0 .. N-1] * @param iVertex * rank of the vertex in the polygon [0 .. M-1]. This parameter is ignored * if (myColorPerVertex == False) * returns * Color value (RGB); if the color is indefinite then returns (0., 0., 0.) */
        	:param iFace:
        	:type iFace: int
        	:param iVertex:
        	:type iVertex: int
        	:rtype: Quantity_Color
        """
        return _VrmlData.VrmlData_IndexedFaceSet_GetColor(self, *args)


    def IndiceNormals(self, *args) -> "Standard_Integer":
        """
        * /** * Query normals indice for one face. This method should be called after * checking myArrNormalInd != NULL, otherwise exception will be thrown. * @param iFace * rank of the face [0 .. N-1] * @param outIndice * <tt>[out]</tt> array of normals indice * returns * number of indice in the array - the dimension of outIndice array */
        	:param iFace:
        	:type iFace: int
        	:param outIndice:
        	:type outIndice: int *
        	:rtype: inline int
        """
        return _VrmlData.VrmlData_IndexedFaceSet_IndiceNormals(self, *args)


    def IsDefault(self, *args) -> "Standard_Boolean":
        """
        * /** * Returns True if the node is default, so that it should not be written. */
        	:rtype: bool
        """
        return _VrmlData.VrmlData_IndexedFaceSet_IsDefault(self, *args)


    def Normals(self, *args) -> "opencascade::handle< VrmlData_Normal > const &":
        """
        * /** * Query the Normals. */
        	:rtype: inline  opencascade::handle<VrmlData_Normal>
        """
        return _VrmlData.VrmlData_IndexedFaceSet_Normals(self, *args)


    def Polygon(self, *args) -> "Standard_Integer":
        """
        * /** * Query one polygon. * @param iFace * rank of the polygon [0 .. N-1] * @param outIndice * <tt>[out]</tt> array of vertex indice * returns * number of vertice in the polygon - the dimension of outIndice array */
        	:param iFace:
        	:type iFace: int
        	:param outIndice:
        	:type outIndice: int *
        	:rtype: inline int
        """
        return _VrmlData.VrmlData_IndexedFaceSet_Polygon(self, *args)


    def Polygons(self, *args) -> "size_t":
        """
        * /** * Query the array of polygons */
        	:param arrPolygons:
        	:type arrPolygons: int * *
        	:rtype: inline size_t
        """
        return _VrmlData.VrmlData_IndexedFaceSet_Polygons(self, *args)


    def Read(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Read the Node from input stream. */
        	:param theBuffer:
        	:type theBuffer: VrmlData_InBuffer
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_IndexedFaceSet_Read(self, *args)


    def SetColorInd(self, *args) -> "void":
        """
        * /** * Set the colors array of indice */
        	:param nIndice:
        	:type nIndice: Standard_Size
        	:param theIndice:
        	:type theIndice: int * *
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetColorInd(self, *args)


    def SetColorPerVertex(self, *args) -> "void":
        """
        * /** * Set the boolean value 'colorPerVertex' */
        	:param isColorPerVertex:
        	:type isColorPerVertex: bool
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetColorPerVertex(self, *args)


    def SetColors(self, *args) -> "void":
        """
        * /** * Set the Color node */
        	:param theColors:
        	:type theColors: VrmlData_Color
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetColors(self, *args)


    def SetCoordinates(self, *args) -> "void":
        """
        * /** * Set the nodes */
        	:param theCoord:
        	:type theCoord: VrmlData_Coordinate
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetCoordinates(self, *args)


    def SetNormalInd(self, *args) -> "void":
        """
        * /** * Set the normals array of indice */
        	:param nIndice:
        	:type nIndice: Standard_Size
        	:param theIndice:
        	:type theIndice: int * *
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetNormalInd(self, *args)


    def SetNormalPerVertex(self, *args) -> "void":
        """
        * /** * Set the boolean value 'normalPerVertex' */
        	:param isNormalPerVertex:
        	:type isNormalPerVertex: bool
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetNormalPerVertex(self, *args)


    def SetNormals(self, *args) -> "void":
        """
        * /** * Set the normals node */
        	:param theNormals:
        	:type theNormals: VrmlData_Normal
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetNormals(self, *args)


    def SetPolygons(self, *args) -> "void":
        """
        * /** * Set the polygons */
        	:param nPolygons:
        	:type nPolygons: Standard_Size
        	:param thePolygons:
        	:type thePolygons: int * *
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetPolygons(self, *args)


    def SetTextureCoordInd(self, *args) -> "void":
        """
        * /** * Set the TexCoordiante array of indice */
        	:param nIndice:
        	:type nIndice: Standard_Size
        	:param theIndice:
        	:type theIndice: int * *
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetTextureCoordInd(self, *args)


    def SetTextureCoords(self, *args) -> "void":
        """
        * /** * Set the Texture Coordinate node */
        	:param tc:
        	:type tc: VrmlData_TextureCoordinate
        	:rtype: inline void
        """
        return _VrmlData.VrmlData_IndexedFaceSet_SetTextureCoords(self, *args)


    def TShape(self, *args) -> "opencascade::handle< TopoDS_TShape > const":
        """
        * /** * Query the shape. This method checks the flag myIsModified; if True it * should rebuild the shape presentation. */
        	:rtype: opencascade::handle<TopoDS_TShape>
        """
        return _VrmlData.VrmlData_IndexedFaceSet_TShape(self, *args)


    def TextureCoords(self, *args) -> "opencascade::handle< VrmlData_TextureCoordinate > const &":
        """
        * /** * Query the Texture Coordinates. */
        	:rtype: inline  opencascade::handle<VrmlData_TextureCoordinate>
        """
        return _VrmlData.VrmlData_IndexedFaceSet_TextureCoords(self, *args)


    def __init__(self, *args):
        """
        * /** * Empty constructor */
        	:rtype: None
        * /** * Constructor */
        	:param theScene:
        	:type theScene: VrmlData_Scene
        	:param theName:
        	:type theName: char *
        	:param isCCW: default value is Standard_True
        	:type isCCW: bool
        	:param isSolid: default value is Standard_True
        	:type isSolid: bool
        	:param isConvex: default value is Standard_True
        	:type isConvex: bool
        	:param theCreaseAngle: default value is 0
        	:type theCreaseAngle: float
        	:rtype: None
        """
        _VrmlData.VrmlData_IndexedFaceSet_swiginit(self, _VrmlData.new_VrmlData_IndexedFaceSet(*args))

    def Write(self, *args) -> "VrmlData_ErrorStatus":
        """
        * /** * Write the Node to output stream. */
        	:param thePrefix:
        	:type thePrefix: char *
        	:rtype: VrmlData_ErrorStatus
        """
        return _VrmlData.VrmlData_IndexedFaceSet_Write(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_VrmlData_IndexedFaceSet_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _VrmlData.delete_VrmlData_IndexedFaceSet
VrmlData_IndexedFaceSet.ArrayColorInd = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_ArrayColorInd, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.ArrayNormalInd = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_ArrayNormalInd, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.ArrayTextureCoordInd = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_ArrayTextureCoordInd, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.Clone = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_Clone, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.Colors = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_Colors, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.Coordinates = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_Coordinates, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.GetColor = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_GetColor, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.IndiceNormals = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_IndiceNormals, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.IsDefault = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_IsDefault, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.Normals = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_Normals, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.Polygon = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_Polygon, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.Polygons = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_Polygons, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.Read = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_Read, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetColorInd = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetColorInd, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetColorPerVertex = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetColorPerVertex, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetColors = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetColors, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetCoordinates = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetCoordinates, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetNormalInd = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetNormalInd, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetNormalPerVertex = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetNormalPerVertex, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetNormals = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetNormals, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetPolygons = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetPolygons, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetTextureCoordInd = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetTextureCoordInd, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.SetTextureCoords = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_SetTextureCoords, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.TShape = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_TShape, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.TextureCoords = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_TextureCoords, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet.Write = new_instancemethod(_VrmlData.VrmlData_IndexedFaceSet_Write, None, VrmlData_IndexedFaceSet)
VrmlData_IndexedFaceSet_swigregister = _VrmlData.VrmlData_IndexedFaceSet_swigregister
VrmlData_IndexedFaceSet_swigregister(VrmlData_IndexedFaceSet)



