# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
gp module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_gp.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _gp.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_gp')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_gp')
    _gp = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gp', [dirname(__file__)])
        except ImportError:
            import _gp
            return _gp
        try:
            _mod = imp.load_module('_gp', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _gp = swig_import_helper()
    del swig_import_helper
else:
    import _gp
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gp.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_gp.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_gp.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_gp.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_gp.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_gp.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_gp.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_gp.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_gp.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_gp.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_gp.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_gp.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_gp.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_gp.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_gp.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_gp.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_gp.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _gp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _gp.process_exception(error, method_name, class_name)
process_exception = _gp.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
gp_Identity = _gp.gp_Identity
gp_Rotation = _gp.gp_Rotation
gp_Translation = _gp.gp_Translation
gp_PntMirror = _gp.gp_PntMirror
gp_Ax1Mirror = _gp.gp_Ax1Mirror
gp_Ax2Mirror = _gp.gp_Ax2Mirror
gp_Scale = _gp.gp_Scale
gp_CompoundTrsf = _gp.gp_CompoundTrsf
gp_Other = _gp.gp_Other
gp_EulerAngles = _gp.gp_EulerAngles
gp_YawPitchRoll = _gp.gp_YawPitchRoll
gp_Extrinsic_XYZ = _gp.gp_Extrinsic_XYZ
gp_Extrinsic_XZY = _gp.gp_Extrinsic_XZY
gp_Extrinsic_YZX = _gp.gp_Extrinsic_YZX
gp_Extrinsic_YXZ = _gp.gp_Extrinsic_YXZ
gp_Extrinsic_ZXY = _gp.gp_Extrinsic_ZXY
gp_Extrinsic_ZYX = _gp.gp_Extrinsic_ZYX
gp_Intrinsic_XYZ = _gp.gp_Intrinsic_XYZ
gp_Intrinsic_XZY = _gp.gp_Intrinsic_XZY
gp_Intrinsic_YZX = _gp.gp_Intrinsic_YZX
gp_Intrinsic_YXZ = _gp.gp_Intrinsic_YXZ
gp_Intrinsic_ZXY = _gp.gp_Intrinsic_ZXY
gp_Intrinsic_ZYX = _gp.gp_Intrinsic_ZYX
gp_Extrinsic_XYX = _gp.gp_Extrinsic_XYX
gp_Extrinsic_XZX = _gp.gp_Extrinsic_XZX
gp_Extrinsic_YZY = _gp.gp_Extrinsic_YZY
gp_Extrinsic_YXY = _gp.gp_Extrinsic_YXY
gp_Extrinsic_ZYZ = _gp.gp_Extrinsic_ZYZ
gp_Extrinsic_ZXZ = _gp.gp_Extrinsic_ZXZ
gp_Intrinsic_XYX = _gp.gp_Intrinsic_XYX
gp_Intrinsic_XZX = _gp.gp_Intrinsic_XZX
gp_Intrinsic_YZY = _gp.gp_Intrinsic_YZY
gp_Intrinsic_YXY = _gp.gp_Intrinsic_YXY
gp_Intrinsic_ZXZ = _gp.gp_Intrinsic_ZXZ
gp_Intrinsic_ZYZ = _gp.gp_Intrinsic_ZYZ
class gp(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DX(*args) -> "gp_Dir const":
        """
        * Returns a unit vector with the combination (1,0,0)
        	:rtype: gp_Dir
        """
        return _gp.gp_DX(*args)

    DX = staticmethod(DX)

    def DX2d(*args) -> "gp_Dir2d const":
        """
        * Returns a unit vector with the combinations (1,0)
        	:rtype: gp_Dir2d
        """
        return _gp.gp_DX2d(*args)

    DX2d = staticmethod(DX2d)

    def DY(*args) -> "gp_Dir const":
        """
        * Returns a unit vector with the combination (0,1,0)
        	:rtype: gp_Dir
        """
        return _gp.gp_DY(*args)

    DY = staticmethod(DY)

    def DY2d(*args) -> "gp_Dir2d const":
        """
        * Returns a unit vector with the combinations (0,1)
        	:rtype: gp_Dir2d
        """
        return _gp.gp_DY2d(*args)

    DY2d = staticmethod(DY2d)

    def DZ(*args) -> "gp_Dir const":
        """
        * Returns a unit vector with the combination (0,0,1)
        	:rtype: gp_Dir
        """
        return _gp.gp_DZ(*args)

    DZ = staticmethod(DZ)

    def OX(*args) -> "gp_Ax1 const":
        """
        * Identifies an axis where its origin is Origin and its unit vector coordinates X = 1.0, Y = Z = 0.0
        	:rtype: gp_Ax1
        """
        return _gp.gp_OX(*args)

    OX = staticmethod(OX)

    def OX2d(*args) -> "gp_Ax2d const":
        """
        * Identifies an axis where its origin is Origin2d and its unit vector coordinates are: X = 1.0, Y = 0.0
        	:rtype: gp_Ax2d
        """
        return _gp.gp_OX2d(*args)

    OX2d = staticmethod(OX2d)

    def OY(*args) -> "gp_Ax1 const":
        """
        * Identifies an axis where its origin is Origin and its unit vector coordinates Y = 1.0, X = Z = 0.0
        	:rtype: gp_Ax1
        """
        return _gp.gp_OY(*args)

    OY = staticmethod(OY)

    def OY2d(*args) -> "gp_Ax2d const":
        """
        * Identifies an axis where its origin is Origin2d and its unit vector coordinates are Y = 1.0, X = 0.0
        	:rtype: gp_Ax2d
        """
        return _gp.gp_OY2d(*args)

    OY2d = staticmethod(OY2d)

    def OZ(*args) -> "gp_Ax1 const":
        """
        * Identifies an axis where its origin is Origin and its unit vector coordinates Z = 1.0, Y = X = 0.0
        	:rtype: gp_Ax1
        """
        return _gp.gp_OZ(*args)

    OZ = staticmethod(OZ)

    def Origin(*args) -> "gp_Pnt const":
        """
        * Identifies a Cartesian point with coordinates X = Y = Z = 0.0.0
        	:rtype: gp_Pnt
        """
        return _gp.gp_Origin(*args)

    Origin = staticmethod(Origin)

    def Origin2d(*args) -> "gp_Pnt2d const":
        """
        * Identifies a Cartesian point with coordinates X = Y = 0.0
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Origin2d(*args)

    Origin2d = staticmethod(Origin2d)

    def Resolution(*args) -> "Standard_Real":
        """
        * Method of package gp //! In geometric computations, defines the tolerance criterion used to determine when two numbers can be considered equal. Many class functions use this tolerance criterion, for example, to avoid division by zero in geometric computations. In the documentation, tolerance criterion is always referred to as gp::Resolution().
        	:rtype: float
        """
        return _gp.gp_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def XOY(*args) -> "gp_Ax2 const":
        """
        * Identifies a coordinate system where its origin is Origin, and its 'main Direction' and 'X Direction' coordinates Z = 1.0, X = Y =0.0 and X direction coordinates X = 1.0, Y = Z = 0.0
        	:rtype: gp_Ax2
        """
        return _gp.gp_XOY(*args)

    XOY = staticmethod(XOY)

    def YOZ(*args) -> "gp_Ax2 const":
        """
        * Identifies a coordinate system where its origin is Origin, and its 'main Direction' and 'X Direction' coordinates X = 1.0, Z = Y =0.0 and X direction coordinates Y = 1.0, X = Z = 0.0 In 2D space
        	:rtype: gp_Ax2
        """
        return _gp.gp_YOZ(*args)

    YOZ = staticmethod(YOZ)

    def ZOX(*args) -> "gp_Ax2 const":
        """
        * Identifies a coordinate system where its origin is Origin, and its 'main Direction' and 'X Direction' coordinates Y = 1.0, X = Z =0.0 and X direction coordinates Z = 1.0, X = Y = 0.0
        	:rtype: gp_Ax2
        """
        return _gp.gp_ZOX(*args)

    ZOX = staticmethod(ZOX)

    __repr__ = _dumps_object


    def __init__(self):
        _gp.gp_swiginit(self, _gp.new_gp())
    __swig_destroy__ = _gp.delete_gp
gp_swigregister = _gp.gp_swigregister
gp_swigregister(gp)

def gp_DX(*args) -> "gp_Dir const":
    """
    * Returns a unit vector with the combination (1,0,0)
    	:rtype: gp_Dir
    """
    return _gp.gp_DX(*args)

def gp_DX2d(*args) -> "gp_Dir2d const":
    """
    * Returns a unit vector with the combinations (1,0)
    	:rtype: gp_Dir2d
    """
    return _gp.gp_DX2d(*args)

def gp_DY(*args) -> "gp_Dir const":
    """
    * Returns a unit vector with the combination (0,1,0)
    	:rtype: gp_Dir
    """
    return _gp.gp_DY(*args)

def gp_DY2d(*args) -> "gp_Dir2d const":
    """
    * Returns a unit vector with the combinations (0,1)
    	:rtype: gp_Dir2d
    """
    return _gp.gp_DY2d(*args)

def gp_DZ(*args) -> "gp_Dir const":
    """
    * Returns a unit vector with the combination (0,0,1)
    	:rtype: gp_Dir
    """
    return _gp.gp_DZ(*args)

def gp_OX(*args) -> "gp_Ax1 const":
    """
    * Identifies an axis where its origin is Origin and its unit vector coordinates X = 1.0, Y = Z = 0.0
    	:rtype: gp_Ax1
    """
    return _gp.gp_OX(*args)

def gp_OX2d(*args) -> "gp_Ax2d const":
    """
    * Identifies an axis where its origin is Origin2d and its unit vector coordinates are: X = 1.0, Y = 0.0
    	:rtype: gp_Ax2d
    """
    return _gp.gp_OX2d(*args)

def gp_OY(*args) -> "gp_Ax1 const":
    """
    * Identifies an axis where its origin is Origin and its unit vector coordinates Y = 1.0, X = Z = 0.0
    	:rtype: gp_Ax1
    """
    return _gp.gp_OY(*args)

def gp_OY2d(*args) -> "gp_Ax2d const":
    """
    * Identifies an axis where its origin is Origin2d and its unit vector coordinates are Y = 1.0, X = 0.0
    	:rtype: gp_Ax2d
    """
    return _gp.gp_OY2d(*args)

def gp_OZ(*args) -> "gp_Ax1 const":
    """
    * Identifies an axis where its origin is Origin and its unit vector coordinates Z = 1.0, Y = X = 0.0
    	:rtype: gp_Ax1
    """
    return _gp.gp_OZ(*args)

def gp_Origin(*args) -> "gp_Pnt const":
    """
    * Identifies a Cartesian point with coordinates X = Y = Z = 0.0.0
    	:rtype: gp_Pnt
    """
    return _gp.gp_Origin(*args)

def gp_Origin2d(*args) -> "gp_Pnt2d const":
    """
    * Identifies a Cartesian point with coordinates X = Y = 0.0
    	:rtype: gp_Pnt2d
    """
    return _gp.gp_Origin2d(*args)

def gp_Resolution(*args) -> "Standard_Real":
    """
    * Method of package gp //! In geometric computations, defines the tolerance criterion used to determine when two numbers can be considered equal. Many class functions use this tolerance criterion, for example, to avoid division by zero in geometric computations. In the documentation, tolerance criterion is always referred to as gp::Resolution().
    	:rtype: float
    """
    return _gp.gp_Resolution(*args)

def gp_XOY(*args) -> "gp_Ax2 const":
    """
    * Identifies a coordinate system where its origin is Origin, and its 'main Direction' and 'X Direction' coordinates Z = 1.0, X = Y =0.0 and X direction coordinates X = 1.0, Y = Z = 0.0
    	:rtype: gp_Ax2
    """
    return _gp.gp_XOY(*args)

def gp_YOZ(*args) -> "gp_Ax2 const":
    """
    * Identifies a coordinate system where its origin is Origin, and its 'main Direction' and 'X Direction' coordinates X = 1.0, Z = Y =0.0 and X direction coordinates Y = 1.0, X = Z = 0.0 In 2D space
    	:rtype: gp_Ax2
    """
    return _gp.gp_YOZ(*args)

def gp_ZOX(*args) -> "gp_Ax2 const":
    """
    * Identifies a coordinate system where its origin is Origin, and its 'main Direction' and 'X Direction' coordinates Y = 1.0, X = Z =0.0 and X direction coordinates Z = 1.0, X = Y = 0.0
    	:rtype: gp_Ax2
    """
    return _gp.gp_ZOX(*args)

class gp_Ax1(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angular value, in radians, between <self>.Direction() and <Other>.Direction(). Returns the angle between 0 and 2*PI radians.
        	:param Other:
        	:type Other: gp_Ax1
        	:rtype: float
        """
        return _gp.gp_Ax1_Angle(self, *args)


    def Direction(self, *args) -> "gp_Dir const":
        """
        * Returns the direction of <self>.
        	:rtype: gp_Dir
        """
        return _gp.gp_Ax1_Direction(self, *args)


    def IsCoaxial(self, *args) -> "Standard_Boolean":
        """
        * Returns True if : . the angle between <self> and <Other> is lower or equal to <AngularTolerance> and . the distance between <self>.Location() and <Other> is lower or equal to <LinearTolerance> and . the distance between <Other>.Location() and <self> is lower or equal to LinearTolerance.
        	:param Other:
        	:type Other: gp_Ax1
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax1_IsCoaxial(self, *args)


    def IsNormal(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the direction of the <self> and <Other> are normal to each other. That is, if the angle between the two axes is equal to Pi/2. Note: the tolerance criterion is given by AngularTolerance..
        	:param Other:
        	:type Other: gp_Ax1
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax1_IsNormal(self, *args)


    def IsOpposite(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the direction of <self> and <Other> are parallel with opposite orientation. That is, if the angle between the two axes is equal to Pi. Note: the tolerance criterion is given by AngularTolerance.
        	:param Other:
        	:type Other: gp_Ax1
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax1_IsOpposite(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the direction of <self> and <Other> are parallel with same orientation or opposite orientation. That is, if the angle between the two axes is equal to 0 or Pi. Note: the tolerance criterion is given by AngularTolerance.
        	:param Other:
        	:type Other: gp_Ax1
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax1_IsParallel(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the location point of <self>.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Ax1_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        * Performs the symmetrical transformation of an axis placement with respect to the point P which is the center of the symmetry and assigns the result to this axis.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        * Performs the symmetrical transformation of an axis placement with respect to an axis placement which is the axis of the symmetry and assigns the result to this axis.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        * Performs the symmetrical transformation of an axis placement with respect to a plane. The axis placement <A2> locates the plane of the symmetry : (Location, XDirection, YDirection) and assigns the result to this axis.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Ax1_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Ax1":
        """
        * Performs the symmetrical transformation of an axis placement with respect to the point P which is the center of the symmetry and creates a new axis.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Ax1
        * Performs the symmetrical transformation of an axis placement with respect to an axis placement which is the axis of the symmetry and creates a new axis.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Ax1
        * Performs the symmetrical transformation of an axis placement with respect to a plane. The axis placement <A2> locates the plane of the symmetry : (Location, XDirection, YDirection) and creates a new axis.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Ax1
        """
        return _gp.gp_Ax1_Mirrored(self, *args)


    def Reverse(self, *args) -> "void":
        """
        * Reverses the unit vector of this axis. and assigns the result to this axis.
        	:rtype: None
        """
        return _gp.gp_Ax1_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Ax1":
        """
        * Reverses the unit vector of this axis and creates a new one.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Ax1_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        * Rotates this axis at an angle Ang (in radians) about the axis A1 and assigns the result to this axis.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Ax1_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Ax1":
        """
        * Rotates this axis at an angle Ang (in radians) about the axis A1 and creates a new one.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Ax1
        """
        return _gp.gp_Ax1_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        * Applies a scaling transformation to this axis with: - scale factor S, and - center P and assigns the result to this axis.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Ax1_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Ax1":
        """
        * Applies a scaling transformation to this axis with: - scale factor S, and - center P and creates a new axis.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Ax1
        """
        return _gp.gp_Ax1_Scaled(self, *args)


    def SetDirection(self, *args) -> "void":
        """
        * Assigns V as the 'Direction' of this axis.
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Ax1_SetDirection(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Assigns P as the origin of this axis.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Ax1_SetLocation(self, *args)


    def Transform(self, *args) -> "void":
        """
        * Applies the transformation T to this axis. and assigns the result to this axis.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Ax1_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Ax1":
        """
        * Applies the transformation T to this axis and creates a new one. //! Translates an axis plaxement in the direction of the vector <V>. The magnitude of the translation is the vector's magnitude.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Ax1
        """
        return _gp.gp_Ax1_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        * Translates this axis by the vector V, and assigns the result to this axis.
        	:param V:
        	:type V: gp_Vec
        	:rtype: None
        * Translates this axis by: the vector (P1, P2) defined from point P1 to point P2. and assigns the result to this axis.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Ax1_Translate(self, *args)


    def Translated(self, *args) -> "gp_Ax1":
        """
        * Translates this axis by the vector V, and creates a new one.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Ax1
        * Translates this axis by: the vector (P1, P2) defined from point P1 to point P2. and creates a new one.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Ax1
        """
        return _gp.gp_Ax1_Translated(self, *args)


    def __init__(self, *args):
        """
        * Creates an axis object representing Z axis of the reference co-ordinate system.
        	:rtype: None
        * P is the location point and V is the direction of <self>.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _gp.gp_Ax1_swiginit(self, _gp.new_gp_Ax1(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax1
gp_Ax1.Angle = new_instancemethod(_gp.gp_Ax1_Angle, None, gp_Ax1)
gp_Ax1.Direction = new_instancemethod(_gp.gp_Ax1_Direction, None, gp_Ax1)
gp_Ax1.IsCoaxial = new_instancemethod(_gp.gp_Ax1_IsCoaxial, None, gp_Ax1)
gp_Ax1.IsNormal = new_instancemethod(_gp.gp_Ax1_IsNormal, None, gp_Ax1)
gp_Ax1.IsOpposite = new_instancemethod(_gp.gp_Ax1_IsOpposite, None, gp_Ax1)
gp_Ax1.IsParallel = new_instancemethod(_gp.gp_Ax1_IsParallel, None, gp_Ax1)
gp_Ax1.Location = new_instancemethod(_gp.gp_Ax1_Location, None, gp_Ax1)
gp_Ax1.Mirror = new_instancemethod(_gp.gp_Ax1_Mirror, None, gp_Ax1)
gp_Ax1.Mirrored = new_instancemethod(_gp.gp_Ax1_Mirrored, None, gp_Ax1)
gp_Ax1.Reverse = new_instancemethod(_gp.gp_Ax1_Reverse, None, gp_Ax1)
gp_Ax1.Reversed = new_instancemethod(_gp.gp_Ax1_Reversed, None, gp_Ax1)
gp_Ax1.Rotate = new_instancemethod(_gp.gp_Ax1_Rotate, None, gp_Ax1)
gp_Ax1.Rotated = new_instancemethod(_gp.gp_Ax1_Rotated, None, gp_Ax1)
gp_Ax1.Scale = new_instancemethod(_gp.gp_Ax1_Scale, None, gp_Ax1)
gp_Ax1.Scaled = new_instancemethod(_gp.gp_Ax1_Scaled, None, gp_Ax1)
gp_Ax1.SetDirection = new_instancemethod(_gp.gp_Ax1_SetDirection, None, gp_Ax1)
gp_Ax1.SetLocation = new_instancemethod(_gp.gp_Ax1_SetLocation, None, gp_Ax1)
gp_Ax1.Transform = new_instancemethod(_gp.gp_Ax1_Transform, None, gp_Ax1)
gp_Ax1.Transformed = new_instancemethod(_gp.gp_Ax1_Transformed, None, gp_Ax1)
gp_Ax1.Translate = new_instancemethod(_gp.gp_Ax1_Translate, None, gp_Ax1)
gp_Ax1.Translated = new_instancemethod(_gp.gp_Ax1_Translated, None, gp_Ax1)
gp_Ax1_swigregister = _gp.gp_Ax1_swigregister
gp_Ax1_swigregister(gp_Ax1)

class gp_Ax2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angular value, in radians, between the main direction of <self> and the main direction of <Other>. Returns the angle between 0 and PI in radians.
        	:param Other:
        	:type Other: gp_Ax2
        	:rtype: float
        """
        return _gp.gp_Ax2_Angle(self, *args)


    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * Returns the main axis of <self>. It is the 'Location' point and the main 'Direction'.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Ax2_Axis(self, *args)


    def Direction(self, *args) -> "gp_Dir const":
        """
        * Returns the main direction of <self>.
        	:rtype: gp_Dir
        """
        return _gp.gp_Ax2_Direction(self, *args)


    def IsCoplanar(self, *args) -> "Standard_Boolean":
        """
        :param Other:
        	:type Other: gp_Ax2
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        * Returns True if . the distance between <self> and the 'Location' point of A1 is lower of equal to LinearTolerance and . the main direction of <self> and the direction of A1 are normal. Note: the tolerance criterion for angular equality is given by AngularTolerance.
        	:param A1:
        	:type A1: gp_Ax1
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax2_IsCoplanar(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the 'Location' point (origin) of <self>.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Ax2_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        * Performs a symmetrical transformation of this coordinate system with respect to: - the point P, and assigns the result to this coordinate system. Warning This transformation is always performed on the origin. In case of a reflection with respect to a point: - the main direction of the coordinate system is not changed, and - the 'X Direction' and the 'Y Direction' are simply reversed In case of a reflection with respect to an axis or a plane: - the transformation is applied to the 'X Direction' and the 'Y Direction', then - the 'main Direction' is recomputed as the cross product 'X Direction' ^ 'Y Direction'. This maintains the right-handed property of the coordinate system.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        * Performs a symmetrical transformation of this coordinate system with respect to: - the axis A1, and assigns the result to this coordinate systeme. Warning This transformation is always performed on the origin. In case of a reflection with respect to a point: - the main direction of the coordinate system is not changed, and - the 'X Direction' and the 'Y Direction' are simply reversed In case of a reflection with respect to an axis or a plane: - the transformation is applied to the 'X Direction' and the 'Y Direction', then - the 'main Direction' is recomputed as the cross product 'X Direction' ^ 'Y Direction'. This maintains the right-handed property of the coordinate system.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        * Performs a symmetrical transformation of this coordinate system with respect to: - the plane defined by the origin, 'X Direction' and 'Y Direction' of coordinate system A2 and assigns the result to this coordinate systeme. Warning This transformation is always performed on the origin. In case of a reflection with respect to a point: - the main direction of the coordinate system is not changed, and - the 'X Direction' and the 'Y Direction' are simply reversed In case of a reflection with respect to an axis or a plane: - the transformation is applied to the 'X Direction' and the 'Y Direction', then - the 'main Direction' is recomputed as the cross product 'X Direction' ^ 'Y Direction'. This maintains the right-handed property of the coordinate system.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Ax2_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Ax2":
        """
        * Performs a symmetrical transformation of this coordinate system with respect to: - the point P, and creates a new one. Warning This transformation is always performed on the origin. In case of a reflection with respect to a point: - the main direction of the coordinate system is not changed, and - the 'X Direction' and the 'Y Direction' are simply reversed In case of a reflection with respect to an axis or a plane: - the transformation is applied to the 'X Direction' and the 'Y Direction', then - the 'main Direction' is recomputed as the cross product 'X Direction' ^ 'Y Direction'. This maintains the right-handed property of the coordinate system.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Ax2
        * Performs a symmetrical transformation of this coordinate system with respect to: - the axis A1, and creates a new one. Warning This transformation is always performed on the origin. In case of a reflection with respect to a point: - the main direction of the coordinate system is not changed, and - the 'X Direction' and the 'Y Direction' are simply reversed In case of a reflection with respect to an axis or a plane: - the transformation is applied to the 'X Direction' and the 'Y Direction', then - the 'main Direction' is recomputed as the cross product 'X Direction' ^ 'Y Direction'. This maintains the right-handed property of the coordinate system.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Ax2
        * Performs a symmetrical transformation of this coordinate system with respect to: - the plane defined by the origin, 'X Direction' and 'Y Direction' of coordinate system A2 and creates a new one. Warning This transformation is always performed on the origin. In case of a reflection with respect to a point: - the main direction of the coordinate system is not changed, and - the 'X Direction' and the 'Y Direction' are simply reversed In case of a reflection with respect to an axis or a plane: - the transformation is applied to the 'X Direction' and the 'Y Direction', then - the 'main Direction' is recomputed as the cross product 'X Direction' ^ 'Y Direction'. This maintains the right-handed property of the coordinate system.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Ax2
        """
        return _gp.gp_Ax2_Mirrored(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Ax2_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Ax2":
        """
        * Rotates an axis placement. <A1> is the axis of the rotation . Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Ax2
        """
        return _gp.gp_Ax2_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Ax2_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Ax2":
        """
        * Applies a scaling transformation on the axis placement. The 'Location' point of the axisplacement is modified. Warnings : If the scale <S> is negative : . the main direction of the axis placement is not changed. . The 'XDirection' and the 'YDirection' are reversed. So the axis placement stay right handed.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Ax2
        """
        return _gp.gp_Ax2_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Assigns the origin and 'main Direction' of the axis A1 to this coordinate system, then recomputes its 'X Direction' and 'Y Direction'. Note: The new 'X Direction' is computed as follows: new 'X Direction' = V1 ^(previous 'X Direction' ^ V) where V is the 'Direction' of A1. Exceptions Standard_ConstructionError if A1 is parallel to the 'X Direction' of this coordinate system.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Ax2_SetAxis(self, *args)


    def SetDirection(self, *args) -> "void":
        """
        * Changes the 'main Direction' of this coordinate system, then recomputes its 'X Direction' and 'Y Direction'. Note: the new 'X Direction' is computed as follows: new 'X Direction' = V ^ (previous 'X Direction' ^ V) Exceptions Standard_ConstructionError if V is parallel to the 'X Direction' of this coordinate system.
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Ax2_SetDirection(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the 'Location' point (origin) of <self>.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Ax2_SetLocation(self, *args)


    def SetXDirection(self, *args) -> "void":
        """
        * Changes the 'Xdirection' of <self>. The main direction 'Direction' is not modified, the 'Ydirection' is modified. If <Vx> is not normal to the main direction then <XDirection> is computed as follows XDirection = Direction ^ (Vx ^ Direction). Exceptions Standard_ConstructionError if Vx or Vy is parallel to the 'main Direction' of this coordinate system.
        	:param Vx:
        	:type Vx: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Ax2_SetXDirection(self, *args)


    def SetYDirection(self, *args) -> "void":
        """
        * Changes the 'Ydirection' of <self>. The main direction is not modified but the 'Xdirection' is changed. If <Vy> is not normal to the main direction then 'YDirection' is computed as follows YDirection = Direction ^ (<Vy> ^ Direction). Exceptions Standard_ConstructionError if Vx or Vy is parallel to the 'main Direction' of this coordinate system.
        	:param Vy:
        	:type Vy: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Ax2_SetYDirection(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Ax2_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Ax2":
        """
        * Transforms an axis placement with a Trsf. The 'Location' point, the 'XDirection' and the 'YDirection' are transformed with T. The resulting main 'Direction' of <self> is the cross product between the 'XDirection' and the 'YDirection' after transformation.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Ax2
        """
        return _gp.gp_Ax2_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Ax2_Translate(self, *args)


    def Translated(self, *args) -> "gp_Ax2":
        """
        * Translates an axis plaxement in the direction of the vector <V>. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Ax2
        * Translates an axis placement from the point <P1> to the point <P2>.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Ax2
        """
        return _gp.gp_Ax2_Translated(self, *args)


    def XDirection(self, *args) -> "gp_Dir const":
        """
        * Returns the 'XDirection' of <self>.
        	:rtype: gp_Dir
        """
        return _gp.gp_Ax2_XDirection(self, *args)


    def YDirection(self, *args) -> "gp_Dir const":
        """
        * Returns the 'YDirection' of <self>.
        	:rtype: gp_Dir
        """
        return _gp.gp_Ax2_YDirection(self, *args)


    def __init__(self, *args):
        """
        * Creates an object corresponding to the reference coordinate system (OXYZ).
        	:rtype: None
        * Creates an axis placement with an origin P such that: - N is the Direction, and - the 'X Direction' is normal to N, in the plane defined by the vectors (N, Vx): 'X Direction' = (N ^ Vx) ^ N, Exception: raises ConstructionError if N and Vx are parallel (same or opposite orientation).
        	:param P:
        	:type P: gp_Pnt
        	:param N:
        	:type N: gp_Dir
        	:param Vx:
        	:type Vx: gp_Dir
        	:rtype: None
        * Creates - a coordinate system with an origin P, where V gives the 'main Direction' (here, 'X Direction' and 'Y Direction' are defined automatically).
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _gp.gp_Ax2_swiginit(self, _gp.new_gp_Ax2(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax2
gp_Ax2.Angle = new_instancemethod(_gp.gp_Ax2_Angle, None, gp_Ax2)
gp_Ax2.Axis = new_instancemethod(_gp.gp_Ax2_Axis, None, gp_Ax2)
gp_Ax2.Direction = new_instancemethod(_gp.gp_Ax2_Direction, None, gp_Ax2)
gp_Ax2.IsCoplanar = new_instancemethod(_gp.gp_Ax2_IsCoplanar, None, gp_Ax2)
gp_Ax2.Location = new_instancemethod(_gp.gp_Ax2_Location, None, gp_Ax2)
gp_Ax2.Mirror = new_instancemethod(_gp.gp_Ax2_Mirror, None, gp_Ax2)
gp_Ax2.Mirrored = new_instancemethod(_gp.gp_Ax2_Mirrored, None, gp_Ax2)
gp_Ax2.Rotate = new_instancemethod(_gp.gp_Ax2_Rotate, None, gp_Ax2)
gp_Ax2.Rotated = new_instancemethod(_gp.gp_Ax2_Rotated, None, gp_Ax2)
gp_Ax2.Scale = new_instancemethod(_gp.gp_Ax2_Scale, None, gp_Ax2)
gp_Ax2.Scaled = new_instancemethod(_gp.gp_Ax2_Scaled, None, gp_Ax2)
gp_Ax2.SetAxis = new_instancemethod(_gp.gp_Ax2_SetAxis, None, gp_Ax2)
gp_Ax2.SetDirection = new_instancemethod(_gp.gp_Ax2_SetDirection, None, gp_Ax2)
gp_Ax2.SetLocation = new_instancemethod(_gp.gp_Ax2_SetLocation, None, gp_Ax2)
gp_Ax2.SetXDirection = new_instancemethod(_gp.gp_Ax2_SetXDirection, None, gp_Ax2)
gp_Ax2.SetYDirection = new_instancemethod(_gp.gp_Ax2_SetYDirection, None, gp_Ax2)
gp_Ax2.Transform = new_instancemethod(_gp.gp_Ax2_Transform, None, gp_Ax2)
gp_Ax2.Transformed = new_instancemethod(_gp.gp_Ax2_Transformed, None, gp_Ax2)
gp_Ax2.Translate = new_instancemethod(_gp.gp_Ax2_Translate, None, gp_Ax2)
gp_Ax2.Translated = new_instancemethod(_gp.gp_Ax2_Translated, None, gp_Ax2)
gp_Ax2.XDirection = new_instancemethod(_gp.gp_Ax2_XDirection, None, gp_Ax2)
gp_Ax2.YDirection = new_instancemethod(_gp.gp_Ax2_YDirection, None, gp_Ax2)
gp_Ax2_swigregister = _gp.gp_Ax2_swigregister
gp_Ax2_swigregister(gp_Ax2)

class gp_Ax22d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Location(self, *args) -> "gp_Pnt2d const":
        """
        * Returns the 'Location' point (origin) of <self>.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Ax22d_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        :param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Ax22d_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Ax22d":
        """
        * Performs the symmetrical transformation of an axis placement with respect to the point P which is the center of the symmetry. Warnings : The main direction of the axis placement is not changed. The 'XDirection' and the 'YDirection' are reversed. So the axis placement stay right handed.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Ax22d
        * Performs the symmetrical transformation of an axis placement with respect to an axis placement which is the axis of the symmetry. The transformation is performed on the 'Location' point, on the 'XDirection' and 'YDirection'. The resulting main 'Direction' is the cross product between the 'XDirection' and the 'YDirection' after transformation.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Ax22d_Mirrored(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Ax22d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Ax22d":
        """
        * Rotates an axis placement. <A1> is the axis of the rotation . Ang is the angular value of the rotation in radians.
        	:param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Ax22d_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Ax22d_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Ax22d":
        """
        * Applies a scaling transformation on the axis placement. The 'Location' point of the axisplacement is modified. Warnings : If the scale <S> is negative : . the main direction of the axis placement is not changed. . The 'XDirection' and the 'YDirection' are reversed. So the axis placement stay right handed.
        	:param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Ax22d_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Assigns the origin and the two unit vectors of the coordinate system A1 to this coordinate system.
        	:param A1:
        	:type A1: gp_Ax22d
        	:rtype: None
        """
        return _gp.gp_Ax22d_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the 'Location' point (origin) of <self>.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Ax22d_SetLocation(self, *args)


    def SetXAxis(self, *args) -> "void":
        """
        * Changes the XAxis and YAxis ('Location' point and 'Direction') of <self>. The 'YDirection' is recomputed in the same sense as before.
        	:param A1:
        	:type A1: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Ax22d_SetXAxis(self, *args)


    def SetXDirection(self, *args) -> "void":
        """
        * Assigns Vx to the 'X Direction' of this coordinate system. The other unit vector of this coordinate system is recomputed, normal to Vx , without modifying the orientation (right-handed or left-handed) of this coordinate system.
        	:param Vx:
        	:type Vx: gp_Dir2d
        	:rtype: None
        """
        return _gp.gp_Ax22d_SetXDirection(self, *args)


    def SetYAxis(self, *args) -> "void":
        """
        * Changes the XAxis and YAxis ('Location' point and 'Direction') of <self>. The 'XDirection' is recomputed in the same sense as before.
        	:param A1:
        	:type A1: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Ax22d_SetYAxis(self, *args)


    def SetYDirection(self, *args) -> "void":
        """
        * Assignsr Vy to the 'Y Direction' of this coordinate system. The other unit vector of this coordinate system is recomputed, normal to Vy, without modifying the orientation (right-handed or left-handed) of this coordinate system.
        	:param Vy:
        	:type Vy: gp_Dir2d
        	:rtype: None
        """
        return _gp.gp_Ax22d_SetYDirection(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Ax22d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Ax22d":
        """
        * Transforms an axis placement with a Trsf. The 'Location' point, the 'XDirection' and the 'YDirection' are transformed with T. The resulting main 'Direction' of <self> is the cross product between the 'XDirection' and the 'YDirection' after transformation.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Ax22d_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec2d
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Ax22d_Translate(self, *args)


    def Translated(self, *args) -> "gp_Ax22d":
        """
        * Translates an axis plaxement in the direction of the vector <V>. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: gp_Ax22d
        * Translates an axis placement from the point <P1> to the point <P2>.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Ax22d_Translated(self, *args)


    def XAxis(self, *args) -> "gp_Ax2d":
        """
        * Returns an axis, for which - the origin is that of this coordinate system, and - the unit vector is either the 'X Direction' of this coordinate system. Note: the result is the 'X Axis' of this coordinate system.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Ax22d_XAxis(self, *args)


    def XDirection(self, *args) -> "gp_Dir2d const":
        """
        * Returns the 'XDirection' of <self>.
        	:rtype: gp_Dir2d
        """
        return _gp.gp_Ax22d_XDirection(self, *args)


    def YAxis(self, *args) -> "gp_Ax2d":
        """
        * Returns an axis, for which - the origin is that of this coordinate system, and - the unit vector is either the 'Y Direction' of this coordinate system. Note: the result is the 'Y Axis' of this coordinate system.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Ax22d_YAxis(self, *args)


    def YDirection(self, *args) -> "gp_Dir2d const":
        """
        * Returns the 'YDirection' of <self>.
        	:rtype: gp_Dir2d
        """
        return _gp.gp_Ax22d_YDirection(self, *args)


    def __init__(self, *args):
        """
        * Creates an object representing the reference co-ordinate system (OXY).
        	:rtype: None
        * Creates a coordinate system with origin P and where: - Vx is the 'X Direction', and - the 'Y Direction' is orthogonal to Vx and oriented so that the cross products Vx^'Y Direction' and Vx^Vy have the same sign. Raises ConstructionError if Vx and Vy are parallel (same or opposite orientation).
        	:param P:
        	:type P: gp_Pnt2d
        	:param Vx:
        	:type Vx: gp_Dir2d
        	:param Vy:
        	:type Vy: gp_Dir2d
        	:rtype: None
        * Creates - a coordinate system with origin P and 'X Direction' V, which is: - right-handed if Sense is true (default value), or - left-handed if Sense is false
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Dir2d
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        * Creates - a coordinate system where its origin is the origin of A and its 'X Direction' is the unit vector of A, which is: - right-handed if Sense is true (default value), or - left-handed if Sense is false.
        	:param A:
        	:type A: gp_Ax2d
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        """
        _gp.gp_Ax22d_swiginit(self, _gp.new_gp_Ax22d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax22d
gp_Ax22d.Location = new_instancemethod(_gp.gp_Ax22d_Location, None, gp_Ax22d)
gp_Ax22d.Mirror = new_instancemethod(_gp.gp_Ax22d_Mirror, None, gp_Ax22d)
gp_Ax22d.Mirrored = new_instancemethod(_gp.gp_Ax22d_Mirrored, None, gp_Ax22d)
gp_Ax22d.Rotate = new_instancemethod(_gp.gp_Ax22d_Rotate, None, gp_Ax22d)
gp_Ax22d.Rotated = new_instancemethod(_gp.gp_Ax22d_Rotated, None, gp_Ax22d)
gp_Ax22d.Scale = new_instancemethod(_gp.gp_Ax22d_Scale, None, gp_Ax22d)
gp_Ax22d.Scaled = new_instancemethod(_gp.gp_Ax22d_Scaled, None, gp_Ax22d)
gp_Ax22d.SetAxis = new_instancemethod(_gp.gp_Ax22d_SetAxis, None, gp_Ax22d)
gp_Ax22d.SetLocation = new_instancemethod(_gp.gp_Ax22d_SetLocation, None, gp_Ax22d)
gp_Ax22d.SetXAxis = new_instancemethod(_gp.gp_Ax22d_SetXAxis, None, gp_Ax22d)
gp_Ax22d.SetXDirection = new_instancemethod(_gp.gp_Ax22d_SetXDirection, None, gp_Ax22d)
gp_Ax22d.SetYAxis = new_instancemethod(_gp.gp_Ax22d_SetYAxis, None, gp_Ax22d)
gp_Ax22d.SetYDirection = new_instancemethod(_gp.gp_Ax22d_SetYDirection, None, gp_Ax22d)
gp_Ax22d.Transform = new_instancemethod(_gp.gp_Ax22d_Transform, None, gp_Ax22d)
gp_Ax22d.Transformed = new_instancemethod(_gp.gp_Ax22d_Transformed, None, gp_Ax22d)
gp_Ax22d.Translate = new_instancemethod(_gp.gp_Ax22d_Translate, None, gp_Ax22d)
gp_Ax22d.Translated = new_instancemethod(_gp.gp_Ax22d_Translated, None, gp_Ax22d)
gp_Ax22d.XAxis = new_instancemethod(_gp.gp_Ax22d_XAxis, None, gp_Ax22d)
gp_Ax22d.XDirection = new_instancemethod(_gp.gp_Ax22d_XDirection, None, gp_Ax22d)
gp_Ax22d.YAxis = new_instancemethod(_gp.gp_Ax22d_YAxis, None, gp_Ax22d)
gp_Ax22d.YDirection = new_instancemethod(_gp.gp_Ax22d_YDirection, None, gp_Ax22d)
gp_Ax22d_swigregister = _gp.gp_Ax22d_swigregister
gp_Ax22d_swigregister(gp_Ax22d)

class gp_Ax2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angle, in radians, between this axis and the axis Other. The value of the angle is between -Pi and Pi.
        	:param Other:
        	:type Other: gp_Ax2d
        	:rtype: float
        """
        return _gp.gp_Ax2d_Angle(self, *args)


    def Direction(self, *args) -> "gp_Dir2d const":
        """
        * Returns the direction of <self>.
        	:rtype: gp_Dir2d
        """
        return _gp.gp_Ax2d_Direction(self, *args)


    def IsCoaxial(self, *args) -> "Standard_Boolean":
        """
        * Returns True if : . the angle between <self> and <Other> is lower or equal to <AngularTolerance> and . the distance between <self>.Location() and <Other> is lower or equal to <LinearTolerance> and . the distance between <Other>.Location() and <self> is lower or equal to LinearTolerance.
        	:param Other:
        	:type Other: gp_Ax2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax2d_IsCoaxial(self, *args)


    def IsNormal(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this axis and the axis Other are normal to each other. That is, if the angle between the two axes is equal to Pi/2 or -Pi/2. Note: the tolerance criterion is given by AngularTolerance.
        	:param Other:
        	:type Other: gp_Ax2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax2d_IsNormal(self, *args)


    def IsOpposite(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this axis and the axis Other are parallel, and have opposite orientations. That is, if the angle between the two axes is equal to Pi or -Pi. Note: the tolerance criterion is given by AngularTolerance.
        	:param Other:
        	:type Other: gp_Ax2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax2d_IsOpposite(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this axis and the axis Other are parallel, and have either the same or opposite orientations. That is, if the angle between the two axes is equal to 0, Pi or -Pi. Note: the tolerance criterion is given by AngularTolerance.
        	:param Other:
        	:type Other: gp_Ax2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax2d_IsParallel(self, *args)


    def Location(self, *args) -> "gp_Pnt2d const":
        """
        * Returns the origin of <self>.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Ax2d_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        :param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Ax2d_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Ax2d":
        """
        * Performs the symmetrical transformation of an axis placement with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Ax2d
        * Performs the symmetrical transformation of an axis placement with respect to an axis placement which is the axis of the symmetry.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Ax2d_Mirrored(self, *args)


    def Reverse(self, *args) -> "void":
        """
        * Reverses the direction of <self> and assigns the result to this axis.
        	:rtype: None
        """
        return _gp.gp_Ax2d_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Ax2d":
        """
        * Computes a new axis placement with a direction opposite to the direction of <self>.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Ax2d_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Ax2d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Ax2d":
        """
        * Rotates an axis placement. <P> is the center of the rotation . Ang is the angular value of the rotation in radians.
        	:param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Ax2d_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Ax2d_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Ax2d":
        """
        * Applies a scaling transformation on the axis placement. The 'Location' point of the axisplacement is modified. The 'Direction' is reversed if the scale is negative.
        	:param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Ax2d_Scaled(self, *args)


    def SetDirection(self, *args) -> "void":
        """
        * Changes the direction of <self>.
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        """
        return _gp.gp_Ax2d_SetDirection(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the 'Location' point (origin) of <self>.
        	:param Locat:
        	:type Locat: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Ax2d_SetLocation(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Ax2d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Ax2d":
        """
        * Transforms an axis placement with a Trsf.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Ax2d_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec2d
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Ax2d_Translate(self, *args)


    def Translated(self, *args) -> "gp_Ax2d":
        """
        * Translates an axis placement in the direction of the vector <V>. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: gp_Ax2d
        * Translates an axis placement from the point <P1> to the point <P2>.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Ax2d_Translated(self, *args)


    def __init__(self, *args):
        """
        * Creates an axis object representing X axis of the reference co-ordinate system.
        	:rtype: None
        * Creates an Ax2d. <P> is the 'Location' point of the axis placement and V is the 'Direction' of the axis placement.
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        """
        _gp.gp_Ax2d_swiginit(self, _gp.new_gp_Ax2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax2d
gp_Ax2d.Angle = new_instancemethod(_gp.gp_Ax2d_Angle, None, gp_Ax2d)
gp_Ax2d.Direction = new_instancemethod(_gp.gp_Ax2d_Direction, None, gp_Ax2d)
gp_Ax2d.IsCoaxial = new_instancemethod(_gp.gp_Ax2d_IsCoaxial, None, gp_Ax2d)
gp_Ax2d.IsNormal = new_instancemethod(_gp.gp_Ax2d_IsNormal, None, gp_Ax2d)
gp_Ax2d.IsOpposite = new_instancemethod(_gp.gp_Ax2d_IsOpposite, None, gp_Ax2d)
gp_Ax2d.IsParallel = new_instancemethod(_gp.gp_Ax2d_IsParallel, None, gp_Ax2d)
gp_Ax2d.Location = new_instancemethod(_gp.gp_Ax2d_Location, None, gp_Ax2d)
gp_Ax2d.Mirror = new_instancemethod(_gp.gp_Ax2d_Mirror, None, gp_Ax2d)
gp_Ax2d.Mirrored = new_instancemethod(_gp.gp_Ax2d_Mirrored, None, gp_Ax2d)
gp_Ax2d.Reverse = new_instancemethod(_gp.gp_Ax2d_Reverse, None, gp_Ax2d)
gp_Ax2d.Reversed = new_instancemethod(_gp.gp_Ax2d_Reversed, None, gp_Ax2d)
gp_Ax2d.Rotate = new_instancemethod(_gp.gp_Ax2d_Rotate, None, gp_Ax2d)
gp_Ax2d.Rotated = new_instancemethod(_gp.gp_Ax2d_Rotated, None, gp_Ax2d)
gp_Ax2d.Scale = new_instancemethod(_gp.gp_Ax2d_Scale, None, gp_Ax2d)
gp_Ax2d.Scaled = new_instancemethod(_gp.gp_Ax2d_Scaled, None, gp_Ax2d)
gp_Ax2d.SetDirection = new_instancemethod(_gp.gp_Ax2d_SetDirection, None, gp_Ax2d)
gp_Ax2d.SetLocation = new_instancemethod(_gp.gp_Ax2d_SetLocation, None, gp_Ax2d)
gp_Ax2d.Transform = new_instancemethod(_gp.gp_Ax2d_Transform, None, gp_Ax2d)
gp_Ax2d.Transformed = new_instancemethod(_gp.gp_Ax2d_Transformed, None, gp_Ax2d)
gp_Ax2d.Translate = new_instancemethod(_gp.gp_Ax2d_Translate, None, gp_Ax2d)
gp_Ax2d.Translated = new_instancemethod(_gp.gp_Ax2d_Translated, None, gp_Ax2d)
gp_Ax2d_swigregister = _gp.gp_Ax2d_swigregister
gp_Ax2d_swigregister(gp_Ax2d)

class gp_Ax3(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angular value between the main direction of <self> and the main direction of <Other>. Returns the angle between 0 and PI in radians.
        	:param Other:
        	:type Other: gp_Ax3
        	:rtype: float
        """
        return _gp.gp_Ax3_Angle(self, *args)


    def Ax2(self, *args) -> "gp_Ax2":
        """
        * Computes a right-handed coordinate system with the same 'X Direction' and 'Y Direction' as those of this coordinate system, then recomputes the 'main Direction'. If this coordinate system is right-handed, the result returned is the same coordinate system. If this coordinate system is left-handed, the result is reversed.
        	:rtype: gp_Ax2
        """
        return _gp.gp_Ax3_Ax2(self, *args)


    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * Returns the main axis of <self>. It is the 'Location' point and the main 'Direction'.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Ax3_Axis(self, *args)


    def Direct(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the coordinate system is right-handed. i.e. XDirection().Crossed(YDirection()).Dot(Direction()) > 0
        	:rtype: bool
        """
        return _gp.gp_Ax3_Direct(self, *args)


    def Direction(self, *args) -> "gp_Dir const":
        """
        * Returns the main direction of <self>.
        	:rtype: gp_Dir
        """
        return _gp.gp_Ax3_Direction(self, *args)


    def IsCoplanar(self, *args) -> "Standard_Boolean":
        """
        * Returns True if . the distance between the 'Location' point of <self> and <Other> is lower or equal to LinearTolerance and . the distance between the 'Location' point of <Other> and <self> is lower or equal to LinearTolerance and . the main direction of <self> and the main direction of <Other> are parallel (same or opposite orientation).
        	:param Other:
        	:type Other: gp_Ax3
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        * Returns True if . the distance between <self> and the 'Location' point of A1 is lower of equal to LinearTolerance and . the distance between A1 and the 'Location' point of <self> is lower or equal to LinearTolerance and . the main direction of <self> and the direction of A1 are normal.
        	:param A1:
        	:type A1: gp_Ax1
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Ax3_IsCoplanar(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the 'Location' point (origin) of <self>.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Ax3_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Ax3_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Ax3":
        """
        * Performs the symmetrical transformation of an axis placement with respect to the point P which is the center of the symmetry. Warnings : The main direction of the axis placement is not changed. The 'XDirection' and the 'YDirection' are reversed. So the axis placement stay right handed.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Ax3
        * Performs the symmetrical transformation of an axis placement with respect to an axis placement which is the axis of the symmetry. The transformation is performed on the 'Location' point, on the 'XDirection' and 'YDirection'. The resulting main 'Direction' is the cross product between the 'XDirection' and the 'YDirection' after transformation.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Ax3
        * Performs the symmetrical transformation of an axis placement with respect to a plane. The axis placement <A2> locates the plane of the symmetry : (Location, XDirection, YDirection). The transformation is performed on the 'Location' point, on the 'XDirection' and 'YDirection'. The resulting main 'Direction' is the cross product between the 'XDirection' and the 'YDirection' after transformation.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Ax3
        """
        return _gp.gp_Ax3_Mirrored(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Ax3_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Ax3":
        """
        * Rotates an axis placement. <A1> is the axis of the rotation . Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Ax3
        """
        return _gp.gp_Ax3_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Ax3_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Ax3":
        """
        * Applies a scaling transformation on the axis placement. The 'Location' point of the axisplacement is modified. Warnings : If the scale <S> is negative : . the main direction of the axis placement is not changed. . The 'XDirection' and the 'YDirection' are reversed. So the axis placement stay right handed.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Ax3
        """
        return _gp.gp_Ax3_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Assigns the origin and 'main Direction' of the axis A1 to this coordinate system, then recomputes its 'X Direction' and 'Y Direction'. Note: - The new 'X Direction' is computed as follows: new 'X Direction' = V1 ^(previous 'X Direction' ^ V) where V is the 'Direction' of A1. - The orientation of this coordinate system (right-handed or left-handed) is not modified. Raises ConstructionError if the 'Direction' of <A1> and the 'XDirection' of <self> are parallel (same or opposite orientation) because it is impossible to calculate the new 'XDirection' and the new 'YDirection'.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Ax3_SetAxis(self, *args)


    def SetDirection(self, *args) -> "void":
        """
        * Changes the main direction of this coordinate system, then recomputes its 'X Direction' and 'Y Direction'. Note: - The new 'X Direction' is computed as follows: new 'X Direction' = V ^ (previous 'X Direction' ^ V). - The orientation of this coordinate system (left- or right-handed) is not modified. Raises ConstructionError if <V< and the previous 'XDirection' are parallel because it is impossible to calculate the new 'XDirection' and the new 'YDirection'.
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Ax3_SetDirection(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the 'Location' point (origin) of <self>.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Ax3_SetLocation(self, *args)


    def SetXDirection(self, *args) -> "void":
        """
        * Changes the 'Xdirection' of <self>. The main direction 'Direction' is not modified, the 'Ydirection' is modified. If <Vx> is not normal to the main direction then <XDirection> is computed as follows XDirection = Direction ^ (Vx ^ Direction). Raises ConstructionError if <Vx> is parallel (same or opposite orientation) to the main direction of <self>
        	:param Vx:
        	:type Vx: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Ax3_SetXDirection(self, *args)


    def SetYDirection(self, *args) -> "void":
        """
        * Changes the 'Ydirection' of <self>. The main direction is not modified but the 'Xdirection' is changed. If <Vy> is not normal to the main direction then 'YDirection' is computed as follows YDirection = Direction ^ (<Vy> ^ Direction). Raises ConstructionError if <Vy> is parallel to the main direction of <self>
        	:param Vy:
        	:type Vy: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Ax3_SetYDirection(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Ax3_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Ax3":
        """
        * Transforms an axis placement with a Trsf. The 'Location' point, the 'XDirection' and the 'YDirection' are transformed with T. The resulting main 'Direction' of <self> is the cross product between the 'XDirection' and the 'YDirection' after transformation.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Ax3
        """
        return _gp.gp_Ax3_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Ax3_Translate(self, *args)


    def Translated(self, *args) -> "gp_Ax3":
        """
        * Translates an axis plaxement in the direction of the vector <V>. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Ax3
        * Translates an axis placement from the point <P1> to the point <P2>.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Ax3
        """
        return _gp.gp_Ax3_Translated(self, *args)


    def XDirection(self, *args) -> "gp_Dir const":
        """
        * Returns the 'XDirection' of <self>.
        	:rtype: gp_Dir
        """
        return _gp.gp_Ax3_XDirection(self, *args)


    def XReverse(self, *args) -> "void":
        """
        * Reverses the X direction of <self>.
        	:rtype: None
        """
        return _gp.gp_Ax3_XReverse(self, *args)


    def YDirection(self, *args) -> "gp_Dir const":
        """
        * Returns the 'YDirection' of <self>.
        	:rtype: gp_Dir
        """
        return _gp.gp_Ax3_YDirection(self, *args)


    def YReverse(self, *args) -> "void":
        """
        * Reverses the Y direction of <self>.
        	:rtype: None
        """
        return _gp.gp_Ax3_YReverse(self, *args)


    def ZReverse(self, *args) -> "void":
        """
        * Reverses the Z direction of <self>.
        	:rtype: None
        """
        return _gp.gp_Ax3_ZReverse(self, *args)


    def __init__(self, *args):
        """
        * Creates an object corresponding to the reference coordinate system (OXYZ).
        	:rtype: None
        * Creates a coordinate system from a right-handed coordinate system.
        	:param A:
        	:type A: gp_Ax2
        	:rtype: None
        * Creates a right handed axis placement with the 'Location' point P and two directions, N gives the 'Direction' and Vx gives the 'XDirection'. Raises ConstructionError if N and Vx are parallel (same or opposite orientation).
        	:param P:
        	:type P: gp_Pnt
        	:param N:
        	:type N: gp_Dir
        	:param Vx:
        	:type Vx: gp_Dir
        	:rtype: None
        * Creates an axis placement with the 'Location' point <P> and the normal direction <V>.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _gp.gp_Ax3_swiginit(self, _gp.new_gp_Ax3(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax3
gp_Ax3.Angle = new_instancemethod(_gp.gp_Ax3_Angle, None, gp_Ax3)
gp_Ax3.Ax2 = new_instancemethod(_gp.gp_Ax3_Ax2, None, gp_Ax3)
gp_Ax3.Axis = new_instancemethod(_gp.gp_Ax3_Axis, None, gp_Ax3)
gp_Ax3.Direct = new_instancemethod(_gp.gp_Ax3_Direct, None, gp_Ax3)
gp_Ax3.Direction = new_instancemethod(_gp.gp_Ax3_Direction, None, gp_Ax3)
gp_Ax3.IsCoplanar = new_instancemethod(_gp.gp_Ax3_IsCoplanar, None, gp_Ax3)
gp_Ax3.Location = new_instancemethod(_gp.gp_Ax3_Location, None, gp_Ax3)
gp_Ax3.Mirror = new_instancemethod(_gp.gp_Ax3_Mirror, None, gp_Ax3)
gp_Ax3.Mirrored = new_instancemethod(_gp.gp_Ax3_Mirrored, None, gp_Ax3)
gp_Ax3.Rotate = new_instancemethod(_gp.gp_Ax3_Rotate, None, gp_Ax3)
gp_Ax3.Rotated = new_instancemethod(_gp.gp_Ax3_Rotated, None, gp_Ax3)
gp_Ax3.Scale = new_instancemethod(_gp.gp_Ax3_Scale, None, gp_Ax3)
gp_Ax3.Scaled = new_instancemethod(_gp.gp_Ax3_Scaled, None, gp_Ax3)
gp_Ax3.SetAxis = new_instancemethod(_gp.gp_Ax3_SetAxis, None, gp_Ax3)
gp_Ax3.SetDirection = new_instancemethod(_gp.gp_Ax3_SetDirection, None, gp_Ax3)
gp_Ax3.SetLocation = new_instancemethod(_gp.gp_Ax3_SetLocation, None, gp_Ax3)
gp_Ax3.SetXDirection = new_instancemethod(_gp.gp_Ax3_SetXDirection, None, gp_Ax3)
gp_Ax3.SetYDirection = new_instancemethod(_gp.gp_Ax3_SetYDirection, None, gp_Ax3)
gp_Ax3.Transform = new_instancemethod(_gp.gp_Ax3_Transform, None, gp_Ax3)
gp_Ax3.Transformed = new_instancemethod(_gp.gp_Ax3_Transformed, None, gp_Ax3)
gp_Ax3.Translate = new_instancemethod(_gp.gp_Ax3_Translate, None, gp_Ax3)
gp_Ax3.Translated = new_instancemethod(_gp.gp_Ax3_Translated, None, gp_Ax3)
gp_Ax3.XDirection = new_instancemethod(_gp.gp_Ax3_XDirection, None, gp_Ax3)
gp_Ax3.XReverse = new_instancemethod(_gp.gp_Ax3_XReverse, None, gp_Ax3)
gp_Ax3.YDirection = new_instancemethod(_gp.gp_Ax3_YDirection, None, gp_Ax3)
gp_Ax3.YReverse = new_instancemethod(_gp.gp_Ax3_YReverse, None, gp_Ax3)
gp_Ax3.ZReverse = new_instancemethod(_gp.gp_Ax3_ZReverse, None, gp_Ax3)
gp_Ax3_swigregister = _gp.gp_Ax3_swigregister
gp_Ax3_swigregister(gp_Ax3)

class gp_Circ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Area(self, *args) -> "Standard_Real":
        """
        * Computes the area of the circle.
        	:rtype: float
        """
        return _gp.gp_Circ_Area(self, *args)


    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * Returns the main axis of the circle. It is the axis perpendicular to the plane of the circle, passing through the 'Location' point (center) of the circle.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Circ_Axis(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the point P is on the circumference. The distance between <self> and <P> must be lower or equal to LinearTolerance.
        	:param P:
        	:type P: gp_Pnt
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Circ_Contains(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        * Computes the minimum of distance between the point P and any point on the circumference of the circle.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: float
        """
        return _gp.gp_Circ_Distance(self, *args)


    def Length(self, *args) -> "Standard_Real":
        """
        * Computes the circumference of the circle.
        	:rtype: float
        """
        return _gp.gp_Circ_Length(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the center of the circle. It is the 'Location' point of the local coordinate system of the circle
        	:rtype: gp_Pnt
        """
        return _gp.gp_Circ_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Circ_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Circ":
        """
        * Performs the symmetrical transformation of a circle with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Circ
        * Performs the symmetrical transformation of a circle with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Circ
        * Performs the symmetrical transformation of a circle with respect to a plane. The axis placement A2 locates the plane of the of the symmetry : (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Circ
        """
        return _gp.gp_Circ_Mirrored(self, *args)


    def Position(self, *args) -> "gp_Ax2 const":
        """
        * Returns the position of the circle. It is the local coordinate system of the circle.
        	:rtype: gp_Ax2
        """
        return _gp.gp_Circ_Position(self, *args)


    def Radius(self, *args) -> "Standard_Real":
        """
        * Returns the radius of this circle.
        	:rtype: float
        """
        return _gp.gp_Circ_Radius(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Circ_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Circ":
        """
        * Rotates a circle. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Circ
        """
        return _gp.gp_Circ_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Circ_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Circ":
        """
        * Scales a circle. S is the scaling value. Warnings : If S is negative the radius stay positive but the 'XAxis' and the 'YAxis' are reversed as for an ellipse.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Circ
        """
        return _gp.gp_Circ_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Changes the main axis of the circle. It is the axis perpendicular to the plane of the circle. Raises ConstructionError if the direction of A1 is parallel to the 'XAxis' of the circle.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Circ_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the 'Location' point (center) of the circle.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Circ_SetLocation(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Changes the position of the circle.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Circ_SetPosition(self, *args)


    def SetRadius(self, *args) -> "void":
        """
        * Modifies the radius of this circle. Warning. This class does not prevent the creation of a circle where Radius is null. Exceptions Standard_ConstructionError if Radius is negative.
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        return _gp.gp_Circ_SetRadius(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        * Computes the square distance between <self> and the point P.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: float
        """
        return _gp.gp_Circ_SquareDistance(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Circ_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Circ":
        """
        * Transforms a circle with the transformation T from class Trsf.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Circ
        """
        return _gp.gp_Circ_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Circ_Translate(self, *args)


    def Translated(self, *args) -> "gp_Circ":
        """
        * Translates a circle in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Circ
        * Translates a circle from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Circ
        """
        return _gp.gp_Circ_Translated(self, *args)


    def XAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the 'XAxis' of the circle. This axis is perpendicular to the axis of the conic. This axis and the 'Yaxis' define the plane of the conic.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Circ_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the 'YAxis' of the circle. This axis and the 'Xaxis' define the plane of the conic. The 'YAxis' is perpendicular to the 'Xaxis'.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Circ_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates an indefinite circle.
        	:rtype: None
        * A2 locates the circle and gives its orientation in 3D space. Warnings : It is not forbidden to create a circle with Radius = 0.0 Raises ConstructionError if Radius < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Circ_swiginit(self, _gp.new_gp_Circ(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Circ
gp_Circ.Area = new_instancemethod(_gp.gp_Circ_Area, None, gp_Circ)
gp_Circ.Axis = new_instancemethod(_gp.gp_Circ_Axis, None, gp_Circ)
gp_Circ.Contains = new_instancemethod(_gp.gp_Circ_Contains, None, gp_Circ)
gp_Circ.Distance = new_instancemethod(_gp.gp_Circ_Distance, None, gp_Circ)
gp_Circ.Length = new_instancemethod(_gp.gp_Circ_Length, None, gp_Circ)
gp_Circ.Location = new_instancemethod(_gp.gp_Circ_Location, None, gp_Circ)
gp_Circ.Mirror = new_instancemethod(_gp.gp_Circ_Mirror, None, gp_Circ)
gp_Circ.Mirrored = new_instancemethod(_gp.gp_Circ_Mirrored, None, gp_Circ)
gp_Circ.Position = new_instancemethod(_gp.gp_Circ_Position, None, gp_Circ)
gp_Circ.Radius = new_instancemethod(_gp.gp_Circ_Radius, None, gp_Circ)
gp_Circ.Rotate = new_instancemethod(_gp.gp_Circ_Rotate, None, gp_Circ)
gp_Circ.Rotated = new_instancemethod(_gp.gp_Circ_Rotated, None, gp_Circ)
gp_Circ.Scale = new_instancemethod(_gp.gp_Circ_Scale, None, gp_Circ)
gp_Circ.Scaled = new_instancemethod(_gp.gp_Circ_Scaled, None, gp_Circ)
gp_Circ.SetAxis = new_instancemethod(_gp.gp_Circ_SetAxis, None, gp_Circ)
gp_Circ.SetLocation = new_instancemethod(_gp.gp_Circ_SetLocation, None, gp_Circ)
gp_Circ.SetPosition = new_instancemethod(_gp.gp_Circ_SetPosition, None, gp_Circ)
gp_Circ.SetRadius = new_instancemethod(_gp.gp_Circ_SetRadius, None, gp_Circ)
gp_Circ.SquareDistance = new_instancemethod(_gp.gp_Circ_SquareDistance, None, gp_Circ)
gp_Circ.Transform = new_instancemethod(_gp.gp_Circ_Transform, None, gp_Circ)
gp_Circ.Transformed = new_instancemethod(_gp.gp_Circ_Transformed, None, gp_Circ)
gp_Circ.Translate = new_instancemethod(_gp.gp_Circ_Translate, None, gp_Circ)
gp_Circ.Translated = new_instancemethod(_gp.gp_Circ_Translated, None, gp_Circ)
gp_Circ.XAxis = new_instancemethod(_gp.gp_Circ_XAxis, None, gp_Circ)
gp_Circ.YAxis = new_instancemethod(_gp.gp_Circ_YAxis, None, gp_Circ)
gp_Circ_swigregister = _gp.gp_Circ_swigregister
gp_Circ_swigregister(gp_Circ)

class gp_Circ2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Area(self, *args) -> "Standard_Real":
        """
        * Computes the area of the circle.
        	:rtype: float
        """
        return _gp.gp_Circ2d_Area(self, *args)


    def Axis(self, *args) -> "gp_Ax22d const":
        """
        * returns the position of the circle.
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Circ2d_Axis(self, *args)


    def Coefficients(self, *args) -> "void":
        """
        * Returns the normalized coefficients from the implicit equation of the circle : A * (X**2) + B * (Y**2) + 2*C*(X*Y) + 2*D*X + 2*E*Y + F = 0.0
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param F:
        	:type F: float
        	:rtype: None
        """
        return _gp.gp_Circ2d_Coefficients(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        * Does <self> contain P ? Returns True if the distance between P and any point on the circumference of the circle is lower of equal to <LinearTolerance>.
        	:param P:
        	:type P: gp_Pnt2d
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Circ2d_Contains(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        * Computes the minimum of distance between the point P and any point on the circumference of the circle.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: float
        """
        return _gp.gp_Circ2d_Distance(self, *args)


    def IsDirect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the local coordinate system is direct and false in the other case.
        	:rtype: bool
        """
        return _gp.gp_Circ2d_IsDirect(self, *args)


    def Length(self, *args) -> "Standard_Real":
        """
        * computes the circumference of the circle.
        	:rtype: float
        """
        return _gp.gp_Circ2d_Length(self, *args)


    def Location(self, *args) -> "gp_Pnt2d const":
        """
        * Returns the location point (center) of the circle.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Circ2d_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        :param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Circ2d_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Circ2d":
        """
        * Performs the symmetrical transformation of a circle with respect to the point P which is the center of the symmetry
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Circ2d
        * Performs the symmetrical transformation of a circle with respect to an axis placement which is the axis of the symmetry.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: gp_Circ2d
        """
        return _gp.gp_Circ2d_Mirrored(self, *args)


    def Position(self, *args) -> "gp_Ax22d const":
        """
        * returns the position of the circle. Idem Axis(me).
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Circ2d_Position(self, *args)


    def Radius(self, *args) -> "Standard_Real":
        """
        * Returns the radius value of the circle.
        	:rtype: float
        """
        return _gp.gp_Circ2d_Radius(self, *args)


    def Reverse(self, *args) -> "void":
        """
        * Reverses the orientation of the local coordinate system of this circle (the 'Y Direction' is reversed) and therefore changes the implicit orientation of this circle. Reverse assigns the result to this circle,
        	:rtype: None
        """
        return _gp.gp_Circ2d_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Circ2d":
        """
        * Reverses the orientation of the local coordinate system of this circle (the 'Y Direction' is reversed) and therefore changes the implicit orientation of this circle. Reversed creates a new circle.
        	:rtype: gp_Circ2d
        """
        return _gp.gp_Circ2d_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Circ2d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Circ2d":
        """
        * Rotates a circle. P is the center of the rotation. Ang is the angular value of the rotation in radians.
        	:param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Circ2d
        """
        return _gp.gp_Circ2d_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Circ2d_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Circ2d":
        """
        * Scales a circle. S is the scaling value. Warnings : If S is negative the radius stay positive but the 'XAxis' and the 'YAxis' are reversed as for an ellipse.
        	:param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: gp_Circ2d
        """
        return _gp.gp_Circ2d_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Changes the X axis of the circle.
        	:param A:
        	:type A: gp_Ax22d
        	:rtype: None
        """
        return _gp.gp_Circ2d_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the location point (center) of the circle.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Circ2d_SetLocation(self, *args)


    def SetRadius(self, *args) -> "void":
        """
        * Modifies the radius of this circle. This class does not prevent the creation of a circle where Radius is null. Exceptions Standard_ConstructionError if Radius is negative.
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        return _gp.gp_Circ2d_SetRadius(self, *args)


    def SetXAxis(self, *args) -> "void":
        """
        * Changes the X axis of the circle.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Circ2d_SetXAxis(self, *args)


    def SetYAxis(self, *args) -> "void":
        """
        * Changes the Y axis of the circle.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Circ2d_SetYAxis(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        * Computes the square distance between <self> and the point P.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: float
        """
        return _gp.gp_Circ2d_SquareDistance(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Circ2d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Circ2d":
        """
        * Transforms a circle with the transformation T from class Trsf2d.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Circ2d
        """
        return _gp.gp_Circ2d_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec2d
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Circ2d_Translate(self, *args)


    def Translated(self, *args) -> "gp_Circ2d":
        """
        * Translates a circle in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: gp_Circ2d
        * Translates a circle from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: gp_Circ2d
        """
        return _gp.gp_Circ2d_Translated(self, *args)


    def XAxis(self, *args) -> "gp_Ax2d":
        """
        * returns the X axis of the circle.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Circ2d_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax2d":
        """
        * Returns the Y axis of the circle. Reverses the direction of the circle.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Circ2d_YAxis(self, *args)


    def __init__(self, *args):
        """
        * creates an indefinite circle.
        	:rtype: None
        * The location point of XAxis is the center of the circle. Warnings : It is not forbidden to create a circle with Radius = 0.0 Raises ConstructionError if Radius < 0.0. Raised if Radius < 0.0.
        	:param XAxis:
        	:type XAxis: gp_Ax2d
        	:param Radius:
        	:type Radius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        * Axis defines the Xaxis and Yaxis of the circle which defines the origin and the sense of parametrization. The location point of Axis is the center of the circle. Warnings : It is not forbidden to create a circle with Radius = 0.0 Raises ConstructionError if Radius < 0.0. Raised if Radius < 0.0.
        	:param Axis:
        	:type Axis: gp_Ax22d
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Circ2d_swiginit(self, _gp.new_gp_Circ2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Circ2d
gp_Circ2d.Area = new_instancemethod(_gp.gp_Circ2d_Area, None, gp_Circ2d)
gp_Circ2d.Axis = new_instancemethod(_gp.gp_Circ2d_Axis, None, gp_Circ2d)
gp_Circ2d.Coefficients = new_instancemethod(_gp.gp_Circ2d_Coefficients, None, gp_Circ2d)
gp_Circ2d.Contains = new_instancemethod(_gp.gp_Circ2d_Contains, None, gp_Circ2d)
gp_Circ2d.Distance = new_instancemethod(_gp.gp_Circ2d_Distance, None, gp_Circ2d)
gp_Circ2d.IsDirect = new_instancemethod(_gp.gp_Circ2d_IsDirect, None, gp_Circ2d)
gp_Circ2d.Length = new_instancemethod(_gp.gp_Circ2d_Length, None, gp_Circ2d)
gp_Circ2d.Location = new_instancemethod(_gp.gp_Circ2d_Location, None, gp_Circ2d)
gp_Circ2d.Mirror = new_instancemethod(_gp.gp_Circ2d_Mirror, None, gp_Circ2d)
gp_Circ2d.Mirrored = new_instancemethod(_gp.gp_Circ2d_Mirrored, None, gp_Circ2d)
gp_Circ2d.Position = new_instancemethod(_gp.gp_Circ2d_Position, None, gp_Circ2d)
gp_Circ2d.Radius = new_instancemethod(_gp.gp_Circ2d_Radius, None, gp_Circ2d)
gp_Circ2d.Reverse = new_instancemethod(_gp.gp_Circ2d_Reverse, None, gp_Circ2d)
gp_Circ2d.Reversed = new_instancemethod(_gp.gp_Circ2d_Reversed, None, gp_Circ2d)
gp_Circ2d.Rotate = new_instancemethod(_gp.gp_Circ2d_Rotate, None, gp_Circ2d)
gp_Circ2d.Rotated = new_instancemethod(_gp.gp_Circ2d_Rotated, None, gp_Circ2d)
gp_Circ2d.Scale = new_instancemethod(_gp.gp_Circ2d_Scale, None, gp_Circ2d)
gp_Circ2d.Scaled = new_instancemethod(_gp.gp_Circ2d_Scaled, None, gp_Circ2d)
gp_Circ2d.SetAxis = new_instancemethod(_gp.gp_Circ2d_SetAxis, None, gp_Circ2d)
gp_Circ2d.SetLocation = new_instancemethod(_gp.gp_Circ2d_SetLocation, None, gp_Circ2d)
gp_Circ2d.SetRadius = new_instancemethod(_gp.gp_Circ2d_SetRadius, None, gp_Circ2d)
gp_Circ2d.SetXAxis = new_instancemethod(_gp.gp_Circ2d_SetXAxis, None, gp_Circ2d)
gp_Circ2d.SetYAxis = new_instancemethod(_gp.gp_Circ2d_SetYAxis, None, gp_Circ2d)
gp_Circ2d.SquareDistance = new_instancemethod(_gp.gp_Circ2d_SquareDistance, None, gp_Circ2d)
gp_Circ2d.Transform = new_instancemethod(_gp.gp_Circ2d_Transform, None, gp_Circ2d)
gp_Circ2d.Transformed = new_instancemethod(_gp.gp_Circ2d_Transformed, None, gp_Circ2d)
gp_Circ2d.Translate = new_instancemethod(_gp.gp_Circ2d_Translate, None, gp_Circ2d)
gp_Circ2d.Translated = new_instancemethod(_gp.gp_Circ2d_Translated, None, gp_Circ2d)
gp_Circ2d.XAxis = new_instancemethod(_gp.gp_Circ2d_XAxis, None, gp_Circ2d)
gp_Circ2d.YAxis = new_instancemethod(_gp.gp_Circ2d_YAxis, None, gp_Circ2d)
gp_Circ2d_swigregister = _gp.gp_Circ2d_swigregister
gp_Circ2d_swigregister(gp_Circ2d)

class gp_Cone(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Apex(self, *args) -> "gp_Pnt":
        """
        * Computes the cone's top. The Apex of the cone is on the negative side of the symmetry axis of the cone.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Cone_Apex(self, *args)


    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * returns the symmetry axis of the cone.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Cone_Axis(self, *args)


    def Coefficients(self, *args) -> "void":
        """
        * Computes the coefficients of the implicit equation of the quadric in the absolute cartesian coordinates system : A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) + 2.(C1.X + C2.Y + C3.Z) + D = 0.0
        	:param A1:
        	:type A1: float
        	:param A2:
        	:type A2: float
        	:param A3:
        	:type A3: float
        	:param B1:
        	:type B1: float
        	:param B2:
        	:type B2: float
        	:param B3:
        	:type B3: float
        	:param C1:
        	:type C1: float
        	:param C2:
        	:type C2: float
        	:param C3:
        	:type C3: float
        	:param D:
        	:type D: float
        	:rtype: None
        """
        return _gp.gp_Cone_Coefficients(self, *args)


    def Direct(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the local coordinate system of this cone is right-handed.
        	:rtype: bool
        """
        return _gp.gp_Cone_Direct(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * returns the 'Location' point of the cone.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Cone_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Cone_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Cone":
        """
        * Performs the symmetrical transformation of a cone with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Cone
        * Performs the symmetrical transformation of a cone with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Cone
        * Performs the symmetrical transformation of a cone with respect to a plane. The axis placement A2 locates the plane of the of the symmetry : (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Cone
        """
        return _gp.gp_Cone_Mirrored(self, *args)


    def Position(self, *args) -> "gp_Ax3 const":
        """
        * Returns the local coordinates system of the cone.
        	:rtype: gp_Ax3
        """
        return _gp.gp_Cone_Position(self, *args)


    def RefRadius(self, *args) -> "Standard_Real":
        """
        * Returns the radius of the cone in the reference plane.
        	:rtype: float
        """
        return _gp.gp_Cone_RefRadius(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Cone_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Cone":
        """
        * Rotates a cone. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Cone
        """
        return _gp.gp_Cone_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Cone_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Cone":
        """
        * Scales a cone. S is the scaling value. The absolute value of S is used to scale the cone
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Cone
        """
        return _gp.gp_Cone_Scaled(self, *args)


    def SemiAngle(self, *args) -> "Standard_Real":
        """
        * Returns the half-angle at the apex of this cone. Attention! Semi-angle can be negative.
        	:rtype: float
        """
        return _gp.gp_Cone_SemiAngle(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Changes the symmetry axis of the cone. Raises ConstructionError the direction of A1 is parallel to the 'XDirection' of the coordinate system of the cone.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Cone_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the location of the cone.
        	:param Loc:
        	:type Loc: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Cone_SetLocation(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Changes the local coordinate system of the cone. This coordinate system defines the reference plane of the cone.
        	:param A3:
        	:type A3: gp_Ax3
        	:rtype: None
        """
        return _gp.gp_Cone_SetPosition(self, *args)


    def SetRadius(self, *args) -> "void":
        """
        * Changes the radius of the cone in the reference plane of the cone. Raised if R < 0.0
        	:param R:
        	:type R: float
        	:rtype: None
        """
        return _gp.gp_Cone_SetRadius(self, *args)


    def SetSemiAngle(self, *args) -> "void":
        """
        * Changes the semi-angle of the cone. Semi-angle can be negative. Its absolute value Abs(Ang) is in range ]0,PI/2[. Raises ConstructionError if Abs(Ang) < Resolution from gp or Abs(Ang) >= PI/2 - Resolution
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Cone_SetSemiAngle(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Cone_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Cone":
        """
        * Transforms a cone with the transformation T from class Trsf.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Cone
        """
        return _gp.gp_Cone_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Cone_Translate(self, *args)


    def Translated(self, *args) -> "gp_Cone":
        """
        * Translates a cone in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Cone
        * Translates a cone from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Cone
        """
        return _gp.gp_Cone_Translated(self, *args)


    def UReverse(self, *args) -> "void":
        """
        * Reverses the U parametrization of the cone reversing the YAxis.
        	:rtype: None
        """
        return _gp.gp_Cone_UReverse(self, *args)


    def VReverse(self, *args) -> "void":
        """
        * Reverses the V parametrization of the cone reversing the ZAxis.
        	:rtype: None
        """
        return _gp.gp_Cone_VReverse(self, *args)


    def XAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the XAxis of the reference plane.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Cone_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the YAxis of the reference plane.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Cone_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates an indefinite Cone.
        	:rtype: None
        * Creates an infinite conical surface. A3 locates the cone in the space and defines the reference plane of the surface. Ang is the conical surface semi-angle. Its absolute value is in range ]0, PI/2[. Radius is the radius of the circle in the reference plane of the cone. Raises ConstructionError * if Radius is lower than 0.0 * Abs(Ang) < Resolution from gp or Abs(Ang) >= (PI/2) - Resolution.
        	:param A3:
        	:type A3: gp_Ax3
        	:param Ang:
        	:type Ang: float
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Cone_swiginit(self, _gp.new_gp_Cone(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Cone
gp_Cone.Apex = new_instancemethod(_gp.gp_Cone_Apex, None, gp_Cone)
gp_Cone.Axis = new_instancemethod(_gp.gp_Cone_Axis, None, gp_Cone)
gp_Cone.Coefficients = new_instancemethod(_gp.gp_Cone_Coefficients, None, gp_Cone)
gp_Cone.Direct = new_instancemethod(_gp.gp_Cone_Direct, None, gp_Cone)
gp_Cone.Location = new_instancemethod(_gp.gp_Cone_Location, None, gp_Cone)
gp_Cone.Mirror = new_instancemethod(_gp.gp_Cone_Mirror, None, gp_Cone)
gp_Cone.Mirrored = new_instancemethod(_gp.gp_Cone_Mirrored, None, gp_Cone)
gp_Cone.Position = new_instancemethod(_gp.gp_Cone_Position, None, gp_Cone)
gp_Cone.RefRadius = new_instancemethod(_gp.gp_Cone_RefRadius, None, gp_Cone)
gp_Cone.Rotate = new_instancemethod(_gp.gp_Cone_Rotate, None, gp_Cone)
gp_Cone.Rotated = new_instancemethod(_gp.gp_Cone_Rotated, None, gp_Cone)
gp_Cone.Scale = new_instancemethod(_gp.gp_Cone_Scale, None, gp_Cone)
gp_Cone.Scaled = new_instancemethod(_gp.gp_Cone_Scaled, None, gp_Cone)
gp_Cone.SemiAngle = new_instancemethod(_gp.gp_Cone_SemiAngle, None, gp_Cone)
gp_Cone.SetAxis = new_instancemethod(_gp.gp_Cone_SetAxis, None, gp_Cone)
gp_Cone.SetLocation = new_instancemethod(_gp.gp_Cone_SetLocation, None, gp_Cone)
gp_Cone.SetPosition = new_instancemethod(_gp.gp_Cone_SetPosition, None, gp_Cone)
gp_Cone.SetRadius = new_instancemethod(_gp.gp_Cone_SetRadius, None, gp_Cone)
gp_Cone.SetSemiAngle = new_instancemethod(_gp.gp_Cone_SetSemiAngle, None, gp_Cone)
gp_Cone.Transform = new_instancemethod(_gp.gp_Cone_Transform, None, gp_Cone)
gp_Cone.Transformed = new_instancemethod(_gp.gp_Cone_Transformed, None, gp_Cone)
gp_Cone.Translate = new_instancemethod(_gp.gp_Cone_Translate, None, gp_Cone)
gp_Cone.Translated = new_instancemethod(_gp.gp_Cone_Translated, None, gp_Cone)
gp_Cone.UReverse = new_instancemethod(_gp.gp_Cone_UReverse, None, gp_Cone)
gp_Cone.VReverse = new_instancemethod(_gp.gp_Cone_VReverse, None, gp_Cone)
gp_Cone.XAxis = new_instancemethod(_gp.gp_Cone_XAxis, None, gp_Cone)
gp_Cone.YAxis = new_instancemethod(_gp.gp_Cone_YAxis, None, gp_Cone)
gp_Cone_swigregister = _gp.gp_Cone_swigregister
gp_Cone_swigregister(gp_Cone)

class gp_Cylinder(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * Returns the symmetry axis of the cylinder.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Cylinder_Axis(self, *args)


    def Coefficients(self, *args) -> "void":
        """
        * Computes the coefficients of the implicit equation of the quadric in the absolute cartesian coordinate system : A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) + 2.(C1.X + C2.Y + C3.Z) + D = 0.0
        	:param A1:
        	:type A1: float
        	:param A2:
        	:type A2: float
        	:param A3:
        	:type A3: float
        	:param B1:
        	:type B1: float
        	:param B2:
        	:type B2: float
        	:param B3:
        	:type B3: float
        	:param C1:
        	:type C1: float
        	:param C2:
        	:type C2: float
        	:param C3:
        	:type C3: float
        	:param D:
        	:type D: float
        	:rtype: None
        """
        return _gp.gp_Cylinder_Coefficients(self, *args)


    def Direct(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the local coordinate system of this cylinder is right-handed.
        	:rtype: bool
        """
        return _gp.gp_Cylinder_Direct(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the 'Location' point of the cylinder.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Cylinder_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Cylinder_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Cylinder":
        """
        * Performs the symmetrical transformation of a cylinder with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Cylinder
        * Performs the symmetrical transformation of a cylinder with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Cylinder
        * Performs the symmetrical transformation of a cylinder with respect to a plane. The axis placement A2 locates the plane of the of the symmetry : (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Cylinder
        """
        return _gp.gp_Cylinder_Mirrored(self, *args)


    def Position(self, *args) -> "gp_Ax3 const":
        """
        * Returns the local coordinate system of the cylinder.
        	:rtype: gp_Ax3
        """
        return _gp.gp_Cylinder_Position(self, *args)


    def Radius(self, *args) -> "Standard_Real":
        """
        * Returns the radius of the cylinder.
        	:rtype: float
        """
        return _gp.gp_Cylinder_Radius(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Cylinder_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Cylinder":
        """
        * Rotates a cylinder. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Cylinder
        """
        return _gp.gp_Cylinder_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Cylinder_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Cylinder":
        """
        * Scales a cylinder. S is the scaling value. The absolute value of S is used to scale the cylinder
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Cylinder
        """
        return _gp.gp_Cylinder_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Changes the symmetry axis of the cylinder. Raises ConstructionError if the direction of A1 is parallel to the 'XDirection' of the coordinate system of the cylinder.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Cylinder_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the location of the surface.
        	:param Loc:
        	:type Loc: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Cylinder_SetLocation(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Change the local coordinate system of the surface.
        	:param A3:
        	:type A3: gp_Ax3
        	:rtype: None
        """
        return _gp.gp_Cylinder_SetPosition(self, *args)


    def SetRadius(self, *args) -> "void":
        """
        * Modifies the radius of this cylinder. Exceptions Standard_ConstructionError if R is negative.
        	:param R:
        	:type R: float
        	:rtype: None
        """
        return _gp.gp_Cylinder_SetRadius(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Cylinder_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Cylinder":
        """
        * Transforms a cylinder with the transformation T from class Trsf.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Cylinder
        """
        return _gp.gp_Cylinder_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Cylinder_Translate(self, *args)


    def Translated(self, *args) -> "gp_Cylinder":
        """
        * Translates a cylinder in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Cylinder
        * Translates a cylinder from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Cylinder
        """
        return _gp.gp_Cylinder_Translated(self, *args)


    def UReverse(self, *args) -> "void":
        """
        * Reverses the U parametrization of the cylinder reversing the YAxis.
        	:rtype: None
        """
        return _gp.gp_Cylinder_UReverse(self, *args)


    def VReverse(self, *args) -> "void":
        """
        * Reverses the V parametrization of the plane reversing the Axis.
        	:rtype: None
        """
        return _gp.gp_Cylinder_VReverse(self, *args)


    def XAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the axis X of the cylinder.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Cylinder_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the axis Y of the cylinder.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Cylinder_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates a indefinite cylinder.
        	:rtype: None
        * Creates a cylinder of radius Radius, whose axis is the 'main Axis' of A3. A3 is the local coordinate system of the cylinder. Raises ConstructionErrord if R < 0.0
        	:param A3:
        	:type A3: gp_Ax3
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Cylinder_swiginit(self, _gp.new_gp_Cylinder(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Cylinder
gp_Cylinder.Axis = new_instancemethod(_gp.gp_Cylinder_Axis, None, gp_Cylinder)
gp_Cylinder.Coefficients = new_instancemethod(_gp.gp_Cylinder_Coefficients, None, gp_Cylinder)
gp_Cylinder.Direct = new_instancemethod(_gp.gp_Cylinder_Direct, None, gp_Cylinder)
gp_Cylinder.Location = new_instancemethod(_gp.gp_Cylinder_Location, None, gp_Cylinder)
gp_Cylinder.Mirror = new_instancemethod(_gp.gp_Cylinder_Mirror, None, gp_Cylinder)
gp_Cylinder.Mirrored = new_instancemethod(_gp.gp_Cylinder_Mirrored, None, gp_Cylinder)
gp_Cylinder.Position = new_instancemethod(_gp.gp_Cylinder_Position, None, gp_Cylinder)
gp_Cylinder.Radius = new_instancemethod(_gp.gp_Cylinder_Radius, None, gp_Cylinder)
gp_Cylinder.Rotate = new_instancemethod(_gp.gp_Cylinder_Rotate, None, gp_Cylinder)
gp_Cylinder.Rotated = new_instancemethod(_gp.gp_Cylinder_Rotated, None, gp_Cylinder)
gp_Cylinder.Scale = new_instancemethod(_gp.gp_Cylinder_Scale, None, gp_Cylinder)
gp_Cylinder.Scaled = new_instancemethod(_gp.gp_Cylinder_Scaled, None, gp_Cylinder)
gp_Cylinder.SetAxis = new_instancemethod(_gp.gp_Cylinder_SetAxis, None, gp_Cylinder)
gp_Cylinder.SetLocation = new_instancemethod(_gp.gp_Cylinder_SetLocation, None, gp_Cylinder)
gp_Cylinder.SetPosition = new_instancemethod(_gp.gp_Cylinder_SetPosition, None, gp_Cylinder)
gp_Cylinder.SetRadius = new_instancemethod(_gp.gp_Cylinder_SetRadius, None, gp_Cylinder)
gp_Cylinder.Transform = new_instancemethod(_gp.gp_Cylinder_Transform, None, gp_Cylinder)
gp_Cylinder.Transformed = new_instancemethod(_gp.gp_Cylinder_Transformed, None, gp_Cylinder)
gp_Cylinder.Translate = new_instancemethod(_gp.gp_Cylinder_Translate, None, gp_Cylinder)
gp_Cylinder.Translated = new_instancemethod(_gp.gp_Cylinder_Translated, None, gp_Cylinder)
gp_Cylinder.UReverse = new_instancemethod(_gp.gp_Cylinder_UReverse, None, gp_Cylinder)
gp_Cylinder.VReverse = new_instancemethod(_gp.gp_Cylinder_VReverse, None, gp_Cylinder)
gp_Cylinder.XAxis = new_instancemethod(_gp.gp_Cylinder_XAxis, None, gp_Cylinder)
gp_Cylinder.YAxis = new_instancemethod(_gp.gp_Cylinder_YAxis, None, gp_Cylinder)
gp_Cylinder_swigregister = _gp.gp_Cylinder_swigregister
gp_Cylinder_swigregister(gp_Cylinder)

class gp_Dir(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angular value in radians between <self> and <Other>. This value is always positive in 3D space. Returns the angle in the range [0, PI]
        	:param Other:
        	:type Other: gp_Dir
        	:rtype: float
        """
        return _gp.gp_Dir_Angle(self, *args)


    def AngleWithRef(self, *args) -> "Standard_Real":
        """
        * Computes the angular value between <self> and <Other>. <VRef> is the direction of reference normal to <self> and <Other> and its orientation gives the positive sense of rotation. If the cross product <self> ^ <Other> has the same orientation as <VRef> the angular value is positive else negative. Returns the angular value in the range -PI and PI (in radians). Raises DomainError if <self> and <Other> are not parallel this exception is raised when <VRef> is in the same plane as <self> and <Other> The tolerance criterion is Resolution from package gp.
        	:param Other:
        	:type Other: gp_Dir
        	:param VRef:
        	:type VRef: gp_Dir
        	:rtype: float
        """
        return _gp.gp_Dir_AngleWithRef(self, *args)


    def Coord(self, *args) -> "void":
        """
        * Returns the coordinate of range Index : Index = 1 => X is returned Index = 2 => Y is returned Index = 3 => Z is returned Exceptions Standard_OutOfRange if Index is not 1, 2, or 3.
        	:param Index:
        	:type Index: int
        	:rtype: float
        * Returns for the unit vector its three coordinates Xv, Yv, and Zv.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:param Zv:
        	:type Zv: float
        	:rtype: None
        """
        return _gp.gp_Dir_Coord(self, *args)


    def Cross(self, *args) -> "void":
        """
        * Computes the cross product between two directions Raises the exception ConstructionError if the two directions are parallel because the computed vector cannot be normalized to create a direction.
        	:param Right:
        	:type Right: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Dir_Cross(self, *args)


    def CrossCross(self, *args) -> "void":
        """
        :param V1:
        	:type V1: gp_Dir
        	:param V2:
        	:type V2: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Dir_CrossCross(self, *args)


    def CrossCrossed(self, *args) -> "gp_Dir":
        """
        * Computes the double vector product this ^ (V1 ^ V2). - CrossCrossed creates a new unit vector. Exceptions Standard_ConstructionError if: - V1 and V2 are parallel, or - this unit vector and (V1 ^ V2) are parallel. This is because, in these conditions, the computed vector is null and cannot be normalized.
        	:param V1:
        	:type V1: gp_Dir
        	:param V2:
        	:type V2: gp_Dir
        	:rtype: gp_Dir
        """
        return _gp.gp_Dir_CrossCrossed(self, *args)


    def Crossed(self, *args) -> "gp_Dir":
        """
        * Computes the triple vector product. <self> ^ (V1 ^ V2) Raises the exception ConstructionError if V1 and V2 are parallel or <self> and (V1^V2) are parallel because the computed vector can't be normalized to create a direction.
        	:param Right:
        	:type Right: gp_Dir
        	:rtype: gp_Dir
        """
        return _gp.gp_Dir_Crossed(self, *args)


    def Dot(self, *args) -> "Standard_Real":
        """
        * Computes the scalar product
        	:param Other:
        	:type Other: gp_Dir
        	:rtype: float
        """
        return _gp.gp_Dir_Dot(self, *args)


    def DotCross(self, *args) -> "Standard_Real":
        """
        * Computes the triple scalar product <self> * (V1 ^ V2). Warnings : The computed vector V1' = V1 ^ V2 is not normalized to create a unitary vector. So this method never raises an exception even if V1 and V2 are parallel.
        	:param V1:
        	:type V1: gp_Dir
        	:param V2:
        	:type V2: gp_Dir
        	:rtype: float
        """
        return _gp.gp_Dir_DotCross(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the angle between the two directions is lower or equal to AngularTolerance.
        	:param Other:
        	:type Other: gp_Dir
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Dir_IsEqual(self, *args)


    def IsNormal(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the angle between this unit vector and the unit vector Other is equal to Pi/2 (normal).
        	:param Other:
        	:type Other: gp_Dir
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Dir_IsNormal(self, *args)


    def IsOpposite(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the angle between this unit vector and the unit vector Other is equal to Pi (opposite).
        	:param Other:
        	:type Other: gp_Dir
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Dir_IsOpposite(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the angle between this unit vector and the unit vector Other is equal to 0 or to Pi. Note: the tolerance criterion is given by AngularTolerance.
        	:param Other:
        	:type Other: gp_Dir
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Dir_IsParallel(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Dir
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Dir_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Dir":
        """
        * Performs the symmetrical transformation of a direction with respect to the direction V which is the center of the symmetry.
        	:param V:
        	:type V: gp_Dir
        	:rtype: gp_Dir
        * Performs the symmetrical transformation of a direction with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Dir
        * Performs the symmetrical transformation of a direction with respect to a plane. The axis placement A2 locates the plane of the symmetry : (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Dir
        """
        return _gp.gp_Dir_Mirrored(self, *args)


    def Reverse(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Dir_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Dir":
        """
        * Reverses the orientation of a direction geometric transformations Performs the symmetrical transformation of a direction with respect to the direction V which is the center of the symmetry.]
        	:rtype: gp_Dir
        """
        return _gp.gp_Dir_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Dir_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Dir":
        """
        * Rotates a direction. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Dir
        """
        return _gp.gp_Dir_Rotated(self, *args)


    def SetCoord(self, *args) -> "void":
        """
        * For this unit vector, assigns the value Xi to: - the X coordinate if Index is 1, or - the Y coordinate if Index is 2, or - the Z coordinate if Index is 3, and then normalizes it. Warning Remember that all the coordinates of a unit vector are implicitly modified when any single one is changed directly. Exceptions Standard_OutOfRange if Index is not 1, 2, or 3. Standard_ConstructionError if either of the following is less than or equal to gp::Resolution(): - Sqrt(Xv*Xv + Yv*Yv + Zv*Zv), or - the modulus of the number triple formed by the new value Xi and the two other coordinates of this vector that were not directly modified.
        	:param Index:
        	:type Index: int
        	:param Xi:
        	:type Xi: float
        	:rtype: None
        * For this unit vector, assigns the values Xv, Yv and Zv to its three coordinates. Remember that all the coordinates of a unit vector are implicitly modified when any single one is changed directly.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:param Zv:
        	:type Zv: float
        	:rtype: None
        """
        return _gp.gp_Dir_SetCoord(self, *args)


    def SetX(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate of this unit vector.
        	:param X:
        	:type X: float
        	:rtype: None
        """
        return _gp.gp_Dir_SetX(self, *args)


    def SetXYZ(self, *args) -> "void":
        """
        * Assigns the three coordinates of Coord to this unit vector.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Dir_SetXYZ(self, *args)


    def SetY(self, *args) -> "void":
        """
        * Assigns the given value to the Y coordinate of this unit vector.
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_Dir_SetY(self, *args)


    def SetZ(self, *args) -> "void":
        """
        * Assigns the given value to the Z coordinate of this unit vector.
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        return _gp.gp_Dir_SetZ(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Dir_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Dir":
        """
        * Transforms a direction with a 'Trsf' from gp. Warnings : If the scale factor of the 'Trsf' T is negative then the direction <self> is reversed.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Dir
        """
        return _gp.gp_Dir_Transformed(self, *args)


    def X(self, *args) -> "Standard_Real":
        """
        * Returns the X coordinate for a unit vector.
        	:rtype: float
        """
        return _gp.gp_Dir_X(self, *args)


    def XYZ(self, *args) -> "gp_XYZ const":
        """
        * for this unit vector, returns its three coordinates as a number triplea.
        	:rtype: gp_XYZ
        """
        return _gp.gp_Dir_XYZ(self, *args)


    def Y(self, *args) -> "Standard_Real":
        """
        * Returns the Y coordinate for a unit vector.
        	:rtype: float
        """
        return _gp.gp_Dir_Y(self, *args)


    def Z(self, *args) -> "Standard_Real":
        """
        * Returns the Z coordinate for a unit vector.
        	:rtype: float
        """
        return _gp.gp_Dir_Z(self, *args)


    def __init__(self, *args):
        """
        * Creates a direction corresponding to X axis.
        	:rtype: None
        * Normalizes the vector V and creates a direction. Raises ConstructionError if V.Magnitude() <= Resolution.
        	:param V:
        	:type V: gp_Vec
        	:rtype: None
        * Creates a direction from a triplet of coordinates. Raises ConstructionError if Coord.Modulus() <= Resolution from gp.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        * Creates a direction with its 3 cartesian coordinates. Raises ConstructionError if Sqrt(Xv*Xv + Yv*Yv + Zv*Zv) <= Resolution Modification of the direction's coordinates If Sqrt (X*X + Y*Y + Z*Z) <= Resolution from gp where X, Y ,Z are the new coordinates it is not possible to construct the direction and the method raises the exception ConstructionError.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:param Zv:
        	:type Zv: float
        	:rtype: None
        """
        _gp.gp_Dir_swiginit(self, _gp.new_gp_Dir(*args))

    def __mul__(self, *args) -> "Standard_Real":
        """
        :param Other:
        	:type Other: gp_Dir
        	:rtype: float
        """
        return _gp.gp_Dir___mul__(self, *args)


    def __neg__(self, *args) -> "gp_Dir":
        """:rtype: gp_Dir"""
        return _gp.gp_Dir___neg__(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Dir
gp_Dir.Angle = new_instancemethod(_gp.gp_Dir_Angle, None, gp_Dir)
gp_Dir.AngleWithRef = new_instancemethod(_gp.gp_Dir_AngleWithRef, None, gp_Dir)
gp_Dir.Coord = new_instancemethod(_gp.gp_Dir_Coord, None, gp_Dir)
gp_Dir.Cross = new_instancemethod(_gp.gp_Dir_Cross, None, gp_Dir)
gp_Dir.CrossCross = new_instancemethod(_gp.gp_Dir_CrossCross, None, gp_Dir)
gp_Dir.CrossCrossed = new_instancemethod(_gp.gp_Dir_CrossCrossed, None, gp_Dir)
gp_Dir.Crossed = new_instancemethod(_gp.gp_Dir_Crossed, None, gp_Dir)
gp_Dir.Dot = new_instancemethod(_gp.gp_Dir_Dot, None, gp_Dir)
gp_Dir.DotCross = new_instancemethod(_gp.gp_Dir_DotCross, None, gp_Dir)
gp_Dir.IsEqual = new_instancemethod(_gp.gp_Dir_IsEqual, None, gp_Dir)
gp_Dir.IsNormal = new_instancemethod(_gp.gp_Dir_IsNormal, None, gp_Dir)
gp_Dir.IsOpposite = new_instancemethod(_gp.gp_Dir_IsOpposite, None, gp_Dir)
gp_Dir.IsParallel = new_instancemethod(_gp.gp_Dir_IsParallel, None, gp_Dir)
gp_Dir.Mirror = new_instancemethod(_gp.gp_Dir_Mirror, None, gp_Dir)
gp_Dir.Mirrored = new_instancemethod(_gp.gp_Dir_Mirrored, None, gp_Dir)
gp_Dir.Reverse = new_instancemethod(_gp.gp_Dir_Reverse, None, gp_Dir)
gp_Dir.Reversed = new_instancemethod(_gp.gp_Dir_Reversed, None, gp_Dir)
gp_Dir.Rotate = new_instancemethod(_gp.gp_Dir_Rotate, None, gp_Dir)
gp_Dir.Rotated = new_instancemethod(_gp.gp_Dir_Rotated, None, gp_Dir)
gp_Dir.SetCoord = new_instancemethod(_gp.gp_Dir_SetCoord, None, gp_Dir)
gp_Dir.SetX = new_instancemethod(_gp.gp_Dir_SetX, None, gp_Dir)
gp_Dir.SetXYZ = new_instancemethod(_gp.gp_Dir_SetXYZ, None, gp_Dir)
gp_Dir.SetY = new_instancemethod(_gp.gp_Dir_SetY, None, gp_Dir)
gp_Dir.SetZ = new_instancemethod(_gp.gp_Dir_SetZ, None, gp_Dir)
gp_Dir.Transform = new_instancemethod(_gp.gp_Dir_Transform, None, gp_Dir)
gp_Dir.Transformed = new_instancemethod(_gp.gp_Dir_Transformed, None, gp_Dir)
gp_Dir.X = new_instancemethod(_gp.gp_Dir_X, None, gp_Dir)
gp_Dir.XYZ = new_instancemethod(_gp.gp_Dir_XYZ, None, gp_Dir)
gp_Dir.Y = new_instancemethod(_gp.gp_Dir_Y, None, gp_Dir)
gp_Dir.Z = new_instancemethod(_gp.gp_Dir_Z, None, gp_Dir)
gp_Dir.__mul__ = new_instancemethod(_gp.gp_Dir___mul__, None, gp_Dir)
gp_Dir.__neg__ = new_instancemethod(_gp.gp_Dir___neg__, None, gp_Dir)
gp_Dir_swigregister = _gp.gp_Dir_swigregister
gp_Dir_swigregister(gp_Dir)

class gp_Dir2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angular value in radians between <self> and <Other>. Returns the angle in the range [-PI, PI].
        	:param Other:
        	:type Other: gp_Dir2d
        	:rtype: float
        """
        return _gp.gp_Dir2d_Angle(self, *args)


    def Coord(self, *args) -> "void":
        """
        * For this unit vector returns the coordinate of range Index : Index = 1 => X is returned Index = 2 => Y is returned Raises OutOfRange if Index != {1, 2}.
        	:param Index:
        	:type Index: int
        	:rtype: float
        * For this unit vector returns its two coordinates Xv and Yv. Raises OutOfRange if Index != {1, 2}.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:rtype: None
        """
        return _gp.gp_Dir2d_Coord(self, *args)


    def Crossed(self, *args) -> "Standard_Real":
        """
        * Computes the cross product between two directions.
        	:param Right:
        	:type Right: gp_Dir2d
        	:rtype: float
        """
        return _gp.gp_Dir2d_Crossed(self, *args)


    def Dot(self, *args) -> "Standard_Real":
        """
        * Computes the scalar product
        	:param Other:
        	:type Other: gp_Dir2d
        	:rtype: float
        """
        return _gp.gp_Dir2d_Dot(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the two vectors have the same direction i.e. the angle between this unit vector and the unit vector Other is less than or equal to AngularTolerance.
        	:param Other:
        	:type Other: gp_Dir2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Dir2d_IsEqual(self, *args)


    def IsNormal(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the angle between this unit vector and the unit vector Other is equal to Pi/2 or -Pi/2 (normal) i.e. Abs(Abs(<self>.Angle(Other)) - PI/2.) <= AngularTolerance
        	:param Other:
        	:type Other: gp_Dir2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Dir2d_IsNormal(self, *args)


    def IsOpposite(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the angle between this unit vector and the unit vector Other is equal to Pi or -Pi (opposite). i.e. PI - Abs(<self>.Angle(Other)) <= AngularTolerance
        	:param Other:
        	:type Other: gp_Dir2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Dir2d_IsOpposite(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * returns true if if the angle between this unit vector and unit vector Other is equal to 0, Pi or -Pi. i.e. Abs(Angle(<self>, Other)) <= AngularTolerance or PI - Abs(Angle(<self>, Other)) <= AngularTolerance
        	:param Other:
        	:type Other: gp_Dir2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Dir2d_IsParallel(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Dir2d
        	:rtype: None
        :param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Dir2d_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Dir2d":
        """
        * Performs the symmetrical transformation of a direction with respect to the direction V which is the center of the symmetry.
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: gp_Dir2d
        * Performs the symmetrical transformation of a direction with respect to an axis placement which is the axis of the symmetry.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: gp_Dir2d
        """
        return _gp.gp_Dir2d_Mirrored(self, *args)


    def Reverse(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Dir2d_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Dir2d":
        """
        * Reverses the orientation of a direction
        	:rtype: gp_Dir2d
        """
        return _gp.gp_Dir2d_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Dir2d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Dir2d":
        """
        * Rotates a direction. Ang is the angular value of the rotation in radians.
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Dir2d
        """
        return _gp.gp_Dir2d_Rotated(self, *args)


    def SetCoord(self, *args) -> "void":
        """
        * For this unit vector, assigns: the value Xi to: - the X coordinate if Index is 1, or - the Y coordinate if Index is 2, and then normalizes it. Warning Remember that all the coordinates of a unit vector are implicitly modified when any single one is changed directly. Exceptions Standard_OutOfRange if Index is not 1 or 2. Standard_ConstructionError if either of the following is less than or equal to gp::Resolution(): - Sqrt(Xv*Xv + Yv*Yv), or - the modulus of the number pair formed by the new value Xi and the other coordinate of this vector that was not directly modified. Raises OutOfRange if Index != {1, 2}.
        	:param Index:
        	:type Index: int
        	:param Xi:
        	:type Xi: float
        	:rtype: None
        * For this unit vector, assigns: - the values Xv and Yv to its two coordinates, Warning Remember that all the coordinates of a unit vector are implicitly modified when any single one is changed directly. Exceptions Standard_OutOfRange if Index is not 1 or 2. Standard_ConstructionError if either of the following is less than or equal to gp::Resolution(): - Sqrt(Xv*Xv + Yv*Yv), or - the modulus of the number pair formed by the new value Xi and the other coordinate of this vector that was not directly modified. Raises OutOfRange if Index != {1, 2}.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:rtype: None
        """
        return _gp.gp_Dir2d_SetCoord(self, *args)


    def SetX(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate of this unit vector, and then normalizes it. Warning Remember that all the coordinates of a unit vector are implicitly modified when any single one is changed directly. Exceptions Standard_ConstructionError if either of the following is less than or equal to gp::Resolution(): - the modulus of Coord, or - the modulus of the number pair formed from the new X or Y coordinate and the other coordinate of this vector that was not directly modified.
        	:param X:
        	:type X: float
        	:rtype: None
        """
        return _gp.gp_Dir2d_SetX(self, *args)


    def SetXY(self, *args) -> "void":
        """
        * Assigns: - the two coordinates of Coord to this unit vector, and then normalizes it. Warning Remember that all the coordinates of a unit vector are implicitly modified when any single one is changed directly. Exceptions Standard_ConstructionError if either of the following is less than or equal to gp::Resolution(): - the modulus of Coord, or - the modulus of the number pair formed from the new X or Y coordinate and the other coordinate of this vector that was not directly modified.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        """
        return _gp.gp_Dir2d_SetXY(self, *args)


    def SetY(self, *args) -> "void":
        """
        * Assigns the given value to the Y coordinate of this unit vector, and then normalizes it. Warning Remember that all the coordinates of a unit vector are implicitly modified when any single one is changed directly. Exceptions Standard_ConstructionError if either of the following is less than or equal to gp::Resolution(): - the modulus of Coord, or - the modulus of the number pair formed from the new X or Y coordinate and the other coordinate of this vector that was not directly modified.
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_Dir2d_SetY(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Dir2d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Dir2d":
        """
        * Transforms a direction with the 'Trsf' T. Warnings : If the scale factor of the 'Trsf' T is negative then the direction <self> is reversed.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Dir2d
        """
        return _gp.gp_Dir2d_Transformed(self, *args)


    def X(self, *args) -> "Standard_Real":
        """
        * For this unit vector, returns its X coordinate.
        	:rtype: float
        """
        return _gp.gp_Dir2d_X(self, *args)


    def XY(self, *args) -> "gp_XY const":
        """
        * For this unit vector, returns its two coordinates as a number pair. Comparison between Directions The precision value is an input data.
        	:rtype: gp_XY
        """
        return _gp.gp_Dir2d_XY(self, *args)


    def Y(self, *args) -> "Standard_Real":
        """
        * For this unit vector, returns its Y coordinate.
        	:rtype: float
        """
        return _gp.gp_Dir2d_Y(self, *args)


    def __init__(self, *args):
        """
        * Creates a direction corresponding to X axis.
        	:rtype: None
        * Normalizes the vector V and creates a Direction. Raises ConstructionError if V.Magnitude() <= Resolution from gp.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None
        * Creates a Direction from a doublet of coordinates. Raises ConstructionError if Coord.Modulus() <= Resolution from gp.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        * Creates a Direction with its 2 cartesian coordinates. Raises ConstructionError if Sqrt(Xv*Xv + Yv*Yv) <= Resolution from gp.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:rtype: None
        """
        _gp.gp_Dir2d_swiginit(self, _gp.new_gp_Dir2d(*args))

    def __mul__(self, *args) -> "Standard_Real":
        """
        :param Other:
        	:type Other: gp_Dir2d
        	:rtype: float
        """
        return _gp.gp_Dir2d___mul__(self, *args)


    def __neg__(self, *args) -> "gp_Dir2d":
        """:rtype: gp_Dir2d"""
        return _gp.gp_Dir2d___neg__(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Dir2d
gp_Dir2d.Angle = new_instancemethod(_gp.gp_Dir2d_Angle, None, gp_Dir2d)
gp_Dir2d.Coord = new_instancemethod(_gp.gp_Dir2d_Coord, None, gp_Dir2d)
gp_Dir2d.Crossed = new_instancemethod(_gp.gp_Dir2d_Crossed, None, gp_Dir2d)
gp_Dir2d.Dot = new_instancemethod(_gp.gp_Dir2d_Dot, None, gp_Dir2d)
gp_Dir2d.IsEqual = new_instancemethod(_gp.gp_Dir2d_IsEqual, None, gp_Dir2d)
gp_Dir2d.IsNormal = new_instancemethod(_gp.gp_Dir2d_IsNormal, None, gp_Dir2d)
gp_Dir2d.IsOpposite = new_instancemethod(_gp.gp_Dir2d_IsOpposite, None, gp_Dir2d)
gp_Dir2d.IsParallel = new_instancemethod(_gp.gp_Dir2d_IsParallel, None, gp_Dir2d)
gp_Dir2d.Mirror = new_instancemethod(_gp.gp_Dir2d_Mirror, None, gp_Dir2d)
gp_Dir2d.Mirrored = new_instancemethod(_gp.gp_Dir2d_Mirrored, None, gp_Dir2d)
gp_Dir2d.Reverse = new_instancemethod(_gp.gp_Dir2d_Reverse, None, gp_Dir2d)
gp_Dir2d.Reversed = new_instancemethod(_gp.gp_Dir2d_Reversed, None, gp_Dir2d)
gp_Dir2d.Rotate = new_instancemethod(_gp.gp_Dir2d_Rotate, None, gp_Dir2d)
gp_Dir2d.Rotated = new_instancemethod(_gp.gp_Dir2d_Rotated, None, gp_Dir2d)
gp_Dir2d.SetCoord = new_instancemethod(_gp.gp_Dir2d_SetCoord, None, gp_Dir2d)
gp_Dir2d.SetX = new_instancemethod(_gp.gp_Dir2d_SetX, None, gp_Dir2d)
gp_Dir2d.SetXY = new_instancemethod(_gp.gp_Dir2d_SetXY, None, gp_Dir2d)
gp_Dir2d.SetY = new_instancemethod(_gp.gp_Dir2d_SetY, None, gp_Dir2d)
gp_Dir2d.Transform = new_instancemethod(_gp.gp_Dir2d_Transform, None, gp_Dir2d)
gp_Dir2d.Transformed = new_instancemethod(_gp.gp_Dir2d_Transformed, None, gp_Dir2d)
gp_Dir2d.X = new_instancemethod(_gp.gp_Dir2d_X, None, gp_Dir2d)
gp_Dir2d.XY = new_instancemethod(_gp.gp_Dir2d_XY, None, gp_Dir2d)
gp_Dir2d.Y = new_instancemethod(_gp.gp_Dir2d_Y, None, gp_Dir2d)
gp_Dir2d.__mul__ = new_instancemethod(_gp.gp_Dir2d___mul__, None, gp_Dir2d)
gp_Dir2d.__neg__ = new_instancemethod(_gp.gp_Dir2d___neg__, None, gp_Dir2d)
gp_Dir2d_swigregister = _gp.gp_Dir2d_swigregister
gp_Dir2d_swigregister(gp_Dir2d)

class gp_Elips(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Area(self, *args) -> "Standard_Real":
        """
        * Computes the area of the Ellipse.
        	:rtype: float
        """
        return _gp.gp_Elips_Area(self, *args)


    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * Computes the axis normal to the plane of the ellipse.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Elips_Axis(self, *args)


    def Directrix1(self, *args) -> "gp_Ax1":
        """
        * Computes the first or second directrix of this ellipse. These are the lines, in the plane of the ellipse, normal to the major axis, at a distance equal to MajorRadius/e from the center of the ellipse, where e is the eccentricity of the ellipse. The first directrix (Directrix1) is on the positive side of the major axis. The second directrix (Directrix2) is on the negative side. The directrix is returned as an axis (gp_Ax1 object), the origin of which is situated on the 'X Axis' of the local coordinate system of this ellipse. Exceptions Standard_ConstructionError if the eccentricity is null (the ellipse has degenerated into a circle).
        	:rtype: gp_Ax1
        """
        return _gp.gp_Elips_Directrix1(self, *args)


    def Directrix2(self, *args) -> "gp_Ax1":
        """
        * This line is obtained by the symmetrical transformation of 'Directrix1' with respect to the 'YAxis' of the ellipse. Exceptions Standard_ConstructionError if the eccentricity is null (the ellipse has degenerated into a circle).
        	:rtype: gp_Ax1
        """
        return _gp.gp_Elips_Directrix2(self, *args)


    def Eccentricity(self, *args) -> "Standard_Real":
        """
        * Returns the eccentricity of the ellipse between 0.0 and 1.0 If f is the distance between the center of the ellipse and the Focus1 then the eccentricity e = f / MajorRadius. Raises ConstructionError if MajorRadius = 0.0
        	:rtype: float
        """
        return _gp.gp_Elips_Eccentricity(self, *args)


    def Focal(self, *args) -> "Standard_Real":
        """
        * Computes the focal distance. It is the distance between the two focus focus1 and focus2 of the ellipse.
        	:rtype: float
        """
        return _gp.gp_Elips_Focal(self, *args)


    def Focus1(self, *args) -> "gp_Pnt":
        """
        * Returns the first focus of the ellipse. This focus is on the positive side of the 'XAxis' of the ellipse.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Elips_Focus1(self, *args)


    def Focus2(self, *args) -> "gp_Pnt":
        """
        * Returns the second focus of the ellipse. This focus is on the negative side of the 'XAxis' of the ellipse.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Elips_Focus2(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the center of the ellipse. It is the 'Location' point of the coordinate system of the ellipse.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Elips_Location(self, *args)


    def MajorRadius(self, *args) -> "Standard_Real":
        """
        * Returns the major radius of the ellipse.
        	:rtype: float
        """
        return _gp.gp_Elips_MajorRadius(self, *args)


    def MinorRadius(self, *args) -> "Standard_Real":
        """
        * Returns the minor radius of the ellipse.
        	:rtype: float
        """
        return _gp.gp_Elips_MinorRadius(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Elips_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Elips":
        """
        * Performs the symmetrical transformation of an ellipse with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Elips
        * Performs the symmetrical transformation of an ellipse with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Elips
        * Performs the symmetrical transformation of an ellipse with respect to a plane. The axis placement A2 locates the plane of the symmetry (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Elips
        """
        return _gp.gp_Elips_Mirrored(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        * Returns p = (1 - e * e) * MajorRadius where e is the eccentricity of the ellipse. Returns 0 if MajorRadius = 0
        	:rtype: float
        """
        return _gp.gp_Elips_Parameter(self, *args)


    def Position(self, *args) -> "gp_Ax2 const":
        """
        * Returns the coordinate system of the ellipse.
        	:rtype: gp_Ax2
        """
        return _gp.gp_Elips_Position(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Elips_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Elips":
        """
        * Rotates an ellipse. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Elips
        """
        return _gp.gp_Elips_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Elips_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Elips":
        """
        * Scales an ellipse. S is the scaling value.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Elips
        """
        return _gp.gp_Elips_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Changes the axis normal to the plane of the ellipse. It modifies the definition of this plane. The 'XAxis' and the 'YAxis' are recomputed. The local coordinate system is redefined so that: - its origin and 'main Direction' become those of the axis A1 (the 'X Direction' and 'Y Direction' are then recomputed in the same way as for any gp_Ax2), or Raises ConstructionError if the direction of A1 is parallel to the direction of the 'XAxis' of the ellipse.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Elips_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Modifies this ellipse, by redefining its local coordinate so that its origin becomes P.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Elips_SetLocation(self, *args)


    def SetMajorRadius(self, *args) -> "void":
        """
        * The major radius of the ellipse is on the 'XAxis' (major axis) of the ellipse. Raises ConstructionError if MajorRadius < MinorRadius.
        	:param MajorRadius:
        	:type MajorRadius: float
        	:rtype: None
        """
        return _gp.gp_Elips_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args) -> "void":
        """
        * The minor radius of the ellipse is on the 'YAxis' (minor axis) of the ellipse. Raises ConstructionError if MinorRadius > MajorRadius or MinorRadius < 0.
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        return _gp.gp_Elips_SetMinorRadius(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Modifies this ellipse, by redefining its local coordinate so that it becomes A2e.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Elips_SetPosition(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Elips_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Elips":
        """
        * Transforms an ellipse with the transformation T from class Trsf.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Elips
        """
        return _gp.gp_Elips_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Elips_Translate(self, *args)


    def Translated(self, *args) -> "gp_Elips":
        """
        * Translates an ellipse in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Elips
        * Translates an ellipse from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Elips
        """
        return _gp.gp_Elips_Translated(self, *args)


    def XAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the 'XAxis' of the ellipse whose origin is the center of this ellipse. It is the major axis of the ellipse.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Elips_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the 'YAxis' of the ellipse whose unit vector is the 'X Direction' or the 'Y Direction' of the local coordinate system of this ellipse. This is the minor axis of the ellipse.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Elips_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates an indefinite ellipse.
        	:rtype: None
        * The major radius of the ellipse is on the 'XAxis' and the minor radius is on the 'YAxis' of the ellipse. The 'XAxis' is defined with the 'XDirection' of A2 and the 'YAxis' is defined with the 'YDirection' of A2. Warnings : It is not forbidden to create an ellipse with MajorRadius = MinorRadius. Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.
        	:param A2:
        	:type A2: gp_Ax2
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Elips_swiginit(self, _gp.new_gp_Elips(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Elips
gp_Elips.Area = new_instancemethod(_gp.gp_Elips_Area, None, gp_Elips)
gp_Elips.Axis = new_instancemethod(_gp.gp_Elips_Axis, None, gp_Elips)
gp_Elips.Directrix1 = new_instancemethod(_gp.gp_Elips_Directrix1, None, gp_Elips)
gp_Elips.Directrix2 = new_instancemethod(_gp.gp_Elips_Directrix2, None, gp_Elips)
gp_Elips.Eccentricity = new_instancemethod(_gp.gp_Elips_Eccentricity, None, gp_Elips)
gp_Elips.Focal = new_instancemethod(_gp.gp_Elips_Focal, None, gp_Elips)
gp_Elips.Focus1 = new_instancemethod(_gp.gp_Elips_Focus1, None, gp_Elips)
gp_Elips.Focus2 = new_instancemethod(_gp.gp_Elips_Focus2, None, gp_Elips)
gp_Elips.Location = new_instancemethod(_gp.gp_Elips_Location, None, gp_Elips)
gp_Elips.MajorRadius = new_instancemethod(_gp.gp_Elips_MajorRadius, None, gp_Elips)
gp_Elips.MinorRadius = new_instancemethod(_gp.gp_Elips_MinorRadius, None, gp_Elips)
gp_Elips.Mirror = new_instancemethod(_gp.gp_Elips_Mirror, None, gp_Elips)
gp_Elips.Mirrored = new_instancemethod(_gp.gp_Elips_Mirrored, None, gp_Elips)
gp_Elips.Parameter = new_instancemethod(_gp.gp_Elips_Parameter, None, gp_Elips)
gp_Elips.Position = new_instancemethod(_gp.gp_Elips_Position, None, gp_Elips)
gp_Elips.Rotate = new_instancemethod(_gp.gp_Elips_Rotate, None, gp_Elips)
gp_Elips.Rotated = new_instancemethod(_gp.gp_Elips_Rotated, None, gp_Elips)
gp_Elips.Scale = new_instancemethod(_gp.gp_Elips_Scale, None, gp_Elips)
gp_Elips.Scaled = new_instancemethod(_gp.gp_Elips_Scaled, None, gp_Elips)
gp_Elips.SetAxis = new_instancemethod(_gp.gp_Elips_SetAxis, None, gp_Elips)
gp_Elips.SetLocation = new_instancemethod(_gp.gp_Elips_SetLocation, None, gp_Elips)
gp_Elips.SetMajorRadius = new_instancemethod(_gp.gp_Elips_SetMajorRadius, None, gp_Elips)
gp_Elips.SetMinorRadius = new_instancemethod(_gp.gp_Elips_SetMinorRadius, None, gp_Elips)
gp_Elips.SetPosition = new_instancemethod(_gp.gp_Elips_SetPosition, None, gp_Elips)
gp_Elips.Transform = new_instancemethod(_gp.gp_Elips_Transform, None, gp_Elips)
gp_Elips.Transformed = new_instancemethod(_gp.gp_Elips_Transformed, None, gp_Elips)
gp_Elips.Translate = new_instancemethod(_gp.gp_Elips_Translate, None, gp_Elips)
gp_Elips.Translated = new_instancemethod(_gp.gp_Elips_Translated, None, gp_Elips)
gp_Elips.XAxis = new_instancemethod(_gp.gp_Elips_XAxis, None, gp_Elips)
gp_Elips.YAxis = new_instancemethod(_gp.gp_Elips_YAxis, None, gp_Elips)
gp_Elips_swigregister = _gp.gp_Elips_swigregister
gp_Elips_swigregister(gp_Elips)

class gp_Elips2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Area(self, *args) -> "Standard_Real":
        """
        * Computes the area of the ellipse.
        	:rtype: float
        """
        return _gp.gp_Elips2d_Area(self, *args)


    def Axis(self, *args) -> "gp_Ax22d const":
        """
        * Returns the major axis of the ellipse.
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Elips2d_Axis(self, *args)


    def Coefficients(self, *args) -> "void":
        """
        * Returns the coefficients of the implicit equation of the ellipse. A * (X**2) + B * (Y**2) + 2*C*(X*Y) + 2*D*X + 2*E*Y + F = 0.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param F:
        	:type F: float
        	:rtype: None
        """
        return _gp.gp_Elips2d_Coefficients(self, *args)


    def Directrix1(self, *args) -> "gp_Ax2d":
        """
        * This directrix is the line normal to the XAxis of the ellipse in the local plane (Z = 0) at a distance d = MajorRadius / e from the center of the ellipse, where e is the eccentricity of the ellipse. This line is parallel to the 'YAxis'. The intersection point between directrix1 and the 'XAxis' is the location point of the directrix1. This point is on the positive side of the 'XAxis'. //! Raised if Eccentricity = 0.0. (The ellipse degenerates into a circle)
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Elips2d_Directrix1(self, *args)


    def Directrix2(self, *args) -> "gp_Ax2d":
        """
        * This line is obtained by the symmetrical transformation of 'Directrix1' with respect to the minor axis of the ellipse. //! Raised if Eccentricity = 0.0. (The ellipse degenerates into a circle).
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Elips2d_Directrix2(self, *args)


    def Eccentricity(self, *args) -> "Standard_Real":
        """
        * Returns the eccentricity of the ellipse between 0.0 and 1.0 If f is the distance between the center of the ellipse and the Focus1 then the eccentricity e = f / MajorRadius. Returns 0 if MajorRadius = 0.
        	:rtype: float
        """
        return _gp.gp_Elips2d_Eccentricity(self, *args)


    def Focal(self, *args) -> "Standard_Real":
        """
        * Returns the distance between the center of the ellipse and focus1 or focus2.
        	:rtype: float
        """
        return _gp.gp_Elips2d_Focal(self, *args)


    def Focus1(self, *args) -> "gp_Pnt2d":
        """
        * Returns the first focus of the ellipse. This focus is on the positive side of the major axis of the ellipse.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Elips2d_Focus1(self, *args)


    def Focus2(self, *args) -> "gp_Pnt2d":
        """
        * Returns the second focus of the ellipse. This focus is on the negative side of the major axis of the ellipse.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Elips2d_Focus2(self, *args)


    def IsDirect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the local coordinate system is direct and false in the other case.
        	:rtype: bool
        """
        return _gp.gp_Elips2d_IsDirect(self, *args)


    def Location(self, *args) -> "gp_Pnt2d const":
        """
        * Returns the center of the ellipse.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Elips2d_Location(self, *args)


    def MajorRadius(self, *args) -> "Standard_Real":
        """
        * Returns the major radius of the Ellipse.
        	:rtype: float
        """
        return _gp.gp_Elips2d_MajorRadius(self, *args)


    def MinorRadius(self, *args) -> "Standard_Real":
        """
        * Returns the minor radius of the Ellipse.
        	:rtype: float
        """
        return _gp.gp_Elips2d_MinorRadius(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        :param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Elips2d_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Elips2d":
        """
        * Performs the symmetrical transformation of a ellipse with respect to the point P which is the center of the symmetry
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Elips2d
        * Performs the symmetrical transformation of a ellipse with respect to an axis placement which is the axis of the symmetry.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: gp_Elips2d
        """
        return _gp.gp_Elips2d_Mirrored(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        * Returns p = (1 - e * e) * MajorRadius where e is the eccentricity of the ellipse. Returns 0 if MajorRadius = 0
        	:rtype: float
        """
        return _gp.gp_Elips2d_Parameter(self, *args)


    def Reverse(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Elips2d_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Elips2d":
        """:rtype: gp_Elips2d"""
        return _gp.gp_Elips2d_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Elips2d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Elips2d":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Elips2d
        """
        return _gp.gp_Elips2d_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Elips2d_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Elips2d":
        """
        * Scales a ellipse. S is the scaling value.
        	:param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: gp_Elips2d
        """
        return _gp.gp_Elips2d_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Modifies this ellipse, by redefining its local coordinate system so that it becomes A.
        	:param A:
        	:type A: gp_Ax22d
        	:rtype: None
        """
        return _gp.gp_Elips2d_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Modifies this ellipse, by redefining its local coordinate system so that - its origin becomes P.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Elips2d_SetLocation(self, *args)


    def SetMajorRadius(self, *args) -> "void":
        """
        * Changes the value of the major radius. Raises ConstructionError if MajorRadius < MinorRadius.
        	:param MajorRadius:
        	:type MajorRadius: float
        	:rtype: None
        """
        return _gp.gp_Elips2d_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args) -> "void":
        """
        * Changes the value of the minor radius. Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.0
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        return _gp.gp_Elips2d_SetMinorRadius(self, *args)


    def SetXAxis(self, *args) -> "void":
        """
        * Modifies this ellipse, by redefining its local coordinate system so that its origin and its 'X Direction' become those of the axis A. The 'Y Direction' is then recomputed. The orientation of the local coordinate system is not modified.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Elips2d_SetXAxis(self, *args)


    def SetYAxis(self, *args) -> "void":
        """
        * Modifies this ellipse, by redefining its local coordinate system so that its origin and its 'Y Direction' become those of the axis A. The 'X Direction' is then recomputed. The orientation of the local coordinate system is not modified.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Elips2d_SetYAxis(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Elips2d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Elips2d":
        """
        * Transforms an ellipse with the transformation T from class Trsf2d.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Elips2d
        """
        return _gp.gp_Elips2d_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec2d
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Elips2d_Translate(self, *args)


    def Translated(self, *args) -> "gp_Elips2d":
        """
        * Translates a ellipse in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: gp_Elips2d
        * Translates a ellipse from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: gp_Elips2d
        """
        return _gp.gp_Elips2d_Translated(self, *args)


    def XAxis(self, *args) -> "gp_Ax2d":
        """
        * Returns the major axis of the ellipse.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Elips2d_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax2d":
        """
        * Returns the minor axis of the ellipse. Reverses the direction of the circle.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Elips2d_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates an indefinite ellipse.
        	:rtype: None
        * Creates an ellipse with the major axis, the major and the minor radius. The location of the MajorAxis is the center of the ellipse. The sense of parametrization is given by Sense. Warnings : It is possible to create an ellipse with MajorRadius = MinorRadius. Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.0
        	:param MajorAxis:
        	:type MajorAxis: gp_Ax2d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        * Creates an ellipse with radii MajorRadius and MinorRadius, positioned in the plane by coordinate system A where: - the origin of A is the center of the ellipse, - the 'X Direction' of A defines the major axis of the ellipse, that is, the major radius MajorRadius is measured along this axis, and - the 'Y Direction' of A defines the minor axis of the ellipse, that is, the minor radius MinorRadius is measured along this axis, and - the orientation (direct or indirect sense) of A gives the orientation of the ellipse. Warnings : It is possible to create an ellipse with MajorRadius = MinorRadius. Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.0
        	:param A:
        	:type A: gp_Ax22d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Elips2d_swiginit(self, _gp.new_gp_Elips2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Elips2d
gp_Elips2d.Area = new_instancemethod(_gp.gp_Elips2d_Area, None, gp_Elips2d)
gp_Elips2d.Axis = new_instancemethod(_gp.gp_Elips2d_Axis, None, gp_Elips2d)
gp_Elips2d.Coefficients = new_instancemethod(_gp.gp_Elips2d_Coefficients, None, gp_Elips2d)
gp_Elips2d.Directrix1 = new_instancemethod(_gp.gp_Elips2d_Directrix1, None, gp_Elips2d)
gp_Elips2d.Directrix2 = new_instancemethod(_gp.gp_Elips2d_Directrix2, None, gp_Elips2d)
gp_Elips2d.Eccentricity = new_instancemethod(_gp.gp_Elips2d_Eccentricity, None, gp_Elips2d)
gp_Elips2d.Focal = new_instancemethod(_gp.gp_Elips2d_Focal, None, gp_Elips2d)
gp_Elips2d.Focus1 = new_instancemethod(_gp.gp_Elips2d_Focus1, None, gp_Elips2d)
gp_Elips2d.Focus2 = new_instancemethod(_gp.gp_Elips2d_Focus2, None, gp_Elips2d)
gp_Elips2d.IsDirect = new_instancemethod(_gp.gp_Elips2d_IsDirect, None, gp_Elips2d)
gp_Elips2d.Location = new_instancemethod(_gp.gp_Elips2d_Location, None, gp_Elips2d)
gp_Elips2d.MajorRadius = new_instancemethod(_gp.gp_Elips2d_MajorRadius, None, gp_Elips2d)
gp_Elips2d.MinorRadius = new_instancemethod(_gp.gp_Elips2d_MinorRadius, None, gp_Elips2d)
gp_Elips2d.Mirror = new_instancemethod(_gp.gp_Elips2d_Mirror, None, gp_Elips2d)
gp_Elips2d.Mirrored = new_instancemethod(_gp.gp_Elips2d_Mirrored, None, gp_Elips2d)
gp_Elips2d.Parameter = new_instancemethod(_gp.gp_Elips2d_Parameter, None, gp_Elips2d)
gp_Elips2d.Reverse = new_instancemethod(_gp.gp_Elips2d_Reverse, None, gp_Elips2d)
gp_Elips2d.Reversed = new_instancemethod(_gp.gp_Elips2d_Reversed, None, gp_Elips2d)
gp_Elips2d.Rotate = new_instancemethod(_gp.gp_Elips2d_Rotate, None, gp_Elips2d)
gp_Elips2d.Rotated = new_instancemethod(_gp.gp_Elips2d_Rotated, None, gp_Elips2d)
gp_Elips2d.Scale = new_instancemethod(_gp.gp_Elips2d_Scale, None, gp_Elips2d)
gp_Elips2d.Scaled = new_instancemethod(_gp.gp_Elips2d_Scaled, None, gp_Elips2d)
gp_Elips2d.SetAxis = new_instancemethod(_gp.gp_Elips2d_SetAxis, None, gp_Elips2d)
gp_Elips2d.SetLocation = new_instancemethod(_gp.gp_Elips2d_SetLocation, None, gp_Elips2d)
gp_Elips2d.SetMajorRadius = new_instancemethod(_gp.gp_Elips2d_SetMajorRadius, None, gp_Elips2d)
gp_Elips2d.SetMinorRadius = new_instancemethod(_gp.gp_Elips2d_SetMinorRadius, None, gp_Elips2d)
gp_Elips2d.SetXAxis = new_instancemethod(_gp.gp_Elips2d_SetXAxis, None, gp_Elips2d)
gp_Elips2d.SetYAxis = new_instancemethod(_gp.gp_Elips2d_SetYAxis, None, gp_Elips2d)
gp_Elips2d.Transform = new_instancemethod(_gp.gp_Elips2d_Transform, None, gp_Elips2d)
gp_Elips2d.Transformed = new_instancemethod(_gp.gp_Elips2d_Transformed, None, gp_Elips2d)
gp_Elips2d.Translate = new_instancemethod(_gp.gp_Elips2d_Translate, None, gp_Elips2d)
gp_Elips2d.Translated = new_instancemethod(_gp.gp_Elips2d_Translated, None, gp_Elips2d)
gp_Elips2d.XAxis = new_instancemethod(_gp.gp_Elips2d_XAxis, None, gp_Elips2d)
gp_Elips2d.YAxis = new_instancemethod(_gp.gp_Elips2d_YAxis, None, gp_Elips2d)
gp_Elips2d_swigregister = _gp.gp_Elips2d_swigregister
gp_Elips2d_swigregister(gp_Elips2d)

class gp_GTrsf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Form(self, *args) -> "gp_TrsfForm":
        """
        * Returns the nature of the transformation. It can be an identity transformation, a rotation, a translation, a mirror transformation (relative to a point, an axis or a plane), a scaling transformation, a compound transformation or some other type of transformation.
        	:rtype: gp_TrsfForm
        """
        return _gp.gp_GTrsf_Form(self, *args)


    def Invert(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_GTrsf_Invert(self, *args)


    def Inverted(self, *args) -> "gp_GTrsf":
        """
        * Computes the reverse transformation. Raises an exception if the matrix of the transformation is not inversible.
        	:rtype: gp_GTrsf
        """
        return _gp.gp_GTrsf_Inverted(self, *args)


    def IsNegative(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the determinant of the vectorial part of this transformation is negative.
        	:rtype: bool
        """
        return _gp.gp_GTrsf_IsNegative(self, *args)


    def IsSingular(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this transformation is singular (and therefore, cannot be inverted). Note: The Gauss LU decomposition is used to invert the transformation matrix. Consequently, the transformation is considered as singular if the largest pivot found is less than or equal to gp::Resolution(). Warning If this transformation is singular, it cannot be inverted.
        	:rtype: bool
        """
        return _gp.gp_GTrsf_IsSingular(self, *args)


    def Multiplied(self, *args) -> "gp_GTrsf":
        """
        * Computes the transformation composed from T and <self>. In a C++ implementation you can also write Tcomposed = <self> * T. Example : GTrsf T1, T2, Tcomp; ............... //composition : Tcomp = T2.Multiplied(T1); // or (Tcomp = T2 * T1) // transformation of a point XYZ P(10.,3.,4.); XYZ P1(P); Tcomp.Transforms(P1); //using Tcomp XYZ P2(P); T1.Transforms(P2); //using T1 then T2 T2.Transforms(P2); // P1 = P2 !!!
        	:param T:
        	:type T: gp_GTrsf
        	:rtype: gp_GTrsf
        """
        return _gp.gp_GTrsf_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * Computes the transformation composed with <self> and T. <self> = <self> * T
        	:param T:
        	:type T: gp_GTrsf
        	:rtype: None
        """
        return _gp.gp_GTrsf_Multiply(self, *args)


    def Power(self, *args) -> "void":
        """
        :param N:
        	:type N: int
        	:rtype: None
        """
        return _gp.gp_GTrsf_Power(self, *args)


    def Powered(self, *args) -> "gp_GTrsf":
        """
        * Computes: - the product of this transformation multiplied by itself N times, if N is positive, or - the product of the inverse of this transformation multiplied by itself |N| times, if N is negative. If N equals zero, the result is equal to the Identity transformation. I.e.: <self> * <self> * .......* <self>, N time. if N =0 <self> = Identity if N < 0 <self> = <self>.Inverse() *...........* <self>.Inverse(). //! Raises an exception if N < 0 and if the matrix of the transformation not inversible.
        	:param N:
        	:type N: int
        	:rtype: gp_GTrsf
        """
        return _gp.gp_GTrsf_Powered(self, *args)


    def PreMultiply(self, *args) -> "void":
        """
        * Computes the product of the transformation T and this transformation and assigns the result to this transformation. this = T * this
        	:param T:
        	:type T: gp_GTrsf
        	:rtype: None
        """
        return _gp.gp_GTrsf_PreMultiply(self, *args)


    def SetAffinity(self, *args) -> "void":
        """
        * Changes this transformation into an affinity of ratio Ratio with respect to the axis A1. Note: an affinity is a point-by-point transformation that transforms any point P into a point P' such that if H is the orthogonal projection of P on the axis A1 or the plane A2, the vectors HP and HP' satisfy: HP' = Ratio * HP.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ratio:
        	:type Ratio: float
        	:rtype: None
        * Changes this transformation into an affinity of ratio Ratio with respect to the plane defined by the origin, the 'X Direction' and the 'Y Direction' of coordinate system A2. Note: an affinity is a point-by-point transformation that transforms any point P into a point P' such that if H is the orthogonal projection of P on the axis A1 or the plane A2, the vectors HP and HP' satisfy: HP' = Ratio * HP.
        	:param A2:
        	:type A2: gp_Ax2
        	:param Ratio:
        	:type Ratio: float
        	:rtype: None
        """
        return _gp.gp_GTrsf_SetAffinity(self, *args)


    def SetForm(self, *args) -> "void":
        """
        * verify and set the shape of the GTrsf Other or CompoundTrsf Ex : myGTrsf.SetValue(row1,col1,val1); myGTrsf.SetValue(row2,col2,val2); ... myGTrsf.SetForm();
        	:rtype: None
        """
        return _gp.gp_GTrsf_SetForm(self, *args)


    def SetTranslationPart(self, *args) -> "void":
        """
        * Replaces the translation part of this transformation by the coordinates of the number triple Coord.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_GTrsf_SetTranslationPart(self, *args)


    def SetTrsf(self, *args) -> "void":
        """
        * Assigns the vectorial and translation parts of T to this transformation.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_GTrsf_SetTrsf(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Replaces the coefficient (Row, Col) of the matrix representing this transformation by Value. Raises OutOfRange if Row < 1 or Row > 3 or Col < 1 or Col > 4
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:param Value:
        	:type Value: float
        	:rtype: None
        """
        return _gp.gp_GTrsf_SetValue(self, *args)


    def SetVectorialPart(self, *args) -> "void":
        """
        * Replaces the vectorial part of this transformation by Matrix.
        	:param Matrix:
        	:type Matrix: gp_Mat
        	:rtype: None
        """
        return _gp.gp_GTrsf_SetVectorialPart(self, *args)


    def Transforms(self, *args) -> "void":
        """
        :param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        * Transforms a triplet XYZ with a GTrsf.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        return _gp.gp_GTrsf_Transforms(self, *args)


    def TranslationPart(self, *args) -> "gp_XYZ const":
        """
        * Returns the translation part of the GTrsf.
        	:rtype: gp_XYZ
        """
        return _gp.gp_GTrsf_TranslationPart(self, *args)


    def Trsf(self, *args) -> "gp_Trsf":
        """:rtype: gp_Trsf"""
        return _gp.gp_GTrsf_Trsf(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * Returns the coefficients of the global matrix of transformation. Raises OutOfRange if Row < 1 or Row > 3 or Col < 1 or Col > 4
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:rtype: float
        """
        return _gp.gp_GTrsf_Value(self, *args)


    def VectorialPart(self, *args) -> "gp_Mat const":
        """
        * Computes the vectorial part of the GTrsf. The returned Matrix is a 3*3 matrix.
        	:rtype: gp_Mat
        """
        return _gp.gp_GTrsf_VectorialPart(self, *args)


    def __init__(self, *args):
        """
        * Returns the Identity transformation.
        	:rtype: None
        * Converts the gp_Trsf transformation T into a general transformation, i.e. Returns a GTrsf with the same matrix of coefficients as the Trsf T.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None
        * Creates a transformation based on the matrix M and the vector V where M defines the vectorial part of the transformation, and V the translation part, or
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_XYZ
        	:rtype: None
        """
        _gp.gp_GTrsf_swiginit(self, _gp.new_gp_GTrsf(*args))

    def __mul__(self, *args) -> "gp_GTrsf":
        """
        :param T:
        	:type T: gp_GTrsf
        	:rtype: gp_GTrsf
        """
        return _gp.gp_GTrsf___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_GTrsf
gp_GTrsf.Form = new_instancemethod(_gp.gp_GTrsf_Form, None, gp_GTrsf)
gp_GTrsf.Invert = new_instancemethod(_gp.gp_GTrsf_Invert, None, gp_GTrsf)
gp_GTrsf.Inverted = new_instancemethod(_gp.gp_GTrsf_Inverted, None, gp_GTrsf)
gp_GTrsf.IsNegative = new_instancemethod(_gp.gp_GTrsf_IsNegative, None, gp_GTrsf)
gp_GTrsf.IsSingular = new_instancemethod(_gp.gp_GTrsf_IsSingular, None, gp_GTrsf)
gp_GTrsf.Multiplied = new_instancemethod(_gp.gp_GTrsf_Multiplied, None, gp_GTrsf)
gp_GTrsf.Multiply = new_instancemethod(_gp.gp_GTrsf_Multiply, None, gp_GTrsf)
gp_GTrsf.Power = new_instancemethod(_gp.gp_GTrsf_Power, None, gp_GTrsf)
gp_GTrsf.Powered = new_instancemethod(_gp.gp_GTrsf_Powered, None, gp_GTrsf)
gp_GTrsf.PreMultiply = new_instancemethod(_gp.gp_GTrsf_PreMultiply, None, gp_GTrsf)
gp_GTrsf.SetAffinity = new_instancemethod(_gp.gp_GTrsf_SetAffinity, None, gp_GTrsf)
gp_GTrsf.SetForm = new_instancemethod(_gp.gp_GTrsf_SetForm, None, gp_GTrsf)
gp_GTrsf.SetTranslationPart = new_instancemethod(_gp.gp_GTrsf_SetTranslationPart, None, gp_GTrsf)
gp_GTrsf.SetTrsf = new_instancemethod(_gp.gp_GTrsf_SetTrsf, None, gp_GTrsf)
gp_GTrsf.SetValue = new_instancemethod(_gp.gp_GTrsf_SetValue, None, gp_GTrsf)
gp_GTrsf.SetVectorialPart = new_instancemethod(_gp.gp_GTrsf_SetVectorialPart, None, gp_GTrsf)
gp_GTrsf.Transforms = new_instancemethod(_gp.gp_GTrsf_Transforms, None, gp_GTrsf)
gp_GTrsf.TranslationPart = new_instancemethod(_gp.gp_GTrsf_TranslationPart, None, gp_GTrsf)
gp_GTrsf.Trsf = new_instancemethod(_gp.gp_GTrsf_Trsf, None, gp_GTrsf)
gp_GTrsf.Value = new_instancemethod(_gp.gp_GTrsf_Value, None, gp_GTrsf)
gp_GTrsf.VectorialPart = new_instancemethod(_gp.gp_GTrsf_VectorialPart, None, gp_GTrsf)
gp_GTrsf.__mul__ = new_instancemethod(_gp.gp_GTrsf___mul__, None, gp_GTrsf)
gp_GTrsf.__imul_wrapper__ = new_instancemethod(_gp.gp_GTrsf___imul_wrapper__, None, gp_GTrsf)
gp_GTrsf_swigregister = _gp.gp_GTrsf_swigregister
gp_GTrsf_swigregister(gp_GTrsf)

class gp_GTrsf2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Form(self, *args) -> "gp_TrsfForm":
        """
        * Returns the nature of the transformation. It can be an identity transformation, a rotation, a translation, a mirror transformation (relative to a point or axis), a scaling transformation, a compound transformation or some other type of transformation.
        	:rtype: gp_TrsfForm
        """
        return _gp.gp_GTrsf2d_Form(self, *args)


    def Invert(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_GTrsf2d_Invert(self, *args)


    def Inverted(self, *args) -> "gp_GTrsf2d":
        """
        * Computes the reverse transformation. Raised an exception if the matrix of the transformation is not inversible.
        	:rtype: gp_GTrsf2d
        """
        return _gp.gp_GTrsf2d_Inverted(self, *args)


    def IsNegative(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the determinant of the vectorial part of this transformation is negative.
        	:rtype: bool
        """
        return _gp.gp_GTrsf2d_IsNegative(self, *args)


    def IsSingular(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this transformation is singular (and therefore, cannot be inverted). Note: The Gauss LU decomposition is used to invert the transformation matrix. Consequently, the transformation is considered as singular if the largest pivot found is less than or equal to gp::Resolution(). Warning If this transformation is singular, it cannot be inverted.
        	:rtype: bool
        """
        return _gp.gp_GTrsf2d_IsSingular(self, *args)


    def Multiplied(self, *args) -> "gp_GTrsf2d":
        """
        * Computes the transformation composed with T and <self>. In a C++ implementation you can also write Tcomposed = <self> * T. Example : GTrsf2d T1, T2, Tcomp; ............... //composition : Tcomp = T2.Multiplied(T1); // or (Tcomp = T2 * T1) // transformation of a point XY P(10.,3.); XY P1(P); Tcomp.Transforms(P1); //using Tcomp XY P2(P); T1.Transforms(P2); //using T1 then T2 T2.Transforms(P2); // P1 = P2 !!!
        	:param T:
        	:type T: gp_GTrsf2d
        	:rtype: gp_GTrsf2d
        """
        return _gp.gp_GTrsf2d_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_GTrsf2d
        	:rtype: None
        """
        return _gp.gp_GTrsf2d_Multiply(self, *args)


    def Power(self, *args) -> "void":
        """
        :param N:
        	:type N: int
        	:rtype: None
        """
        return _gp.gp_GTrsf2d_Power(self, *args)


    def Powered(self, *args) -> "gp_GTrsf2d":
        """
        * Computes the following composition of transformations <self> * <self> * .......* <self>, N time. if N = 0 <self> = Identity if N < 0 <self> = <self>.Inverse() *...........* <self>.Inverse(). //! Raises an exception if N < 0 and if the matrix of the transformation is not inversible.
        	:param N:
        	:type N: int
        	:rtype: gp_GTrsf2d
        """
        return _gp.gp_GTrsf2d_Powered(self, *args)


    def PreMultiply(self, *args) -> "void":
        """
        * Computes the product of the transformation T and this transformation, and assigns the result to this transformation: this = T * this
        	:param T:
        	:type T: gp_GTrsf2d
        	:rtype: None
        """
        return _gp.gp_GTrsf2d_PreMultiply(self, *args)


    def SetAffinity(self, *args) -> "void":
        """
        * Changes this transformation into an affinity of ratio Ratio with respect to the axis A. Note: An affinity is a point-by-point transformation that transforms any point P into a point P' such that if H is the orthogonal projection of P on the axis A, the vectors HP and HP' satisfy: HP' = Ratio * HP.
        	:param A:
        	:type A: gp_Ax2d
        	:param Ratio:
        	:type Ratio: float
        	:rtype: None
        """
        return _gp.gp_GTrsf2d_SetAffinity(self, *args)


    def SetTranslationPart(self, *args) -> "void":
        """
        * Replacesthe translation part of this transformation by the coordinates of the number pair Coord.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        """
        return _gp.gp_GTrsf2d_SetTranslationPart(self, *args)


    def SetTrsf2d(self, *args) -> "void":
        """
        * Assigns the vectorial and translation parts of T to this transformation.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_GTrsf2d_SetTrsf2d(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Replaces the coefficient (Row, Col) of the matrix representing this transformation by Value, Raises OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 3
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:param Value:
        	:type Value: float
        	:rtype: None
        """
        return _gp.gp_GTrsf2d_SetValue(self, *args)


    def SetVectorialPart(self, *args) -> "void":
        """
        * Replaces the vectorial part of this transformation by Matrix.
        	:param Matrix:
        	:type Matrix: gp_Mat2d
        	:rtype: None
        """
        return _gp.gp_GTrsf2d_SetVectorialPart(self, *args)


    def Transformed(self, *args) -> "gp_XY":
        """
        :param Coord:
        	:type Coord: gp_XY
        	:rtype: gp_XY
        """
        return _gp.gp_GTrsf2d_Transformed(self, *args)


    def Transforms(self, *args) -> "void":
        """
        :param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        * Applies this transformation to the coordinates: - of the number pair Coord, or - X and Y. //! Note: - Transforms modifies X, Y, or the coordinate pair Coord, while - Transformed creates a new coordinate pair.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_GTrsf2d_Transforms(self, *args)


    def TranslationPart(self, *args) -> "gp_XY const":
        """
        * Returns the translation part of the GTrsf2d.
        	:rtype: gp_XY
        """
        return _gp.gp_GTrsf2d_TranslationPart(self, *args)


    def Trsf2d(self, *args) -> "gp_Trsf2d":
        """
        * Converts this transformation into a gp_Trsf2d transformation. Exceptions Standard_ConstructionError if this transformation cannot be converted, i.e. if its form is gp_Other.
        	:rtype: gp_Trsf2d
        """
        return _gp.gp_GTrsf2d_Trsf2d(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * Returns the coefficients of the global matrix of transformation. Raised OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 3
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:rtype: float
        """
        return _gp.gp_GTrsf2d_Value(self, *args)


    def VectorialPart(self, *args) -> "gp_Mat2d const":
        """
        * Computes the vectorial part of the GTrsf2d. The returned Matrix is a 2*2 matrix.
        	:rtype: gp_Mat2d
        """
        return _gp.gp_GTrsf2d_VectorialPart(self, *args)


    def __init__(self, *args):
        """
        * returns identity transformation.
        	:rtype: None
        * Converts the gp_Trsf2d transformation T into a general transformation.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        * Creates a transformation based on the matrix M and the vector V where M defines the vectorial part of the transformation, and V the translation part.
        	:param M:
        	:type M: gp_Mat2d
        	:param V:
        	:type V: gp_XY
        	:rtype: None
        """
        _gp.gp_GTrsf2d_swiginit(self, _gp.new_gp_GTrsf2d(*args))

    def __mul__(self, *args) -> "gp_GTrsf2d":
        """
        :param T:
        	:type T: gp_GTrsf2d
        	:rtype: gp_GTrsf2d
        """
        return _gp.gp_GTrsf2d___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_GTrsf2d
gp_GTrsf2d.Form = new_instancemethod(_gp.gp_GTrsf2d_Form, None, gp_GTrsf2d)
gp_GTrsf2d.Invert = new_instancemethod(_gp.gp_GTrsf2d_Invert, None, gp_GTrsf2d)
gp_GTrsf2d.Inverted = new_instancemethod(_gp.gp_GTrsf2d_Inverted, None, gp_GTrsf2d)
gp_GTrsf2d.IsNegative = new_instancemethod(_gp.gp_GTrsf2d_IsNegative, None, gp_GTrsf2d)
gp_GTrsf2d.IsSingular = new_instancemethod(_gp.gp_GTrsf2d_IsSingular, None, gp_GTrsf2d)
gp_GTrsf2d.Multiplied = new_instancemethod(_gp.gp_GTrsf2d_Multiplied, None, gp_GTrsf2d)
gp_GTrsf2d.Multiply = new_instancemethod(_gp.gp_GTrsf2d_Multiply, None, gp_GTrsf2d)
gp_GTrsf2d.Power = new_instancemethod(_gp.gp_GTrsf2d_Power, None, gp_GTrsf2d)
gp_GTrsf2d.Powered = new_instancemethod(_gp.gp_GTrsf2d_Powered, None, gp_GTrsf2d)
gp_GTrsf2d.PreMultiply = new_instancemethod(_gp.gp_GTrsf2d_PreMultiply, None, gp_GTrsf2d)
gp_GTrsf2d.SetAffinity = new_instancemethod(_gp.gp_GTrsf2d_SetAffinity, None, gp_GTrsf2d)
gp_GTrsf2d.SetTranslationPart = new_instancemethod(_gp.gp_GTrsf2d_SetTranslationPart, None, gp_GTrsf2d)
gp_GTrsf2d.SetTrsf2d = new_instancemethod(_gp.gp_GTrsf2d_SetTrsf2d, None, gp_GTrsf2d)
gp_GTrsf2d.SetValue = new_instancemethod(_gp.gp_GTrsf2d_SetValue, None, gp_GTrsf2d)
gp_GTrsf2d.SetVectorialPart = new_instancemethod(_gp.gp_GTrsf2d_SetVectorialPart, None, gp_GTrsf2d)
gp_GTrsf2d.Transformed = new_instancemethod(_gp.gp_GTrsf2d_Transformed, None, gp_GTrsf2d)
gp_GTrsf2d.Transforms = new_instancemethod(_gp.gp_GTrsf2d_Transforms, None, gp_GTrsf2d)
gp_GTrsf2d.TranslationPart = new_instancemethod(_gp.gp_GTrsf2d_TranslationPart, None, gp_GTrsf2d)
gp_GTrsf2d.Trsf2d = new_instancemethod(_gp.gp_GTrsf2d_Trsf2d, None, gp_GTrsf2d)
gp_GTrsf2d.Value = new_instancemethod(_gp.gp_GTrsf2d_Value, None, gp_GTrsf2d)
gp_GTrsf2d.VectorialPart = new_instancemethod(_gp.gp_GTrsf2d_VectorialPart, None, gp_GTrsf2d)
gp_GTrsf2d.__mul__ = new_instancemethod(_gp.gp_GTrsf2d___mul__, None, gp_GTrsf2d)
gp_GTrsf2d.__imul_wrapper__ = new_instancemethod(_gp.gp_GTrsf2d___imul_wrapper__, None, gp_GTrsf2d)
gp_GTrsf2d_swigregister = _gp.gp_GTrsf2d_swigregister
gp_GTrsf2d_swigregister(gp_GTrsf2d)

class gp_Hypr(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Asymptote1(self, *args) -> "gp_Ax1":
        """
        * In the local coordinate system of the hyperbola the equation of the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the equation of the first asymptote is Y = (B/A)*X where A is the major radius and B is the minor radius. Raises ConstructionError if MajorRadius = 0.0
        	:rtype: gp_Ax1
        """
        return _gp.gp_Hypr_Asymptote1(self, *args)


    def Asymptote2(self, *args) -> "gp_Ax1":
        """
        * In the local coordinate system of the hyperbola the equation of the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the equation of the first asymptote is Y = -(B/A)*X. where A is the major radius and B is the minor radius. Raises ConstructionError if MajorRadius = 0.0
        	:rtype: gp_Ax1
        """
        return _gp.gp_Hypr_Asymptote2(self, *args)


    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * Returns the axis passing through the center, and normal to the plane of this hyperbola.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Hypr_Axis(self, *args)


    def ConjugateBranch1(self, *args) -> "gp_Hypr":
        """
        * Computes the branch of hyperbola which is on the positive side of the 'YAxis' of <self>.
        	:rtype: gp_Hypr
        """
        return _gp.gp_Hypr_ConjugateBranch1(self, *args)


    def ConjugateBranch2(self, *args) -> "gp_Hypr":
        """
        * Computes the branch of hyperbola which is on the negative side of the 'YAxis' of <self>.
        	:rtype: gp_Hypr
        """
        return _gp.gp_Hypr_ConjugateBranch2(self, *args)


    def Directrix1(self, *args) -> "gp_Ax1":
        """
        * This directrix is the line normal to the XAxis of the hyperbola in the local plane (Z = 0) at a distance d = MajorRadius / e from the center of the hyperbola, where e is the eccentricity of the hyperbola. This line is parallel to the 'YAxis'. The intersection point between the directrix1 and the 'XAxis' is the 'Location' point of the directrix1. This point is on the positive side of the 'XAxis'.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Hypr_Directrix1(self, *args)


    def Directrix2(self, *args) -> "gp_Ax1":
        """
        * This line is obtained by the symmetrical transformation of 'Directrix1' with respect to the 'YAxis' of the hyperbola.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Hypr_Directrix2(self, *args)


    def Eccentricity(self, *args) -> "Standard_Real":
        """
        * Returns the excentricity of the hyperbola (e > 1). If f is the distance between the location of the hyperbola and the Focus1 then the eccentricity e = f / MajorRadius. Raises DomainError if MajorRadius = 0.0
        	:rtype: float
        """
        return _gp.gp_Hypr_Eccentricity(self, *args)


    def Focal(self, *args) -> "Standard_Real":
        """
        * Computes the focal distance. It is the distance between the the two focus of the hyperbola.
        	:rtype: float
        """
        return _gp.gp_Hypr_Focal(self, *args)


    def Focus1(self, *args) -> "gp_Pnt":
        """
        * Returns the first focus of the hyperbola. This focus is on the positive side of the 'XAxis' of the hyperbola.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Hypr_Focus1(self, *args)


    def Focus2(self, *args) -> "gp_Pnt":
        """
        * Returns the second focus of the hyperbola. This focus is on the negative side of the 'XAxis' of the hyperbola.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Hypr_Focus2(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the location point of the hyperbola. It is the intersection point between the 'XAxis' and the 'YAxis'.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Hypr_Location(self, *args)


    def MajorRadius(self, *args) -> "Standard_Real":
        """
        * Returns the major radius of the hyperbola. It is the radius on the 'XAxis' of the hyperbola.
        	:rtype: float
        """
        return _gp.gp_Hypr_MajorRadius(self, *args)


    def MinorRadius(self, *args) -> "Standard_Real":
        """
        * Returns the minor radius of the hyperbola. It is the radius on the 'YAxis' of the hyperbola.
        	:rtype: float
        """
        return _gp.gp_Hypr_MinorRadius(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Hypr_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Hypr":
        """
        * Performs the symmetrical transformation of an hyperbola with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Hypr
        * Performs the symmetrical transformation of an hyperbola with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Hypr
        * Performs the symmetrical transformation of an hyperbola with respect to a plane. The axis placement A2 locates the plane of the symmetry (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Hypr
        """
        return _gp.gp_Hypr_Mirrored(self, *args)


    def OtherBranch(self, *args) -> "gp_Hypr":
        """
        * Returns the branch of hyperbola obtained by doing the symmetrical transformation of <self> with respect to the 'YAxis' of <self>.
        	:rtype: gp_Hypr
        """
        return _gp.gp_Hypr_OtherBranch(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        * Returns p = (e * e - 1) * MajorRadius where e is the eccentricity of the hyperbola. Raises DomainError if MajorRadius = 0.0
        	:rtype: float
        """
        return _gp.gp_Hypr_Parameter(self, *args)


    def Position(self, *args) -> "gp_Ax2 const":
        """
        * Returns the coordinate system of the hyperbola.
        	:rtype: gp_Ax2
        """
        return _gp.gp_Hypr_Position(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Hypr_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Hypr":
        """
        * Rotates an hyperbola. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Hypr
        """
        return _gp.gp_Hypr_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Hypr_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Hypr":
        """
        * Scales an hyperbola. S is the scaling value.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Hypr
        """
        return _gp.gp_Hypr_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Modifies this hyperbola, by redefining its local coordinate system so that: - its origin and 'main Direction' become those of the axis A1 (the 'X Direction' and 'Y Direction' are then recomputed in the same way as for any gp_Ax2). Raises ConstructionError if the direction of A1 is parallel to the direction of the 'XAxis' of the hyperbola.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Hypr_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Modifies this hyperbola, by redefining its local coordinate system so that its origin becomes P.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Hypr_SetLocation(self, *args)


    def SetMajorRadius(self, *args) -> "void":
        """
        * Modifies the major radius of this hyperbola. Exceptions Standard_ConstructionError if MajorRadius is negative.
        	:param MajorRadius:
        	:type MajorRadius: float
        	:rtype: None
        """
        return _gp.gp_Hypr_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args) -> "void":
        """
        * Modifies the minor radius of this hyperbola. Exceptions Standard_ConstructionError if MinorRadius is negative.
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        return _gp.gp_Hypr_SetMinorRadius(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Modifies this hyperbola, by redefining its local coordinate system so that it becomes A2.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Hypr_SetPosition(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Hypr_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Hypr":
        """
        * Transforms an hyperbola with the transformation T from class Trsf.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Hypr
        """
        return _gp.gp_Hypr_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Hypr_Translate(self, *args)


    def Translated(self, *args) -> "gp_Hypr":
        """
        * Translates an hyperbola in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Hypr
        * Translates an hyperbola from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Hypr
        """
        return _gp.gp_Hypr_Translated(self, *args)


    def XAxis(self, *args) -> "gp_Ax1":
        """
        * Computes an axis, whose - the origin is the center of this hyperbola, and - the unit vector is the 'X Direction' of the local coordinate system of this hyperbola. These axes are, the major axis (the 'X Axis') and of this hyperboReturns the 'XAxis' of the hyperbola.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Hypr_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax1":
        """
        * Computes an axis, whose - the origin is the center of this hyperbola, and - the unit vector is the 'Y Direction' of the local coordinate system of this hyperbola. These axes are the minor axis (the 'Y Axis') of this hyperbola
        	:rtype: gp_Ax1
        """
        return _gp.gp_Hypr_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates of an indefinite hyperbola.
        	:rtype: None
        * Creates a hyperbola with radii MajorRadius and MinorRadius, positioned in the space by the coordinate system A2 such that: - the origin of A2 is the center of the hyperbola, - the 'X Direction' of A2 defines the major axis of the hyperbola, that is, the major radius MajorRadius is measured along this axis, and - the 'Y Direction' of A2 defines the minor axis of the hyperbola, that is, the minor radius MinorRadius is measured along this axis. Note: This class does not prevent the creation of a hyperbola where: - MajorAxis is equal to MinorAxis, or - MajorAxis is less than MinorAxis. Exceptions Standard_ConstructionError if MajorAxis or MinorAxis is negative. Raises ConstructionError if MajorRadius < 0.0 or MinorRadius < 0.0 Raised if MajorRadius < 0.0 or MinorRadius < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Hypr_swiginit(self, _gp.new_gp_Hypr(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Hypr
gp_Hypr.Asymptote1 = new_instancemethod(_gp.gp_Hypr_Asymptote1, None, gp_Hypr)
gp_Hypr.Asymptote2 = new_instancemethod(_gp.gp_Hypr_Asymptote2, None, gp_Hypr)
gp_Hypr.Axis = new_instancemethod(_gp.gp_Hypr_Axis, None, gp_Hypr)
gp_Hypr.ConjugateBranch1 = new_instancemethod(_gp.gp_Hypr_ConjugateBranch1, None, gp_Hypr)
gp_Hypr.ConjugateBranch2 = new_instancemethod(_gp.gp_Hypr_ConjugateBranch2, None, gp_Hypr)
gp_Hypr.Directrix1 = new_instancemethod(_gp.gp_Hypr_Directrix1, None, gp_Hypr)
gp_Hypr.Directrix2 = new_instancemethod(_gp.gp_Hypr_Directrix2, None, gp_Hypr)
gp_Hypr.Eccentricity = new_instancemethod(_gp.gp_Hypr_Eccentricity, None, gp_Hypr)
gp_Hypr.Focal = new_instancemethod(_gp.gp_Hypr_Focal, None, gp_Hypr)
gp_Hypr.Focus1 = new_instancemethod(_gp.gp_Hypr_Focus1, None, gp_Hypr)
gp_Hypr.Focus2 = new_instancemethod(_gp.gp_Hypr_Focus2, None, gp_Hypr)
gp_Hypr.Location = new_instancemethod(_gp.gp_Hypr_Location, None, gp_Hypr)
gp_Hypr.MajorRadius = new_instancemethod(_gp.gp_Hypr_MajorRadius, None, gp_Hypr)
gp_Hypr.MinorRadius = new_instancemethod(_gp.gp_Hypr_MinorRadius, None, gp_Hypr)
gp_Hypr.Mirror = new_instancemethod(_gp.gp_Hypr_Mirror, None, gp_Hypr)
gp_Hypr.Mirrored = new_instancemethod(_gp.gp_Hypr_Mirrored, None, gp_Hypr)
gp_Hypr.OtherBranch = new_instancemethod(_gp.gp_Hypr_OtherBranch, None, gp_Hypr)
gp_Hypr.Parameter = new_instancemethod(_gp.gp_Hypr_Parameter, None, gp_Hypr)
gp_Hypr.Position = new_instancemethod(_gp.gp_Hypr_Position, None, gp_Hypr)
gp_Hypr.Rotate = new_instancemethod(_gp.gp_Hypr_Rotate, None, gp_Hypr)
gp_Hypr.Rotated = new_instancemethod(_gp.gp_Hypr_Rotated, None, gp_Hypr)
gp_Hypr.Scale = new_instancemethod(_gp.gp_Hypr_Scale, None, gp_Hypr)
gp_Hypr.Scaled = new_instancemethod(_gp.gp_Hypr_Scaled, None, gp_Hypr)
gp_Hypr.SetAxis = new_instancemethod(_gp.gp_Hypr_SetAxis, None, gp_Hypr)
gp_Hypr.SetLocation = new_instancemethod(_gp.gp_Hypr_SetLocation, None, gp_Hypr)
gp_Hypr.SetMajorRadius = new_instancemethod(_gp.gp_Hypr_SetMajorRadius, None, gp_Hypr)
gp_Hypr.SetMinorRadius = new_instancemethod(_gp.gp_Hypr_SetMinorRadius, None, gp_Hypr)
gp_Hypr.SetPosition = new_instancemethod(_gp.gp_Hypr_SetPosition, None, gp_Hypr)
gp_Hypr.Transform = new_instancemethod(_gp.gp_Hypr_Transform, None, gp_Hypr)
gp_Hypr.Transformed = new_instancemethod(_gp.gp_Hypr_Transformed, None, gp_Hypr)
gp_Hypr.Translate = new_instancemethod(_gp.gp_Hypr_Translate, None, gp_Hypr)
gp_Hypr.Translated = new_instancemethod(_gp.gp_Hypr_Translated, None, gp_Hypr)
gp_Hypr.XAxis = new_instancemethod(_gp.gp_Hypr_XAxis, None, gp_Hypr)
gp_Hypr.YAxis = new_instancemethod(_gp.gp_Hypr_YAxis, None, gp_Hypr)
gp_Hypr_swigregister = _gp.gp_Hypr_swigregister
gp_Hypr_swigregister(gp_Hypr)

class gp_Hypr2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Asymptote1(self, *args) -> "gp_Ax2d":
        """
        * In the local coordinate system of the hyperbola the equation of the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the equation of the first asymptote is Y = (B/A)*X where A is the major radius of the hyperbola and B the minor radius of the hyperbola. Raises ConstructionError if MajorRadius = 0.0
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Hypr2d_Asymptote1(self, *args)


    def Asymptote2(self, *args) -> "gp_Ax2d":
        """
        * In the local coordinate system of the hyperbola the equation of the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the equation of the first asymptote is Y = -(B/A)*X where A is the major radius of the hyperbola and B the minor radius of the hyperbola. Raises ConstructionError if MajorRadius = 0.0
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Hypr2d_Asymptote2(self, *args)


    def Axis(self, *args) -> "gp_Ax22d const":
        """
        * Returns the axisplacement of the hyperbola.
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Hypr2d_Axis(self, *args)


    def Coefficients(self, *args) -> "void":
        """
        * Computes the coefficients of the implicit equation of the hyperbola : A * (X**2) + B * (Y**2) + 2*C*(X*Y) + 2*D*X + 2*E*Y + F = 0.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param F:
        	:type F: float
        	:rtype: None
        """
        return _gp.gp_Hypr2d_Coefficients(self, *args)


    def ConjugateBranch1(self, *args) -> "gp_Hypr2d":
        """
        * Computes the branch of hyperbola which is on the positive side of the 'YAxis' of <self>.
        	:rtype: gp_Hypr2d
        """
        return _gp.gp_Hypr2d_ConjugateBranch1(self, *args)


    def ConjugateBranch2(self, *args) -> "gp_Hypr2d":
        """
        * Computes the branch of hyperbola which is on the negative side of the 'YAxis' of <self>.
        	:rtype: gp_Hypr2d
        """
        return _gp.gp_Hypr2d_ConjugateBranch2(self, *args)


    def Directrix1(self, *args) -> "gp_Ax2d":
        """
        * Computes the directrix which is the line normal to the XAxis of the hyperbola in the local plane (Z = 0) at a distance d = MajorRadius / e from the center of the hyperbola, where e is the eccentricity of the hyperbola. This line is parallel to the 'YAxis'. The intersection point between the 'Directrix1' and the 'XAxis' is the 'Location' point of the 'Directrix1'. This point is on the positive side of the 'XAxis'.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Hypr2d_Directrix1(self, *args)


    def Directrix2(self, *args) -> "gp_Ax2d":
        """
        * This line is obtained by the symmetrical transformation of 'Directrix1' with respect to the 'YAxis' of the hyperbola.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Hypr2d_Directrix2(self, *args)


    def Eccentricity(self, *args) -> "Standard_Real":
        """
        * Returns the excentricity of the hyperbola (e > 1). If f is the distance between the location of the hyperbola and the Focus1 then the eccentricity e = f / MajorRadius. Raises DomainError if MajorRadius = 0.0.
        	:rtype: float
        """
        return _gp.gp_Hypr2d_Eccentricity(self, *args)


    def Focal(self, *args) -> "Standard_Real":
        """
        * Computes the focal distance. It is the distance between the 'Location' of the hyperbola and 'Focus1' or 'Focus2'.
        	:rtype: float
        """
        return _gp.gp_Hypr2d_Focal(self, *args)


    def Focus1(self, *args) -> "gp_Pnt2d":
        """
        * Returns the first focus of the hyperbola. This focus is on the positive side of the 'XAxis' of the hyperbola.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Hypr2d_Focus1(self, *args)


    def Focus2(self, *args) -> "gp_Pnt2d":
        """
        * Returns the second focus of the hyperbola. This focus is on the negative side of the 'XAxis' of the hyperbola.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Hypr2d_Focus2(self, *args)


    def IsDirect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the local coordinate system is direct and false in the other case.
        	:rtype: bool
        """
        return _gp.gp_Hypr2d_IsDirect(self, *args)


    def Location(self, *args) -> "gp_Pnt2d const":
        """
        * Returns the location point of the hyperbola. It is the intersection point between the 'XAxis' and the 'YAxis'.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Hypr2d_Location(self, *args)


    def MajorRadius(self, *args) -> "Standard_Real":
        """
        * Returns the major radius of the hyperbola (it is the radius corresponding to the 'XAxis' of the hyperbola).
        	:rtype: float
        """
        return _gp.gp_Hypr2d_MajorRadius(self, *args)


    def MinorRadius(self, *args) -> "Standard_Real":
        """
        * Returns the minor radius of the hyperbola (it is the radius corresponding to the 'YAxis' of the hyperbola).
        	:rtype: float
        """
        return _gp.gp_Hypr2d_MinorRadius(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        :param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Hypr2d_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Hypr2d":
        """
        * Performs the symmetrical transformation of an hyperbola with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Hypr2d
        * Performs the symmetrical transformation of an hyperbola with respect to an axis placement which is the axis of the symmetry.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: gp_Hypr2d
        """
        return _gp.gp_Hypr2d_Mirrored(self, *args)


    def OtherBranch(self, *args) -> "gp_Hypr2d":
        """
        * Returns the branch of hyperbola obtained by doing the symmetrical transformation of <self> with respect to the 'YAxis' of <self>.
        	:rtype: gp_Hypr2d
        """
        return _gp.gp_Hypr2d_OtherBranch(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        * Returns p = (e * e - 1) * MajorRadius where e is the eccentricity of the hyperbola. Raises DomainError if MajorRadius = 0.0
        	:rtype: float
        """
        return _gp.gp_Hypr2d_Parameter(self, *args)


    def Reverse(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Hypr2d_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Hypr2d":
        """
        * Reverses the orientation of the local coordinate system of this hyperbola (the 'Y Axis' is reversed). Therefore, the implicit orientation of this hyperbola is reversed. Note: - Reverse assigns the result to this hyperbola, while - Reversed creates a new one.
        	:rtype: gp_Hypr2d
        """
        return _gp.gp_Hypr2d_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Hypr2d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Hypr2d":
        """
        * Rotates an hyperbola. P is the center of the rotation. Ang is the angular value of the rotation in radians.
        	:param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Hypr2d
        """
        return _gp.gp_Hypr2d_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Hypr2d_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Hypr2d":
        """
        * Scales an hyperbola. <S> is the scaling value. If <S> is positive only the location point is modified. But if <S> is negative the 'XAxis' is reversed and the 'YAxis' too.
        	:param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: gp_Hypr2d
        """
        return _gp.gp_Hypr2d_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Modifies this hyperbola, by redefining its local coordinate system so that it becomes A.
        	:param A:
        	:type A: gp_Ax22d
        	:rtype: None
        """
        return _gp.gp_Hypr2d_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Modifies this hyperbola, by redefining its local coordinate system so that its origin becomes P.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Hypr2d_SetLocation(self, *args)


    def SetMajorRadius(self, *args) -> "void":
        """
        * Modifies the major or minor radius of this hyperbola. Exceptions Standard_ConstructionError if MajorRadius or MinorRadius is negative.
        	:param MajorRadius:
        	:type MajorRadius: float
        	:rtype: None
        """
        return _gp.gp_Hypr2d_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args) -> "void":
        """
        * Modifies the major or minor radius of this hyperbola. Exceptions Standard_ConstructionError if MajorRadius or MinorRadius is negative.
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        return _gp.gp_Hypr2d_SetMinorRadius(self, *args)


    def SetXAxis(self, *args) -> "void":
        """
        * Changes the major axis of the hyperbola. The minor axis is recomputed and the location of the hyperbola too.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Hypr2d_SetXAxis(self, *args)


    def SetYAxis(self, *args) -> "void":
        """
        * Changes the minor axis of the hyperbola.The minor axis is recomputed and the location of the hyperbola too.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Hypr2d_SetYAxis(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Hypr2d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Hypr2d":
        """
        * Transforms an hyperbola with the transformation T from class Trsf2d.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Hypr2d
        """
        return _gp.gp_Hypr2d_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec2d
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Hypr2d_Translate(self, *args)


    def Translated(self, *args) -> "gp_Hypr2d":
        """
        * Translates an hyperbola in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: gp_Hypr2d
        * Translates an hyperbola from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: gp_Hypr2d
        """
        return _gp.gp_Hypr2d_Translated(self, *args)


    def XAxis(self, *args) -> "gp_Ax2d":
        """
        * Computes an axis whose - the origin is the center of this hyperbola, and - the unit vector is the 'X Direction' or 'Y Direction' respectively of the local coordinate system of this hyperbola Returns the major axis of the hyperbola.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Hypr2d_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax2d":
        """
        * Computes an axis whose - the origin is the center of this hyperbola, and - the unit vector is the 'X Direction' or 'Y Direction' respectively of the local coordinate system of this hyperbola Returns the minor axis of the hyperbola.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Hypr2d_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates of an indefinite hyperbola.
        	:rtype: None
        * Creates a hyperbola with radii MajorRadius and MinorRadius, centered on the origin of MajorAxis and where the unit vector of MajorAxis is the 'X Direction' of the local coordinate system of the hyperbola. This coordinate system is direct if Sense is true (the default value), and indirect if Sense is false. Warnings : It is yet possible to create an Hyperbola with MajorRadius <= MinorRadius. Raises ConstructionError if MajorRadius < 0.0 or MinorRadius < 0.0
        	:param MajorAxis:
        	:type MajorAxis: gp_Ax2d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        * a hyperbola with radii MajorRadius and MinorRadius, positioned in the plane by coordinate system A where: - the origin of A is the center of the hyperbola, - the 'X Direction' of A defines the major axis of the hyperbola, that is, the major radius MajorRadius is measured along this axis, and - the 'Y Direction' of A defines the minor axis of the hyperbola, that is, the minor radius MinorRadius is measured along this axis, and - the orientation (direct or indirect sense) of A gives the implicit orientation of the hyperbola. Warnings : It is yet possible to create an Hyperbola with MajorRadius <= MinorRadius. Raises ConstructionError if MajorRadius < 0.0 or MinorRadius < 0.0
        	:param A:
        	:type A: gp_Ax22d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Hypr2d_swiginit(self, _gp.new_gp_Hypr2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Hypr2d
gp_Hypr2d.Asymptote1 = new_instancemethod(_gp.gp_Hypr2d_Asymptote1, None, gp_Hypr2d)
gp_Hypr2d.Asymptote2 = new_instancemethod(_gp.gp_Hypr2d_Asymptote2, None, gp_Hypr2d)
gp_Hypr2d.Axis = new_instancemethod(_gp.gp_Hypr2d_Axis, None, gp_Hypr2d)
gp_Hypr2d.Coefficients = new_instancemethod(_gp.gp_Hypr2d_Coefficients, None, gp_Hypr2d)
gp_Hypr2d.ConjugateBranch1 = new_instancemethod(_gp.gp_Hypr2d_ConjugateBranch1, None, gp_Hypr2d)
gp_Hypr2d.ConjugateBranch2 = new_instancemethod(_gp.gp_Hypr2d_ConjugateBranch2, None, gp_Hypr2d)
gp_Hypr2d.Directrix1 = new_instancemethod(_gp.gp_Hypr2d_Directrix1, None, gp_Hypr2d)
gp_Hypr2d.Directrix2 = new_instancemethod(_gp.gp_Hypr2d_Directrix2, None, gp_Hypr2d)
gp_Hypr2d.Eccentricity = new_instancemethod(_gp.gp_Hypr2d_Eccentricity, None, gp_Hypr2d)
gp_Hypr2d.Focal = new_instancemethod(_gp.gp_Hypr2d_Focal, None, gp_Hypr2d)
gp_Hypr2d.Focus1 = new_instancemethod(_gp.gp_Hypr2d_Focus1, None, gp_Hypr2d)
gp_Hypr2d.Focus2 = new_instancemethod(_gp.gp_Hypr2d_Focus2, None, gp_Hypr2d)
gp_Hypr2d.IsDirect = new_instancemethod(_gp.gp_Hypr2d_IsDirect, None, gp_Hypr2d)
gp_Hypr2d.Location = new_instancemethod(_gp.gp_Hypr2d_Location, None, gp_Hypr2d)
gp_Hypr2d.MajorRadius = new_instancemethod(_gp.gp_Hypr2d_MajorRadius, None, gp_Hypr2d)
gp_Hypr2d.MinorRadius = new_instancemethod(_gp.gp_Hypr2d_MinorRadius, None, gp_Hypr2d)
gp_Hypr2d.Mirror = new_instancemethod(_gp.gp_Hypr2d_Mirror, None, gp_Hypr2d)
gp_Hypr2d.Mirrored = new_instancemethod(_gp.gp_Hypr2d_Mirrored, None, gp_Hypr2d)
gp_Hypr2d.OtherBranch = new_instancemethod(_gp.gp_Hypr2d_OtherBranch, None, gp_Hypr2d)
gp_Hypr2d.Parameter = new_instancemethod(_gp.gp_Hypr2d_Parameter, None, gp_Hypr2d)
gp_Hypr2d.Reverse = new_instancemethod(_gp.gp_Hypr2d_Reverse, None, gp_Hypr2d)
gp_Hypr2d.Reversed = new_instancemethod(_gp.gp_Hypr2d_Reversed, None, gp_Hypr2d)
gp_Hypr2d.Rotate = new_instancemethod(_gp.gp_Hypr2d_Rotate, None, gp_Hypr2d)
gp_Hypr2d.Rotated = new_instancemethod(_gp.gp_Hypr2d_Rotated, None, gp_Hypr2d)
gp_Hypr2d.Scale = new_instancemethod(_gp.gp_Hypr2d_Scale, None, gp_Hypr2d)
gp_Hypr2d.Scaled = new_instancemethod(_gp.gp_Hypr2d_Scaled, None, gp_Hypr2d)
gp_Hypr2d.SetAxis = new_instancemethod(_gp.gp_Hypr2d_SetAxis, None, gp_Hypr2d)
gp_Hypr2d.SetLocation = new_instancemethod(_gp.gp_Hypr2d_SetLocation, None, gp_Hypr2d)
gp_Hypr2d.SetMajorRadius = new_instancemethod(_gp.gp_Hypr2d_SetMajorRadius, None, gp_Hypr2d)
gp_Hypr2d.SetMinorRadius = new_instancemethod(_gp.gp_Hypr2d_SetMinorRadius, None, gp_Hypr2d)
gp_Hypr2d.SetXAxis = new_instancemethod(_gp.gp_Hypr2d_SetXAxis, None, gp_Hypr2d)
gp_Hypr2d.SetYAxis = new_instancemethod(_gp.gp_Hypr2d_SetYAxis, None, gp_Hypr2d)
gp_Hypr2d.Transform = new_instancemethod(_gp.gp_Hypr2d_Transform, None, gp_Hypr2d)
gp_Hypr2d.Transformed = new_instancemethod(_gp.gp_Hypr2d_Transformed, None, gp_Hypr2d)
gp_Hypr2d.Translate = new_instancemethod(_gp.gp_Hypr2d_Translate, None, gp_Hypr2d)
gp_Hypr2d.Translated = new_instancemethod(_gp.gp_Hypr2d_Translated, None, gp_Hypr2d)
gp_Hypr2d.XAxis = new_instancemethod(_gp.gp_Hypr2d_XAxis, None, gp_Hypr2d)
gp_Hypr2d.YAxis = new_instancemethod(_gp.gp_Hypr2d_YAxis, None, gp_Hypr2d)
gp_Hypr2d_swigregister = _gp.gp_Hypr2d_swigregister
gp_Hypr2d_swigregister(gp_Hypr2d)

class gp_Lin(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angle between two lines in radians.
        	:param Other:
        	:type Other: gp_Lin
        	:rtype: float
        """
        return _gp.gp_Lin_Angle(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this line contains the point P, that is, if the distance between point P and this line is less than or equal to LinearTolerance..
        	:param P:
        	:type P: gp_Pnt
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Lin_Contains(self, *args)


    def Direction(self, *args) -> "gp_Dir const":
        """
        * Returns the direction of the line.
        	:rtype: gp_Dir
        """
        return _gp.gp_Lin_Direction(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        * Computes the distance between <self> and the point P.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: float
        * Computes the distance between two lines.
        	:param Other:
        	:type Other: gp_Lin
        	:rtype: float
        """
        return _gp.gp_Lin_Distance(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the location point (origin) of the line.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Lin_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Lin_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Lin":
        """
        * Performs the symmetrical transformation of a line with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Lin
        * Performs the symmetrical transformation of a line with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Lin
        * Performs the symmetrical transformation of a line with respect to a plane. The axis placement <A2> locates the plane of the symmetry : (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Lin
        """
        return _gp.gp_Lin_Mirrored(self, *args)


    def Normal(self, *args) -> "gp_Lin":
        """
        * Computes the line normal to the direction of <self>, passing through the point P. Raises ConstructionError if the distance between <self> and the point P is lower or equal to Resolution from gp because there is an infinity of solutions in 3D space.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Lin
        """
        return _gp.gp_Lin_Normal(self, *args)


    def Position(self, *args) -> "gp_Ax1 const":
        """
        * Returns the axis placement one axis whith the same location and direction as <self>.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Lin_Position(self, *args)


    def Reverse(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Lin_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Lin":
        """
        * Reverses the direction of the line. Note: - Reverse assigns the result to this line, while - Reversed creates a new one.
        	:rtype: gp_Lin
        """
        return _gp.gp_Lin_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Lin_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Lin":
        """
        * Rotates a line. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Lin
        """
        return _gp.gp_Lin_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Lin_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Lin":
        """
        * Scales a line. S is the scaling value. The 'Location' point (origin) of the line is modified. The 'Direction' is reversed if the scale is negative.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Lin
        """
        return _gp.gp_Lin_Scaled(self, *args)


    def SetDirection(self, *args) -> "void":
        """
        * Changes the direction of the line.
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        return _gp.gp_Lin_SetDirection(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the location point (origin) of the line.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Lin_SetLocation(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Complete redefinition of the line. The 'Location' point of <A1> is the origin of the line. The 'Direction' of <A1> is the direction of the line.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Lin_SetPosition(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        * Computes the square distance between <self> and the point P.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: float
        * Computes the square distance between two lines.
        	:param Other:
        	:type Other: gp_Lin
        	:rtype: float
        """
        return _gp.gp_Lin_SquareDistance(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Lin_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Lin":
        """
        * Transforms a line with the transformation T from class Trsf.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Lin
        """
        return _gp.gp_Lin_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Lin_Translate(self, *args)


    def Translated(self, *args) -> "gp_Lin":
        """
        * Translates a line in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Lin
        * Translates a line from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Lin
        """
        return _gp.gp_Lin_Translated(self, *args)


    def __init__(self, *args):
        """
        * Creates a Line corresponding to Z axis of the reference coordinate system.
        	:rtype: None
        * Creates a line defined by axis A1.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        * Creates a line passing through point P and parallel to vector V (P and V are, respectively, the origin and the unit vector of the positioning axis of the line).
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _gp.gp_Lin_swiginit(self, _gp.new_gp_Lin(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Lin
gp_Lin.Angle = new_instancemethod(_gp.gp_Lin_Angle, None, gp_Lin)
gp_Lin.Contains = new_instancemethod(_gp.gp_Lin_Contains, None, gp_Lin)
gp_Lin.Direction = new_instancemethod(_gp.gp_Lin_Direction, None, gp_Lin)
gp_Lin.Distance = new_instancemethod(_gp.gp_Lin_Distance, None, gp_Lin)
gp_Lin.Location = new_instancemethod(_gp.gp_Lin_Location, None, gp_Lin)
gp_Lin.Mirror = new_instancemethod(_gp.gp_Lin_Mirror, None, gp_Lin)
gp_Lin.Mirrored = new_instancemethod(_gp.gp_Lin_Mirrored, None, gp_Lin)
gp_Lin.Normal = new_instancemethod(_gp.gp_Lin_Normal, None, gp_Lin)
gp_Lin.Position = new_instancemethod(_gp.gp_Lin_Position, None, gp_Lin)
gp_Lin.Reverse = new_instancemethod(_gp.gp_Lin_Reverse, None, gp_Lin)
gp_Lin.Reversed = new_instancemethod(_gp.gp_Lin_Reversed, None, gp_Lin)
gp_Lin.Rotate = new_instancemethod(_gp.gp_Lin_Rotate, None, gp_Lin)
gp_Lin.Rotated = new_instancemethod(_gp.gp_Lin_Rotated, None, gp_Lin)
gp_Lin.Scale = new_instancemethod(_gp.gp_Lin_Scale, None, gp_Lin)
gp_Lin.Scaled = new_instancemethod(_gp.gp_Lin_Scaled, None, gp_Lin)
gp_Lin.SetDirection = new_instancemethod(_gp.gp_Lin_SetDirection, None, gp_Lin)
gp_Lin.SetLocation = new_instancemethod(_gp.gp_Lin_SetLocation, None, gp_Lin)
gp_Lin.SetPosition = new_instancemethod(_gp.gp_Lin_SetPosition, None, gp_Lin)
gp_Lin.SquareDistance = new_instancemethod(_gp.gp_Lin_SquareDistance, None, gp_Lin)
gp_Lin.Transform = new_instancemethod(_gp.gp_Lin_Transform, None, gp_Lin)
gp_Lin.Transformed = new_instancemethod(_gp.gp_Lin_Transformed, None, gp_Lin)
gp_Lin.Translate = new_instancemethod(_gp.gp_Lin_Translate, None, gp_Lin)
gp_Lin.Translated = new_instancemethod(_gp.gp_Lin_Translated, None, gp_Lin)
gp_Lin_swigregister = _gp.gp_Lin_swigregister
gp_Lin_swigregister(gp_Lin)

class gp_Lin2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angle between two lines in radians.
        	:param Other:
        	:type Other: gp_Lin2d
        	:rtype: float
        """
        return _gp.gp_Lin2d_Angle(self, *args)


    def Coefficients(self, *args) -> "void":
        """
        * Returns the normalized coefficients of the line : A * X + B * Y + C = 0.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:rtype: None
        """
        return _gp.gp_Lin2d_Coefficients(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this line contains the point P, that is, if the distance between point P and this line is less than or equal to LinearTolerance.
        	:param P:
        	:type P: gp_Pnt2d
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Lin2d_Contains(self, *args)


    def Direction(self, *args) -> "gp_Dir2d const":
        """
        * Returns the direction of the line.
        	:rtype: gp_Dir2d
        """
        return _gp.gp_Lin2d_Direction(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        * Computes the distance between <self> and the point <P>.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: float
        * Computes the distance between two lines.
        	:param Other:
        	:type Other: gp_Lin2d
        	:rtype: float
        """
        return _gp.gp_Lin2d_Distance(self, *args)


    def Location(self, *args) -> "gp_Pnt2d const":
        """
        * Returns the location point (origin) of the line.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Lin2d_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        :param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Lin2d_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Lin2d":
        """
        * Performs the symmetrical transformation of a line with respect to the point <P> which is the center of the symmetry
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Lin2d
        * Performs the symmetrical transformation of a line with respect to an axis placement which is the axis of the symmetry.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: gp_Lin2d
        """
        return _gp.gp_Lin2d_Mirrored(self, *args)


    def Normal(self, *args) -> "gp_Lin2d":
        """
        * Computes the line normal to the direction of <self>, passing through the point <P>.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Lin2d
        """
        return _gp.gp_Lin2d_Normal(self, *args)


    def Position(self, *args) -> "gp_Ax2d const":
        """
        * Returns the axis placement one axis whith the same location and direction as <self>.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Lin2d_Position(self, *args)


    def Reverse(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Lin2d_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Lin2d":
        """
        * Reverses the positioning axis of this line. Note: - Reverse assigns the result to this line, while - Reversed creates a new one.
        	:rtype: gp_Lin2d
        """
        return _gp.gp_Lin2d_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Lin2d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Lin2d":
        """
        * Rotates a line. P is the center of the rotation. Ang is the angular value of the rotation in radians.
        	:param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Lin2d
        """
        return _gp.gp_Lin2d_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Lin2d_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Lin2d":
        """
        * Scales a line. S is the scaling value. Only the origin of the line is modified.
        	:param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: gp_Lin2d
        """
        return _gp.gp_Lin2d_Scaled(self, *args)


    def SetDirection(self, *args) -> "void":
        """
        * Changes the direction of the line.
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        """
        return _gp.gp_Lin2d_SetDirection(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the origin of the line.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Lin2d_SetLocation(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Complete redefinition of the line. The 'Location' point of <A> is the origin of the line. The 'Direction' of <A> is the direction of the line.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Lin2d_SetPosition(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        * Computes the square distance between <self> and the point <P>.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: float
        * Computes the square distance between two lines.
        	:param Other:
        	:type Other: gp_Lin2d
        	:rtype: float
        """
        return _gp.gp_Lin2d_SquareDistance(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Lin2d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Lin2d":
        """
        * Transforms a line with the transformation T from class Trsf2d.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Lin2d
        """
        return _gp.gp_Lin2d_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec2d
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Lin2d_Translate(self, *args)


    def Translated(self, *args) -> "gp_Lin2d":
        """
        * Translates a line in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: gp_Lin2d
        * Translates a line from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: gp_Lin2d
        """
        return _gp.gp_Lin2d_Translated(self, *args)


    def __init__(self, *args):
        """
        * Creates a Line corresponding to X axis of the reference coordinate system.
        	:rtype: None
        * Creates a line located with A.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        * <P> is the location point (origin) of the line and <V> is the direction of the line.
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        * Creates the line from the equation A*X + B*Y + C = 0.0 Raises ConstructionError if Sqrt(A*A + B*B) <= Resolution from gp. Raised if Sqrt(A*A + B*B) <= Resolution from gp.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:rtype: None
        """
        _gp.gp_Lin2d_swiginit(self, _gp.new_gp_Lin2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Lin2d
gp_Lin2d.Angle = new_instancemethod(_gp.gp_Lin2d_Angle, None, gp_Lin2d)
gp_Lin2d.Coefficients = new_instancemethod(_gp.gp_Lin2d_Coefficients, None, gp_Lin2d)
gp_Lin2d.Contains = new_instancemethod(_gp.gp_Lin2d_Contains, None, gp_Lin2d)
gp_Lin2d.Direction = new_instancemethod(_gp.gp_Lin2d_Direction, None, gp_Lin2d)
gp_Lin2d.Distance = new_instancemethod(_gp.gp_Lin2d_Distance, None, gp_Lin2d)
gp_Lin2d.Location = new_instancemethod(_gp.gp_Lin2d_Location, None, gp_Lin2d)
gp_Lin2d.Mirror = new_instancemethod(_gp.gp_Lin2d_Mirror, None, gp_Lin2d)
gp_Lin2d.Mirrored = new_instancemethod(_gp.gp_Lin2d_Mirrored, None, gp_Lin2d)
gp_Lin2d.Normal = new_instancemethod(_gp.gp_Lin2d_Normal, None, gp_Lin2d)
gp_Lin2d.Position = new_instancemethod(_gp.gp_Lin2d_Position, None, gp_Lin2d)
gp_Lin2d.Reverse = new_instancemethod(_gp.gp_Lin2d_Reverse, None, gp_Lin2d)
gp_Lin2d.Reversed = new_instancemethod(_gp.gp_Lin2d_Reversed, None, gp_Lin2d)
gp_Lin2d.Rotate = new_instancemethod(_gp.gp_Lin2d_Rotate, None, gp_Lin2d)
gp_Lin2d.Rotated = new_instancemethod(_gp.gp_Lin2d_Rotated, None, gp_Lin2d)
gp_Lin2d.Scale = new_instancemethod(_gp.gp_Lin2d_Scale, None, gp_Lin2d)
gp_Lin2d.Scaled = new_instancemethod(_gp.gp_Lin2d_Scaled, None, gp_Lin2d)
gp_Lin2d.SetDirection = new_instancemethod(_gp.gp_Lin2d_SetDirection, None, gp_Lin2d)
gp_Lin2d.SetLocation = new_instancemethod(_gp.gp_Lin2d_SetLocation, None, gp_Lin2d)
gp_Lin2d.SetPosition = new_instancemethod(_gp.gp_Lin2d_SetPosition, None, gp_Lin2d)
gp_Lin2d.SquareDistance = new_instancemethod(_gp.gp_Lin2d_SquareDistance, None, gp_Lin2d)
gp_Lin2d.Transform = new_instancemethod(_gp.gp_Lin2d_Transform, None, gp_Lin2d)
gp_Lin2d.Transformed = new_instancemethod(_gp.gp_Lin2d_Transformed, None, gp_Lin2d)
gp_Lin2d.Translate = new_instancemethod(_gp.gp_Lin2d_Translate, None, gp_Lin2d)
gp_Lin2d.Translated = new_instancemethod(_gp.gp_Lin2d_Translated, None, gp_Lin2d)
gp_Lin2d_swigregister = _gp.gp_Lin2d_swigregister
gp_Lin2d_swigregister(gp_Lin2d)

class gp_Mat(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        :param Other:
        	:type Other: gp_Mat
        	:rtype: None
        """
        return _gp.gp_Mat_Add(self, *args)


    def Added(self, *args) -> "gp_Mat":
        """
        * Computes the sum of this matrix and the matrix Other for each coefficient of the matrix : <self>.Coef(i,j) + <Other>.Coef(i,j)
        	:param Other:
        	:type Other: gp_Mat
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat_Added(self, *args)


    def GetChangeValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const') -> "Standard_Real":
        """GetChangeValue(gp_Mat self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real"""
        return _gp.gp_Mat_GetChangeValue(self, Row, Col)


    def SetChangeValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetChangeValue(gp_Mat self, Standard_Integer const Row, Standard_Integer const Col, Standard_Real value)"""
        return _gp.gp_Mat_SetChangeValue(self, Row, Col, value)


    def Column(self, *args) -> "gp_XYZ":
        """
        * Returns the column of Col index. Raises OutOfRange if Col < 1 or Col > 3
        	:param Col:
        	:type Col: int
        	:rtype: gp_XYZ
        """
        return _gp.gp_Mat_Column(self, *args)


    def Determinant(self, *args) -> "Standard_Real":
        """
        * Computes the determinant of the matrix.
        	:rtype: float
        """
        return _gp.gp_Mat_Determinant(self, *args)


    def Diagonal(self, *args) -> "gp_XYZ":
        """
        * Returns the main diagonal of the matrix.
        	:rtype: gp_XYZ
        """
        return _gp.gp_Mat_Diagonal(self, *args)


    def Divide(self, *args) -> "void":
        """
        :param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_Mat_Divide(self, *args)


    def Divided(self, *args) -> "gp_Mat":
        """
        * Divides all the coefficients of the matrix by Scalar
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat_Divided(self, *args)


    def DumpJsonToString(self, depth: 'int'=-1) -> "std::string":
        """
        DumpJsonToString(gp_Mat self, int depth=-1) -> std::string
        DumpJsonToString(gp_Mat self) -> std::string
        """
        return _gp.gp_Mat_DumpJsonToString(self, depth)


    def Invert(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Mat_Invert(self, *args)


    def Inverted(self, *args) -> "gp_Mat":
        """
        * Inverses the matrix and raises if the matrix is singular. - Invert assigns the result to this matrix, while - Inverted creates a new one. Warning The Gauss LU decomposition is used to invert the matrix. Consequently, the matrix is considered as singular if the largest pivot found is less than or equal to gp::Resolution(). Exceptions Standard_ConstructionError if this matrix is singular, and therefore cannot be inverted.
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat_Inverted(self, *args)


    def IsSingular(self, *args) -> "Standard_Boolean":
        """
        * The Gauss LU decomposition is used to invert the matrix (see Math package) so the matrix is considered as singular if the largest pivot found is lower or equal to Resolution from gp.
        	:rtype: bool
        """
        return _gp.gp_Mat_IsSingular(self, *args)


    def Multiplied(self, *args) -> "gp_Mat":
        """
        * Computes the product of two matrices <self> * <Other>
        	:param Other:
        	:type Other: gp_Mat
        	:rtype: gp_Mat
        :param Scalar:
        	:type Scalar: float
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * Computes the product of two matrices <self> = <Other> * <self>.
        	:param Other:
        	:type Other: gp_Mat
        	:rtype: None
        * Multiplies all the coefficients of the matrix by Scalar
        	:param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_Mat_Multiply(self, *args)


    def Power(self, *args) -> "void":
        """
        :param N:
        	:type N: int
        	:rtype: None
        """
        return _gp.gp_Mat_Power(self, *args)


    def Powered(self, *args) -> "gp_Mat":
        """
        * Computes <self> = <self> * <self> * .......* <self>, N time. if N = 0 <self> = Identity if N < 0 <self> = <self>.Invert() *...........* <self>.Invert(). If N < 0 an exception will be raised if the matrix is not inversible
        	:param N:
        	:type N: int
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat_Powered(self, *args)


    def PreMultiply(self, *args) -> "void":
        """
        :param Other:
        	:type Other: gp_Mat
        	:rtype: None
        """
        return _gp.gp_Mat_PreMultiply(self, *args)


    def Row(self, *args) -> "gp_XYZ":
        """
        * returns the row of Row index. Raises OutOfRange if Row < 1 or Row > 3
        	:param Row:
        	:type Row: int
        	:rtype: gp_XYZ
        """
        return _gp.gp_Mat_Row(self, *args)


    def SetCol(self, *args) -> "void":
        """
        * Assigns the three coordinates of Value to the column of index Col of this matrix. Raises OutOfRange if Col < 1 or Col > 3.
        	:param Col:
        	:type Col: int
        	:param Value:
        	:type Value: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Mat_SetCol(self, *args)


    def SetCols(self, *args) -> "void":
        """
        * Assigns the number triples Col1, Col2, Col3 to the three columns of this matrix.
        	:param Col1:
        	:type Col1: gp_XYZ
        	:param Col2:
        	:type Col2: gp_XYZ
        	:param Col3:
        	:type Col3: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Mat_SetCols(self, *args)


    def SetCross(self, *args) -> "void":
        """
        * Modifies the matrix M so that applying it to any number triple (X, Y, Z) produces the same result as the cross product of Ref and the number triple (X, Y, Z): i.e.: M * {X,Y,Z}t = Ref.Cross({X, Y ,Z}) this matrix is anti symmetric. To apply this matrix to the triplet {XYZ} is the same as to do the cross product between the triplet Ref and the triplet {XYZ}. Note: this matrix is anti-symmetric.
        	:param Ref:
        	:type Ref: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Mat_SetCross(self, *args)


    def SetDiagonal(self, *args) -> "void":
        """
        * Modifies the main diagonal of the matrix. <self>.Value (1, 1) = X1 <self>.Value (2, 2) = X2 <self>.Value (3, 3) = X3 The other coefficients of the matrix are not modified.
        	:param X1:
        	:type X1: float
        	:param X2:
        	:type X2: float
        	:param X3:
        	:type X3: float
        	:rtype: None
        """
        return _gp.gp_Mat_SetDiagonal(self, *args)


    def SetDot(self, *args) -> "void":
        """
        * Modifies this matrix so that applying it to any number triple (X, Y, Z) produces the same result as the scalar product of Ref and the number triple (X, Y, Z): this * (X,Y,Z) = Ref.(X,Y,Z) Note: this matrix is symmetric.
        	:param Ref:
        	:type Ref: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Mat_SetDot(self, *args)


    def SetIdentity(self, *args) -> "void":
        """
        * Modifies this matrix so that it represents the Identity matrix.
        	:rtype: None
        """
        return _gp.gp_Mat_SetIdentity(self, *args)


    def SetRotation(self, *args) -> "void":
        """
        * Modifies this matrix so that it represents a rotation. Ang is the angular value in radians and the XYZ axis gives the direction of the rotation. Raises ConstructionError if XYZ.Modulus() <= Resolution()
        	:param Axis:
        	:type Axis: gp_XYZ
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Mat_SetRotation(self, *args)


    def SetRow(self, *args) -> "void":
        """
        * Assigns the three coordinates of Value to the row of index Row of this matrix. Raises OutOfRange if Row < 1 or Row > 3.
        	:param Row:
        	:type Row: int
        	:param Value:
        	:type Value: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Mat_SetRow(self, *args)


    def SetRows(self, *args) -> "void":
        """
        * Assigns the number triples Row1, Row2, Row3 to the three rows of this matrix.
        	:param Row1:
        	:type Row1: gp_XYZ
        	:param Row2:
        	:type Row2: gp_XYZ
        	:param Row3:
        	:type Row3: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Mat_SetRows(self, *args)


    def SetScale(self, *args) -> "void":
        """
        * Modifies the the matrix so that it represents a scaling transformation, where S is the scale factor. : | S 0.0 0.0 | <self> = | 0.0 S 0.0 | | 0.0 0.0 S |
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Mat_SetScale(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Assigns <Value> to the coefficient of row Row, column Col of this matrix. Raises OutOfRange if Row < 1 or Row > 3 or Col < 1 or Col > 3
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:param Value:
        	:type Value: float
        	:rtype: None
        """
        return _gp.gp_Mat_SetValue(self, *args)


    def Subtract(self, *args) -> "void":
        """
        :param Other:
        	:type Other: gp_Mat
        	:rtype: None
        """
        return _gp.gp_Mat_Subtract(self, *args)


    def Subtracted(self, *args) -> "gp_Mat":
        """
        * cOmputes for each coefficient of the matrix : <self>.Coef(i,j) - <Other>.Coef(i,j)
        	:param Other:
        	:type Other: gp_Mat
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat_Subtracted(self, *args)


    def Transpose(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Mat_Transpose(self, *args)


    def Transposed(self, *args) -> "gp_Mat":
        """
        * Transposes the matrix. A(j, i) -> A (i, j)
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat_Transposed(self, *args)


    def Value(self, *args) -> "Standard_Real const &":
        """
        * Returns the coefficient of range (Row, Col) Raises OutOfRange if Row < 1 or Row > 3 or Col < 1 or Col > 3
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:rtype: float
        """
        return _gp.gp_Mat_Value(self, *args)


    def __init__(self, *args):
        """
        * creates a matrix with null coefficients.
        	:rtype: None
        :param a11:
        	:type a11: float
        	:param a12:
        	:type a12: float
        	:param a13:
        	:type a13: float
        	:param a21:
        	:type a21: float
        	:param a22:
        	:type a22: float
        	:param a23:
        	:type a23: float
        	:param a31:
        	:type a31: float
        	:param a32:
        	:type a32: float
        	:param a33:
        	:type a33: float
        	:rtype: None
        * Creates a matrix. Col1, Col2, Col3 are the 3 columns of the matrix.
        	:param Col1:
        	:type Col1: gp_XYZ
        	:param Col2:
        	:type Col2: gp_XYZ
        	:param Col3:
        	:type Col3: gp_XYZ
        	:rtype: None
        """
        _gp.gp_Mat_swiginit(self, _gp.new_gp_Mat(*args))

    def __mul__(self, *args) -> "gp_Mat":
        """
        :param Other:
        	:type Other: gp_Mat
        	:rtype: gp_Mat
        :param Scalar:
        	:type Scalar: float
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul_wrapper__(self, *args) -> "void":
        """
        __imul_wrapper__(gp_Mat self, gp_Mat other)
        __imul_wrapper__(gp_Mat self, Standard_Real const other)
        """
        return _gp.gp_Mat___imul_wrapper__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "gp_Mat":
        """
        :param Other:
        	:type Other: gp_Mat
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat___add__(self, *args)


    def __iadd_wrapper__(self, other: 'gp_Mat') -> "void":
        """__iadd_wrapper__(gp_Mat self, gp_Mat other)"""
        return _gp.gp_Mat___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __sub__(self, *args) -> "gp_Mat":
        """
        :param Other:
        	:type Other: gp_Mat
        	:rtype: gp_Mat
        """
        return _gp.gp_Mat___sub__(self, *args)


    def __isub_wrapper__(self, other: 'gp_Mat') -> "void":
        """__isub_wrapper__(gp_Mat self, gp_Mat other)"""
        return _gp.gp_Mat___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_Mat___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__itruediv_wrapper__(gp_Mat self, Standard_Real const other)"""
        return _gp.gp_Mat___itruediv_wrapper__(self, other)


    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Mat
gp_Mat.Add = new_instancemethod(_gp.gp_Mat_Add, None, gp_Mat)
gp_Mat.Added = new_instancemethod(_gp.gp_Mat_Added, None, gp_Mat)
gp_Mat.GetChangeValue = new_instancemethod(_gp.gp_Mat_GetChangeValue, None, gp_Mat)
gp_Mat.SetChangeValue = new_instancemethod(_gp.gp_Mat_SetChangeValue, None, gp_Mat)
gp_Mat.Column = new_instancemethod(_gp.gp_Mat_Column, None, gp_Mat)
gp_Mat.Determinant = new_instancemethod(_gp.gp_Mat_Determinant, None, gp_Mat)
gp_Mat.Diagonal = new_instancemethod(_gp.gp_Mat_Diagonal, None, gp_Mat)
gp_Mat.Divide = new_instancemethod(_gp.gp_Mat_Divide, None, gp_Mat)
gp_Mat.Divided = new_instancemethod(_gp.gp_Mat_Divided, None, gp_Mat)
gp_Mat.DumpJsonToString = new_instancemethod(_gp.gp_Mat_DumpJsonToString, None, gp_Mat)
gp_Mat.Invert = new_instancemethod(_gp.gp_Mat_Invert, None, gp_Mat)
gp_Mat.Inverted = new_instancemethod(_gp.gp_Mat_Inverted, None, gp_Mat)
gp_Mat.IsSingular = new_instancemethod(_gp.gp_Mat_IsSingular, None, gp_Mat)
gp_Mat.Multiplied = new_instancemethod(_gp.gp_Mat_Multiplied, None, gp_Mat)
gp_Mat.Multiply = new_instancemethod(_gp.gp_Mat_Multiply, None, gp_Mat)
gp_Mat.Power = new_instancemethod(_gp.gp_Mat_Power, None, gp_Mat)
gp_Mat.Powered = new_instancemethod(_gp.gp_Mat_Powered, None, gp_Mat)
gp_Mat.PreMultiply = new_instancemethod(_gp.gp_Mat_PreMultiply, None, gp_Mat)
gp_Mat.Row = new_instancemethod(_gp.gp_Mat_Row, None, gp_Mat)
gp_Mat.SetCol = new_instancemethod(_gp.gp_Mat_SetCol, None, gp_Mat)
gp_Mat.SetCols = new_instancemethod(_gp.gp_Mat_SetCols, None, gp_Mat)
gp_Mat.SetCross = new_instancemethod(_gp.gp_Mat_SetCross, None, gp_Mat)
gp_Mat.SetDiagonal = new_instancemethod(_gp.gp_Mat_SetDiagonal, None, gp_Mat)
gp_Mat.SetDot = new_instancemethod(_gp.gp_Mat_SetDot, None, gp_Mat)
gp_Mat.SetIdentity = new_instancemethod(_gp.gp_Mat_SetIdentity, None, gp_Mat)
gp_Mat.SetRotation = new_instancemethod(_gp.gp_Mat_SetRotation, None, gp_Mat)
gp_Mat.SetRow = new_instancemethod(_gp.gp_Mat_SetRow, None, gp_Mat)
gp_Mat.SetRows = new_instancemethod(_gp.gp_Mat_SetRows, None, gp_Mat)
gp_Mat.SetScale = new_instancemethod(_gp.gp_Mat_SetScale, None, gp_Mat)
gp_Mat.SetValue = new_instancemethod(_gp.gp_Mat_SetValue, None, gp_Mat)
gp_Mat.Subtract = new_instancemethod(_gp.gp_Mat_Subtract, None, gp_Mat)
gp_Mat.Subtracted = new_instancemethod(_gp.gp_Mat_Subtracted, None, gp_Mat)
gp_Mat.Transpose = new_instancemethod(_gp.gp_Mat_Transpose, None, gp_Mat)
gp_Mat.Transposed = new_instancemethod(_gp.gp_Mat_Transposed, None, gp_Mat)
gp_Mat.Value = new_instancemethod(_gp.gp_Mat_Value, None, gp_Mat)
gp_Mat.__mul__ = new_instancemethod(_gp.gp_Mat___mul__, None, gp_Mat)
gp_Mat.__imul_wrapper__ = new_instancemethod(_gp.gp_Mat___imul_wrapper__, None, gp_Mat)
gp_Mat.__add__ = new_instancemethod(_gp.gp_Mat___add__, None, gp_Mat)
gp_Mat.__iadd_wrapper__ = new_instancemethod(_gp.gp_Mat___iadd_wrapper__, None, gp_Mat)
gp_Mat.__sub__ = new_instancemethod(_gp.gp_Mat___sub__, None, gp_Mat)
gp_Mat.__isub_wrapper__ = new_instancemethod(_gp.gp_Mat___isub_wrapper__, None, gp_Mat)
gp_Mat.__itruediv_wrapper__ = new_instancemethod(_gp.gp_Mat___itruediv_wrapper__, None, gp_Mat)
gp_Mat_swigregister = _gp.gp_Mat_swigregister
gp_Mat_swigregister(gp_Mat)

class gp_Mat2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        :param Other:
        	:type Other: gp_Mat2d
        	:rtype: None
        """
        return _gp.gp_Mat2d_Add(self, *args)


    def Added(self, *args) -> "gp_Mat2d":
        """
        * Computes the sum of this matrix and the matrix Other.for each coefficient of the matrix : <self>.Coef(i,j) + <Other>.Coef(i,j) Note: - operator += assigns the result to this matrix, while - operator + creates a new one.
        	:param Other:
        	:type Other: gp_Mat2d
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d_Added(self, *args)


    def GetChangeValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const') -> "Standard_Real":
        """GetChangeValue(gp_Mat2d self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real"""
        return _gp.gp_Mat2d_GetChangeValue(self, Row, Col)


    def SetChangeValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetChangeValue(gp_Mat2d self, Standard_Integer const Row, Standard_Integer const Col, Standard_Real value)"""
        return _gp.gp_Mat2d_SetChangeValue(self, Row, Col, value)


    def Column(self, *args) -> "gp_XY":
        """
        * Returns the column of Col index. Raises OutOfRange if Col < 1 or Col > 2
        	:param Col:
        	:type Col: int
        	:rtype: gp_XY
        """
        return _gp.gp_Mat2d_Column(self, *args)


    def Determinant(self, *args) -> "Standard_Real":
        """
        * Computes the determinant of the matrix.
        	:rtype: float
        """
        return _gp.gp_Mat2d_Determinant(self, *args)


    def Diagonal(self, *args) -> "gp_XY":
        """
        * Returns the main diagonal of the matrix.
        	:rtype: gp_XY
        """
        return _gp.gp_Mat2d_Diagonal(self, *args)


    def Divide(self, *args) -> "void":
        """
        :param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_Mat2d_Divide(self, *args)


    def Divided(self, *args) -> "gp_Mat2d":
        """
        * Divides all the coefficients of the matrix by a scalar.
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d_Divided(self, *args)


    def Invert(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Mat2d_Invert(self, *args)


    def Inverted(self, *args) -> "gp_Mat2d":
        """
        * Inverses the matrix and raises exception if the matrix is singular.
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d_Inverted(self, *args)


    def IsSingular(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this matrix is singular (and therefore, cannot be inverted). The Gauss LU decomposition is used to invert the matrix so the matrix is considered as singular if the largest pivot found is lower or equal to Resolution from gp.
        	:rtype: bool
        """
        return _gp.gp_Mat2d_IsSingular(self, *args)


    def Multiplied(self, *args) -> "gp_Mat2d":
        """
        :param Other:
        	:type Other: gp_Mat2d
        	:rtype: gp_Mat2d
        :param Scalar:
        	:type Scalar: float
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * Computes the product of two matrices <self> * <Other>
        	:param Other:
        	:type Other: gp_Mat2d
        	:rtype: None
        * Multiplies all the coefficients of the matrix by a scalar.
        	:param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_Mat2d_Multiply(self, *args)


    def Power(self, *args) -> "void":
        """
        :param N:
        	:type N: int
        	:rtype: None
        """
        return _gp.gp_Mat2d_Power(self, *args)


    def Powered(self, *args) -> "gp_Mat2d":
        """
        * computes <self> = <self> * <self> * .......* <self>, N time. if N = 0 <self> = Identity if N < 0 <self> = <self>.Invert() *...........* <self>.Invert(). If N < 0 an exception can be raised if the matrix is not inversible
        	:param N:
        	:type N: int
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d_Powered(self, *args)


    def PreMultiply(self, *args) -> "void":
        """
        * Modifies this matrix by premultiplying it by the matrix Other <self> = Other * <self>.
        	:param Other:
        	:type Other: gp_Mat2d
        	:rtype: None
        """
        return _gp.gp_Mat2d_PreMultiply(self, *args)


    def Row(self, *args) -> "gp_XY":
        """
        * Returns the row of index Row. Raised if Row < 1 or Row > 2
        	:param Row:
        	:type Row: int
        	:rtype: gp_XY
        """
        return _gp.gp_Mat2d_Row(self, *args)


    def SetCol(self, *args) -> "void":
        """
        * Assigns the two coordinates of Value to the column of range Col of this matrix Raises OutOfRange if Col < 1 or Col > 2.
        	:param Col:
        	:type Col: int
        	:param Value:
        	:type Value: gp_XY
        	:rtype: None
        """
        return _gp.gp_Mat2d_SetCol(self, *args)


    def SetCols(self, *args) -> "void":
        """
        * Assigns the number pairs Col1, Col2 to the two columns of this matrix
        	:param Col1:
        	:type Col1: gp_XY
        	:param Col2:
        	:type Col2: gp_XY
        	:rtype: None
        """
        return _gp.gp_Mat2d_SetCols(self, *args)


    def SetDiagonal(self, *args) -> "void":
        """
        * Modifies the main diagonal of the matrix. <self>.Value (1, 1) = X1 <self>.Value (2, 2) = X2 The other coefficients of the matrix are not modified.
        	:param X1:
        	:type X1: float
        	:param X2:
        	:type X2: float
        	:rtype: None
        """
        return _gp.gp_Mat2d_SetDiagonal(self, *args)


    def SetIdentity(self, *args) -> "void":
        """
        * Modifies this matrix, so that it represents the Identity matrix.
        	:rtype: None
        """
        return _gp.gp_Mat2d_SetIdentity(self, *args)


    def SetRotation(self, *args) -> "void":
        """
        * Modifies this matrix, so that it representso a rotation. Ang is the angular value in radian of the rotation.
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Mat2d_SetRotation(self, *args)


    def SetRow(self, *args) -> "void":
        """
        * Assigns the two coordinates of Value to the row of index Row of this matrix. Raises OutOfRange if Row < 1 or Row > 2.
        	:param Row:
        	:type Row: int
        	:param Value:
        	:type Value: gp_XY
        	:rtype: None
        """
        return _gp.gp_Mat2d_SetRow(self, *args)


    def SetRows(self, *args) -> "void":
        """
        * Assigns the number pairs Row1, Row2 to the two rows of this matrix.
        	:param Row1:
        	:type Row1: gp_XY
        	:param Row2:
        	:type Row2: gp_XY
        	:rtype: None
        """
        return _gp.gp_Mat2d_SetRows(self, *args)


    def SetScale(self, *args) -> "void":
        """
        * Modifies the matrix such that it represents a scaling transformation, where S is the scale factor : | S 0.0 | <self> = | 0.0 S |
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Mat2d_SetScale(self, *args)


    def SetValue(self, *args) -> "void":
        """
        * Assigns <Value> to the coefficient of row Row, column Col of this matrix. Raises OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 2
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:param Value:
        	:type Value: float
        	:rtype: None
        """
        return _gp.gp_Mat2d_SetValue(self, *args)


    def Subtract(self, *args) -> "void":
        """
        :param Other:
        	:type Other: gp_Mat2d
        	:rtype: None
        """
        return _gp.gp_Mat2d_Subtract(self, *args)


    def Subtracted(self, *args) -> "gp_Mat2d":
        """
        * Computes for each coefficient of the matrix : <self>.Coef(i,j) - <Other>.Coef(i,j)
        	:param Other:
        	:type Other: gp_Mat2d
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d_Subtracted(self, *args)


    def Transpose(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Mat2d_Transpose(self, *args)


    def Transposed(self, *args) -> "gp_Mat2d":
        """
        * Transposes the matrix. A(j, i) -> A (i, j)
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d_Transposed(self, *args)


    def Value(self, *args) -> "Standard_Real const &":
        """
        * Returns the coefficient of range (Row, Col) Raises OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 2
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:rtype: float
        """
        return _gp.gp_Mat2d_Value(self, *args)


    def __init__(self, *args):
        """
        * Creates a matrix with null coefficients.
        	:rtype: None
        * Col1, Col2 are the 2 columns of the matrix.
        	:param Col1:
        	:type Col1: gp_XY
        	:param Col2:
        	:type Col2: gp_XY
        	:rtype: None
        """
        _gp.gp_Mat2d_swiginit(self, _gp.new_gp_Mat2d(*args))

    def __mul__(self, *args) -> "gp_Mat2d":
        """
        :param Other:
        	:type Other: gp_Mat2d
        	:rtype: gp_Mat2d
        :param Scalar:
        	:type Scalar: float
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d___mul__(self, *args)


    def __imul_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__imul_wrapper__(gp_Mat2d self, Standard_Real const other)"""
        return _gp.gp_Mat2d___imul_wrapper__(self, other)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "gp_Mat2d":
        """
        :param Other:
        	:type Other: gp_Mat2d
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d___add__(self, *args)


    def __iadd_wrapper__(self, other: 'gp_Mat2d') -> "void":
        """__iadd_wrapper__(gp_Mat2d self, gp_Mat2d other)"""
        return _gp.gp_Mat2d___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __sub__(self, *args) -> "gp_Mat2d":
        """
        :param Other:
        	:type Other: gp_Mat2d
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Mat2d___sub__(self, *args)


    def __isub_wrapper__(self, other: 'gp_Mat2d') -> "void":
        """__isub_wrapper__(gp_Mat2d self, gp_Mat2d other)"""
        return _gp.gp_Mat2d___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_Mat2d___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__itruediv_wrapper__(gp_Mat2d self, Standard_Real const other)"""
        return _gp.gp_Mat2d___itruediv_wrapper__(self, other)


    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Mat2d
gp_Mat2d.Add = new_instancemethod(_gp.gp_Mat2d_Add, None, gp_Mat2d)
gp_Mat2d.Added = new_instancemethod(_gp.gp_Mat2d_Added, None, gp_Mat2d)
gp_Mat2d.GetChangeValue = new_instancemethod(_gp.gp_Mat2d_GetChangeValue, None, gp_Mat2d)
gp_Mat2d.SetChangeValue = new_instancemethod(_gp.gp_Mat2d_SetChangeValue, None, gp_Mat2d)
gp_Mat2d.Column = new_instancemethod(_gp.gp_Mat2d_Column, None, gp_Mat2d)
gp_Mat2d.Determinant = new_instancemethod(_gp.gp_Mat2d_Determinant, None, gp_Mat2d)
gp_Mat2d.Diagonal = new_instancemethod(_gp.gp_Mat2d_Diagonal, None, gp_Mat2d)
gp_Mat2d.Divide = new_instancemethod(_gp.gp_Mat2d_Divide, None, gp_Mat2d)
gp_Mat2d.Divided = new_instancemethod(_gp.gp_Mat2d_Divided, None, gp_Mat2d)
gp_Mat2d.Invert = new_instancemethod(_gp.gp_Mat2d_Invert, None, gp_Mat2d)
gp_Mat2d.Inverted = new_instancemethod(_gp.gp_Mat2d_Inverted, None, gp_Mat2d)
gp_Mat2d.IsSingular = new_instancemethod(_gp.gp_Mat2d_IsSingular, None, gp_Mat2d)
gp_Mat2d.Multiplied = new_instancemethod(_gp.gp_Mat2d_Multiplied, None, gp_Mat2d)
gp_Mat2d.Multiply = new_instancemethod(_gp.gp_Mat2d_Multiply, None, gp_Mat2d)
gp_Mat2d.Power = new_instancemethod(_gp.gp_Mat2d_Power, None, gp_Mat2d)
gp_Mat2d.Powered = new_instancemethod(_gp.gp_Mat2d_Powered, None, gp_Mat2d)
gp_Mat2d.PreMultiply = new_instancemethod(_gp.gp_Mat2d_PreMultiply, None, gp_Mat2d)
gp_Mat2d.Row = new_instancemethod(_gp.gp_Mat2d_Row, None, gp_Mat2d)
gp_Mat2d.SetCol = new_instancemethod(_gp.gp_Mat2d_SetCol, None, gp_Mat2d)
gp_Mat2d.SetCols = new_instancemethod(_gp.gp_Mat2d_SetCols, None, gp_Mat2d)
gp_Mat2d.SetDiagonal = new_instancemethod(_gp.gp_Mat2d_SetDiagonal, None, gp_Mat2d)
gp_Mat2d.SetIdentity = new_instancemethod(_gp.gp_Mat2d_SetIdentity, None, gp_Mat2d)
gp_Mat2d.SetRotation = new_instancemethod(_gp.gp_Mat2d_SetRotation, None, gp_Mat2d)
gp_Mat2d.SetRow = new_instancemethod(_gp.gp_Mat2d_SetRow, None, gp_Mat2d)
gp_Mat2d.SetRows = new_instancemethod(_gp.gp_Mat2d_SetRows, None, gp_Mat2d)
gp_Mat2d.SetScale = new_instancemethod(_gp.gp_Mat2d_SetScale, None, gp_Mat2d)
gp_Mat2d.SetValue = new_instancemethod(_gp.gp_Mat2d_SetValue, None, gp_Mat2d)
gp_Mat2d.Subtract = new_instancemethod(_gp.gp_Mat2d_Subtract, None, gp_Mat2d)
gp_Mat2d.Subtracted = new_instancemethod(_gp.gp_Mat2d_Subtracted, None, gp_Mat2d)
gp_Mat2d.Transpose = new_instancemethod(_gp.gp_Mat2d_Transpose, None, gp_Mat2d)
gp_Mat2d.Transposed = new_instancemethod(_gp.gp_Mat2d_Transposed, None, gp_Mat2d)
gp_Mat2d.Value = new_instancemethod(_gp.gp_Mat2d_Value, None, gp_Mat2d)
gp_Mat2d.__mul__ = new_instancemethod(_gp.gp_Mat2d___mul__, None, gp_Mat2d)
gp_Mat2d.__imul_wrapper__ = new_instancemethod(_gp.gp_Mat2d___imul_wrapper__, None, gp_Mat2d)
gp_Mat2d.__add__ = new_instancemethod(_gp.gp_Mat2d___add__, None, gp_Mat2d)
gp_Mat2d.__iadd_wrapper__ = new_instancemethod(_gp.gp_Mat2d___iadd_wrapper__, None, gp_Mat2d)
gp_Mat2d.__sub__ = new_instancemethod(_gp.gp_Mat2d___sub__, None, gp_Mat2d)
gp_Mat2d.__isub_wrapper__ = new_instancemethod(_gp.gp_Mat2d___isub_wrapper__, None, gp_Mat2d)
gp_Mat2d.__itruediv_wrapper__ = new_instancemethod(_gp.gp_Mat2d___itruediv_wrapper__, None, gp_Mat2d)
gp_Mat2d_swigregister = _gp.gp_Mat2d_swigregister
gp_Mat2d_swigregister(gp_Mat2d)

class gp_Parab(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * Returns the main axis of the parabola. It is the axis normal to the plane of the parabola passing through the vertex of the parabola.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Parab_Axis(self, *args)


    def Directrix(self, *args) -> "gp_Ax1":
        """
        * Computes the directrix of this parabola. The directrix is: - a line parallel to the 'Y Direction' of the local coordinate system of this parabola, and - located on the negative side of the axis of symmetry, at a distance from the apex which is equal to the focal length of this parabola. The directrix is returned as an axis (a gp_Ax1 object), the origin of which is situated on the 'X Axis' of this parabola.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Parab_Directrix(self, *args)


    def Focal(self, *args) -> "Standard_Real":
        """
        * Returns the distance between the vertex and the focus of the parabola.
        	:rtype: float
        """
        return _gp.gp_Parab_Focal(self, *args)


    def Focus(self, *args) -> "gp_Pnt":
        """
        * - Computes the focus of the parabola.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Parab_Focus(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the vertex of the parabola. It is the 'Location' point of the coordinate system of the parabola.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Parab_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Parab_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Parab":
        """
        * Performs the symmetrical transformation of a parabola with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Parab
        * Performs the symmetrical transformation of a parabola with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Parab
        * Performs the symmetrical transformation of a parabola with respect to a plane. The axis placement A2 locates the plane of the symmetry (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Parab
        """
        return _gp.gp_Parab_Mirrored(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        * Computes the parameter of the parabola. It is the distance between the focus and the directrix of the parabola. This distance is twice the focal length.
        	:rtype: float
        """
        return _gp.gp_Parab_Parameter(self, *args)


    def Position(self, *args) -> "gp_Ax2 const":
        """
        * Returns the local coordinate system of the parabola.
        	:rtype: gp_Ax2
        """
        return _gp.gp_Parab_Position(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Parab_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Parab":
        """
        * Rotates a parabola. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Parab
        """
        return _gp.gp_Parab_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Parab_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Parab":
        """
        * Scales a parabola. S is the scaling value. If S is negative the direction of the symmetry axis XAxis is reversed and the direction of the YAxis too.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Parab
        """
        return _gp.gp_Parab_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Modifies this parabola by redefining its local coordinate system so that - its origin and 'main Direction' become those of the axis A1 (the 'X Direction' and 'Y Direction' are then recomputed in the same way as for any gp_Ax2) Raises ConstructionError if the direction of A1 is parallel to the previous XAxis of the parabola.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Parab_SetAxis(self, *args)


    def SetFocal(self, *args) -> "void":
        """
        * Changes the focal distance of the parabola. Raises ConstructionError if Focal < 0.0
        	:param Focal:
        	:type Focal: float
        	:rtype: None
        """
        return _gp.gp_Parab_SetFocal(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the location of the parabola. It is the vertex of the parabola.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Parab_SetLocation(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Changes the local coordinate system of the parabola.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Parab_SetPosition(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Parab_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Parab":
        """
        * Transforms a parabola with the transformation T from class Trsf.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Parab
        """
        return _gp.gp_Parab_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Parab_Translate(self, *args)


    def Translated(self, *args) -> "gp_Parab":
        """
        * Translates a parabola in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Parab
        * Translates a parabola from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Parab
        """
        return _gp.gp_Parab_Translated(self, *args)


    def XAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the symmetry axis of the parabola. The location point of the axis is the vertex of the parabola.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Parab_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax1":
        """
        * It is an axis parallel to the directrix of the parabola. The location point of this axis is the vertex of the parabola.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Parab_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates an indefinite Parabola.
        	:rtype: None
        * Creates a parabola with its local coordinate system 'A2' and it's focal length 'Focal'. The XDirection of A2 defines the axis of symmetry of the parabola. The YDirection of A2 is parallel to the directrix of the parabola. The Location point of A2 is the vertex of the parabola Raises ConstructionError if Focal < 0.0 Raised if Focal < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param Focal:
        	:type Focal: float
        	:rtype: None
        * D is the directrix of the parabola and F the focus point. The symmetry axis (XAxis) of the parabola is normal to the directrix and pass through the focus point F, but its location point is the vertex of the parabola. The YAxis of the parabola is parallel to D and its location point is the vertex of the parabola. The normal to the plane of the parabola is the cross product between the XAxis and the YAxis.
        	:param D:
        	:type D: gp_Ax1
        	:param F:
        	:type F: gp_Pnt
        	:rtype: None
        """
        _gp.gp_Parab_swiginit(self, _gp.new_gp_Parab(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Parab
gp_Parab.Axis = new_instancemethod(_gp.gp_Parab_Axis, None, gp_Parab)
gp_Parab.Directrix = new_instancemethod(_gp.gp_Parab_Directrix, None, gp_Parab)
gp_Parab.Focal = new_instancemethod(_gp.gp_Parab_Focal, None, gp_Parab)
gp_Parab.Focus = new_instancemethod(_gp.gp_Parab_Focus, None, gp_Parab)
gp_Parab.Location = new_instancemethod(_gp.gp_Parab_Location, None, gp_Parab)
gp_Parab.Mirror = new_instancemethod(_gp.gp_Parab_Mirror, None, gp_Parab)
gp_Parab.Mirrored = new_instancemethod(_gp.gp_Parab_Mirrored, None, gp_Parab)
gp_Parab.Parameter = new_instancemethod(_gp.gp_Parab_Parameter, None, gp_Parab)
gp_Parab.Position = new_instancemethod(_gp.gp_Parab_Position, None, gp_Parab)
gp_Parab.Rotate = new_instancemethod(_gp.gp_Parab_Rotate, None, gp_Parab)
gp_Parab.Rotated = new_instancemethod(_gp.gp_Parab_Rotated, None, gp_Parab)
gp_Parab.Scale = new_instancemethod(_gp.gp_Parab_Scale, None, gp_Parab)
gp_Parab.Scaled = new_instancemethod(_gp.gp_Parab_Scaled, None, gp_Parab)
gp_Parab.SetAxis = new_instancemethod(_gp.gp_Parab_SetAxis, None, gp_Parab)
gp_Parab.SetFocal = new_instancemethod(_gp.gp_Parab_SetFocal, None, gp_Parab)
gp_Parab.SetLocation = new_instancemethod(_gp.gp_Parab_SetLocation, None, gp_Parab)
gp_Parab.SetPosition = new_instancemethod(_gp.gp_Parab_SetPosition, None, gp_Parab)
gp_Parab.Transform = new_instancemethod(_gp.gp_Parab_Transform, None, gp_Parab)
gp_Parab.Transformed = new_instancemethod(_gp.gp_Parab_Transformed, None, gp_Parab)
gp_Parab.Translate = new_instancemethod(_gp.gp_Parab_Translate, None, gp_Parab)
gp_Parab.Translated = new_instancemethod(_gp.gp_Parab_Translated, None, gp_Parab)
gp_Parab.XAxis = new_instancemethod(_gp.gp_Parab_XAxis, None, gp_Parab)
gp_Parab.YAxis = new_instancemethod(_gp.gp_Parab_YAxis, None, gp_Parab)
gp_Parab_swigregister = _gp.gp_Parab_swigregister
gp_Parab_swigregister(gp_Parab)

class gp_Parab2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Axis(self, *args) -> "gp_Ax22d":
        """
        * Returns the local coordinate system of the parabola. The 'Location' point of this axis is the vertex of the parabola.
        	:rtype: gp_Ax22d
        """
        return _gp.gp_Parab2d_Axis(self, *args)


    def Coefficients(self, *args) -> "void":
        """
        * Computes the coefficients of the implicit equation of the parabola (in WCS - World Coordinate System). A * (X**2) + B * (Y**2) + 2*C*(X*Y) + 2*D*X + 2*E*Y + F = 0.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param F:
        	:type F: float
        	:rtype: None
        """
        return _gp.gp_Parab2d_Coefficients(self, *args)


    def Directrix(self, *args) -> "gp_Ax2d":
        """
        * Computes the directrix of the parabola. The directrix is: - a line parallel to the 'Y Direction' of the local coordinate system of this parabola, and - located on the negative side of the axis of symmetry, at a distance from the apex which is equal to the focal length of this parabola. The directrix is returned as an axis (a gp_Ax2d object), the origin of which is situated on the 'X Axis' of this parabola.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Parab2d_Directrix(self, *args)


    def Focal(self, *args) -> "Standard_Real":
        """
        * Returns the distance between the vertex and the focus of the parabola.
        	:rtype: float
        """
        return _gp.gp_Parab2d_Focal(self, *args)


    def Focus(self, *args) -> "gp_Pnt2d":
        """
        * Returns the focus of the parabola.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Parab2d_Focus(self, *args)


    def IsDirect(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the local coordinate system is direct and false in the other case.
        	:rtype: bool
        """
        return _gp.gp_Parab2d_IsDirect(self, *args)


    def Location(self, *args) -> "gp_Pnt2d":
        """
        * Returns the vertex of the parabola.
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Parab2d_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        :param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Parab2d_Mirror(self, *args)


    def MirrorAxis(self, *args) -> "gp_Ax2d":
        """
        * Returns the symmetry axis of the parabola. The 'Location' point of this axis is the vertex of the parabola.
        	:rtype: gp_Ax2d
        """
        return _gp.gp_Parab2d_MirrorAxis(self, *args)


    def Mirrored(self, *args) -> "gp_Parab2d":
        """
        * Performs the symmetrical transformation of a parabola with respect to the point P which is the center of the symmetry
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Parab2d
        * Performs the symmetrical transformation of a parabola with respect to an axis placement which is the axis of the symmetry.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: gp_Parab2d
        """
        return _gp.gp_Parab2d_Mirrored(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        * Returns the distance between the focus and the directrix of the parabola.
        	:rtype: float
        """
        return _gp.gp_Parab2d_Parameter(self, *args)


    def Reverse(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Parab2d_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Parab2d":
        """
        * Reverses the orientation of the local coordinate system of this parabola (the 'Y Direction' is reversed). Therefore, the implicit orientation of this parabola is reversed. Note: - Reverse assigns the result to this parabola, while - Reversed creates a new one.
        	:rtype: gp_Parab2d
        """
        return _gp.gp_Parab2d_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Parab2d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Parab2d":
        """
        * Rotates a parabola. P is the center of the rotation. Ang is the angular value of the rotation in radians.
        	:param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Parab2d
        """
        return _gp.gp_Parab2d_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Parab2d_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Parab2d":
        """
        * Scales a parabola. S is the scaling value. If S is negative the direction of the symmetry axis 'XAxis' is reversed and the direction of the 'YAxis' too.
        	:param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: gp_Parab2d
        """
        return _gp.gp_Parab2d_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Changes the local coordinate system of the parabola. The 'Location' point of A becomes the vertex of the parabola.
        	:param A:
        	:type A: gp_Ax22d
        	:rtype: None
        """
        return _gp.gp_Parab2d_SetAxis(self, *args)


    def SetFocal(self, *args) -> "void":
        """
        * Changes the focal distance of the parabola Warnings : It is possible to have Focal = 0. Raises ConstructionError if Focal < 0.0
        	:param Focal:
        	:type Focal: float
        	:rtype: None
        """
        return _gp.gp_Parab2d_SetFocal(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the 'Location' point of the parabola. It is the vertex of the parabola.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Parab2d_SetLocation(self, *args)


    def SetMirrorAxis(self, *args) -> "void":
        """
        * Modifies this parabola, by redefining its local coordinate system so that its origin and 'X Direction' become those of the axis MA. The 'Y Direction' of the local coordinate system is then recomputed. The orientation of the local coordinate system is not modified.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Parab2d_SetMirrorAxis(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Parab2d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Parab2d":
        """
        * Transforms an parabola with the transformation T from class Trsf2d.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Parab2d
        """
        return _gp.gp_Parab2d_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec2d
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Parab2d_Translate(self, *args)


    def Translated(self, *args) -> "gp_Parab2d":
        """
        * Translates a parabola in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: gp_Parab2d
        * Translates a parabola from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: gp_Parab2d
        """
        return _gp.gp_Parab2d_Translated(self, *args)


    def __init__(self, *args):
        """
        * Creates an indefinite parabola.
        	:rtype: None
        * Creates a parabola with its vertex point, its axis of symmetry ('XAxis') and its focal length. The sense of parametrization is given by theSense. If theSense == True (by default) then right-handed coordinate system is used, otherwise - left-handed. Warnings : It is possible to have FocalLength = 0. In this case, the parabola looks like a line, which is parallel to the symmetry-axis. Raises ConstructionError if FocalLength < 0.0
        	:param theMirrorAxis:
        	:type theMirrorAxis: gp_Ax2d
        	:param theFocalLength:
        	:type theFocalLength: float
        	:param theSense: default value is Standard_True
        	:type theSense: bool
        	:rtype: None
        * Creates a parabola with its vertex point, its axis of symmetry ('XAxis'), correspond Y-axis and its focal length. Warnings : It is possible to have FocalLength = 0. In this case, the parabola looks like a line, which is parallel to the symmetry-axis. Raises ConstructionError if Focal < 0.0
        	:param theAxes:
        	:type theAxes: gp_Ax22d
        	:param theFocalLength:
        	:type theFocalLength: float
        	:rtype: None
        * Creates a parabola with the directrix and the focus point. Y-axis of the parabola (in User Coordinate System - UCS) is the direction of theDirectrix. X-axis always directs from theDirectrix to theFocus point and always comes through theFocus. Apex of the parabola is a middle point between the theFocus and the intersection point of theDirectrix and the X-axis. Warnings : It is possible to have FocalLength = 0 (when theFocus lies in theDirectrix). In this case, X-direction of the parabola is defined by theSense parameter. If theSense == True (by default) then right-handed coordinate system is used, otherwise - left-handed. Result parabola will look like a line, which is perpendicular to the directrix.
        	:param theDirectrix:
        	:type theDirectrix: gp_Ax2d
        	:param theFocus:
        	:type theFocus: gp_Pnt2d
        	:param theSense: default value is Standard_True
        	:type theSense: bool
        	:rtype: None
        """
        _gp.gp_Parab2d_swiginit(self, _gp.new_gp_Parab2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Parab2d
gp_Parab2d.Axis = new_instancemethod(_gp.gp_Parab2d_Axis, None, gp_Parab2d)
gp_Parab2d.Coefficients = new_instancemethod(_gp.gp_Parab2d_Coefficients, None, gp_Parab2d)
gp_Parab2d.Directrix = new_instancemethod(_gp.gp_Parab2d_Directrix, None, gp_Parab2d)
gp_Parab2d.Focal = new_instancemethod(_gp.gp_Parab2d_Focal, None, gp_Parab2d)
gp_Parab2d.Focus = new_instancemethod(_gp.gp_Parab2d_Focus, None, gp_Parab2d)
gp_Parab2d.IsDirect = new_instancemethod(_gp.gp_Parab2d_IsDirect, None, gp_Parab2d)
gp_Parab2d.Location = new_instancemethod(_gp.gp_Parab2d_Location, None, gp_Parab2d)
gp_Parab2d.Mirror = new_instancemethod(_gp.gp_Parab2d_Mirror, None, gp_Parab2d)
gp_Parab2d.MirrorAxis = new_instancemethod(_gp.gp_Parab2d_MirrorAxis, None, gp_Parab2d)
gp_Parab2d.Mirrored = new_instancemethod(_gp.gp_Parab2d_Mirrored, None, gp_Parab2d)
gp_Parab2d.Parameter = new_instancemethod(_gp.gp_Parab2d_Parameter, None, gp_Parab2d)
gp_Parab2d.Reverse = new_instancemethod(_gp.gp_Parab2d_Reverse, None, gp_Parab2d)
gp_Parab2d.Reversed = new_instancemethod(_gp.gp_Parab2d_Reversed, None, gp_Parab2d)
gp_Parab2d.Rotate = new_instancemethod(_gp.gp_Parab2d_Rotate, None, gp_Parab2d)
gp_Parab2d.Rotated = new_instancemethod(_gp.gp_Parab2d_Rotated, None, gp_Parab2d)
gp_Parab2d.Scale = new_instancemethod(_gp.gp_Parab2d_Scale, None, gp_Parab2d)
gp_Parab2d.Scaled = new_instancemethod(_gp.gp_Parab2d_Scaled, None, gp_Parab2d)
gp_Parab2d.SetAxis = new_instancemethod(_gp.gp_Parab2d_SetAxis, None, gp_Parab2d)
gp_Parab2d.SetFocal = new_instancemethod(_gp.gp_Parab2d_SetFocal, None, gp_Parab2d)
gp_Parab2d.SetLocation = new_instancemethod(_gp.gp_Parab2d_SetLocation, None, gp_Parab2d)
gp_Parab2d.SetMirrorAxis = new_instancemethod(_gp.gp_Parab2d_SetMirrorAxis, None, gp_Parab2d)
gp_Parab2d.Transform = new_instancemethod(_gp.gp_Parab2d_Transform, None, gp_Parab2d)
gp_Parab2d.Transformed = new_instancemethod(_gp.gp_Parab2d_Transformed, None, gp_Parab2d)
gp_Parab2d.Translate = new_instancemethod(_gp.gp_Parab2d_Translate, None, gp_Parab2d)
gp_Parab2d.Translated = new_instancemethod(_gp.gp_Parab2d_Translated, None, gp_Parab2d)
gp_Parab2d_swigregister = _gp.gp_Parab2d_swigregister
gp_Parab2d_swigregister(gp_Parab2d)

class gp_Pln(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * Returns the plane's normal Axis.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Pln_Axis(self, *args)


    def Coefficients(self, *args) -> "void":
        """
        * Returns the coefficients of the plane's cartesian equation : A * X + B * Y + C * Z + D = 0.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:rtype: None
        """
        return _gp.gp_Pln_Coefficients(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        * Returns true if this plane contains the point P. This means that - the distance between point P and this plane is less than or equal to LinearTolerance, or - line L is normal to the 'main Axis' of the local coordinate system of this plane, within the tolerance AngularTolerance, and the distance between the origin of line L and this plane is less than or equal to LinearTolerance.
        	:param P:
        	:type P: gp_Pnt
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:rtype: bool
        * Returns true if this plane contains the line L. This means that - the distance between point P and this plane is less than or equal to LinearTolerance, or - line L is normal to the 'main Axis' of the local coordinate system of this plane, within the tolerance AngularTolerance, and the distance between the origin of line L and this plane is less than or equal to LinearTolerance.
        	:param L:
        	:type L: gp_Lin
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Pln_Contains(self, *args)


    def Direct(self, *args) -> "Standard_Boolean":
        """
        * returns true if the Ax3 is right handed.
        	:rtype: bool
        """
        return _gp.gp_Pln_Direct(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        * Computes the distance between <self> and the point <P>.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: float
        * Computes the distance between <self> and the line <L>.
        	:param L:
        	:type L: gp_Lin
        	:rtype: float
        * Computes the distance between two planes.
        	:param Other:
        	:type Other: gp_Pln
        	:rtype: float
        """
        return _gp.gp_Pln_Distance(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the plane's location (origin).
        	:rtype: gp_Pnt
        """
        return _gp.gp_Pln_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Pln_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Pln":
        """
        * Performs the symmetrical transformation of a plane with respect to the point <P> which is the center of the symmetry Warnings : The normal direction to the plane is not changed. The 'XAxis' and the 'YAxis' are reversed.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Pln
        * Performs the symmetrical transformation of a plane with respect to an axis placement which is the axis of the symmetry. The transformation is performed on the 'Location' point, on the 'XAxis' and the 'YAxis'. The resulting normal direction is the cross product between the 'XDirection' and the 'YDirection' after transformation if the initial plane was right handed, else it is the opposite.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Pln
        * Performs the symmetrical transformation of a plane with respect to an axis placement. The axis placement <A2> locates the plane of the symmetry. The transformation is performed on the 'Location' point, on the 'XAxis' and the 'YAxis'. The resulting normal direction is the cross product between the 'XDirection' and the 'YDirection' after transformation if the initial plane was right handed, else it is the opposite.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Pln
        """
        return _gp.gp_Pln_Mirrored(self, *args)


    def Position(self, *args) -> "gp_Ax3 const":
        """
        * Returns the local coordinate system of the plane .
        	:rtype: gp_Ax3
        """
        return _gp.gp_Pln_Position(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Pln_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Pln":
        """
        * rotates a plane. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Pln
        """
        return _gp.gp_Pln_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Pln_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Pln":
        """
        * Scales a plane. S is the scaling value.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Pln
        """
        return _gp.gp_Pln_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Modifies this plane, by redefining its local coordinate system so that - its origin and 'main Direction' become those of the axis A1 (the 'X Direction' and 'Y Direction' are then recomputed). Raises ConstructionError if the A1 is parallel to the 'XAxis' of the plane.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Pln_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the origin of the plane.
        	:param Loc:
        	:type Loc: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Pln_SetLocation(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Changes the local coordinate system of the plane.
        	:param A3:
        	:type A3: gp_Ax3
        	:rtype: None
        """
        return _gp.gp_Pln_SetPosition(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        * Computes the square distance between <self> and the point <P>.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: float
        * Computes the square distance between <self> and the line <L>.
        	:param L:
        	:type L: gp_Lin
        	:rtype: float
        * Computes the square distance between two planes.
        	:param Other:
        	:type Other: gp_Pln
        	:rtype: float
        """
        return _gp.gp_Pln_SquareDistance(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Pln_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Pln":
        """
        * Transforms a plane with the transformation T from class Trsf. The transformation is performed on the 'Location' point, on the 'XAxis' and the 'YAxis'. The resulting normal direction is the cross product between the 'XDirection' and the 'YDirection' after transformation.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Pln
        """
        return _gp.gp_Pln_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Pln_Translate(self, *args)


    def Translated(self, *args) -> "gp_Pln":
        """
        * Translates a plane in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Pln
        * Translates a plane from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Pln
        """
        return _gp.gp_Pln_Translated(self, *args)


    def UReverse(self, *args) -> "void":
        """
        * Reverses the U parametrization of the plane reversing the XAxis.
        	:rtype: None
        """
        return _gp.gp_Pln_UReverse(self, *args)


    def VReverse(self, *args) -> "void":
        """
        * Reverses the V parametrization of the plane reversing the YAxis.
        	:rtype: None
        """
        return _gp.gp_Pln_VReverse(self, *args)


    def XAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the X axis of the plane.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Pln_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the Y axis of the plane.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Pln_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates a plane coincident with OXY plane of the reference coordinate system.
        	:rtype: None
        * The coordinate system of the plane is defined with the axis placement A3. The 'Direction' of A3 defines the normal to the plane. The 'Location' of A3 defines the location (origin) of the plane. The 'XDirection' and 'YDirection' of A3 define the 'XAxis' and the 'YAxis' of the plane used to parametrize the plane.
        	:param A3:
        	:type A3: gp_Ax3
        	:rtype: None
        * Creates a plane with the 'Location' point <P> and the normal direction <V>.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        * Creates a plane from its cartesian equation : A * X + B * Y + C * Z + D = 0.0 Raises ConstructionError if Sqrt (A*A + B*B + C*C) <= Resolution from gp.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:rtype: None
        """
        _gp.gp_Pln_swiginit(self, _gp.new_gp_Pln(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Pln
gp_Pln.Axis = new_instancemethod(_gp.gp_Pln_Axis, None, gp_Pln)
gp_Pln.Coefficients = new_instancemethod(_gp.gp_Pln_Coefficients, None, gp_Pln)
gp_Pln.Contains = new_instancemethod(_gp.gp_Pln_Contains, None, gp_Pln)
gp_Pln.Direct = new_instancemethod(_gp.gp_Pln_Direct, None, gp_Pln)
gp_Pln.Distance = new_instancemethod(_gp.gp_Pln_Distance, None, gp_Pln)
gp_Pln.Location = new_instancemethod(_gp.gp_Pln_Location, None, gp_Pln)
gp_Pln.Mirror = new_instancemethod(_gp.gp_Pln_Mirror, None, gp_Pln)
gp_Pln.Mirrored = new_instancemethod(_gp.gp_Pln_Mirrored, None, gp_Pln)
gp_Pln.Position = new_instancemethod(_gp.gp_Pln_Position, None, gp_Pln)
gp_Pln.Rotate = new_instancemethod(_gp.gp_Pln_Rotate, None, gp_Pln)
gp_Pln.Rotated = new_instancemethod(_gp.gp_Pln_Rotated, None, gp_Pln)
gp_Pln.Scale = new_instancemethod(_gp.gp_Pln_Scale, None, gp_Pln)
gp_Pln.Scaled = new_instancemethod(_gp.gp_Pln_Scaled, None, gp_Pln)
gp_Pln.SetAxis = new_instancemethod(_gp.gp_Pln_SetAxis, None, gp_Pln)
gp_Pln.SetLocation = new_instancemethod(_gp.gp_Pln_SetLocation, None, gp_Pln)
gp_Pln.SetPosition = new_instancemethod(_gp.gp_Pln_SetPosition, None, gp_Pln)
gp_Pln.SquareDistance = new_instancemethod(_gp.gp_Pln_SquareDistance, None, gp_Pln)
gp_Pln.Transform = new_instancemethod(_gp.gp_Pln_Transform, None, gp_Pln)
gp_Pln.Transformed = new_instancemethod(_gp.gp_Pln_Transformed, None, gp_Pln)
gp_Pln.Translate = new_instancemethod(_gp.gp_Pln_Translate, None, gp_Pln)
gp_Pln.Translated = new_instancemethod(_gp.gp_Pln_Translated, None, gp_Pln)
gp_Pln.UReverse = new_instancemethod(_gp.gp_Pln_UReverse, None, gp_Pln)
gp_Pln.VReverse = new_instancemethod(_gp.gp_Pln_VReverse, None, gp_Pln)
gp_Pln.XAxis = new_instancemethod(_gp.gp_Pln_XAxis, None, gp_Pln)
gp_Pln.YAxis = new_instancemethod(_gp.gp_Pln_YAxis, None, gp_Pln)
gp_Pln_swigregister = _gp.gp_Pln_swigregister
gp_Pln_swigregister(gp_Pln)

class gp_Pnt(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BaryCenter(self, *args) -> "void":
        """
        * Assigns the result of the following expression to this point (Alpha*this + Beta*P) / (Alpha + Beta)
        	:param Alpha:
        	:type Alpha: float
        	:param P:
        	:type P: gp_Pnt
        	:param Beta:
        	:type Beta: float
        	:rtype: None
        """
        return _gp.gp_Pnt_BaryCenter(self, *args)


    def ChangeCoord(self, *args) -> "gp_XYZ":
        """
        * Returns the coordinates of this point. Note: This syntax allows direct modification of the returned value.
        	:rtype: gp_XYZ
        """
        return _gp.gp_Pnt_ChangeCoord(self, *args)


    def Coord(self, *args) -> "gp_XYZ const":
        """
        * Returns the coordinate of corresponding to the value of Index : Index = 1 => X is returned Index = 2 => Y is returned Index = 3 => Z is returned Raises OutOfRange if Index != {1, 2, 3}. Raised if Index != {1, 2, 3}.
        	:param Index:
        	:type Index: int
        	:rtype: float
        * For this point gives its three coordinates Xp, Yp and Zp.
        	:param Xp:
        	:type Xp: float
        	:param Yp:
        	:type Yp: float
        	:param Zp:
        	:type Zp: float
        	:rtype: None
        * For this point, returns its three coordinates as a XYZ object.
        	:rtype: gp_XYZ
        """
        return _gp.gp_Pnt_Coord(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        * Computes the distance between two points.
        	:param Other:
        	:type Other: gp_Pnt
        	:rtype: float
        """
        return _gp.gp_Pnt_Distance(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Comparison Returns True if the distance between the two points is lower or equal to LinearTolerance.
        	:param Other:
        	:type Other: gp_Pnt
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Pnt_IsEqual(self, *args)


    def Mirror(self, *args) -> "void":
        """
        * Performs the symmetrical transformation of a point with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Pnt_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Pnt":
        """
        * Performs the symmetrical transformation of a point with respect to an axis placement which is the axis of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Pnt
        * Performs the symmetrical transformation of a point with respect to a plane. The axis placement A2 locates the plane of the symmetry : (Location, XDirection, YDirection).
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Pnt
        * Rotates a point. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Pnt
        """
        return _gp.gp_Pnt_Mirrored(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Pnt_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Pnt":
        """
        * Scales a point. S is the scaling value.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Pnt
        """
        return _gp.gp_Pnt_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Pnt_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Pnt":
        """
        * Transforms a point with the transformation T.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Pnt
        """
        return _gp.gp_Pnt_Scaled(self, *args)


    def SetCoord(self, *args) -> "void":
        """
        * Changes the coordinate of range Index : Index = 1 => X is modified Index = 2 => Y is modified Index = 3 => Z is modified Raised if Index != {1, 2, 3}.
        	:param Index:
        	:type Index: int
        	:param Xi:
        	:type Xi: float
        	:rtype: None
        * For this point, assigns the values Xp, Yp and Zp to its three coordinates.
        	:param Xp:
        	:type Xp: float
        	:param Yp:
        	:type Yp: float
        	:param Zp:
        	:type Zp: float
        	:rtype: None
        """
        return _gp.gp_Pnt_SetCoord(self, *args)


    def SetX(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate of this point.
        	:param X:
        	:type X: float
        	:rtype: None
        """
        return _gp.gp_Pnt_SetX(self, *args)


    def SetXYZ(self, *args) -> "void":
        """
        * Assigns the three coordinates of Coord to this point.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Pnt_SetXYZ(self, *args)


    def SetY(self, *args) -> "void":
        """
        * Assigns the given value to the Y coordinate of this point.
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_Pnt_SetY(self, *args)


    def SetZ(self, *args) -> "void":
        """
        * Assigns the given value to the Z coordinate of this point.
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        return _gp.gp_Pnt_SetZ(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        * Computes the square distance between two points.
        	:param Other:
        	:type Other: gp_Pnt
        	:rtype: float
        """
        return _gp.gp_Pnt_SquareDistance(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Pnt_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Pnt":
        """
        * Translates a point in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Pnt
        """
        return _gp.gp_Pnt_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Pnt_Translate(self, *args)


    def Translated(self, *args) -> "gp_Pnt":
        """
        * Translates a point from the point P1 to the point P2.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Pnt
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Pnt
        """
        return _gp.gp_Pnt_Translated(self, *args)


    def X(self, *args) -> "Standard_Real":
        """
        * For this point, returns its X coordinate.
        	:rtype: float
        """
        return _gp.gp_Pnt_X(self, *args)


    def XYZ(self, *args) -> "gp_XYZ const":
        """
        * For this point, returns its three coordinates as a XYZ object.
        	:rtype: gp_XYZ
        """
        return _gp.gp_Pnt_XYZ(self, *args)


    def Y(self, *args) -> "Standard_Real":
        """
        * For this point, returns its Y coordinate.
        	:rtype: float
        """
        return _gp.gp_Pnt_Y(self, *args)


    def Z(self, *args) -> "Standard_Real":
        """
        * For this point, returns its Z coordinate.
        	:rtype: float
        """
        return _gp.gp_Pnt_Z(self, *args)


    def __init__(self, *args):
        """
        * Creates a point with zero coordinates.
        	:rtype: None
        * Creates a point from a XYZ object.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        * Creates a point with its 3 cartesian's coordinates : Xp, Yp, Zp.
        	:param Xp:
        	:type Xp: float
        	:param Yp:
        	:type Yp: float
        	:param Zp:
        	:type Zp: float
        	:rtype: None
        """
        _gp.gp_Pnt_swiginit(self, _gp.new_gp_Pnt(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Pnt
gp_Pnt.BaryCenter = new_instancemethod(_gp.gp_Pnt_BaryCenter, None, gp_Pnt)
gp_Pnt.ChangeCoord = new_instancemethod(_gp.gp_Pnt_ChangeCoord, None, gp_Pnt)
gp_Pnt.Coord = new_instancemethod(_gp.gp_Pnt_Coord, None, gp_Pnt)
gp_Pnt.Distance = new_instancemethod(_gp.gp_Pnt_Distance, None, gp_Pnt)
gp_Pnt.IsEqual = new_instancemethod(_gp.gp_Pnt_IsEqual, None, gp_Pnt)
gp_Pnt.Mirror = new_instancemethod(_gp.gp_Pnt_Mirror, None, gp_Pnt)
gp_Pnt.Mirrored = new_instancemethod(_gp.gp_Pnt_Mirrored, None, gp_Pnt)
gp_Pnt.Rotate = new_instancemethod(_gp.gp_Pnt_Rotate, None, gp_Pnt)
gp_Pnt.Rotated = new_instancemethod(_gp.gp_Pnt_Rotated, None, gp_Pnt)
gp_Pnt.Scale = new_instancemethod(_gp.gp_Pnt_Scale, None, gp_Pnt)
gp_Pnt.Scaled = new_instancemethod(_gp.gp_Pnt_Scaled, None, gp_Pnt)
gp_Pnt.SetCoord = new_instancemethod(_gp.gp_Pnt_SetCoord, None, gp_Pnt)
gp_Pnt.SetX = new_instancemethod(_gp.gp_Pnt_SetX, None, gp_Pnt)
gp_Pnt.SetXYZ = new_instancemethod(_gp.gp_Pnt_SetXYZ, None, gp_Pnt)
gp_Pnt.SetY = new_instancemethod(_gp.gp_Pnt_SetY, None, gp_Pnt)
gp_Pnt.SetZ = new_instancemethod(_gp.gp_Pnt_SetZ, None, gp_Pnt)
gp_Pnt.SquareDistance = new_instancemethod(_gp.gp_Pnt_SquareDistance, None, gp_Pnt)
gp_Pnt.Transform = new_instancemethod(_gp.gp_Pnt_Transform, None, gp_Pnt)
gp_Pnt.Transformed = new_instancemethod(_gp.gp_Pnt_Transformed, None, gp_Pnt)
gp_Pnt.Translate = new_instancemethod(_gp.gp_Pnt_Translate, None, gp_Pnt)
gp_Pnt.Translated = new_instancemethod(_gp.gp_Pnt_Translated, None, gp_Pnt)
gp_Pnt.X = new_instancemethod(_gp.gp_Pnt_X, None, gp_Pnt)
gp_Pnt.XYZ = new_instancemethod(_gp.gp_Pnt_XYZ, None, gp_Pnt)
gp_Pnt.Y = new_instancemethod(_gp.gp_Pnt_Y, None, gp_Pnt)
gp_Pnt.Z = new_instancemethod(_gp.gp_Pnt_Z, None, gp_Pnt)
gp_Pnt_swigregister = _gp.gp_Pnt_swigregister
gp_Pnt_swigregister(gp_Pnt)

class gp_Pnt2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ChangeCoord(self, *args) -> "gp_XY":
        """
        * Returns the coordinates of this point. Note: This syntax allows direct modification of the returned value.
        	:rtype: gp_XY
        """
        return _gp.gp_Pnt2d_ChangeCoord(self, *args)


    def Coord(self, *args) -> "gp_XY const":
        """
        * Returns the coordinate of range Index : Index = 1 => X is returned Index = 2 => Y is returned Raises OutOfRange if Index != {1, 2}.
        	:param Index:
        	:type Index: int
        	:rtype: float
        * For this point returns its two coordinates as a number pair.
        	:param Xp:
        	:type Xp: float
        	:param Yp:
        	:type Yp: float
        	:rtype: None
        * For this point, returns its two coordinates as a number pair.
        	:rtype: gp_XY
        """
        return _gp.gp_Pnt2d_Coord(self, *args)


    def Distance(self, *args) -> "Standard_Real":
        """
        * Computes the distance between two points.
        	:param Other:
        	:type Other: gp_Pnt2d
        	:rtype: float
        """
        return _gp.gp_Pnt2d_Distance(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Comparison Returns True if the distance between the two points is lower or equal to LinearTolerance.
        	:param Other:
        	:type Other: gp_Pnt2d
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Pnt2d_IsEqual(self, *args)


    def Mirror(self, *args) -> "void":
        """
        * Performs the symmetrical transformation of a point with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        :param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Pnt2d_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Pnt2d":
        """
        * Performs the symmetrical transformation of a point with respect to an axis placement which is the axis
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: gp_Pnt2d
        * Rotates a point. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Pnt2d_Mirrored(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Pnt2d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Pnt2d":
        """
        * Scales a point. S is the scaling value.
        	:param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Pnt2d_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Pnt2d_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Pnt2d":
        """
        * Transforms a point with the transformation T.
        	:param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Pnt2d_Scaled(self, *args)


    def SetCoord(self, *args) -> "void":
        """
        * Assigns the value Xi to the coordinate that corresponds to Index: Index = 1 => X is modified Index = 2 => Y is modified Raises OutOfRange if Index != {1, 2}.
        	:param Index:
        	:type Index: int
        	:param Xi:
        	:type Xi: float
        	:rtype: None
        * For this point, assigns the values Xp and Yp to its two coordinates
        	:param Xp:
        	:type Xp: float
        	:param Yp:
        	:type Yp: float
        	:rtype: None
        """
        return _gp.gp_Pnt2d_SetCoord(self, *args)


    def SetX(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate of this point.
        	:param X:
        	:type X: float
        	:rtype: None
        """
        return _gp.gp_Pnt2d_SetX(self, *args)


    def SetXY(self, *args) -> "void":
        """
        * Assigns the two coordinates of Coord to this point.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        """
        return _gp.gp_Pnt2d_SetXY(self, *args)


    def SetY(self, *args) -> "void":
        """
        * Assigns the given value to the Y coordinate of this point.
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_Pnt2d_SetY(self, *args)


    def SquareDistance(self, *args) -> "Standard_Real":
        """
        * Computes the square distance between two points.
        	:param Other:
        	:type Other: gp_Pnt2d
        	:rtype: float
        """
        return _gp.gp_Pnt2d_SquareDistance(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Pnt2d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Pnt2d":
        """
        * Translates a point in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Pnt2d_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec2d
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Pnt2d_Translate(self, *args)


    def Translated(self, *args) -> "gp_Pnt2d":
        """
        * Translates a point from the point P1 to the point P2.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: gp_Pnt2d
        :param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: gp_Pnt2d
        """
        return _gp.gp_Pnt2d_Translated(self, *args)


    def X(self, *args) -> "Standard_Real":
        """
        * For this point, returns its X coordinate.
        	:rtype: float
        """
        return _gp.gp_Pnt2d_X(self, *args)


    def XY(self, *args) -> "gp_XY const":
        """
        * For this point, returns its two coordinates as a number pair.
        	:rtype: gp_XY
        """
        return _gp.gp_Pnt2d_XY(self, *args)


    def Y(self, *args) -> "Standard_Real":
        """
        * For this point, returns its Y coordinate.
        	:rtype: float
        """
        return _gp.gp_Pnt2d_Y(self, *args)


    def __init__(self, *args):
        """
        * Creates a point with zero coordinates.
        	:rtype: None
        * Creates a point with a doublet of coordinates.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        * Creates a point with its 2 cartesian's coordinates : Xp, Yp.
        	:param Xp:
        	:type Xp: float
        	:param Yp:
        	:type Yp: float
        	:rtype: None
        """
        _gp.gp_Pnt2d_swiginit(self, _gp.new_gp_Pnt2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Pnt2d
gp_Pnt2d.ChangeCoord = new_instancemethod(_gp.gp_Pnt2d_ChangeCoord, None, gp_Pnt2d)
gp_Pnt2d.Coord = new_instancemethod(_gp.gp_Pnt2d_Coord, None, gp_Pnt2d)
gp_Pnt2d.Distance = new_instancemethod(_gp.gp_Pnt2d_Distance, None, gp_Pnt2d)
gp_Pnt2d.IsEqual = new_instancemethod(_gp.gp_Pnt2d_IsEqual, None, gp_Pnt2d)
gp_Pnt2d.Mirror = new_instancemethod(_gp.gp_Pnt2d_Mirror, None, gp_Pnt2d)
gp_Pnt2d.Mirrored = new_instancemethod(_gp.gp_Pnt2d_Mirrored, None, gp_Pnt2d)
gp_Pnt2d.Rotate = new_instancemethod(_gp.gp_Pnt2d_Rotate, None, gp_Pnt2d)
gp_Pnt2d.Rotated = new_instancemethod(_gp.gp_Pnt2d_Rotated, None, gp_Pnt2d)
gp_Pnt2d.Scale = new_instancemethod(_gp.gp_Pnt2d_Scale, None, gp_Pnt2d)
gp_Pnt2d.Scaled = new_instancemethod(_gp.gp_Pnt2d_Scaled, None, gp_Pnt2d)
gp_Pnt2d.SetCoord = new_instancemethod(_gp.gp_Pnt2d_SetCoord, None, gp_Pnt2d)
gp_Pnt2d.SetX = new_instancemethod(_gp.gp_Pnt2d_SetX, None, gp_Pnt2d)
gp_Pnt2d.SetXY = new_instancemethod(_gp.gp_Pnt2d_SetXY, None, gp_Pnt2d)
gp_Pnt2d.SetY = new_instancemethod(_gp.gp_Pnt2d_SetY, None, gp_Pnt2d)
gp_Pnt2d.SquareDistance = new_instancemethod(_gp.gp_Pnt2d_SquareDistance, None, gp_Pnt2d)
gp_Pnt2d.Transform = new_instancemethod(_gp.gp_Pnt2d_Transform, None, gp_Pnt2d)
gp_Pnt2d.Transformed = new_instancemethod(_gp.gp_Pnt2d_Transformed, None, gp_Pnt2d)
gp_Pnt2d.Translate = new_instancemethod(_gp.gp_Pnt2d_Translate, None, gp_Pnt2d)
gp_Pnt2d.Translated = new_instancemethod(_gp.gp_Pnt2d_Translated, None, gp_Pnt2d)
gp_Pnt2d.X = new_instancemethod(_gp.gp_Pnt2d_X, None, gp_Pnt2d)
gp_Pnt2d.XY = new_instancemethod(_gp.gp_Pnt2d_XY, None, gp_Pnt2d)
gp_Pnt2d.Y = new_instancemethod(_gp.gp_Pnt2d_Y, None, gp_Pnt2d)
gp_Pnt2d_swigregister = _gp.gp_Pnt2d_swigregister
gp_Pnt2d_swigregister(gp_Pnt2d)

class gp_Quaternion(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds componnets of other quaternion; result is 'rotations mix'
        	:param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_Quaternion_Add(self, *args)


    def Added(self, *args) -> "gp_Quaternion":
        """
        * Makes sum of quaternion components; result is 'rotations mix'
        	:param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion_Added(self, *args)


    def Dot(self, *args) -> "Standard_Real":
        """
        * Computes inner product / scalar product / Dot
        	:param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: float
        """
        return _gp.gp_Quaternion_Dot(self, *args)


    def GetEulerAngles(self, *args) -> "void":
        """
        * Returns Euler angles describing current rotation
        	:param theOrder:
        	:type theOrder: gp_EulerSequence
        	:param theAlpha:
        	:type theAlpha: float
        	:param theBeta:
        	:type theBeta: float
        	:param theGamma:
        	:type theGamma: float
        	:rtype: None
        """
        return _gp.gp_Quaternion_GetEulerAngles(self, *args)


    def GetMatrix(self, *args) -> "gp_Mat":
        """
        * Returns rotation operation as 3*3 matrix
        	:rtype: gp_Mat
        """
        return _gp.gp_Quaternion_GetMatrix(self, *args)


    def GetRotationAngle(self, *args) -> "Standard_Real":
        """
        * Return rotation angle from -PI to PI
        	:rtype: float
        """
        return _gp.gp_Quaternion_GetRotationAngle(self, *args)


    def GetVectorAndAngle(self, *args) -> "void":
        """
        * Convert a quaternion to Axis+Angle representation, preserve the axis direction and angle from -PI to +PI
        	:param theAxis:
        	:type theAxis: gp_Vec
        	:param theAngle:
        	:type theAngle: float
        	:rtype: None
        """
        return _gp.gp_Quaternion_GetVectorAndAngle(self, *args)


    def Invert(self, *args) -> "void":
        """
        * Inverts quaternion (both rotation direction and norm)
        	:rtype: None
        """
        return _gp.gp_Quaternion_Invert(self, *args)


    def Inverted(self, *args) -> "gp_Quaternion":
        """
        * Return inversed quaternion q^-1
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion_Inverted(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Simple equal test without precision
        	:param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: bool
        """
        return _gp.gp_Quaternion_IsEqual(self, *args)


    def Multiplied(self, *args) -> "gp_Quaternion":
        """
        * Multiply function - work the same as Matrices multiplying. qq' = (cross(v,v') + wv' + w'v, ww' - dot(v,v')) Result is rotation combination: q' than q (here q=this, q'=theQ). Notices than: qq' != q'q; qq^-1 = q;
        	:param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion_Multiplied(self, *args)


    def Multiply(self, *args) -> "gp_Vec":
        """
        * Adds rotation by multiplication
        	:param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: None
        * Rotates vector by quaternion as rotation operator
        	:param theVec:
        	:type theVec: gp_Vec
        	:rtype: gp_Vec
        """
        return _gp.gp_Quaternion_Multiply(self, *args)


    def Negated(self, *args) -> "gp_Quaternion":
        """
        * Returns quaternion with all components negated. Note that this operation does not affect neither rotation operator defined by quaternion nor its norm.
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion_Negated(self, *args)


    def Norm(self, *args) -> "Standard_Real":
        """
        * Returns norm of quaternion
        	:rtype: float
        """
        return _gp.gp_Quaternion_Norm(self, *args)


    def Normalize(self, *args) -> "void":
        """
        * Scale quaternion that its norm goes to 1. The appearing of 0 magnitude or near is a error, so we can be sure that can divide by magnitude
        	:rtype: None
        """
        return _gp.gp_Quaternion_Normalize(self, *args)


    def Normalized(self, *args) -> "gp_Quaternion":
        """
        * Returns quaternion scaled so that its norm goes to 1.
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion_Normalized(self, *args)


    def Reverse(self, *args) -> "void":
        """
        * Reverse direction of rotation (conjugate quaternion)
        	:rtype: None
        """
        return _gp.gp_Quaternion_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Quaternion":
        """
        * Return rotation with reversed direction (conjugated quaternion)
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion_Reversed(self, *args)


    def Scale(self, *args) -> "void":
        """
        * Scale all components by quaternion by theScale; note that rotation is not changed by this operation (except 0-scaling)
        	:param theScale:
        	:type theScale: float
        	:rtype: None
        """
        return _gp.gp_Quaternion_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Quaternion":
        """
        * Returns scaled quaternion
        	:param theScale:
        	:type theScale: float
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion_Scaled(self, *args)


    def Set(self, *args) -> "void":
        """
        :param x:
        	:type x: float
        	:param y:
        	:type y: float
        	:param z:
        	:type z: float
        	:param w:
        	:type w: float
        	:rtype: None
        :param theQuaternion:
        	:type theQuaternion: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_Quaternion_Set(self, *args)


    def SetEulerAngles(self, *args) -> "void":
        """
        * Create a unit quaternion representing rotation defined by generalized Euler angles
        	:param theOrder:
        	:type theOrder: gp_EulerSequence
        	:param theAlpha:
        	:type theAlpha: float
        	:param theBeta:
        	:type theBeta: float
        	:param theGamma:
        	:type theGamma: float
        	:rtype: None
        """
        return _gp.gp_Quaternion_SetEulerAngles(self, *args)


    def SetIdent(self, *args) -> "void":
        """
        * Make identity quaternion (zero-rotation)
        	:rtype: None
        """
        return _gp.gp_Quaternion_SetIdent(self, *args)


    def SetMatrix(self, *args) -> "void":
        """
        * Create a unit quaternion by rotation matrix matrix must contain only rotation (not scale or shear) //! For numerical stability we find first the greatest component of quaternion and than search others from this one
        	:param theMat:
        	:type theMat: gp_Mat
        	:rtype: None
        """
        return _gp.gp_Quaternion_SetMatrix(self, *args)


    def SetRotation(self, *args) -> "void":
        """
        * Sets quaternion to shortest-arc rotation producing vector theVecTo from vector theVecFrom. If vectors theVecFrom and theVecTo are opposite then rotation axis is computed as theVecFrom ^ (1,0,0) or theVecFrom ^ (0,0,1).
        	:param theVecFrom:
        	:type theVecFrom: gp_Vec
        	:param theVecTo:
        	:type theVecTo: gp_Vec
        	:rtype: None
        * Sets quaternion to shortest-arc rotation producing vector theVecTo from vector theVecFrom. If vectors theVecFrom and theVecTo are opposite then rotation axis is computed as theVecFrom ^ theHelpCrossVec.
        	:param theVecFrom:
        	:type theVecFrom: gp_Vec
        	:param theVecTo:
        	:type theVecTo: gp_Vec
        	:param theHelpCrossVec:
        	:type theHelpCrossVec: gp_Vec
        	:rtype: None
        """
        return _gp.gp_Quaternion_SetRotation(self, *args)


    def SetVectorAndAngle(self, *args) -> "void":
        """
        * Create a unit quaternion from Axis+Angle representation
        	:param theAxis:
        	:type theAxis: gp_Vec
        	:param theAngle:
        	:type theAngle: float
        	:rtype: None
        """
        return _gp.gp_Quaternion_SetVectorAndAngle(self, *args)


    def SquareNorm(self, *args) -> "Standard_Real":
        """
        * Returns square norm of quaternion
        	:rtype: float
        """
        return _gp.gp_Quaternion_SquareNorm(self, *args)


    def StabilizeLength(self, *args) -> "void":
        """
        * Stabilize quaternion length within 1 - 1/4. This operation is a lot faster than normalization and preserve length goes to 0 or infinity
        	:rtype: None
        """
        return _gp.gp_Quaternion_StabilizeLength(self, *args)


    def Subtract(self, *args) -> "void":
        """
        * Subtracts componnets of other quaternion; result is 'rotations mix'
        	:param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_Quaternion_Subtract(self, *args)


    def Subtracted(self, *args) -> "gp_Quaternion":
        """
        * Makes difference of quaternion components; result is 'rotations mix'
        	:param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion_Subtracted(self, *args)


    def W(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _gp.gp_Quaternion_W(self, *args)


    def X(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _gp.gp_Quaternion_X(self, *args)


    def Y(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _gp.gp_Quaternion_Y(self, *args)


    def Z(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _gp.gp_Quaternion_Z(self, *args)


    def __init__(self, *args):
        """
        * Creates an identity quaternion
        	:rtype: None
        * Creates quaternion directly from component values
        	:param x:
        	:type x: float
        	:param y:
        	:type y: float
        	:param z:
        	:type z: float
        	:param w:
        	:type w: float
        	:rtype: None
        * Creates copy of another quaternion
        	:param theToCopy:
        	:type theToCopy: gp_Quaternion
        	:rtype: None
        * Creates quaternion representing shortest-arc rotation operator producing vector theVecTo from vector theVecFrom.
        	:param theVecFrom:
        	:type theVecFrom: gp_Vec
        	:param theVecTo:
        	:type theVecTo: gp_Vec
        	:rtype: None
        * Creates quaternion representing shortest-arc rotation operator producing vector theVecTo from vector theVecFrom. Additional vector theHelpCrossVec defines preferred direction for rotation and is used when theVecTo and theVecFrom are directed oppositely.
        	:param theVecFrom:
        	:type theVecFrom: gp_Vec
        	:param theVecTo:
        	:type theVecTo: gp_Vec
        	:param theHelpCrossVec:
        	:type theHelpCrossVec: gp_Vec
        	:rtype: None
        * Creates quaternion representing rotation on angle theAngle around vector theAxis
        	:param theAxis:
        	:type theAxis: gp_Vec
        	:param theAngle:
        	:type theAngle: float
        	:rtype: None
        * Creates quaternion from rotation matrix 3*3 (which should be orthonormal skew-symmetric matrix)
        	:param theMat:
        	:type theMat: gp_Mat
        	:rtype: None
        """
        _gp.gp_Quaternion_swiginit(self, _gp.new_gp_Quaternion(*args))

    def __mul__(self, *args) -> "gp_Vec":
        """
        :param theScale:
        	:type theScale: float
        	:rtype: gp_Quaternion
        :param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: gp_Quaternion
        :param theVec:
        	:type theVec: gp_Vec
        	:rtype: gp_Vec
        """
        return _gp.gp_Quaternion___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "gp_Quaternion":
        """
        :param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion___add__(self, *args)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __neg__(self, *args) -> "gp_Quaternion":
        """:rtype: gp_Quaternion"""
        return _gp.gp_Quaternion___neg__(self, *args)


    def __sub__(self, *args) -> "gp_Quaternion":
        """
        :param theOther:
        	:type theOther: gp_Quaternion
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Quaternion___sub__(self, *args)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Quaternion
gp_Quaternion.Add = new_instancemethod(_gp.gp_Quaternion_Add, None, gp_Quaternion)
gp_Quaternion.Added = new_instancemethod(_gp.gp_Quaternion_Added, None, gp_Quaternion)
gp_Quaternion.Dot = new_instancemethod(_gp.gp_Quaternion_Dot, None, gp_Quaternion)
gp_Quaternion.GetEulerAngles = new_instancemethod(_gp.gp_Quaternion_GetEulerAngles, None, gp_Quaternion)
gp_Quaternion.GetMatrix = new_instancemethod(_gp.gp_Quaternion_GetMatrix, None, gp_Quaternion)
gp_Quaternion.GetRotationAngle = new_instancemethod(_gp.gp_Quaternion_GetRotationAngle, None, gp_Quaternion)
gp_Quaternion.GetVectorAndAngle = new_instancemethod(_gp.gp_Quaternion_GetVectorAndAngle, None, gp_Quaternion)
gp_Quaternion.Invert = new_instancemethod(_gp.gp_Quaternion_Invert, None, gp_Quaternion)
gp_Quaternion.Inverted = new_instancemethod(_gp.gp_Quaternion_Inverted, None, gp_Quaternion)
gp_Quaternion.IsEqual = new_instancemethod(_gp.gp_Quaternion_IsEqual, None, gp_Quaternion)
gp_Quaternion.Multiplied = new_instancemethod(_gp.gp_Quaternion_Multiplied, None, gp_Quaternion)
gp_Quaternion.Multiply = new_instancemethod(_gp.gp_Quaternion_Multiply, None, gp_Quaternion)
gp_Quaternion.Negated = new_instancemethod(_gp.gp_Quaternion_Negated, None, gp_Quaternion)
gp_Quaternion.Norm = new_instancemethod(_gp.gp_Quaternion_Norm, None, gp_Quaternion)
gp_Quaternion.Normalize = new_instancemethod(_gp.gp_Quaternion_Normalize, None, gp_Quaternion)
gp_Quaternion.Normalized = new_instancemethod(_gp.gp_Quaternion_Normalized, None, gp_Quaternion)
gp_Quaternion.Reverse = new_instancemethod(_gp.gp_Quaternion_Reverse, None, gp_Quaternion)
gp_Quaternion.Reversed = new_instancemethod(_gp.gp_Quaternion_Reversed, None, gp_Quaternion)
gp_Quaternion.Scale = new_instancemethod(_gp.gp_Quaternion_Scale, None, gp_Quaternion)
gp_Quaternion.Scaled = new_instancemethod(_gp.gp_Quaternion_Scaled, None, gp_Quaternion)
gp_Quaternion.Set = new_instancemethod(_gp.gp_Quaternion_Set, None, gp_Quaternion)
gp_Quaternion.SetEulerAngles = new_instancemethod(_gp.gp_Quaternion_SetEulerAngles, None, gp_Quaternion)
gp_Quaternion.SetIdent = new_instancemethod(_gp.gp_Quaternion_SetIdent, None, gp_Quaternion)
gp_Quaternion.SetMatrix = new_instancemethod(_gp.gp_Quaternion_SetMatrix, None, gp_Quaternion)
gp_Quaternion.SetRotation = new_instancemethod(_gp.gp_Quaternion_SetRotation, None, gp_Quaternion)
gp_Quaternion.SetVectorAndAngle = new_instancemethod(_gp.gp_Quaternion_SetVectorAndAngle, None, gp_Quaternion)
gp_Quaternion.SquareNorm = new_instancemethod(_gp.gp_Quaternion_SquareNorm, None, gp_Quaternion)
gp_Quaternion.StabilizeLength = new_instancemethod(_gp.gp_Quaternion_StabilizeLength, None, gp_Quaternion)
gp_Quaternion.Subtract = new_instancemethod(_gp.gp_Quaternion_Subtract, None, gp_Quaternion)
gp_Quaternion.Subtracted = new_instancemethod(_gp.gp_Quaternion_Subtracted, None, gp_Quaternion)
gp_Quaternion.W = new_instancemethod(_gp.gp_Quaternion_W, None, gp_Quaternion)
gp_Quaternion.X = new_instancemethod(_gp.gp_Quaternion_X, None, gp_Quaternion)
gp_Quaternion.Y = new_instancemethod(_gp.gp_Quaternion_Y, None, gp_Quaternion)
gp_Quaternion.Z = new_instancemethod(_gp.gp_Quaternion_Z, None, gp_Quaternion)
gp_Quaternion.__mul__ = new_instancemethod(_gp.gp_Quaternion___mul__, None, gp_Quaternion)
gp_Quaternion.__imul_wrapper__ = new_instancemethod(_gp.gp_Quaternion___imul_wrapper__, None, gp_Quaternion)
gp_Quaternion.__add__ = new_instancemethod(_gp.gp_Quaternion___add__, None, gp_Quaternion)
gp_Quaternion.__iadd_wrapper__ = new_instancemethod(_gp.gp_Quaternion___iadd_wrapper__, None, gp_Quaternion)
gp_Quaternion.__neg__ = new_instancemethod(_gp.gp_Quaternion___neg__, None, gp_Quaternion)
gp_Quaternion.__sub__ = new_instancemethod(_gp.gp_Quaternion___sub__, None, gp_Quaternion)
gp_Quaternion.__isub_wrapper__ = new_instancemethod(_gp.gp_Quaternion___isub_wrapper__, None, gp_Quaternion)
gp_Quaternion_swigregister = _gp.gp_Quaternion_swigregister
gp_Quaternion_swigregister(gp_Quaternion)

class gp_QuaternionNLerp(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args) -> "void":
        """
        * Initialize the tool with Start and End values.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_QuaternionNLerp_Init(self, *args)


    def InitFromUnit(self, *args) -> "void":
        """
        * Initialize the tool with Start and End unit quaternions.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_QuaternionNLerp_InitFromUnit(self, *args)


    def Interpolate(self, *args) -> "void":
        """
        * Compute interpolated quaternion between two quaternions. @param theStart first quaternion @param theEnd second quaternion @param theT normalized interpolation coefficient within 0..1 range, with 0 pointing to theStart and 1 to theEnd.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:param theT:
        	:type theT: float
        	:rtype: gp_Quaternion
        * Set interpolated quaternion for theT position (from 0.0 to 1.0)
        	:param theT:
        	:type theT: float
        	:param theResultQ:
        	:type theResultQ: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_QuaternionNLerp_Interpolate(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor,
        	:rtype: None
        * Constructor with initialization.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:rtype: None
        """
        _gp.gp_QuaternionNLerp_swiginit(self, _gp.new_gp_QuaternionNLerp(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_QuaternionNLerp
gp_QuaternionNLerp.Init = new_instancemethod(_gp.gp_QuaternionNLerp_Init, None, gp_QuaternionNLerp)
gp_QuaternionNLerp.InitFromUnit = new_instancemethod(_gp.gp_QuaternionNLerp_InitFromUnit, None, gp_QuaternionNLerp)
gp_QuaternionNLerp.Interpolate = new_instancemethod(_gp.gp_QuaternionNLerp_Interpolate, None, gp_QuaternionNLerp)
gp_QuaternionNLerp_swigregister = _gp.gp_QuaternionNLerp_swigregister
gp_QuaternionNLerp_swigregister(gp_QuaternionNLerp)

class gp_QuaternionSLerp(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args) -> "void":
        """
        * Initialize the tool with Start and End values.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_QuaternionSLerp_Init(self, *args)


    def InitFromUnit(self, *args) -> "void":
        """
        * Initialize the tool with Start and End unit quaternions.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_QuaternionSLerp_InitFromUnit(self, *args)


    def Interpolate(self, *args) -> "void":
        """
        * Compute interpolated quaternion between two quaternions. @param theStart first quaternion @param theEnd second quaternion @param theT normalized interpolation coefficient within 0..1 range, with 0 pointing to theStart and 1 to theEnd.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:param theT:
        	:type theT: float
        	:rtype: gp_Quaternion
        * Set interpolated quaternion for theT position (from 0.0 to 1.0)
        	:param theT:
        	:type theT: float
        	:param theResultQ:
        	:type theResultQ: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_QuaternionSLerp_Interpolate(self, *args)


    def __init__(self, *args):
        """
        * Empty constructor,
        	:rtype: None
        * Constructor with initialization.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:rtype: None
        """
        _gp.gp_QuaternionSLerp_swiginit(self, _gp.new_gp_QuaternionSLerp(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_QuaternionSLerp
gp_QuaternionSLerp.Init = new_instancemethod(_gp.gp_QuaternionSLerp_Init, None, gp_QuaternionSLerp)
gp_QuaternionSLerp.InitFromUnit = new_instancemethod(_gp.gp_QuaternionSLerp_InitFromUnit, None, gp_QuaternionSLerp)
gp_QuaternionSLerp.Interpolate = new_instancemethod(_gp.gp_QuaternionSLerp_Interpolate, None, gp_QuaternionSLerp)
gp_QuaternionSLerp_swigregister = _gp.gp_QuaternionSLerp_swigregister
gp_QuaternionSLerp_swigregister(gp_QuaternionSLerp)

class gp_Sphere(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Area(self, *args) -> "Standard_Real":
        """
        * Computes the aera of the sphere.
        	:rtype: float
        """
        return _gp.gp_Sphere_Area(self, *args)


    def Coefficients(self, *args) -> "void":
        """
        * Computes the coefficients of the implicit equation of the quadric in the absolute cartesian coordinates system : A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) + 2.(C1.X + C2.Y + C3.Z) + D = 0.0
        	:param A1:
        	:type A1: float
        	:param A2:
        	:type A2: float
        	:param A3:
        	:type A3: float
        	:param B1:
        	:type B1: float
        	:param B2:
        	:type B2: float
        	:param B3:
        	:type B3: float
        	:param C1:
        	:type C1: float
        	:param C2:
        	:type C2: float
        	:param C3:
        	:type C3: float
        	:param D:
        	:type D: float
        	:rtype: None
        """
        return _gp.gp_Sphere_Coefficients(self, *args)


    def Direct(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the local coordinate system of this sphere is right-handed.
        	:rtype: bool
        """
        return _gp.gp_Sphere_Direct(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * --- Purpose ; Returns the center of the sphere.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Sphere_Location(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Sphere_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Sphere":
        """
        * Performs the symmetrical transformation of a sphere with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Sphere
        * Performs the symmetrical transformation of a sphere with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Sphere
        * Performs the symmetrical transformation of a sphere with respect to a plane. The axis placement A2 locates the plane of the of the symmetry : (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Sphere
        """
        return _gp.gp_Sphere_Mirrored(self, *args)


    def Position(self, *args) -> "gp_Ax3 const":
        """
        * Returns the local coordinates system of the sphere.
        	:rtype: gp_Ax3
        """
        return _gp.gp_Sphere_Position(self, *args)


    def Radius(self, *args) -> "Standard_Real":
        """
        * Returns the radius of the sphere.
        	:rtype: float
        """
        return _gp.gp_Sphere_Radius(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Sphere_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Sphere":
        """
        * Rotates a sphere. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Sphere
        """
        return _gp.gp_Sphere_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Sphere_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Sphere":
        """
        * Scales a sphere. S is the scaling value. The absolute value of S is used to scale the sphere
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Sphere
        """
        return _gp.gp_Sphere_Scaled(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the center of the sphere.
        	:param Loc:
        	:type Loc: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Sphere_SetLocation(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Changes the local coordinate system of the sphere.
        	:param A3:
        	:type A3: gp_Ax3
        	:rtype: None
        """
        return _gp.gp_Sphere_SetPosition(self, *args)


    def SetRadius(self, *args) -> "void":
        """
        * Assigns R the radius of the Sphere. Warnings : It is not forbidden to create a sphere with null radius. Raises ConstructionError if R < 0.0
        	:param R:
        	:type R: float
        	:rtype: None
        """
        return _gp.gp_Sphere_SetRadius(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Sphere_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Sphere":
        """
        * Transforms a sphere with the transformation T from class Trsf.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Sphere
        """
        return _gp.gp_Sphere_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Sphere_Translate(self, *args)


    def Translated(self, *args) -> "gp_Sphere":
        """
        * Translates a sphere in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Sphere
        * Translates a sphere from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Sphere
        """
        return _gp.gp_Sphere_Translated(self, *args)


    def UReverse(self, *args) -> "void":
        """
        * Reverses the U parametrization of the sphere reversing the YAxis.
        	:rtype: None
        """
        return _gp.gp_Sphere_UReverse(self, *args)


    def VReverse(self, *args) -> "void":
        """
        * Reverses the V parametrization of the sphere reversing the ZAxis.
        	:rtype: None
        """
        return _gp.gp_Sphere_VReverse(self, *args)


    def Volume(self, *args) -> "Standard_Real":
        """
        * Computes the volume of the sphere
        	:rtype: float
        """
        return _gp.gp_Sphere_Volume(self, *args)


    def XAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the axis X of the sphere.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Sphere_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax1":
        """
        * Returns the axis Y of the sphere.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Sphere_YAxis(self, *args)


    def __init__(self, *args):
        """
        * Creates an indefinite sphere.
        	:rtype: None
        * Constructs a sphere with radius Radius, centered on the origin of A3. A3 is the local coordinate system of the sphere. Warnings : It is not forbidden to create a sphere with null radius. Raises ConstructionError if Radius < 0.0
        	:param A3:
        	:type A3: gp_Ax3
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Sphere_swiginit(self, _gp.new_gp_Sphere(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Sphere
gp_Sphere.Area = new_instancemethod(_gp.gp_Sphere_Area, None, gp_Sphere)
gp_Sphere.Coefficients = new_instancemethod(_gp.gp_Sphere_Coefficients, None, gp_Sphere)
gp_Sphere.Direct = new_instancemethod(_gp.gp_Sphere_Direct, None, gp_Sphere)
gp_Sphere.Location = new_instancemethod(_gp.gp_Sphere_Location, None, gp_Sphere)
gp_Sphere.Mirror = new_instancemethod(_gp.gp_Sphere_Mirror, None, gp_Sphere)
gp_Sphere.Mirrored = new_instancemethod(_gp.gp_Sphere_Mirrored, None, gp_Sphere)
gp_Sphere.Position = new_instancemethod(_gp.gp_Sphere_Position, None, gp_Sphere)
gp_Sphere.Radius = new_instancemethod(_gp.gp_Sphere_Radius, None, gp_Sphere)
gp_Sphere.Rotate = new_instancemethod(_gp.gp_Sphere_Rotate, None, gp_Sphere)
gp_Sphere.Rotated = new_instancemethod(_gp.gp_Sphere_Rotated, None, gp_Sphere)
gp_Sphere.Scale = new_instancemethod(_gp.gp_Sphere_Scale, None, gp_Sphere)
gp_Sphere.Scaled = new_instancemethod(_gp.gp_Sphere_Scaled, None, gp_Sphere)
gp_Sphere.SetLocation = new_instancemethod(_gp.gp_Sphere_SetLocation, None, gp_Sphere)
gp_Sphere.SetPosition = new_instancemethod(_gp.gp_Sphere_SetPosition, None, gp_Sphere)
gp_Sphere.SetRadius = new_instancemethod(_gp.gp_Sphere_SetRadius, None, gp_Sphere)
gp_Sphere.Transform = new_instancemethod(_gp.gp_Sphere_Transform, None, gp_Sphere)
gp_Sphere.Transformed = new_instancemethod(_gp.gp_Sphere_Transformed, None, gp_Sphere)
gp_Sphere.Translate = new_instancemethod(_gp.gp_Sphere_Translate, None, gp_Sphere)
gp_Sphere.Translated = new_instancemethod(_gp.gp_Sphere_Translated, None, gp_Sphere)
gp_Sphere.UReverse = new_instancemethod(_gp.gp_Sphere_UReverse, None, gp_Sphere)
gp_Sphere.VReverse = new_instancemethod(_gp.gp_Sphere_VReverse, None, gp_Sphere)
gp_Sphere.Volume = new_instancemethod(_gp.gp_Sphere_Volume, None, gp_Sphere)
gp_Sphere.XAxis = new_instancemethod(_gp.gp_Sphere_XAxis, None, gp_Sphere)
gp_Sphere.YAxis = new_instancemethod(_gp.gp_Sphere_YAxis, None, gp_Sphere)
gp_Sphere_swigregister = _gp.gp_Sphere_swigregister
gp_Sphere_swigregister(gp_Sphere)

class gp_Torus(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Area(self, *args) -> "Standard_Real":
        """
        * Computes the area of the torus.
        	:rtype: float
        """
        return _gp.gp_Torus_Area(self, *args)


    def Axis(self, *args) -> "gp_Ax1 const":
        """
        * returns the symmetry axis of the torus.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Torus_Axis(self, *args)


    def Direct(self, *args) -> "Standard_Boolean":
        """
        * returns true if the Ax3, the local coordinate system of this torus, is right handed.
        	:rtype: bool
        """
        return _gp.gp_Torus_Direct(self, *args)


    def Location(self, *args) -> "gp_Pnt const":
        """
        * Returns the Torus's location.
        	:rtype: gp_Pnt
        """
        return _gp.gp_Torus_Location(self, *args)


    def MajorRadius(self, *args) -> "Standard_Real":
        """
        * returns the major radius of the torus.
        	:rtype: float
        """
        return _gp.gp_Torus_MajorRadius(self, *args)


    def MinorRadius(self, *args) -> "Standard_Real":
        """
        * returns the minor radius of the torus.
        	:rtype: float
        """
        return _gp.gp_Torus_MinorRadius(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Torus_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Torus":
        """
        * Performs the symmetrical transformation of a torus with respect to the point P which is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: gp_Torus
        * Performs the symmetrical transformation of a torus with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Torus
        * Performs the symmetrical transformation of a torus with respect to a plane. The axis placement A2 locates the plane of the of the symmetry : (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Torus
        """
        return _gp.gp_Torus_Mirrored(self, *args)


    def Position(self, *args) -> "gp_Ax3 const":
        """
        * Returns the local coordinates system of the torus.
        	:rtype: gp_Ax3
        """
        return _gp.gp_Torus_Position(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Torus_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Torus":
        """
        * Rotates a torus. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Torus
        """
        return _gp.gp_Torus_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Torus_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Torus":
        """
        * Scales a torus. S is the scaling value. The absolute value of S is used to scale the torus
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: gp_Torus
        """
        return _gp.gp_Torus_Scaled(self, *args)


    def SetAxis(self, *args) -> "void":
        """
        * Modifies this torus, by redefining its local coordinate system so that: - its origin and 'main Direction' become those of the axis A1 (the 'X Direction' and 'Y Direction' are then recomputed). Raises ConstructionError if the direction of A1 is parallel to the 'XDirection' of the coordinate system of the toroidal surface.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        return _gp.gp_Torus_SetAxis(self, *args)


    def SetLocation(self, *args) -> "void":
        """
        * Changes the location of the torus.
        	:param Loc:
        	:type Loc: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Torus_SetLocation(self, *args)


    def SetMajorRadius(self, *args) -> "void":
        """
        * Assigns value to the major radius of this torus. Raises ConstructionError if MajorRadius - MinorRadius <= Resolution()
        	:param MajorRadius:
        	:type MajorRadius: float
        	:rtype: None
        """
        return _gp.gp_Torus_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args) -> "void":
        """
        * Assigns value to the minor radius of this torus. Raises ConstructionError if MinorRadius < 0.0 or if MajorRadius - MinorRadius <= Resolution from gp.
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        return _gp.gp_Torus_SetMinorRadius(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        * Changes the local coordinate system of the surface.
        	:param A3:
        	:type A3: gp_Ax3
        	:rtype: None
        """
        return _gp.gp_Torus_SetPosition(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Torus_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Torus":
        """
        * Transforms a torus with the transformation T from class Trsf.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Torus
        """
        return _gp.gp_Torus_Transformed(self, *args)


    def Translate(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Torus_Translate(self, *args)


    def Translated(self, *args) -> "gp_Torus":
        """
        * Translates a torus in the direction of the vector V. The magnitude of the translation is the vector's magnitude.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Torus
        * Translates a torus from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: gp_Torus
        """
        return _gp.gp_Torus_Translated(self, *args)


    def UReverse(self, *args) -> "void":
        """
        * Reverses the U parametrization of the torus reversing the YAxis.
        	:rtype: None
        """
        return _gp.gp_Torus_UReverse(self, *args)


    def VReverse(self, *args) -> "void":
        """
        * Reverses the V parametrization of the torus reversing the ZAxis.
        	:rtype: None
        """
        return _gp.gp_Torus_VReverse(self, *args)


    def Volume(self, *args) -> "Standard_Real":
        """
        * Computes the volume of the torus.
        	:rtype: float
        """
        return _gp.gp_Torus_Volume(self, *args)


    def XAxis(self, *args) -> "gp_Ax1":
        """
        * returns the axis X of the torus.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Torus_XAxis(self, *args)


    def YAxis(self, *args) -> "gp_Ax1":
        """
        * returns the axis Y of the torus.
        	:rtype: gp_Ax1
        """
        return _gp.gp_Torus_YAxis(self, *args)


    def __init__(self, *args):
        """
        * creates an indefinite Torus.
        	:rtype: None
        * a torus centered on the origin of coordinate system A3, with major radius MajorRadius and minor radius MinorRadius, and with the reference plane defined by the origin, the 'X Direction' and the 'Y Direction' of A3. Warnings : It is not forbidden to create a torus with MajorRadius = MinorRadius = 0.0 Raises ConstructionError if MinorRadius < 0.0 or if MajorRadius < 0.0
        	:param A3:
        	:type A3: gp_Ax3
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Torus_swiginit(self, _gp.new_gp_Torus(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Torus
gp_Torus.Area = new_instancemethod(_gp.gp_Torus_Area, None, gp_Torus)
gp_Torus.Axis = new_instancemethod(_gp.gp_Torus_Axis, None, gp_Torus)
gp_Torus.Direct = new_instancemethod(_gp.gp_Torus_Direct, None, gp_Torus)
gp_Torus.Location = new_instancemethod(_gp.gp_Torus_Location, None, gp_Torus)
gp_Torus.MajorRadius = new_instancemethod(_gp.gp_Torus_MajorRadius, None, gp_Torus)
gp_Torus.MinorRadius = new_instancemethod(_gp.gp_Torus_MinorRadius, None, gp_Torus)
gp_Torus.Mirror = new_instancemethod(_gp.gp_Torus_Mirror, None, gp_Torus)
gp_Torus.Mirrored = new_instancemethod(_gp.gp_Torus_Mirrored, None, gp_Torus)
gp_Torus.Position = new_instancemethod(_gp.gp_Torus_Position, None, gp_Torus)
gp_Torus.Rotate = new_instancemethod(_gp.gp_Torus_Rotate, None, gp_Torus)
gp_Torus.Rotated = new_instancemethod(_gp.gp_Torus_Rotated, None, gp_Torus)
gp_Torus.Scale = new_instancemethod(_gp.gp_Torus_Scale, None, gp_Torus)
gp_Torus.Scaled = new_instancemethod(_gp.gp_Torus_Scaled, None, gp_Torus)
gp_Torus.SetAxis = new_instancemethod(_gp.gp_Torus_SetAxis, None, gp_Torus)
gp_Torus.SetLocation = new_instancemethod(_gp.gp_Torus_SetLocation, None, gp_Torus)
gp_Torus.SetMajorRadius = new_instancemethod(_gp.gp_Torus_SetMajorRadius, None, gp_Torus)
gp_Torus.SetMinorRadius = new_instancemethod(_gp.gp_Torus_SetMinorRadius, None, gp_Torus)
gp_Torus.SetPosition = new_instancemethod(_gp.gp_Torus_SetPosition, None, gp_Torus)
gp_Torus.Transform = new_instancemethod(_gp.gp_Torus_Transform, None, gp_Torus)
gp_Torus.Transformed = new_instancemethod(_gp.gp_Torus_Transformed, None, gp_Torus)
gp_Torus.Translate = new_instancemethod(_gp.gp_Torus_Translate, None, gp_Torus)
gp_Torus.Translated = new_instancemethod(_gp.gp_Torus_Translated, None, gp_Torus)
gp_Torus.UReverse = new_instancemethod(_gp.gp_Torus_UReverse, None, gp_Torus)
gp_Torus.VReverse = new_instancemethod(_gp.gp_Torus_VReverse, None, gp_Torus)
gp_Torus.Volume = new_instancemethod(_gp.gp_Torus_Volume, None, gp_Torus)
gp_Torus.XAxis = new_instancemethod(_gp.gp_Torus_XAxis, None, gp_Torus)
gp_Torus.YAxis = new_instancemethod(_gp.gp_Torus_YAxis, None, gp_Torus)
gp_Torus_swigregister = _gp.gp_Torus_swigregister
gp_Torus_swigregister(gp_Torus)

class gp_Trsf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpJsonToString(self, depth: 'int'=-1) -> "std::string":
        """
        DumpJsonToString(gp_Trsf self, int depth=-1) -> std::string
        DumpJsonToString(gp_Trsf self) -> std::string
        """
        return _gp.gp_Trsf_DumpJsonToString(self, depth)


    def Form(self, *args) -> "gp_TrsfForm":
        """
        * Returns the nature of the transformation. It can be: an identity transformation, a rotation, a translation, a mirror transformation (relative to a point, an axis or a plane), a scaling transformation, or a compound transformation.
        	:rtype: gp_TrsfForm
        """
        return _gp.gp_Trsf_Form(self, *args)


    def GetRotation(self, *args) -> "gp_Quaternion":
        """
        * Returns the boolean True if there is non-zero rotation. In the presence of rotation, the output parameters store the axis and the angle of rotation. The method always returns positive value 'theAngle', i.e., 0. < theAngle <= PI. Note that this rotation is defined only by the vectorial part of the transformation; generally you would need to check also the translational part to obtain the axis (gp_Ax1) of rotation.
        	:param theAxis:
        	:type theAxis: gp_XYZ
        	:param theAngle:
        	:type theAngle: float
        	:rtype: bool
        * Returns quaternion representing rotational part of the transformation.
        	:rtype: gp_Quaternion
        """
        return _gp.gp_Trsf_GetRotation(self, *args)


    def HVectorialPart(self, *args) -> "gp_Mat const":
        """
        * Computes the homogeneous vectorial part of the transformation. It is a 3*3 matrix which doesn't include the scale factor. In other words, the vectorial part of this transformation is equal to its homogeneous vectorial part, multiplied by the scale factor. The coefficients of this matrix must be multiplied by the scale factor to obtain the coefficients of the transformation.
        	:rtype: gp_Mat
        """
        return _gp.gp_Trsf_HVectorialPart(self, *args)


    def Invert(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Trsf_Invert(self, *args)


    def Inverted(self, *args) -> "gp_Trsf":
        """
        * Computes the reverse transformation Raises an exception if the matrix of the transformation is not inversible, it means that the scale factor is lower or equal to Resolution from package gp. Computes the transformation composed with T and <self>. In a C++ implementation you can also write Tcomposed = <self> * T. Example : Trsf T1, T2, Tcomp; ............... Tcomp = T2.Multiplied(T1); // or (Tcomp = T2 * T1) Pnt P1(10.,3.,4.); Pnt P2 = P1.Transformed(Tcomp); //using Tcomp Pnt P3 = P1.Transformed(T1); //using T1 then T2 P3.Transform(T2); // P3 = P2 !!!
        	:rtype: gp_Trsf
        """
        return _gp.gp_Trsf_Inverted(self, *args)


    def IsNegative(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the determinant of the vectorial part of this transformation is negative.
        	:rtype: bool
        """
        return _gp.gp_Trsf_IsNegative(self, *args)


    def Multiplied(self, *args) -> "gp_Trsf":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: gp_Trsf
        """
        return _gp.gp_Trsf_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * Computes the transformation composed with <self> and T. <self> = <self> * T
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Trsf_Multiply(self, *args)


    def Power(self, *args) -> "void":
        """
        :param N:
        	:type N: int
        	:rtype: None
        """
        return _gp.gp_Trsf_Power(self, *args)


    def Powered(self, *args) -> "gp_Trsf":
        """
        * Computes the following composition of transformations <self> * <self> * .......* <self>, N time. if N = 0 <self> = Identity if N < 0 <self> = <self>.Inverse() *...........* <self>.Inverse(). //! Raises if N < 0 and if the matrix of the transformation not inversible.
        	:param N:
        	:type N: int
        	:rtype: gp_Trsf
        """
        return _gp.gp_Trsf_Powered(self, *args)


    def PreMultiply(self, *args) -> "void":
        """
        * Computes the transformation composed with <self> and T. <self> = T * <self>
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Trsf_PreMultiply(self, *args)


    def ScaleFactor(self, *args) -> "Standard_Real":
        """
        * Returns the scale factor.
        	:rtype: float
        """
        return _gp.gp_Trsf_ScaleFactor(self, *args)


    def SetDisplacement(self, *args) -> "void":
        """
        * Modifies this transformation so that it transforms the coordinate system defined by FromSystem1 into the one defined by ToSystem2. After this modification, this transformation transforms: - the origin of FromSystem1 into the origin of ToSystem2, - the 'X Direction' of FromSystem1 into the 'X Direction' of ToSystem2, - the 'Y Direction' of FromSystem1 into the 'Y Direction' of ToSystem2, and - the 'main Direction' of FromSystem1 into the 'main Direction' of ToSystem2. Warning When you know the coordinates of a point in one coordinate system and you want to express these coordinates in another one, do not use the transformation resulting from this function. Use the transformation that results from SetTransformation instead. SetDisplacement and SetTransformation create related transformations: the vectorial part of one is the inverse of the vectorial part of the other.
        	:param FromSystem1:
        	:type FromSystem1: gp_Ax3
        	:param ToSystem2:
        	:type ToSystem2: gp_Ax3
        	:rtype: None
        """
        return _gp.gp_Trsf_SetDisplacement(self, *args)


    def SetForm(self, *args) -> "void":
        """
        :param P:
        	:type P: gp_TrsfForm
        	:rtype: None
        """
        return _gp.gp_Trsf_SetForm(self, *args)


    def SetMirror(self, *args) -> "void":
        """
        * Makes the transformation into a symmetrical transformation. P is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None
        * Makes the transformation into a symmetrical transformation. A1 is the center of the axial symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        * Makes the transformation into a symmetrical transformation. A2 is the center of the planar symmetry and defines the plane of symmetry by its origin, 'X Direction' and 'Y Direction'.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Trsf_SetMirror(self, *args)


    def SetRotation(self, *args) -> "void":
        """
        * Changes the transformation into a rotation. A1 is the rotation axis and Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        * Changes the transformation into a rotation defined by quaternion. Note that rotation is performed around origin, i.e. no translation is involved.
        	:param R:
        	:type R: gp_Quaternion
        	:rtype: None
        """
        return _gp.gp_Trsf_SetRotation(self, *args)


    def SetScale(self, *args) -> "void":
        """
        * Changes the transformation into a scale. P is the center of the scale and S is the scaling value. Raises ConstructionError If <S> is null.
        	:param P:
        	:type P: gp_Pnt
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Trsf_SetScale(self, *args)


    def SetScaleFactor(self, *args) -> "void":
        """
        * Modifies the scale factor. Raises ConstructionError If S is null.
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Trsf_SetScaleFactor(self, *args)


    def SetTransformation(self, *args) -> "void":
        """
        * Modifies this transformation so that it transforms the coordinates of any point, (x, y, z), relative to a source coordinate system into the coordinates (x', y', z') which are relative to a target coordinate system, but which represent the same point The transformation is from the coordinate system 'FromSystem1' to the coordinate system 'ToSystem2'. Example : In a C++ implementation : Real x1, y1, z1; // are the coordinates of a point in the // local system FromSystem1 Real x2, y2, z2; // are the coordinates of a point in the // local system ToSystem2 gp_Pnt P1 (x1, y1, z1) Trsf T; T.SetTransformation (FromSystem1, ToSystem2); gp_Pnt P2 = P1.Transformed (T); P2.Coord (x2, y2, z2);
        	:param FromSystem1:
        	:type FromSystem1: gp_Ax3
        	:param ToSystem2:
        	:type ToSystem2: gp_Ax3
        	:rtype: None
        * Modifies this transformation so that it transforms the coordinates of any point, (x, y, z), relative to a source coordinate system into the coordinates (x', y', z') which are relative to a target coordinate system, but which represent the same point The transformation is from the default coordinate system {P(0.,0.,0.), VX (1.,0.,0.), VY (0.,1.,0.), VZ (0., 0. ,1.) } to the local coordinate system defined with the Ax3 ToSystem. Use in the same way as the previous method. FromSystem1 is defaulted to the absolute coordinate system.
        	:param ToSystem:
        	:type ToSystem: gp_Ax3
        	:rtype: None
        * Sets transformation by directly specified rotation and translation.
        	:param R:
        	:type R: gp_Quaternion
        	:param T:
        	:type T: gp_Vec
        	:rtype: None
        """
        return _gp.gp_Trsf_SetTransformation(self, *args)


    def SetTranslation(self, *args) -> "void":
        """
        * Changes the transformation into a translation. V is the vector of the translation.
        	:param V:
        	:type V: gp_Vec
        	:rtype: None
        * Makes the transformation into a translation where the translation vector is the vector (P1, P2) defined from point P1 to point P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        return _gp.gp_Trsf_SetTranslation(self, *args)


    def SetTranslationPart(self, *args) -> "void":
        """
        * Replaces the translation vector with the vector V.
        	:param V:
        	:type V: gp_Vec
        	:rtype: None
        """
        return _gp.gp_Trsf_SetTranslationPart(self, *args)


    def SetValues(self, *args) -> "void":
        """
        * Sets the coefficients of the transformation. The transformation of the point x,y,z is the point x',y',z' with : //! x' = a11 x + a12 y + a13 z + a14 y' = a21 x + a22 y + a23 z + a24 z' = a31 x + a32 y + a33 z + a34 //! The method Value(i,j) will return aij. Raises ConstructionError if the determinant of the aij is null. The matrix is orthogonalized before future using.
        	:param a11:
        	:type a11: float
        	:param a12:
        	:type a12: float
        	:param a13:
        	:type a13: float
        	:param a14:
        	:type a14: float
        	:param a21:
        	:type a21: float
        	:param a22:
        	:type a22: float
        	:param a23:
        	:type a23: float
        	:param a24:
        	:type a24: float
        	:param a31:
        	:type a31: float
        	:param a32:
        	:type a32: float
        	:param a33:
        	:type a33: float
        	:param a34:
        	:type a34: float
        	:rtype: None
        """
        return _gp.gp_Trsf_SetValues(self, *args)


    def Transforms(self, *args) -> "void":
        """
        :param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None
        * Transformation of a triplet XYZ with a Trsf
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Trsf_Transforms(self, *args)


    def TranslationPart(self, *args) -> "gp_XYZ const":
        """
        * Returns the translation part of the transformation's matrix
        	:rtype: gp_XYZ
        """
        return _gp.gp_Trsf_TranslationPart(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * Returns the coefficients of the transformation's matrix. It is a 3 rows * 4 columns matrix. This coefficient includes the scale factor. Raises OutOfRanged if Row < 1 or Row > 3 or Col < 1 or Col > 4
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:rtype: float
        """
        return _gp.gp_Trsf_Value(self, *args)


    def VectorialPart(self, *args) -> "gp_Mat":
        """
        * Returns the vectorial part of the transformation. It is a 3*3 matrix which includes the scale factor.
        	:rtype: gp_Mat
        """
        return _gp.gp_Trsf_VectorialPart(self, *args)


    def __init__(self, *args):
        """
        * Returns the identity transformation.
        	:rtype: None
        * Creates a 3D transformation from the 2D transformation T. The resulting transformation has a homogeneous vectorial part, V3, and a translation part, T3, built from T: a11 a12 0 a13 V3 = a21 a22 0 T3 = a23 0 0 1. 0 It also has the same scale factor as T. This guarantees (by projection) that the transformation which would be performed by T in a plane (2D space) is performed by the resulting transformation in the xOy plane of the 3D space, (i.e. in the plane defined by the origin (0., 0., 0.) and the vectors DX (1., 0., 0.), and DY (0., 1., 0.)). The scale factor is applied to the entire space.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        _gp.gp_Trsf_swiginit(self, _gp.new_gp_Trsf(*args))

    def __mul__(self, *args) -> "gp_Trsf":
        """
        :param T:
        	:type T: gp_Trsf
        	:rtype: gp_Trsf
        """
        return _gp.gp_Trsf___mul__(self, *args)


    def __imul_wrapper__(self, other: 'gp_Trsf') -> "void":
        """__imul_wrapper__(gp_Trsf self, gp_Trsf other)"""
        return _gp.gp_Trsf___imul_wrapper__(self, other)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Trsf
gp_Trsf.DumpJsonToString = new_instancemethod(_gp.gp_Trsf_DumpJsonToString, None, gp_Trsf)
gp_Trsf.Form = new_instancemethod(_gp.gp_Trsf_Form, None, gp_Trsf)
gp_Trsf.GetRotation = new_instancemethod(_gp.gp_Trsf_GetRotation, None, gp_Trsf)
gp_Trsf.HVectorialPart = new_instancemethod(_gp.gp_Trsf_HVectorialPart, None, gp_Trsf)
gp_Trsf.Invert = new_instancemethod(_gp.gp_Trsf_Invert, None, gp_Trsf)
gp_Trsf.Inverted = new_instancemethod(_gp.gp_Trsf_Inverted, None, gp_Trsf)
gp_Trsf.IsNegative = new_instancemethod(_gp.gp_Trsf_IsNegative, None, gp_Trsf)
gp_Trsf.Multiplied = new_instancemethod(_gp.gp_Trsf_Multiplied, None, gp_Trsf)
gp_Trsf.Multiply = new_instancemethod(_gp.gp_Trsf_Multiply, None, gp_Trsf)
gp_Trsf.Power = new_instancemethod(_gp.gp_Trsf_Power, None, gp_Trsf)
gp_Trsf.Powered = new_instancemethod(_gp.gp_Trsf_Powered, None, gp_Trsf)
gp_Trsf.PreMultiply = new_instancemethod(_gp.gp_Trsf_PreMultiply, None, gp_Trsf)
gp_Trsf.ScaleFactor = new_instancemethod(_gp.gp_Trsf_ScaleFactor, None, gp_Trsf)
gp_Trsf.SetDisplacement = new_instancemethod(_gp.gp_Trsf_SetDisplacement, None, gp_Trsf)
gp_Trsf.SetForm = new_instancemethod(_gp.gp_Trsf_SetForm, None, gp_Trsf)
gp_Trsf.SetMirror = new_instancemethod(_gp.gp_Trsf_SetMirror, None, gp_Trsf)
gp_Trsf.SetRotation = new_instancemethod(_gp.gp_Trsf_SetRotation, None, gp_Trsf)
gp_Trsf.SetScale = new_instancemethod(_gp.gp_Trsf_SetScale, None, gp_Trsf)
gp_Trsf.SetScaleFactor = new_instancemethod(_gp.gp_Trsf_SetScaleFactor, None, gp_Trsf)
gp_Trsf.SetTransformation = new_instancemethod(_gp.gp_Trsf_SetTransformation, None, gp_Trsf)
gp_Trsf.SetTranslation = new_instancemethod(_gp.gp_Trsf_SetTranslation, None, gp_Trsf)
gp_Trsf.SetTranslationPart = new_instancemethod(_gp.gp_Trsf_SetTranslationPart, None, gp_Trsf)
gp_Trsf.SetValues = new_instancemethod(_gp.gp_Trsf_SetValues, None, gp_Trsf)
gp_Trsf.Transforms = new_instancemethod(_gp.gp_Trsf_Transforms, None, gp_Trsf)
gp_Trsf.TranslationPart = new_instancemethod(_gp.gp_Trsf_TranslationPart, None, gp_Trsf)
gp_Trsf.Value = new_instancemethod(_gp.gp_Trsf_Value, None, gp_Trsf)
gp_Trsf.VectorialPart = new_instancemethod(_gp.gp_Trsf_VectorialPart, None, gp_Trsf)
gp_Trsf.__mul__ = new_instancemethod(_gp.gp_Trsf___mul__, None, gp_Trsf)
gp_Trsf.__imul_wrapper__ = new_instancemethod(_gp.gp_Trsf___imul_wrapper__, None, gp_Trsf)
gp_Trsf_swigregister = _gp.gp_Trsf_swigregister
gp_Trsf_swigregister(gp_Trsf)

class gp_Trsf2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Form(self, *args) -> "gp_TrsfForm":
        """
        * Returns the nature of the transformation. It can be an identity transformation, a rotation, a translation, a mirror (relative to a point or an axis), a scaling transformation, or a compound transformation.
        	:rtype: gp_TrsfForm
        """
        return _gp.gp_Trsf2d_Form(self, *args)


    def HVectorialPart(self, *args) -> "gp_Mat2d const":
        """
        * Returns the homogeneous vectorial part of the transformation. It is a 2*2 matrix which doesn't include the scale factor. The coefficients of this matrix must be multiplied by the scale factor to obtain the coefficients of the transformation.
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Trsf2d_HVectorialPart(self, *args)


    def Invert(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Trsf2d_Invert(self, *args)


    def Inverted(self, *args) -> "gp_Trsf2d":
        """
        * Computes the reverse transformation. Raises an exception if the matrix of the transformation is not inversible, it means that the scale factor is lower or equal to Resolution from package gp.
        	:rtype: gp_Trsf2d
        """
        return _gp.gp_Trsf2d_Inverted(self, *args)


    def IsNegative(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the determinant of the vectorial part of this transformation is negative..
        	:rtype: bool
        """
        return _gp.gp_Trsf2d_IsNegative(self, *args)


    def Multiplied(self, *args) -> "gp_Trsf2d":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Trsf2d
        """
        return _gp.gp_Trsf2d_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * Computes the transformation composed from <self> and T. <self> = <self> * T
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Trsf2d_Multiply(self, *args)


    def Power(self, *args) -> "void":
        """
        :param N:
        	:type N: int
        	:rtype: None
        """
        return _gp.gp_Trsf2d_Power(self, *args)


    def Powered(self, *args) -> "gp_Trsf2d":
        """
        * Computes the following composition of transformations <self> * <self> * .......* <self>, N time. if N = 0 <self> = Identity if N < 0 <self> = <self>.Inverse() *...........* <self>.Inverse(). //! Raises if N < 0 and if the matrix of the transformation not inversible.
        	:param N:
        	:type N: int
        	:rtype: gp_Trsf2d
        """
        return _gp.gp_Trsf2d_Powered(self, *args)


    def PreMultiply(self, *args) -> "void":
        """
        * Computes the transformation composed from <self> and T. <self> = T * <self>
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Trsf2d_PreMultiply(self, *args)


    def RotationPart(self, *args) -> "Standard_Real":
        """
        * Returns the angle corresponding to the rotational component of the transformation matrix (operation opposite to SetRotation()).
        	:rtype: float
        """
        return _gp.gp_Trsf2d_RotationPart(self, *args)


    def ScaleFactor(self, *args) -> "Standard_Real":
        """
        * Returns the scale factor.
        	:rtype: float
        """
        return _gp.gp_Trsf2d_ScaleFactor(self, *args)


    def SetMirror(self, *args) -> "void":
        """
        * Changes the transformation into a symmetrical transformation. P is the center of the symmetry.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None
        * Changes the transformation into a symmetrical transformation. A is the center of the axial symmetry.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Trsf2d_SetMirror(self, *args)


    def SetRotation(self, *args) -> "void":
        """
        * Changes the transformation into a rotation. P is the rotation's center and Ang is the angular value of the rotation in radian.
        	:param P:
        	:type P: gp_Pnt2d
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Trsf2d_SetRotation(self, *args)


    def SetScale(self, *args) -> "void":
        """
        * Changes the transformation into a scale. P is the center of the scale and S is the scaling value.
        	:param P:
        	:type P: gp_Pnt2d
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Trsf2d_SetScale(self, *args)


    def SetScaleFactor(self, *args) -> "void":
        """
        * Modifies the scale factor.
        	:param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Trsf2d_SetScaleFactor(self, *args)


    def SetTransformation(self, *args) -> "void":
        """
        * Changes a transformation allowing passage from the coordinate system 'FromSystem1' to the coordinate system 'ToSystem2'.
        	:param FromSystem1:
        	:type FromSystem1: gp_Ax2d
        	:param ToSystem2:
        	:type ToSystem2: gp_Ax2d
        	:rtype: None
        * Changes the transformation allowing passage from the basic coordinate system {P(0.,0.,0.), VX (1.,0.,0.), VY (0.,1.,0.)} to the local coordinate system defined with the Ax2d ToSystem.
        	:param ToSystem:
        	:type ToSystem: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Trsf2d_SetTransformation(self, *args)


    def SetTranslation(self, *args) -> "void":
        """
        * Changes the transformation into a translation. V is the vector of the translation.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None
        * Makes the transformation into a translation from the point P1 to the point P2.
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        return _gp.gp_Trsf2d_SetTranslation(self, *args)


    def SetTranslationPart(self, *args) -> "void":
        """
        * Replaces the translation vector with V.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None
        """
        return _gp.gp_Trsf2d_SetTranslationPart(self, *args)


    def SetValues(self, *args) -> "void":
        """
        * Sets the coefficients of the transformation. The transformation of the point x,y is the point x',y' with : //! x' = a11 x + a12 y + a13 y' = a21 x + a22 y + a23 //! The method Value(i,j) will return aij. Raises ConstructionError if the determinant of the aij is null. If the matrix as not a uniform scale it will be orthogonalized before future using.
        	:param a11:
        	:type a11: float
        	:param a12:
        	:type a12: float
        	:param a13:
        	:type a13: float
        	:param a21:
        	:type a21: float
        	:param a22:
        	:type a22: float
        	:param a23:
        	:type a23: float
        	:rtype: None
        """
        return _gp.gp_Trsf2d_SetValues(self, *args)


    def Transforms(self, *args) -> "void":
        """
        :param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None
        * Transforms a doublet XY with a Trsf2d
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        """
        return _gp.gp_Trsf2d_Transforms(self, *args)


    def TranslationPart(self, *args) -> "gp_XY const":
        """
        * Returns the translation part of the transformation's matrix
        	:rtype: gp_XY
        """
        return _gp.gp_Trsf2d_TranslationPart(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * Returns the coefficients of the transformation's matrix. It is a 2 rows * 3 columns matrix. Raises OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 3
        	:param Row:
        	:type Row: int
        	:param Col:
        	:type Col: int
        	:rtype: float
        """
        return _gp.gp_Trsf2d_Value(self, *args)


    def VectorialPart(self, *args) -> "gp_Mat2d":
        """
        * Returns the vectorial part of the transformation. It is a 2*2 matrix which includes the scale factor.
        	:rtype: gp_Mat2d
        """
        return _gp.gp_Trsf2d_VectorialPart(self, *args)


    def __init__(self, *args):
        """
        * Returns identity transformation.
        	:rtype: None
        * Creates a 2d transformation in the XY plane from a 3d transformation .
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        _gp.gp_Trsf2d_swiginit(self, _gp.new_gp_Trsf2d(*args))

    def __mul__(self, *args) -> "gp_Trsf2d":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Trsf2d
        """
        return _gp.gp_Trsf2d___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Trsf2d
gp_Trsf2d.Form = new_instancemethod(_gp.gp_Trsf2d_Form, None, gp_Trsf2d)
gp_Trsf2d.HVectorialPart = new_instancemethod(_gp.gp_Trsf2d_HVectorialPart, None, gp_Trsf2d)
gp_Trsf2d.Invert = new_instancemethod(_gp.gp_Trsf2d_Invert, None, gp_Trsf2d)
gp_Trsf2d.Inverted = new_instancemethod(_gp.gp_Trsf2d_Inverted, None, gp_Trsf2d)
gp_Trsf2d.IsNegative = new_instancemethod(_gp.gp_Trsf2d_IsNegative, None, gp_Trsf2d)
gp_Trsf2d.Multiplied = new_instancemethod(_gp.gp_Trsf2d_Multiplied, None, gp_Trsf2d)
gp_Trsf2d.Multiply = new_instancemethod(_gp.gp_Trsf2d_Multiply, None, gp_Trsf2d)
gp_Trsf2d.Power = new_instancemethod(_gp.gp_Trsf2d_Power, None, gp_Trsf2d)
gp_Trsf2d.Powered = new_instancemethod(_gp.gp_Trsf2d_Powered, None, gp_Trsf2d)
gp_Trsf2d.PreMultiply = new_instancemethod(_gp.gp_Trsf2d_PreMultiply, None, gp_Trsf2d)
gp_Trsf2d.RotationPart = new_instancemethod(_gp.gp_Trsf2d_RotationPart, None, gp_Trsf2d)
gp_Trsf2d.ScaleFactor = new_instancemethod(_gp.gp_Trsf2d_ScaleFactor, None, gp_Trsf2d)
gp_Trsf2d.SetMirror = new_instancemethod(_gp.gp_Trsf2d_SetMirror, None, gp_Trsf2d)
gp_Trsf2d.SetRotation = new_instancemethod(_gp.gp_Trsf2d_SetRotation, None, gp_Trsf2d)
gp_Trsf2d.SetScale = new_instancemethod(_gp.gp_Trsf2d_SetScale, None, gp_Trsf2d)
gp_Trsf2d.SetScaleFactor = new_instancemethod(_gp.gp_Trsf2d_SetScaleFactor, None, gp_Trsf2d)
gp_Trsf2d.SetTransformation = new_instancemethod(_gp.gp_Trsf2d_SetTransformation, None, gp_Trsf2d)
gp_Trsf2d.SetTranslation = new_instancemethod(_gp.gp_Trsf2d_SetTranslation, None, gp_Trsf2d)
gp_Trsf2d.SetTranslationPart = new_instancemethod(_gp.gp_Trsf2d_SetTranslationPart, None, gp_Trsf2d)
gp_Trsf2d.SetValues = new_instancemethod(_gp.gp_Trsf2d_SetValues, None, gp_Trsf2d)
gp_Trsf2d.Transforms = new_instancemethod(_gp.gp_Trsf2d_Transforms, None, gp_Trsf2d)
gp_Trsf2d.TranslationPart = new_instancemethod(_gp.gp_Trsf2d_TranslationPart, None, gp_Trsf2d)
gp_Trsf2d.Value = new_instancemethod(_gp.gp_Trsf2d_Value, None, gp_Trsf2d)
gp_Trsf2d.VectorialPart = new_instancemethod(_gp.gp_Trsf2d_VectorialPart, None, gp_Trsf2d)
gp_Trsf2d.__mul__ = new_instancemethod(_gp.gp_Trsf2d___mul__, None, gp_Trsf2d)
gp_Trsf2d.__imul_wrapper__ = new_instancemethod(_gp.gp_Trsf2d___imul_wrapper__, None, gp_Trsf2d)
gp_Trsf2d_swigregister = _gp.gp_Trsf2d_swigregister
gp_Trsf2d_swigregister(gp_Trsf2d)

class gp_Vec(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Adds two vectors
        	:param Other:
        	:type Other: gp_Vec
        	:rtype: None
        """
        return _gp.gp_Vec_Add(self, *args)


    def Added(self, *args) -> "gp_Vec":
        """
        * Adds two vectors
        	:param Other:
        	:type Other: gp_Vec
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Added(self, *args)


    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angular value between <self> and <Other> Returns the angle value between 0 and PI in radian. Raises VectorWithNullMagnitude if <self>.Magnitude() <= Resolution from gp or Other.Magnitude() <= Resolution because the angular value is indefinite if one of the vectors has a null magnitude.
        	:param Other:
        	:type Other: gp_Vec
        	:rtype: float
        """
        return _gp.gp_Vec_Angle(self, *args)


    def AngleWithRef(self, *args) -> "Standard_Real":
        """
        * Computes the angle, in radians, between this vector and vector Other. The result is a value between -Pi and Pi. For this, VRef defines the positive sense of rotation: the angular value is positive, if the cross product this ^ Other has the same orientation as VRef relative to the plane defined by the vectors this and Other. Otherwise, the angular value is negative. Exceptions gp_VectorWithNullMagnitude if the magnitude of this vector, the vector Other, or the vector VRef is less than or equal to gp::Resolution(). Standard_DomainError if this vector, the vector Other, and the vector VRef are coplanar, unless this vector and the vector Other are parallel.
        	:param Other:
        	:type Other: gp_Vec
        	:param VRef:
        	:type VRef: gp_Vec
        	:rtype: float
        """
        return _gp.gp_Vec_AngleWithRef(self, *args)


    def Coord(self, *args) -> "void":
        """
        * Returns the coordinate of range Index : Index = 1 => X is returned Index = 2 => Y is returned Index = 3 => Z is returned Raised if Index != {1, 2, 3}.
        	:param Index:
        	:type Index: int
        	:rtype: float
        * For this vector returns its three coordinates Xv, Yv, and Zvinline
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:param Zv:
        	:type Zv: float
        	:rtype: None
        """
        return _gp.gp_Vec_Coord(self, *args)


    def Cross(self, *args) -> "void":
        """
        * computes the cross product between two vectors
        	:param Right:
        	:type Right: gp_Vec
        	:rtype: None
        """
        return _gp.gp_Vec_Cross(self, *args)


    def CrossCross(self, *args) -> "void":
        """
        * Computes the triple vector product. <self> ^= (V1 ^ V2)
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: None
        """
        return _gp.gp_Vec_CrossCross(self, *args)


    def CrossCrossed(self, *args) -> "gp_Vec":
        """
        * Computes the triple vector product. <self> ^ (V1 ^ V2)
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_CrossCrossed(self, *args)


    def CrossMagnitude(self, *args) -> "Standard_Real":
        """
        * Computes the magnitude of the cross product between <self> and Right. Returns || <self> ^ Right ||
        	:param Right:
        	:type Right: gp_Vec
        	:rtype: float
        """
        return _gp.gp_Vec_CrossMagnitude(self, *args)


    def CrossSquareMagnitude(self, *args) -> "Standard_Real":
        """
        * Computes the square magnitude of the cross product between <self> and Right. Returns || <self> ^ Right ||**2
        	:param Right:
        	:type Right: gp_Vec
        	:rtype: float
        """
        return _gp.gp_Vec_CrossSquareMagnitude(self, *args)


    def Crossed(self, *args) -> "gp_Vec":
        """
        * computes the cross product between two vectors
        	:param Right:
        	:type Right: gp_Vec
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Crossed(self, *args)


    def Divide(self, *args) -> "void":
        """
        * Divides a vector by a scalar
        	:param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_Vec_Divide(self, *args)


    def Divided(self, *args) -> "gp_Vec":
        """
        * Divides a vector by a scalar
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Divided(self, *args)


    def Dot(self, *args) -> "Standard_Real":
        """
        * computes the scalar product
        	:param Other:
        	:type Other: gp_Vec
        	:rtype: float
        """
        return _gp.gp_Vec_Dot(self, *args)


    def DotCross(self, *args) -> "Standard_Real":
        """
        * Computes the triple scalar product <self> * (V1 ^ V2).
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: float
        """
        return _gp.gp_Vec_DotCross(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the two vectors have the same magnitude value and the same direction. The precision values are LinearTolerance for the magnitude and AngularTolerance for the direction.
        	:param Other:
        	:type Other: gp_Vec
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Vec_IsEqual(self, *args)


    def IsNormal(self, *args) -> "Standard_Boolean":
        """
        * Returns True if abs(<self>.Angle(Other) - PI/2.) <= AngularTolerance Raises VectorWithNullMagnitude if <self>.Magnitude() <= Resolution or Other.Magnitude() <= Resolution from gp
        	:param Other:
        	:type Other: gp_Vec
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Vec_IsNormal(self, *args)


    def IsOpposite(self, *args) -> "Standard_Boolean":
        """
        * Returns True if PI - <self>.Angle(Other) <= AngularTolerance Raises VectorWithNullMagnitude if <self>.Magnitude() <= Resolution or Other.Magnitude() <= Resolution from gp
        	:param Other:
        	:type Other: gp_Vec
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Vec_IsOpposite(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * Returns True if Angle(<self>, Other) <= AngularTolerance or PI - Angle(<self>, Other) <= AngularTolerance This definition means that two parallel vectors cannot define a plane but two vectors with opposite directions are considered as parallel. Raises VectorWithNullMagnitude if <self>.Magnitude() <= Resolution or Other.Magnitude() <= Resolution from gp
        	:param Other:
        	:type Other: gp_Vec
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Vec_IsParallel(self, *args)


    def Magnitude(self, *args) -> "Standard_Real":
        """
        * Computes the magnitude of this vector.
        	:rtype: float
        """
        return _gp.gp_Vec_Magnitude(self, *args)


    def Mirror(self, *args) -> "void":
        """
        :param V:
        	:type V: gp_Vec
        	:rtype: None
        :param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        :param A2:
        	:type A2: gp_Ax2
        	:rtype: None
        """
        return _gp.gp_Vec_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Vec":
        """
        * Performs the symmetrical transformation of a vector with respect to the vector V which is the center of the symmetry.
        	:param V:
        	:type V: gp_Vec
        	:rtype: gp_Vec
        * Performs the symmetrical transformation of a vector with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: gp_Vec
        * Performs the symmetrical transformation of a vector with respect to a plane. The axis placement A2 locates the plane of the symmetry : (Location, XDirection, YDirection).
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Mirrored(self, *args)


    def Multiplied(self, *args) -> "gp_Vec":
        """
        * Multiplies a vector by a scalar
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * Multiplies a vector by a scalar
        	:param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_Vec_Multiply(self, *args)


    def Normalize(self, *args) -> "void":
        """
        * normalizes a vector Raises an exception if the magnitude of the vector is lower or equal to Resolution from gp.
        	:rtype: None
        """
        return _gp.gp_Vec_Normalize(self, *args)


    def Normalized(self, *args) -> "gp_Vec":
        """
        * normalizes a vector Raises an exception if the magnitude of the vector is lower or equal to Resolution from gp.
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Normalized(self, *args)


    def Reverse(self, *args) -> "void":
        """
        * Reverses the direction of a vector
        	:rtype: None
        """
        return _gp.gp_Vec_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Vec":
        """
        * Reverses the direction of a vector
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Vec_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Vec":
        """
        * Rotates a vector. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.
        	:param A1:
        	:type A1: gp_Ax1
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Vec_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Vec":
        """
        * Scales a vector. S is the scaling value.
        	:param S:
        	:type S: float
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Scaled(self, *args)


    def SetCoord(self, *args) -> "void":
        """
        * Changes the coordinate of range Index Index = 1 => X is modified Index = 2 => Y is modified Index = 3 => Z is modified Raised if Index != {1, 2, 3}.
        	:param Index:
        	:type Index: int
        	:param Xi:
        	:type Xi: float
        	:rtype: None
        * For this vector, assigns - the values Xv, Yv and Zv to its three coordinates.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:param Zv:
        	:type Zv: float
        	:rtype: None
        """
        return _gp.gp_Vec_SetCoord(self, *args)


    def SetLinearForm(self, *args) -> "void":
        """
        * <self> is set to the following linear form : A1 * V1 + A2 * V2 + A3 * V3 + V4
        	:param A1:
        	:type A1: float
        	:param V1:
        	:type V1: gp_Vec
        	:param A2:
        	:type A2: float
        	:param V2:
        	:type V2: gp_Vec
        	:param A3:
        	:type A3: float
        	:param V3:
        	:type V3: gp_Vec
        	:param V4:
        	:type V4: gp_Vec
        	:rtype: None
        * <self> is set to the following linear form : A1 * V1 + A2 * V2 + A3 * V3
        	:param A1:
        	:type A1: float
        	:param V1:
        	:type V1: gp_Vec
        	:param A2:
        	:type A2: float
        	:param V2:
        	:type V2: gp_Vec
        	:param A3:
        	:type A3: float
        	:param V3:
        	:type V3: gp_Vec
        	:rtype: None
        * <self> is set to the following linear form : A1 * V1 + A2 * V2 + V3
        	:param A1:
        	:type A1: float
        	:param V1:
        	:type V1: gp_Vec
        	:param A2:
        	:type A2: float
        	:param V2:
        	:type V2: gp_Vec
        	:param V3:
        	:type V3: gp_Vec
        	:rtype: None
        * <self> is set to the following linear form : A1 * V1 + A2 * V2
        	:param A1:
        	:type A1: float
        	:param V1:
        	:type V1: gp_Vec
        	:param A2:
        	:type A2: float
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: None
        * <self> is set to the following linear form : A1 * V1 + V2
        	:param A1:
        	:type A1: float
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: None
        * <self> is set to the following linear form : V1 + V2
        	:param V1:
        	:type V1: gp_Vec
        	:param V2:
        	:type V2: gp_Vec
        	:rtype: None
        """
        return _gp.gp_Vec_SetLinearForm(self, *args)


    def SetX(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate of this vector.
        	:param X:
        	:type X: float
        	:rtype: None
        """
        return _gp.gp_Vec_SetX(self, *args)


    def SetXYZ(self, *args) -> "void":
        """
        * Assigns the three coordinates of Coord to this vector.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_Vec_SetXYZ(self, *args)


    def SetY(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate of this vector.
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_Vec_SetY(self, *args)


    def SetZ(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate of this vector.
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        return _gp.gp_Vec_SetZ(self, *args)


    def SquareMagnitude(self, *args) -> "Standard_Real":
        """
        * Computes the square magnitude of this vector.
        	:rtype: float
        """
        return _gp.gp_Vec_SquareMagnitude(self, *args)


    def Subtract(self, *args) -> "void":
        """
        * Subtracts two vectors
        	:param Right:
        	:type Right: gp_Vec
        	:rtype: None
        """
        return _gp.gp_Vec_Subtract(self, *args)


    def Subtracted(self, *args) -> "gp_Vec":
        """
        * Subtracts two vectors
        	:param Right:
        	:type Right: gp_Vec
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Subtracted(self, *args)


    def Transform(self, *args) -> "void":
        """
        * Transforms a vector with the transformation T.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        return _gp.gp_Vec_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Vec":
        """
        * Transforms a vector with the transformation T.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec_Transformed(self, *args)


    def X(self, *args) -> "Standard_Real":
        """
        * For this vector, returns its X coordinate.
        	:rtype: float
        """
        return _gp.gp_Vec_X(self, *args)


    def XYZ(self, *args) -> "gp_XYZ const":
        """
        * For this vector, returns - its three coordinates as a number triple
        	:rtype: gp_XYZ
        """
        return _gp.gp_Vec_XYZ(self, *args)


    def Y(self, *args) -> "Standard_Real":
        """
        * For this vector, returns its Y coordinate.
        	:rtype: float
        """
        return _gp.gp_Vec_Y(self, *args)


    def Z(self, *args) -> "Standard_Real":
        """
        * For this vector, returns its Z coordinate.
        	:rtype: float
        """
        return _gp.gp_Vec_Z(self, *args)


    def __init__(self, *args):
        """
        * Creates a zero vector.
        	:rtype: None
        * Creates a unitary vector from a direction V.
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        * Creates a vector with a triplet of coordinates.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None
        * Creates a point with its three cartesian coordinates.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:param Zv:
        	:type Zv: float
        	:rtype: None
        * Creates a vector from two points. The length of the vector is the distance between P1 and P2
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        _gp.gp_Vec_swiginit(self, _gp.new_gp_Vec(*args))

    def __mul__(self, *args) -> "Standard_Real":
        """
        :param Scalar:
        	:type Scalar: float
        	:rtype: gp_Vec
        :param Other:
        	:type Other: gp_Vec
        	:rtype: float
        """
        return _gp.gp_Vec___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "gp_Vec":
        """
        :param Other:
        	:type Other: gp_Vec
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec___add__(self, *args)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __sub__(self, *args) -> "gp_Vec":
        """
        :param Right:
        	:type Right: gp_Vec
        	:rtype: gp_Vec
        """
        return _gp.gp_Vec___sub__(self, *args)


    def __neg__(self, *args) -> "gp_Vec":
        """:rtype: gp_Vec"""
        return _gp.gp_Vec___neg__(self, *args)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_Vec___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Vec
gp_Vec.Add = new_instancemethod(_gp.gp_Vec_Add, None, gp_Vec)
gp_Vec.Added = new_instancemethod(_gp.gp_Vec_Added, None, gp_Vec)
gp_Vec.Angle = new_instancemethod(_gp.gp_Vec_Angle, None, gp_Vec)
gp_Vec.AngleWithRef = new_instancemethod(_gp.gp_Vec_AngleWithRef, None, gp_Vec)
gp_Vec.Coord = new_instancemethod(_gp.gp_Vec_Coord, None, gp_Vec)
gp_Vec.Cross = new_instancemethod(_gp.gp_Vec_Cross, None, gp_Vec)
gp_Vec.CrossCross = new_instancemethod(_gp.gp_Vec_CrossCross, None, gp_Vec)
gp_Vec.CrossCrossed = new_instancemethod(_gp.gp_Vec_CrossCrossed, None, gp_Vec)
gp_Vec.CrossMagnitude = new_instancemethod(_gp.gp_Vec_CrossMagnitude, None, gp_Vec)
gp_Vec.CrossSquareMagnitude = new_instancemethod(_gp.gp_Vec_CrossSquareMagnitude, None, gp_Vec)
gp_Vec.Crossed = new_instancemethod(_gp.gp_Vec_Crossed, None, gp_Vec)
gp_Vec.Divide = new_instancemethod(_gp.gp_Vec_Divide, None, gp_Vec)
gp_Vec.Divided = new_instancemethod(_gp.gp_Vec_Divided, None, gp_Vec)
gp_Vec.Dot = new_instancemethod(_gp.gp_Vec_Dot, None, gp_Vec)
gp_Vec.DotCross = new_instancemethod(_gp.gp_Vec_DotCross, None, gp_Vec)
gp_Vec.IsEqual = new_instancemethod(_gp.gp_Vec_IsEqual, None, gp_Vec)
gp_Vec.IsNormal = new_instancemethod(_gp.gp_Vec_IsNormal, None, gp_Vec)
gp_Vec.IsOpposite = new_instancemethod(_gp.gp_Vec_IsOpposite, None, gp_Vec)
gp_Vec.IsParallel = new_instancemethod(_gp.gp_Vec_IsParallel, None, gp_Vec)
gp_Vec.Magnitude = new_instancemethod(_gp.gp_Vec_Magnitude, None, gp_Vec)
gp_Vec.Mirror = new_instancemethod(_gp.gp_Vec_Mirror, None, gp_Vec)
gp_Vec.Mirrored = new_instancemethod(_gp.gp_Vec_Mirrored, None, gp_Vec)
gp_Vec.Multiplied = new_instancemethod(_gp.gp_Vec_Multiplied, None, gp_Vec)
gp_Vec.Multiply = new_instancemethod(_gp.gp_Vec_Multiply, None, gp_Vec)
gp_Vec.Normalize = new_instancemethod(_gp.gp_Vec_Normalize, None, gp_Vec)
gp_Vec.Normalized = new_instancemethod(_gp.gp_Vec_Normalized, None, gp_Vec)
gp_Vec.Reverse = new_instancemethod(_gp.gp_Vec_Reverse, None, gp_Vec)
gp_Vec.Reversed = new_instancemethod(_gp.gp_Vec_Reversed, None, gp_Vec)
gp_Vec.Rotate = new_instancemethod(_gp.gp_Vec_Rotate, None, gp_Vec)
gp_Vec.Rotated = new_instancemethod(_gp.gp_Vec_Rotated, None, gp_Vec)
gp_Vec.Scale = new_instancemethod(_gp.gp_Vec_Scale, None, gp_Vec)
gp_Vec.Scaled = new_instancemethod(_gp.gp_Vec_Scaled, None, gp_Vec)
gp_Vec.SetCoord = new_instancemethod(_gp.gp_Vec_SetCoord, None, gp_Vec)
gp_Vec.SetLinearForm = new_instancemethod(_gp.gp_Vec_SetLinearForm, None, gp_Vec)
gp_Vec.SetX = new_instancemethod(_gp.gp_Vec_SetX, None, gp_Vec)
gp_Vec.SetXYZ = new_instancemethod(_gp.gp_Vec_SetXYZ, None, gp_Vec)
gp_Vec.SetY = new_instancemethod(_gp.gp_Vec_SetY, None, gp_Vec)
gp_Vec.SetZ = new_instancemethod(_gp.gp_Vec_SetZ, None, gp_Vec)
gp_Vec.SquareMagnitude = new_instancemethod(_gp.gp_Vec_SquareMagnitude, None, gp_Vec)
gp_Vec.Subtract = new_instancemethod(_gp.gp_Vec_Subtract, None, gp_Vec)
gp_Vec.Subtracted = new_instancemethod(_gp.gp_Vec_Subtracted, None, gp_Vec)
gp_Vec.Transform = new_instancemethod(_gp.gp_Vec_Transform, None, gp_Vec)
gp_Vec.Transformed = new_instancemethod(_gp.gp_Vec_Transformed, None, gp_Vec)
gp_Vec.X = new_instancemethod(_gp.gp_Vec_X, None, gp_Vec)
gp_Vec.XYZ = new_instancemethod(_gp.gp_Vec_XYZ, None, gp_Vec)
gp_Vec.Y = new_instancemethod(_gp.gp_Vec_Y, None, gp_Vec)
gp_Vec.Z = new_instancemethod(_gp.gp_Vec_Z, None, gp_Vec)
gp_Vec.__mul__ = new_instancemethod(_gp.gp_Vec___mul__, None, gp_Vec)
gp_Vec.__imul_wrapper__ = new_instancemethod(_gp.gp_Vec___imul_wrapper__, None, gp_Vec)
gp_Vec.__add__ = new_instancemethod(_gp.gp_Vec___add__, None, gp_Vec)
gp_Vec.__iadd_wrapper__ = new_instancemethod(_gp.gp_Vec___iadd_wrapper__, None, gp_Vec)
gp_Vec.__sub__ = new_instancemethod(_gp.gp_Vec___sub__, None, gp_Vec)
gp_Vec.__neg__ = new_instancemethod(_gp.gp_Vec___neg__, None, gp_Vec)
gp_Vec.__isub_wrapper__ = new_instancemethod(_gp.gp_Vec___isub_wrapper__, None, gp_Vec)
gp_Vec.__itruediv_wrapper__ = new_instancemethod(_gp.gp_Vec___itruediv_wrapper__, None, gp_Vec)
gp_Vec_swigregister = _gp.gp_Vec_swigregister
gp_Vec_swigregister(gp_Vec)

class gp_Vec2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        :param Other:
        	:type Other: gp_Vec2d
        	:rtype: None
        """
        return _gp.gp_Vec2d_Add(self, *args)


    def Added(self, *args) -> "gp_Vec2d":
        """
        * Adds two vectors
        	:param Other:
        	:type Other: gp_Vec2d
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Added(self, *args)


    def Angle(self, *args) -> "Standard_Real":
        """
        * Computes the angular value between <self> and <Other> returns the angle value between -PI and PI in radian. The orientation is from <self> to Other. The positive sense is the trigonometric sense. Raises VectorWithNullMagnitude if <self>.Magnitude() <= Resolution from gp or Other.Magnitude() <= Resolution because the angular value is indefinite if one of the vectors has a null magnitude.
        	:param Other:
        	:type Other: gp_Vec2d
        	:rtype: float
        """
        return _gp.gp_Vec2d_Angle(self, *args)


    def Coord(self, *args) -> "void":
        """
        * Returns the coordinate of range Index : Index = 1 => X is returned Index = 2 => Y is returned Raised if Index != {1, 2}.
        	:param Index:
        	:type Index: int
        	:rtype: float
        * For this vector, returns its two coordinates Xv and Yv
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:rtype: None
        """
        return _gp.gp_Vec2d_Coord(self, *args)


    def CrossMagnitude(self, *args) -> "Standard_Real":
        """
        * Computes the magnitude of the cross product between <self> and Right. Returns || <self> ^ Right ||
        	:param Right:
        	:type Right: gp_Vec2d
        	:rtype: float
        """
        return _gp.gp_Vec2d_CrossMagnitude(self, *args)


    def CrossSquareMagnitude(self, *args) -> "Standard_Real":
        """
        * Computes the square magnitude of the cross product between <self> and Right. Returns || <self> ^ Right ||**2
        	:param Right:
        	:type Right: gp_Vec2d
        	:rtype: float
        """
        return _gp.gp_Vec2d_CrossSquareMagnitude(self, *args)


    def Crossed(self, *args) -> "Standard_Real":
        """
        * Computes the crossing product between two vectors
        	:param Right:
        	:type Right: gp_Vec2d
        	:rtype: float
        """
        return _gp.gp_Vec2d_Crossed(self, *args)


    def Divide(self, *args) -> "void":
        """
        :param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_Vec2d_Divide(self, *args)


    def Divided(self, *args) -> "gp_Vec2d":
        """
        * divides a vector by a scalar
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Divided(self, *args)


    def Dot(self, *args) -> "Standard_Real":
        """
        * Computes the scalar product
        	:param Other:
        	:type Other: gp_Vec2d
        	:rtype: float
        """
        return _gp.gp_Vec2d_Dot(self, *args)


    def GetNormal(self, *args) -> "gp_Vec2d":
        """:rtype: gp_Vec2d"""
        return _gp.gp_Vec2d_GetNormal(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the two vectors have the same magnitude value and the same direction. The precision values are LinearTolerance for the magnitude and AngularTolerance for the direction.
        	:param Other:
        	:type Other: gp_Vec2d
        	:param LinearTolerance:
        	:type LinearTolerance: float
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Vec2d_IsEqual(self, *args)


    def IsNormal(self, *args) -> "Standard_Boolean":
        """
        * Returns True if abs(Abs(<self>.Angle(Other)) - PI/2.) <= AngularTolerance Raises VectorWithNullMagnitude if <self>.Magnitude() <= Resolution or Other.Magnitude() <= Resolution from gp.
        	:param Other:
        	:type Other: gp_Vec2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Vec2d_IsNormal(self, *args)


    def IsOpposite(self, *args) -> "Standard_Boolean":
        """
        * Returns True if PI - Abs(<self>.Angle(Other)) <= AngularTolerance Raises VectorWithNullMagnitude if <self>.Magnitude() <= Resolution or Other.Magnitude() <= Resolution from gp.
        	:param Other:
        	:type Other: gp_Vec2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Vec2d_IsOpposite(self, *args)


    def IsParallel(self, *args) -> "Standard_Boolean":
        """
        * Returns true if Abs(Angle(<self>, Other)) <= AngularTolerance or PI - Abs(Angle(<self>, Other)) <= AngularTolerance Two vectors with opposite directions are considered as parallel. Raises VectorWithNullMagnitude if <self>.Magnitude() <= Resolution or Other.Magnitude() <= Resolution from gp
        	:param Other:
        	:type Other: gp_Vec2d
        	:param AngularTolerance:
        	:type AngularTolerance: float
        	:rtype: bool
        """
        return _gp.gp_Vec2d_IsParallel(self, *args)


    def Magnitude(self, *args) -> "Standard_Real":
        """
        * Computes the magnitude of this vector.
        	:rtype: float
        """
        return _gp.gp_Vec2d_Magnitude(self, *args)


    def Mirror(self, *args) -> "void":
        """
        * Performs the symmetrical transformation of a vector with respect to the vector V which is the center of the symmetry.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None
        * Performs the symmetrical transformation of a vector with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax2d
        	:rtype: None
        """
        return _gp.gp_Vec2d_Mirror(self, *args)


    def Mirrored(self, *args) -> "gp_Vec2d":
        """
        * Performs the symmetrical transformation of a vector with respect to the vector V which is the center of the symmetry.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: gp_Vec2d
        * Performs the symmetrical transformation of a vector with respect to an axis placement which is the axis of the symmetry.
        	:param A1:
        	:type A1: gp_Ax2d
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Mirrored(self, *args)


    def Multiplied(self, *args) -> "gp_Vec2d":
        """
        * Normalizes a vector Raises an exception if the magnitude of the vector is lower or equal to Resolution from package gp.
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        :param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_Vec2d_Multiply(self, *args)


    def Normalize(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Vec2d_Normalize(self, *args)


    def Normalized(self, *args) -> "gp_Vec2d":
        """
        * Normalizes a vector Raises an exception if the magnitude of the vector is lower or equal to Resolution from package gp. Reverses the direction of a vector
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Normalized(self, *args)


    def Reverse(self, *args) -> "void":
        """:rtype: None"""
        return _gp.gp_Vec2d_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_Vec2d":
        """
        * Reverses the direction of a vector
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Reversed(self, *args)


    def Rotate(self, *args) -> "void":
        """
        :param Ang:
        	:type Ang: float
        	:rtype: None
        """
        return _gp.gp_Vec2d_Rotate(self, *args)


    def Rotated(self, *args) -> "gp_Vec2d":
        """
        * Rotates a vector. Ang is the angular value of the rotation in radians.
        	:param Ang:
        	:type Ang: float
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Rotated(self, *args)


    def Scale(self, *args) -> "void":
        """
        :param S:
        	:type S: float
        	:rtype: None
        """
        return _gp.gp_Vec2d_Scale(self, *args)


    def Scaled(self, *args) -> "gp_Vec2d":
        """
        * Scales a vector. S is the scaling value.
        	:param S:
        	:type S: float
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Scaled(self, *args)


    def SetCoord(self, *args) -> "void":
        """
        * Changes the coordinate of range Index Index = 1 => X is modified Index = 2 => Y is modified Raises OutOfRange if Index != {1, 2}.
        	:param Index:
        	:type Index: int
        	:param Xi:
        	:type Xi: float
        	:rtype: None
        * For this vector, assigns the values Xv and Yv to its two coordinates
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:rtype: None
        """
        return _gp.gp_Vec2d_SetCoord(self, *args)


    def SetLinearForm(self, *args) -> "void":
        """
        * <self> is set to the following linear form : A1 * V1 + A2 * V2 + V3
        	:param A1:
        	:type A1: float
        	:param V1:
        	:type V1: gp_Vec2d
        	:param A2:
        	:type A2: float
        	:param V2:
        	:type V2: gp_Vec2d
        	:param V3:
        	:type V3: gp_Vec2d
        	:rtype: None
        * <self> is set to the following linear form : A1 * V1 + A2 * V2
        	:param A1:
        	:type A1: float
        	:param V1:
        	:type V1: gp_Vec2d
        	:param A2:
        	:type A2: float
        	:param V2:
        	:type V2: gp_Vec2d
        	:rtype: None
        * <self> is set to the following linear form : A1 * V1 + V2
        	:param A1:
        	:type A1: float
        	:param V1:
        	:type V1: gp_Vec2d
        	:param V2:
        	:type V2: gp_Vec2d
        	:rtype: None
        * <self> is set to the following linear form : Left + Right
        	:param Left:
        	:type Left: gp_Vec2d
        	:param Right:
        	:type Right: gp_Vec2d
        	:rtype: None
        """
        return _gp.gp_Vec2d_SetLinearForm(self, *args)


    def SetX(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate of this vector.
        	:param X:
        	:type X: float
        	:rtype: None
        """
        return _gp.gp_Vec2d_SetX(self, *args)


    def SetXY(self, *args) -> "void":
        """
        * Assigns the two coordinates of Coord to this vector.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        """
        return _gp.gp_Vec2d_SetXY(self, *args)


    def SetY(self, *args) -> "void":
        """
        * Assigns the given value to the Y coordinate of this vector.
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_Vec2d_SetY(self, *args)


    def SquareMagnitude(self, *args) -> "Standard_Real":
        """
        * Computes the square magnitude of this vector.
        	:rtype: float
        """
        return _gp.gp_Vec2d_SquareMagnitude(self, *args)


    def Subtract(self, *args) -> "void":
        """
        * Subtracts two vectors
        	:param Right:
        	:type Right: gp_Vec2d
        	:rtype: None
        """
        return _gp.gp_Vec2d_Subtract(self, *args)


    def Subtracted(self, *args) -> "gp_Vec2d":
        """
        * Subtracts two vectors
        	:param Right:
        	:type Right: gp_Vec2d
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Subtracted(self, *args)


    def Transform(self, *args) -> "void":
        """
        :param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        return _gp.gp_Vec2d_Transform(self, *args)


    def Transformed(self, *args) -> "gp_Vec2d":
        """
        * Transforms a vector with a Trsf from gp.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d_Transformed(self, *args)


    def X(self, *args) -> "Standard_Real":
        """
        * For this vector, returns its X coordinate.
        	:rtype: float
        """
        return _gp.gp_Vec2d_X(self, *args)


    def XY(self, *args) -> "gp_XY const":
        """
        * For this vector, returns its two coordinates as a number pair
        	:rtype: gp_XY
        """
        return _gp.gp_Vec2d_XY(self, *args)


    def Y(self, *args) -> "Standard_Real":
        """
        * For this vector, returns its Y coordinate.
        	:rtype: float
        """
        return _gp.gp_Vec2d_Y(self, *args)


    def __init__(self, *args):
        """
        * Creates a zero vector.
        	:rtype: None
        * Creates a unitary vector from a direction V.
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        * Creates a vector with a doublet of coordinates.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None
        * Creates a point with its two Cartesian coordinates.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:rtype: None
        * Creates a vector from two points. The length of the vector is the distance between P1 and P2
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        _gp.gp_Vec2d_swiginit(self, _gp.new_gp_Vec2d(*args))

    def __mul__(self, *args) -> "gp_Vec2d":
        """
        :param Other:
        	:type Other: gp_Vec2d
        	:rtype: float
        :param Scalar:
        	:type Scalar: float
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "gp_Vec2d":
        """
        :param Other:
        	:type Other: gp_Vec2d
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d___add__(self, *args)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __neg__(self, *args) -> "gp_Vec2d":
        """:rtype: gp_Vec2d"""
        return _gp.gp_Vec2d___neg__(self, *args)


    def __sub__(self, *args) -> "gp_Vec2d":
        """
        :param Right:
        	:type Right: gp_Vec2d
        	:rtype: gp_Vec2d
        """
        return _gp.gp_Vec2d___sub__(self, *args)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_Vec2d___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Vec2d
gp_Vec2d.Add = new_instancemethod(_gp.gp_Vec2d_Add, None, gp_Vec2d)
gp_Vec2d.Added = new_instancemethod(_gp.gp_Vec2d_Added, None, gp_Vec2d)
gp_Vec2d.Angle = new_instancemethod(_gp.gp_Vec2d_Angle, None, gp_Vec2d)
gp_Vec2d.Coord = new_instancemethod(_gp.gp_Vec2d_Coord, None, gp_Vec2d)
gp_Vec2d.CrossMagnitude = new_instancemethod(_gp.gp_Vec2d_CrossMagnitude, None, gp_Vec2d)
gp_Vec2d.CrossSquareMagnitude = new_instancemethod(_gp.gp_Vec2d_CrossSquareMagnitude, None, gp_Vec2d)
gp_Vec2d.Crossed = new_instancemethod(_gp.gp_Vec2d_Crossed, None, gp_Vec2d)
gp_Vec2d.Divide = new_instancemethod(_gp.gp_Vec2d_Divide, None, gp_Vec2d)
gp_Vec2d.Divided = new_instancemethod(_gp.gp_Vec2d_Divided, None, gp_Vec2d)
gp_Vec2d.Dot = new_instancemethod(_gp.gp_Vec2d_Dot, None, gp_Vec2d)
gp_Vec2d.GetNormal = new_instancemethod(_gp.gp_Vec2d_GetNormal, None, gp_Vec2d)
gp_Vec2d.IsEqual = new_instancemethod(_gp.gp_Vec2d_IsEqual, None, gp_Vec2d)
gp_Vec2d.IsNormal = new_instancemethod(_gp.gp_Vec2d_IsNormal, None, gp_Vec2d)
gp_Vec2d.IsOpposite = new_instancemethod(_gp.gp_Vec2d_IsOpposite, None, gp_Vec2d)
gp_Vec2d.IsParallel = new_instancemethod(_gp.gp_Vec2d_IsParallel, None, gp_Vec2d)
gp_Vec2d.Magnitude = new_instancemethod(_gp.gp_Vec2d_Magnitude, None, gp_Vec2d)
gp_Vec2d.Mirror = new_instancemethod(_gp.gp_Vec2d_Mirror, None, gp_Vec2d)
gp_Vec2d.Mirrored = new_instancemethod(_gp.gp_Vec2d_Mirrored, None, gp_Vec2d)
gp_Vec2d.Multiplied = new_instancemethod(_gp.gp_Vec2d_Multiplied, None, gp_Vec2d)
gp_Vec2d.Multiply = new_instancemethod(_gp.gp_Vec2d_Multiply, None, gp_Vec2d)
gp_Vec2d.Normalize = new_instancemethod(_gp.gp_Vec2d_Normalize, None, gp_Vec2d)
gp_Vec2d.Normalized = new_instancemethod(_gp.gp_Vec2d_Normalized, None, gp_Vec2d)
gp_Vec2d.Reverse = new_instancemethod(_gp.gp_Vec2d_Reverse, None, gp_Vec2d)
gp_Vec2d.Reversed = new_instancemethod(_gp.gp_Vec2d_Reversed, None, gp_Vec2d)
gp_Vec2d.Rotate = new_instancemethod(_gp.gp_Vec2d_Rotate, None, gp_Vec2d)
gp_Vec2d.Rotated = new_instancemethod(_gp.gp_Vec2d_Rotated, None, gp_Vec2d)
gp_Vec2d.Scale = new_instancemethod(_gp.gp_Vec2d_Scale, None, gp_Vec2d)
gp_Vec2d.Scaled = new_instancemethod(_gp.gp_Vec2d_Scaled, None, gp_Vec2d)
gp_Vec2d.SetCoord = new_instancemethod(_gp.gp_Vec2d_SetCoord, None, gp_Vec2d)
gp_Vec2d.SetLinearForm = new_instancemethod(_gp.gp_Vec2d_SetLinearForm, None, gp_Vec2d)
gp_Vec2d.SetX = new_instancemethod(_gp.gp_Vec2d_SetX, None, gp_Vec2d)
gp_Vec2d.SetXY = new_instancemethod(_gp.gp_Vec2d_SetXY, None, gp_Vec2d)
gp_Vec2d.SetY = new_instancemethod(_gp.gp_Vec2d_SetY, None, gp_Vec2d)
gp_Vec2d.SquareMagnitude = new_instancemethod(_gp.gp_Vec2d_SquareMagnitude, None, gp_Vec2d)
gp_Vec2d.Subtract = new_instancemethod(_gp.gp_Vec2d_Subtract, None, gp_Vec2d)
gp_Vec2d.Subtracted = new_instancemethod(_gp.gp_Vec2d_Subtracted, None, gp_Vec2d)
gp_Vec2d.Transform = new_instancemethod(_gp.gp_Vec2d_Transform, None, gp_Vec2d)
gp_Vec2d.Transformed = new_instancemethod(_gp.gp_Vec2d_Transformed, None, gp_Vec2d)
gp_Vec2d.X = new_instancemethod(_gp.gp_Vec2d_X, None, gp_Vec2d)
gp_Vec2d.XY = new_instancemethod(_gp.gp_Vec2d_XY, None, gp_Vec2d)
gp_Vec2d.Y = new_instancemethod(_gp.gp_Vec2d_Y, None, gp_Vec2d)
gp_Vec2d.__mul__ = new_instancemethod(_gp.gp_Vec2d___mul__, None, gp_Vec2d)
gp_Vec2d.__imul_wrapper__ = new_instancemethod(_gp.gp_Vec2d___imul_wrapper__, None, gp_Vec2d)
gp_Vec2d.__add__ = new_instancemethod(_gp.gp_Vec2d___add__, None, gp_Vec2d)
gp_Vec2d.__iadd_wrapper__ = new_instancemethod(_gp.gp_Vec2d___iadd_wrapper__, None, gp_Vec2d)
gp_Vec2d.__neg__ = new_instancemethod(_gp.gp_Vec2d___neg__, None, gp_Vec2d)
gp_Vec2d.__sub__ = new_instancemethod(_gp.gp_Vec2d___sub__, None, gp_Vec2d)
gp_Vec2d.__isub_wrapper__ = new_instancemethod(_gp.gp_Vec2d___isub_wrapper__, None, gp_Vec2d)
gp_Vec2d.__itruediv_wrapper__ = new_instancemethod(_gp.gp_Vec2d___itruediv_wrapper__, None, gp_Vec2d)
gp_Vec2d_swigregister = _gp.gp_Vec2d_swigregister
gp_Vec2d_swigregister(gp_Vec2d)

class gp_XY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * Computes the sum of this number pair and number pair Other <self>.X() = <self>.X() + Other.X() <self>.Y() = <self>.Y() + Other.Y()
        	:param Other:
        	:type Other: gp_XY
        	:rtype: None
        """
        return _gp.gp_XY_Add(self, *args)


    def Added(self, *args) -> "gp_XY":
        """
        * Computes the sum of this number pair and number pair Other new.X() = <self>.X() + Other.X() new.Y() = <self>.Y() + Other.Y()
        	:param Other:
        	:type Other: gp_XY
        	:rtype: gp_XY
        """
        return _gp.gp_XY_Added(self, *args)


    def GetChangeCoord(self, theIndex: 'Standard_Integer const') -> "Standard_Real":
        """GetChangeCoord(gp_XY self, Standard_Integer const theIndex) -> Standard_Real"""
        return _gp.gp_XY_GetChangeCoord(self, theIndex)


    def SetChangeCoord(self, theIndex: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetChangeCoord(gp_XY self, Standard_Integer const theIndex, Standard_Real value)"""
        return _gp.gp_XY_SetChangeCoord(self, theIndex, value)


    def Coord(self, *args) -> "void":
        """
        * returns the coordinate of range Index : Index = 1 => X is returned Index = 2 => Y is returned Raises OutOfRange if Index != {1, 2}.
        	:param Index:
        	:type Index: int
        	:rtype: float
        * For this number pair, returns its coordinates X and Y.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_XY_Coord(self, *args)


    def CrossMagnitude(self, *args) -> "Standard_Real":
        """
        * computes the magnitude of the cross product between <self> and Right. Returns || <self> ^ Right ||
        	:param Right:
        	:type Right: gp_XY
        	:rtype: float
        """
        return _gp.gp_XY_CrossMagnitude(self, *args)


    def CrossSquareMagnitude(self, *args) -> "Standard_Real":
        """
        * computes the square magnitude of the cross product between <self> and Right. Returns || <self> ^ Right ||**2
        	:param Right:
        	:type Right: gp_XY
        	:rtype: float
        """
        return _gp.gp_XY_CrossSquareMagnitude(self, *args)


    def Crossed(self, *args) -> "Standard_Real":
        """
        * Real D = <self>.X() * Other.Y() - <self>.Y() * Other.X()
        	:param Right:
        	:type Right: gp_XY
        	:rtype: float
        """
        return _gp.gp_XY_Crossed(self, *args)


    def Divide(self, *args) -> "void":
        """
        * divides <self> by a real.
        	:param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_XY_Divide(self, *args)


    def Divided(self, *args) -> "gp_XY":
        """
        * Divides <self> by a real.
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_XY
        """
        return _gp.gp_XY_Divided(self, *args)


    def Dot(self, *args) -> "Standard_Real":
        """
        * Computes the scalar product between <self> and Other
        	:param Other:
        	:type Other: gp_XY
        	:rtype: float
        """
        return _gp.gp_XY_Dot(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the coordinates of this number pair are equal to the respective coordinates of the number pair Other, within the specified tolerance Tolerance. I.e.: abs(<self>.X() - Other.X()) <= Tolerance and abs(<self>.Y() - Other.Y()) <= Tolerance and computations
        	:param Other:
        	:type Other: gp_XY
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: bool
        """
        return _gp.gp_XY_IsEqual(self, *args)


    def Modulus(self, *args) -> "Standard_Real":
        """
        * Computes Sqrt (X*X + Y*Y) where X and Y are the two coordinates of this number pair.
        	:rtype: float
        """
        return _gp.gp_XY_Modulus(self, *args)


    def Multiplied(self, *args) -> "gp_XY":
        """
        * New.X() = <self>.X() * Scalar; New.Y() = <self>.Y() * Scalar;
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_XY
        * new.X() = <self>.X() * Other.X(); new.Y() = <self>.Y() * Other.Y();
        	:param Other:
        	:type Other: gp_XY
        	:rtype: gp_XY
        * New = Matrix * <self>
        	:param Matrix:
        	:type Matrix: gp_Mat2d
        	:rtype: gp_XY
        """
        return _gp.gp_XY_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * <self>.X() = <self>.X() * Scalar; <self>.Y() = <self>.Y() * Scalar;
        	:param Scalar:
        	:type Scalar: float
        	:rtype: None
        * <self>.X() = <self>.X() * Other.X(); <self>.Y() = <self>.Y() * Other.Y();
        	:param Other:
        	:type Other: gp_XY
        	:rtype: None
        * <self> = Matrix * <self>
        	:param Matrix:
        	:type Matrix: gp_Mat2d
        	:rtype: None
        """
        return _gp.gp_XY_Multiply(self, *args)


    def Normalize(self, *args) -> "void":
        """
        * <self>.X() = <self>.X()/ <self>.Modulus() <self>.Y() = <self>.Y()/ <self>.Modulus() Raises ConstructionError if <self>.Modulus() <= Resolution from gp
        	:rtype: None
        """
        return _gp.gp_XY_Normalize(self, *args)


    def Normalized(self, *args) -> "gp_XY":
        """
        * New.X() = <self>.X()/ <self>.Modulus() New.Y() = <self>.Y()/ <self>.Modulus() Raises ConstructionError if <self>.Modulus() <= Resolution from gp
        	:rtype: gp_XY
        """
        return _gp.gp_XY_Normalized(self, *args)


    def Reverse(self, *args) -> "void":
        """
        * <self>.X() = -<self>.X() <self>.Y() = -<self>.Y()
        	:rtype: None
        """
        return _gp.gp_XY_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_XY":
        """
        * New.X() = -<self>.X() New.Y() = -<self>.Y()
        	:rtype: gp_XY
        """
        return _gp.gp_XY_Reversed(self, *args)


    def SetCoord(self, *args) -> "void":
        """
        * modifies the coordinate of range Index Index = 1 => X is modified Index = 2 => Y is modified Raises OutOfRange if Index != {1, 2}.
        	:param Index:
        	:type Index: int
        	:param Xi:
        	:type Xi: float
        	:rtype: None
        * For this number pair, assigns the values X and Y to its coordinates
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_XY_SetCoord(self, *args)


    def SetLinearForm(self, *args) -> "void":
        """
        * Computes the following linear combination and assigns the result to this number pair: A1 * XY1 + A2 * XY2
        	:param A1:
        	:type A1: float
        	:param XY1:
        	:type XY1: gp_XY
        	:param A2:
        	:type A2: float
        	:param XY2:
        	:type XY2: gp_XY
        	:rtype: None
        * -- Computes the following linear combination and assigns the result to this number pair: A1 * XY1 + A2 * XY2 + XY3
        	:param A1:
        	:type A1: float
        	:param XY1:
        	:type XY1: gp_XY
        	:param A2:
        	:type A2: float
        	:param XY2:
        	:type XY2: gp_XY
        	:param XY3:
        	:type XY3: gp_XY
        	:rtype: None
        * Computes the following linear combination and assigns the result to this number pair: A1 * XY1 + XY2
        	:param A1:
        	:type A1: float
        	:param XY1:
        	:type XY1: gp_XY
        	:param XY2:
        	:type XY2: gp_XY
        	:rtype: None
        * Computes the following linear combination and assigns the result to this number pair: XY1 + XY2
        	:param XY1:
        	:type XY1: gp_XY
        	:param XY2:
        	:type XY2: gp_XY
        	:rtype: None
        """
        return _gp.gp_XY_SetLinearForm(self, *args)


    def SetX(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate of this number pair.
        	:param X:
        	:type X: float
        	:rtype: None
        """
        return _gp.gp_XY_SetX(self, *args)


    def SetY(self, *args) -> "void":
        """
        * Assigns the given value to the Y coordinate of this number pair.
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_XY_SetY(self, *args)


    def SquareModulus(self, *args) -> "Standard_Real":
        """
        * Computes X*X + Y*Y where X and Y are the two coordinates of this number pair.
        	:rtype: float
        """
        return _gp.gp_XY_SquareModulus(self, *args)


    def Subtract(self, *args) -> "void":
        """
        * <self>.X() = <self>.X() - Other.X() <self>.Y() = <self>.Y() - Other.Y()
        	:param Right:
        	:type Right: gp_XY
        	:rtype: None
        """
        return _gp.gp_XY_Subtract(self, *args)


    def Subtracted(self, *args) -> "gp_XY":
        """
        * new.X() = <self>.X() - Other.X() new.Y() = <self>.Y() - Other.Y()
        	:param Right:
        	:type Right: gp_XY
        	:rtype: gp_XY
        """
        return _gp.gp_XY_Subtracted(self, *args)


    def X(self, *args) -> "Standard_Real":
        """
        * Returns the X coordinate of this number pair.
        	:rtype: float
        """
        return _gp.gp_XY_X(self, *args)


    def Y(self, *args) -> "Standard_Real":
        """
        * Returns the Y coordinate of this number pair.
        	:rtype: float
        """
        return _gp.gp_XY_Y(self, *args)


    def __init__(self, *args):
        """
        * Creates XY object with zero coordinates (0,0).
        	:rtype: None
        * a number pair defined by the XY coordinates
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        _gp.gp_XY_swiginit(self, _gp.new_gp_XY(*args))

    def __mul__(self, *args) -> "gp_XY":
        """
        :param Other:
        	:type Other: gp_XY
        	:rtype: float
        :param Scalar:
        	:type Scalar: float
        	:rtype: gp_XY
        :param Matrix:
        	:type Matrix: gp_Mat2d
        	:rtype: gp_XY
        """
        return _gp.gp_XY___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul_wrapper__(self, *args) -> "void":
        """
        __imul_wrapper__(gp_XY self, Standard_Real const other)
        __imul_wrapper__(gp_XY self, gp_XY other)
        __imul_wrapper__(gp_XY self, gp_Mat2d other)
        """
        return _gp.gp_XY___imul_wrapper__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "gp_XY":
        """
        :param Other:
        	:type Other: gp_XY
        	:rtype: gp_XY
        """
        return _gp.gp_XY___add__(self, *args)


    def __iadd_wrapper__(self, other: 'gp_XY') -> "void":
        """__iadd_wrapper__(gp_XY self, gp_XY other)"""
        return _gp.gp_XY___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __neg__(self, *args) -> "gp_XY":
        """:rtype: gp_XY"""
        return _gp.gp_XY___neg__(self, *args)


    def __sub__(self, *args) -> "gp_XY":
        """
        :param Right:
        	:type Right: gp_XY
        	:rtype: gp_XY
        """
        return _gp.gp_XY___sub__(self, *args)


    def __isub_wrapper__(self, other: 'gp_XY') -> "void":
        """__isub_wrapper__(gp_XY self, gp_XY other)"""
        return _gp.gp_XY___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_XY___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__itruediv_wrapper__(gp_XY self, Standard_Real const other)"""
        return _gp.gp_XY___itruediv_wrapper__(self, other)


    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_XY
gp_XY.Add = new_instancemethod(_gp.gp_XY_Add, None, gp_XY)
gp_XY.Added = new_instancemethod(_gp.gp_XY_Added, None, gp_XY)
gp_XY.GetChangeCoord = new_instancemethod(_gp.gp_XY_GetChangeCoord, None, gp_XY)
gp_XY.SetChangeCoord = new_instancemethod(_gp.gp_XY_SetChangeCoord, None, gp_XY)
gp_XY.Coord = new_instancemethod(_gp.gp_XY_Coord, None, gp_XY)
gp_XY.CrossMagnitude = new_instancemethod(_gp.gp_XY_CrossMagnitude, None, gp_XY)
gp_XY.CrossSquareMagnitude = new_instancemethod(_gp.gp_XY_CrossSquareMagnitude, None, gp_XY)
gp_XY.Crossed = new_instancemethod(_gp.gp_XY_Crossed, None, gp_XY)
gp_XY.Divide = new_instancemethod(_gp.gp_XY_Divide, None, gp_XY)
gp_XY.Divided = new_instancemethod(_gp.gp_XY_Divided, None, gp_XY)
gp_XY.Dot = new_instancemethod(_gp.gp_XY_Dot, None, gp_XY)
gp_XY.IsEqual = new_instancemethod(_gp.gp_XY_IsEqual, None, gp_XY)
gp_XY.Modulus = new_instancemethod(_gp.gp_XY_Modulus, None, gp_XY)
gp_XY.Multiplied = new_instancemethod(_gp.gp_XY_Multiplied, None, gp_XY)
gp_XY.Multiply = new_instancemethod(_gp.gp_XY_Multiply, None, gp_XY)
gp_XY.Normalize = new_instancemethod(_gp.gp_XY_Normalize, None, gp_XY)
gp_XY.Normalized = new_instancemethod(_gp.gp_XY_Normalized, None, gp_XY)
gp_XY.Reverse = new_instancemethod(_gp.gp_XY_Reverse, None, gp_XY)
gp_XY.Reversed = new_instancemethod(_gp.gp_XY_Reversed, None, gp_XY)
gp_XY.SetCoord = new_instancemethod(_gp.gp_XY_SetCoord, None, gp_XY)
gp_XY.SetLinearForm = new_instancemethod(_gp.gp_XY_SetLinearForm, None, gp_XY)
gp_XY.SetX = new_instancemethod(_gp.gp_XY_SetX, None, gp_XY)
gp_XY.SetY = new_instancemethod(_gp.gp_XY_SetY, None, gp_XY)
gp_XY.SquareModulus = new_instancemethod(_gp.gp_XY_SquareModulus, None, gp_XY)
gp_XY.Subtract = new_instancemethod(_gp.gp_XY_Subtract, None, gp_XY)
gp_XY.Subtracted = new_instancemethod(_gp.gp_XY_Subtracted, None, gp_XY)
gp_XY.X = new_instancemethod(_gp.gp_XY_X, None, gp_XY)
gp_XY.Y = new_instancemethod(_gp.gp_XY_Y, None, gp_XY)
gp_XY.__mul__ = new_instancemethod(_gp.gp_XY___mul__, None, gp_XY)
gp_XY.__imul_wrapper__ = new_instancemethod(_gp.gp_XY___imul_wrapper__, None, gp_XY)
gp_XY.__add__ = new_instancemethod(_gp.gp_XY___add__, None, gp_XY)
gp_XY.__iadd_wrapper__ = new_instancemethod(_gp.gp_XY___iadd_wrapper__, None, gp_XY)
gp_XY.__neg__ = new_instancemethod(_gp.gp_XY___neg__, None, gp_XY)
gp_XY.__sub__ = new_instancemethod(_gp.gp_XY___sub__, None, gp_XY)
gp_XY.__isub_wrapper__ = new_instancemethod(_gp.gp_XY___isub_wrapper__, None, gp_XY)
gp_XY.__itruediv_wrapper__ = new_instancemethod(_gp.gp_XY___itruediv_wrapper__, None, gp_XY)
gp_XY_swigregister = _gp.gp_XY_swigregister
gp_XY_swigregister(gp_XY)

class gp_XYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * <self>.X() = <self>.X() + Other.X() <self>.Y() = <self>.Y() + Other.Y() <self>.Z() = <self>.Z() + Other.Z()
        	:param Other:
        	:type Other: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_XYZ_Add(self, *args)


    def Added(self, *args) -> "gp_XYZ":
        """
        * new.X() = <self>.X() + Other.X() new.Y() = <self>.Y() + Other.Y() new.Z() = <self>.Z() + Other.Z()
        	:param Other:
        	:type Other: gp_XYZ
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ_Added(self, *args)


    def GetChangeCoord(self, theIndex: 'Standard_Integer const') -> "Standard_Real":
        """GetChangeCoord(gp_XYZ self, Standard_Integer const theIndex) -> Standard_Real"""
        return _gp.gp_XYZ_GetChangeCoord(self, theIndex)


    def SetChangeCoord(self, theIndex: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetChangeCoord(gp_XYZ self, Standard_Integer const theIndex, Standard_Real value)"""
        return _gp.gp_XYZ_SetChangeCoord(self, theIndex, value)


    def ChangeData(self, *args) -> "Standard_Real *":
        """
        * Returns a ptr to coordinates location. Is useful for algorithms, but DOES NOT PERFORM ANY CHECKS!
        	:rtype: inline float *
        """
        return _gp.gp_XYZ_ChangeData(self, *args)


    def Coord(self, *args) -> "void":
        """
        * returns the coordinate of range Index : Index = 1 => X is returned Index = 2 => Y is returned Index = 3 => Z is returned //! Raises OutOfRange if Index != {1, 2, 3}.
        	:param Index:
        	:type Index: int
        	:rtype: float
        :param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        return _gp.gp_XYZ_Coord(self, *args)


    def Cross(self, *args) -> "void":
        """
        * <self>.X() = <self>.Y() * Other.Z() - <self>.Z() * Other.Y() <self>.Y() = <self>.Z() * Other.X() - <self>.X() * Other.Z() <self>.Z() = <self>.X() * Other.Y() - <self>.Y() * Other.X()
        	:param Right:
        	:type Right: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_XYZ_Cross(self, *args)


    def CrossCross(self, *args) -> "void":
        """
        * Triple vector product Computes <self> = <self>.Cross(Coord1.Cross(Coord2))
        	:param Coord1:
        	:type Coord1: gp_XYZ
        	:param Coord2:
        	:type Coord2: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_XYZ_CrossCross(self, *args)


    def CrossCrossed(self, *args) -> "gp_XYZ":
        """
        * Triple vector product computes New = <self>.Cross(Coord1.Cross(Coord2))
        	:param Coord1:
        	:type Coord1: gp_XYZ
        	:param Coord2:
        	:type Coord2: gp_XYZ
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ_CrossCrossed(self, *args)


    def CrossMagnitude(self, *args) -> "Standard_Real":
        """
        * Computes the magnitude of the cross product between <self> and Right. Returns || <self> ^ Right ||
        	:param Right:
        	:type Right: gp_XYZ
        	:rtype: float
        """
        return _gp.gp_XYZ_CrossMagnitude(self, *args)


    def CrossSquareMagnitude(self, *args) -> "Standard_Real":
        """
        * Computes the square magnitude of the cross product between <self> and Right. Returns || <self> ^ Right ||**2
        	:param Right:
        	:type Right: gp_XYZ
        	:rtype: float
        """
        return _gp.gp_XYZ_CrossSquareMagnitude(self, *args)


    def Crossed(self, *args) -> "gp_XYZ":
        """
        * new.X() = <self>.Y() * Other.Z() - <self>.Z() * Other.Y() new.Y() = <self>.Z() * Other.X() - <self>.X() * Other.Z() new.Z() = <self>.X() * Other.Y() - <self>.Y() * Other.X()
        	:param Right:
        	:type Right: gp_XYZ
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ_Crossed(self, *args)


    def Divide(self, *args) -> "void":
        """
        * divides <self> by a real.
        	:param Scalar:
        	:type Scalar: float
        	:rtype: None
        """
        return _gp.gp_XYZ_Divide(self, *args)


    def Divided(self, *args) -> "gp_XYZ":
        """
        * divides <self> by a real.
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ_Divided(self, *args)


    def Dot(self, *args) -> "Standard_Real":
        """
        * computes the scalar product between <self> and Other
        	:param Other:
        	:type Other: gp_XYZ
        	:rtype: float
        """
        return _gp.gp_XYZ_Dot(self, *args)


    def DotCross(self, *args) -> "Standard_Real":
        """
        * computes the triple scalar product
        	:param Coord1:
        	:type Coord1: gp_XYZ
        	:param Coord2:
        	:type Coord2: gp_XYZ
        	:rtype: float
        """
        return _gp.gp_XYZ_DotCross(self, *args)


    def DumpJsonToString(self, depth: 'int'=-1) -> "std::string":
        """
        DumpJsonToString(gp_XYZ self, int depth=-1) -> std::string
        DumpJsonToString(gp_XYZ self) -> std::string
        """
        return _gp.gp_XYZ_DumpJsonToString(self, depth)


    def GetData(self, *args) -> "Standard_Real const *":
        """
        * Returns a const ptr to coordinates location. Is useful for algorithms, but DOES NOT PERFORM ANY CHECKS!
        	:rtype: inline  float *
        """
        return _gp.gp_XYZ_GetData(self, *args)


    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        * Returns True if he coordinates of this XYZ object are equal to the respective coordinates Other, within the specified tolerance Tolerance. I.e.: abs(<self>.X() - Other.X()) <= Tolerance and abs(<self>.Y() - Other.Y()) <= Tolerance and abs(<self>.Z() - Other.Z()) <= Tolerance.
        	:param Other:
        	:type Other: gp_XYZ
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: bool
        """
        return _gp.gp_XYZ_IsEqual(self, *args)


    def Modulus(self, *args) -> "Standard_Real":
        """
        * computes Sqrt (X*X + Y*Y + Z*Z) where X, Y and Z are the three coordinates of this XYZ object.
        	:rtype: float
        """
        return _gp.gp_XYZ_Modulus(self, *args)


    def Multiplied(self, *args) -> "gp_XYZ":
        """
        * New.X() = <self>.X() * Scalar; New.Y() = <self>.Y() * Scalar; New.Z() = <self>.Z() * Scalar;
        	:param Scalar:
        	:type Scalar: float
        	:rtype: gp_XYZ
        * new.X() = <self>.X() * Other.X(); new.Y() = <self>.Y() * Other.Y(); new.Z() = <self>.Z() * Other.Z();
        	:param Other:
        	:type Other: gp_XYZ
        	:rtype: gp_XYZ
        * New = Matrix * <self>
        	:param Matrix:
        	:type Matrix: gp_Mat
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * <self>.X() = <self>.X() * Scalar; <self>.Y() = <self>.Y() * Scalar; <self>.Z() = <self>.Z() * Scalar;
        	:param Scalar:
        	:type Scalar: float
        	:rtype: None
        * <self>.X() = <self>.X() * Other.X(); <self>.Y() = <self>.Y() * Other.Y(); <self>.Z() = <self>.Z() * Other.Z();
        	:param Other:
        	:type Other: gp_XYZ
        	:rtype: None
        * <self> = Matrix * <self>
        	:param Matrix:
        	:type Matrix: gp_Mat
        	:rtype: None
        """
        return _gp.gp_XYZ_Multiply(self, *args)


    def Normalize(self, *args) -> "void":
        """
        * <self>.X() = <self>.X()/ <self>.Modulus() <self>.Y() = <self>.Y()/ <self>.Modulus() <self>.Z() = <self>.Z()/ <self>.Modulus() Raised if <self>.Modulus() <= Resolution from gp
        	:rtype: None
        """
        return _gp.gp_XYZ_Normalize(self, *args)


    def Normalized(self, *args) -> "gp_XYZ":
        """
        * New.X() = <self>.X()/ <self>.Modulus() New.Y() = <self>.Y()/ <self>.Modulus() New.Z() = <self>.Z()/ <self>.Modulus() Raised if <self>.Modulus() <= Resolution from gp
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ_Normalized(self, *args)


    def Reverse(self, *args) -> "void":
        """
        * <self>.X() = -<self>.X() <self>.Y() = -<self>.Y() <self>.Z() = -<self>.Z()
        	:rtype: None
        """
        return _gp.gp_XYZ_Reverse(self, *args)


    def Reversed(self, *args) -> "gp_XYZ":
        """
        * New.X() = -<self>.X() New.Y() = -<self>.Y() New.Z() = -<self>.Z()
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ_Reversed(self, *args)


    def SetCoord(self, *args) -> "void":
        """
        * For this XYZ object, assigns the values X, Y and Z to its three coordinates
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None
        * modifies the coordinate of range Index Index = 1 => X is modified Index = 2 => Y is modified Index = 3 => Z is modified Raises OutOfRange if Index != {1, 2, 3}.
        	:param Index:
        	:type Index: int
        	:param Xi:
        	:type Xi: float
        	:rtype: None
        """
        return _gp.gp_XYZ_SetCoord(self, *args)


    def SetLinearForm(self, *args) -> "void":
        """
        * <self> is set to the following linear form : A1 * XYZ1 + A2 * XYZ2 + A3 * XYZ3 + XYZ4
        	:param A1:
        	:type A1: float
        	:param XYZ1:
        	:type XYZ1: gp_XYZ
        	:param A2:
        	:type A2: float
        	:param XYZ2:
        	:type XYZ2: gp_XYZ
        	:param A3:
        	:type A3: float
        	:param XYZ3:
        	:type XYZ3: gp_XYZ
        	:param XYZ4:
        	:type XYZ4: gp_XYZ
        	:rtype: None
        * <self> is set to the following linear form : A1 * XYZ1 + A2 * XYZ2 + A3 * XYZ3
        	:param A1:
        	:type A1: float
        	:param XYZ1:
        	:type XYZ1: gp_XYZ
        	:param A2:
        	:type A2: float
        	:param XYZ2:
        	:type XYZ2: gp_XYZ
        	:param A3:
        	:type A3: float
        	:param XYZ3:
        	:type XYZ3: gp_XYZ
        	:rtype: None
        * <self> is set to the following linear form : A1 * XYZ1 + A2 * XYZ2 + XYZ3
        	:param A1:
        	:type A1: float
        	:param XYZ1:
        	:type XYZ1: gp_XYZ
        	:param A2:
        	:type A2: float
        	:param XYZ2:
        	:type XYZ2: gp_XYZ
        	:param XYZ3:
        	:type XYZ3: gp_XYZ
        	:rtype: None
        * <self> is set to the following linear form : A1 * XYZ1 + A2 * XYZ2
        	:param A1:
        	:type A1: float
        	:param XYZ1:
        	:type XYZ1: gp_XYZ
        	:param A2:
        	:type A2: float
        	:param XYZ2:
        	:type XYZ2: gp_XYZ
        	:rtype: None
        * <self> is set to the following linear form : A1 * XYZ1 + XYZ2
        	:param A1:
        	:type A1: float
        	:param XYZ1:
        	:type XYZ1: gp_XYZ
        	:param XYZ2:
        	:type XYZ2: gp_XYZ
        	:rtype: None
        * <self> is set to the following linear form : XYZ1 + XYZ2
        	:param XYZ1:
        	:type XYZ1: gp_XYZ
        	:param XYZ2:
        	:type XYZ2: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_XYZ_SetLinearForm(self, *args)


    def SetX(self, *args) -> "void":
        """
        * Assigns the given value to the X coordinate
        	:param X:
        	:type X: float
        	:rtype: None
        """
        return _gp.gp_XYZ_SetX(self, *args)


    def SetY(self, *args) -> "void":
        """
        * Assigns the given value to the Y coordinate
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        return _gp.gp_XYZ_SetY(self, *args)


    def SetZ(self, *args) -> "void":
        """
        * Assigns the given value to the Z coordinate
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        return _gp.gp_XYZ_SetZ(self, *args)


    def SquareModulus(self, *args) -> "Standard_Real":
        """
        * Computes X*X + Y*Y + Z*Z where X, Y and Z are the three coordinates of this XYZ object.
        	:rtype: float
        """
        return _gp.gp_XYZ_SquareModulus(self, *args)


    def Subtract(self, *args) -> "void":
        """
        * <self>.X() = <self>.X() - Other.X() <self>.Y() = <self>.Y() - Other.Y() <self>.Z() = <self>.Z() - Other.Z()
        	:param Right:
        	:type Right: gp_XYZ
        	:rtype: None
        """
        return _gp.gp_XYZ_Subtract(self, *args)


    def Subtracted(self, *args) -> "gp_XYZ":
        """
        * new.X() = <self>.X() - Other.X() new.Y() = <self>.Y() - Other.Y() new.Z() = <self>.Z() - Other.Z()
        	:param Right:
        	:type Right: gp_XYZ
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ_Subtracted(self, *args)


    def X(self, *args) -> "Standard_Real":
        """
        * Returns the X coordinate
        	:rtype: float
        """
        return _gp.gp_XYZ_X(self, *args)


    def Y(self, *args) -> "Standard_Real":
        """
        * Returns the Y coordinate
        	:rtype: float
        """
        return _gp.gp_XYZ_Y(self, *args)


    def Z(self, *args) -> "Standard_Real":
        """
        * Returns the Z coordinate
        	:rtype: float
        """
        return _gp.gp_XYZ_Z(self, *args)


    def __init__(self, *args):
        """
        * Creates an XYZ object with zero co-ordinates (0,0,0)
        	:rtype: None
        * creates an XYZ with given coordinates
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        _gp.gp_XYZ_swiginit(self, _gp.new_gp_XYZ(*args))

    def __mul__(self, *args) -> "gp_XYZ":
        """
        :param Other:
        	:type Other: gp_XYZ
        	:rtype: float
        :param Scalar:
        	:type Scalar: float
        	:rtype: gp_XYZ
        :param Matrix:
        	:type Matrix: gp_Mat
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul_wrapper__(self, *args) -> "void":
        """
        __imul_wrapper__(gp_XYZ self, Standard_Real const other)
        __imul_wrapper__(gp_XYZ self, gp_XYZ other)
        __imul_wrapper__(gp_XYZ self, gp_Mat other)
        """
        return _gp.gp_XYZ___imul_wrapper__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "gp_XYZ":
        """
        :param Other:
        	:type Other: gp_XYZ
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ___add__(self, *args)


    def __iadd_wrapper__(self, other: 'gp_XYZ') -> "void":
        """__iadd_wrapper__(gp_XYZ self, gp_XYZ other)"""
        return _gp.gp_XYZ___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __sub__(self, *args) -> "gp_XYZ":
        """
        :param Right:
        	:type Right: gp_XYZ
        	:rtype: gp_XYZ
        """
        return _gp.gp_XYZ___sub__(self, *args)


    def __isub_wrapper__(self, other: 'gp_XYZ') -> "void":
        """__isub_wrapper__(gp_XYZ self, gp_XYZ other)"""
        return _gp.gp_XYZ___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_XYZ___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__itruediv_wrapper__(gp_XYZ self, Standard_Real const other)"""
        return _gp.gp_XYZ___itruediv_wrapper__(self, other)


    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_XYZ
gp_XYZ.Add = new_instancemethod(_gp.gp_XYZ_Add, None, gp_XYZ)
gp_XYZ.Added = new_instancemethod(_gp.gp_XYZ_Added, None, gp_XYZ)
gp_XYZ.GetChangeCoord = new_instancemethod(_gp.gp_XYZ_GetChangeCoord, None, gp_XYZ)
gp_XYZ.SetChangeCoord = new_instancemethod(_gp.gp_XYZ_SetChangeCoord, None, gp_XYZ)
gp_XYZ.ChangeData = new_instancemethod(_gp.gp_XYZ_ChangeData, None, gp_XYZ)
gp_XYZ.Coord = new_instancemethod(_gp.gp_XYZ_Coord, None, gp_XYZ)
gp_XYZ.Cross = new_instancemethod(_gp.gp_XYZ_Cross, None, gp_XYZ)
gp_XYZ.CrossCross = new_instancemethod(_gp.gp_XYZ_CrossCross, None, gp_XYZ)
gp_XYZ.CrossCrossed = new_instancemethod(_gp.gp_XYZ_CrossCrossed, None, gp_XYZ)
gp_XYZ.CrossMagnitude = new_instancemethod(_gp.gp_XYZ_CrossMagnitude, None, gp_XYZ)
gp_XYZ.CrossSquareMagnitude = new_instancemethod(_gp.gp_XYZ_CrossSquareMagnitude, None, gp_XYZ)
gp_XYZ.Crossed = new_instancemethod(_gp.gp_XYZ_Crossed, None, gp_XYZ)
gp_XYZ.Divide = new_instancemethod(_gp.gp_XYZ_Divide, None, gp_XYZ)
gp_XYZ.Divided = new_instancemethod(_gp.gp_XYZ_Divided, None, gp_XYZ)
gp_XYZ.Dot = new_instancemethod(_gp.gp_XYZ_Dot, None, gp_XYZ)
gp_XYZ.DotCross = new_instancemethod(_gp.gp_XYZ_DotCross, None, gp_XYZ)
gp_XYZ.DumpJsonToString = new_instancemethod(_gp.gp_XYZ_DumpJsonToString, None, gp_XYZ)
gp_XYZ.GetData = new_instancemethod(_gp.gp_XYZ_GetData, None, gp_XYZ)
gp_XYZ.IsEqual = new_instancemethod(_gp.gp_XYZ_IsEqual, None, gp_XYZ)
gp_XYZ.Modulus = new_instancemethod(_gp.gp_XYZ_Modulus, None, gp_XYZ)
gp_XYZ.Multiplied = new_instancemethod(_gp.gp_XYZ_Multiplied, None, gp_XYZ)
gp_XYZ.Multiply = new_instancemethod(_gp.gp_XYZ_Multiply, None, gp_XYZ)
gp_XYZ.Normalize = new_instancemethod(_gp.gp_XYZ_Normalize, None, gp_XYZ)
gp_XYZ.Normalized = new_instancemethod(_gp.gp_XYZ_Normalized, None, gp_XYZ)
gp_XYZ.Reverse = new_instancemethod(_gp.gp_XYZ_Reverse, None, gp_XYZ)
gp_XYZ.Reversed = new_instancemethod(_gp.gp_XYZ_Reversed, None, gp_XYZ)
gp_XYZ.SetCoord = new_instancemethod(_gp.gp_XYZ_SetCoord, None, gp_XYZ)
gp_XYZ.SetLinearForm = new_instancemethod(_gp.gp_XYZ_SetLinearForm, None, gp_XYZ)
gp_XYZ.SetX = new_instancemethod(_gp.gp_XYZ_SetX, None, gp_XYZ)
gp_XYZ.SetY = new_instancemethod(_gp.gp_XYZ_SetY, None, gp_XYZ)
gp_XYZ.SetZ = new_instancemethod(_gp.gp_XYZ_SetZ, None, gp_XYZ)
gp_XYZ.SquareModulus = new_instancemethod(_gp.gp_XYZ_SquareModulus, None, gp_XYZ)
gp_XYZ.Subtract = new_instancemethod(_gp.gp_XYZ_Subtract, None, gp_XYZ)
gp_XYZ.Subtracted = new_instancemethod(_gp.gp_XYZ_Subtracted, None, gp_XYZ)
gp_XYZ.X = new_instancemethod(_gp.gp_XYZ_X, None, gp_XYZ)
gp_XYZ.Y = new_instancemethod(_gp.gp_XYZ_Y, None, gp_XYZ)
gp_XYZ.Z = new_instancemethod(_gp.gp_XYZ_Z, None, gp_XYZ)
gp_XYZ.__mul__ = new_instancemethod(_gp.gp_XYZ___mul__, None, gp_XYZ)
gp_XYZ.__imul_wrapper__ = new_instancemethod(_gp.gp_XYZ___imul_wrapper__, None, gp_XYZ)
gp_XYZ.__add__ = new_instancemethod(_gp.gp_XYZ___add__, None, gp_XYZ)
gp_XYZ.__iadd_wrapper__ = new_instancemethod(_gp.gp_XYZ___iadd_wrapper__, None, gp_XYZ)
gp_XYZ.__sub__ = new_instancemethod(_gp.gp_XYZ___sub__, None, gp_XYZ)
gp_XYZ.__isub_wrapper__ = new_instancemethod(_gp.gp_XYZ___isub_wrapper__, None, gp_XYZ)
gp_XYZ.__itruediv_wrapper__ = new_instancemethod(_gp.gp_XYZ___itruediv_wrapper__, None, gp_XYZ)
gp_XYZ_swigregister = _gp.gp_XYZ_swigregister
gp_XYZ_swigregister(gp_XYZ)



