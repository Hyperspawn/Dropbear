# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
math module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_math.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _math.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_math')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_math')
    _math = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_math', [dirname(__file__)])
        except ImportError:
            import _math
            return _math
        try:
            _mod = imp.load_module('_math', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _math = swig_import_helper()
    del swig_import_helper
else:
    import _math
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _math.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_math.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_math.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_math.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_math.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_math.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_math.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_math.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_math.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_math.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_math.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_math.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_math.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_math.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_math.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_math.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_math.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _math.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure const &', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _math.process_exception(error, method_name, class_name)
process_exception = _math.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.gp
math_OK = _math.math_OK
math_TooManyIterations = _math.math_TooManyIterations
math_FunctionError = _math.math_FunctionError
math_DirectionSearchError = _math.math_DirectionSearchError
math_NotBracketed = _math.math_NotBracketed
class math_Array1OfValueAndWeight(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _math.math_Array1OfValueAndWeight_swiginit(self, _math.new_math_Array1OfValueAndWeight(*args))
    __swig_destroy__ = _math.delete_math_Array1OfValueAndWeight

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

math_Array1OfValueAndWeight.begin = new_instancemethod(_math.math_Array1OfValueAndWeight_begin, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.end = new_instancemethod(_math.math_Array1OfValueAndWeight_end, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.cbegin = new_instancemethod(_math.math_Array1OfValueAndWeight_cbegin, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.cend = new_instancemethod(_math.math_Array1OfValueAndWeight_cend, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Init = new_instancemethod(_math.math_Array1OfValueAndWeight_Init, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Size = new_instancemethod(_math.math_Array1OfValueAndWeight_Size, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Length = new_instancemethod(_math.math_Array1OfValueAndWeight_Length, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.IsEmpty = new_instancemethod(_math.math_Array1OfValueAndWeight_IsEmpty, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Lower = new_instancemethod(_math.math_Array1OfValueAndWeight_Lower, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Upper = new_instancemethod(_math.math_Array1OfValueAndWeight_Upper, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.IsDeletable = new_instancemethod(_math.math_Array1OfValueAndWeight_IsDeletable, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.IsAllocated = new_instancemethod(_math.math_Array1OfValueAndWeight_IsAllocated, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Assign = new_instancemethod(_math.math_Array1OfValueAndWeight_Assign, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Move = new_instancemethod(_math.math_Array1OfValueAndWeight_Move, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Set = new_instancemethod(_math.math_Array1OfValueAndWeight_Set, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.First = new_instancemethod(_math.math_Array1OfValueAndWeight_First, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.ChangeFirst = new_instancemethod(_math.math_Array1OfValueAndWeight_ChangeFirst, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Last = new_instancemethod(_math.math_Array1OfValueAndWeight_Last, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.ChangeLast = new_instancemethod(_math.math_Array1OfValueAndWeight_ChangeLast, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Value = new_instancemethod(_math.math_Array1OfValueAndWeight_Value, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.ChangeValue = new_instancemethod(_math.math_Array1OfValueAndWeight_ChangeValue, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.__call__ = new_instancemethod(_math.math_Array1OfValueAndWeight___call__, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.SetValue = new_instancemethod(_math.math_Array1OfValueAndWeight_SetValue, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight.Resize = new_instancemethod(_math.math_Array1OfValueAndWeight_Resize, None, math_Array1OfValueAndWeight)
math_Array1OfValueAndWeight_swigregister = _math.math_Array1OfValueAndWeight_swigregister
math_Array1OfValueAndWeight_swigregister(math_Array1OfValueAndWeight)

class math(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GaussPoints(*args) -> "void":
        """
        :param Index:
        	:type Index: int
        	:param Points:
        	:type Points: math_Vector
        	:rtype: void
        """
        return _math.math_GaussPoints(*args)

    GaussPoints = staticmethod(GaussPoints)

    def GaussPointsMax(*args) -> "Standard_Integer":
        """:rtype: int"""
        return _math.math_GaussPointsMax(*args)

    GaussPointsMax = staticmethod(GaussPointsMax)

    def GaussWeights(*args) -> "void":
        """
        :param Index:
        	:type Index: int
        	:param Weights:
        	:type Weights: math_Vector
        	:rtype: void
        """
        return _math.math_GaussWeights(*args)

    GaussWeights = staticmethod(GaussWeights)

    def KronrodPointsAndWeights(*args) -> "Standard_Boolean":
        """
        * Returns a vector of Kronrod points and a vector of their weights for Gauss-Kronrod computation method. Index should be odd and greater then or equal to 3, as the number of Kronrod points is equal to 2*N + 1, where N is a number of Gauss points. Points and Weights should have the size equal to Index. Each even element of Points represents a Gauss point value of N-th Gauss quadrature. The values from Index equal to 3 to 123 are stored in a table (see the file math_Kronrod.cxx). If Index is greater, then points and weights will be computed. Returns Standard_True if Index is odd, it is equal to the size of Points and Weights and the computation of Points and Weights is performed successfully. Otherwise this method returns Standard_False.
        	:param Index:
        	:type Index: int
        	:param Points:
        	:type Points: math_Vector
        	:param Weights:
        	:type Weights: math_Vector
        	:rtype: bool
        """
        return _math.math_KronrodPointsAndWeights(*args)

    KronrodPointsAndWeights = staticmethod(KronrodPointsAndWeights)

    def KronrodPointsMax(*args) -> "Standard_Integer":
        """
        * Returns the maximal number of points for that the values are stored in the table. If the number is greater then KronrodPointsMax, the points will be computed.
        	:rtype: int
        """
        return _math.math_KronrodPointsMax(*args)

    KronrodPointsMax = staticmethod(KronrodPointsMax)

    def OrderedGaussPointsAndWeights(*args) -> "Standard_Boolean":
        """
        * Returns a vector of Gauss points and a vector of their weights. The difference with the method GaussPoints is the following: - the points are returned in increasing order. - if Index is greater then GaussPointsMax, the points are computed. Returns Standard_True if Index is positive, Points' and Weights' length is equal to Index, Points and Weights are successfully computed.
        	:param Index:
        	:type Index: int
        	:param Points:
        	:type Points: math_Vector
        	:param Weights:
        	:type Weights: math_Vector
        	:rtype: bool
        """
        return _math.math_OrderedGaussPointsAndWeights(*args)

    OrderedGaussPointsAndWeights = staticmethod(OrderedGaussPointsAndWeights)

    __repr__ = _dumps_object


    def __init__(self):
        _math.math_swiginit(self, _math.new_math())
    __swig_destroy__ = _math.delete_math
math_swigregister = _math.math_swigregister
math_swigregister(math)

def math_GaussPoints(*args) -> "void":
    """
    :param Index:
    	:type Index: int
    	:param Points:
    	:type Points: math_Vector
    	:rtype: void
    """
    return _math.math_GaussPoints(*args)

def math_GaussPointsMax(*args) -> "Standard_Integer":
    """:rtype: int"""
    return _math.math_GaussPointsMax(*args)

def math_GaussWeights(*args) -> "void":
    """
    :param Index:
    	:type Index: int
    	:param Weights:
    	:type Weights: math_Vector
    	:rtype: void
    """
    return _math.math_GaussWeights(*args)

def math_KronrodPointsAndWeights(*args) -> "Standard_Boolean":
    """
    * Returns a vector of Kronrod points and a vector of their weights for Gauss-Kronrod computation method. Index should be odd and greater then or equal to 3, as the number of Kronrod points is equal to 2*N + 1, where N is a number of Gauss points. Points and Weights should have the size equal to Index. Each even element of Points represents a Gauss point value of N-th Gauss quadrature. The values from Index equal to 3 to 123 are stored in a table (see the file math_Kronrod.cxx). If Index is greater, then points and weights will be computed. Returns Standard_True if Index is odd, it is equal to the size of Points and Weights and the computation of Points and Weights is performed successfully. Otherwise this method returns Standard_False.
    	:param Index:
    	:type Index: int
    	:param Points:
    	:type Points: math_Vector
    	:param Weights:
    	:type Weights: math_Vector
    	:rtype: bool
    """
    return _math.math_KronrodPointsAndWeights(*args)

def math_KronrodPointsMax(*args) -> "Standard_Integer":
    """
    * Returns the maximal number of points for that the values are stored in the table. If the number is greater then KronrodPointsMax, the points will be computed.
    	:rtype: int
    """
    return _math.math_KronrodPointsMax(*args)

def math_OrderedGaussPointsAndWeights(*args) -> "Standard_Boolean":
    """
    * Returns a vector of Gauss points and a vector of their weights. The difference with the method GaussPoints is the following: - the points are returned in increasing order. - if Index is greater then GaussPointsMax, the points are computed. Returns Standard_True if Index is positive, Points' and Weights' length is equal to Index, Points and Weights are successfully computed.
    	:param Index:
    	:type Index: int
    	:param Points:
    	:type Points: math_Vector
    	:param Weights:
    	:type Weights: math_Vector
    	:rtype: bool
    """
    return _math.math_OrderedGaussPointsAndWeights(*args)

class math_BFGS(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_BFGS self) -> std::string"""
        return _math.math_BFGS_DumpToString(self)


    def Gradient(self, *args) -> "void":
        """
        * Returns the gradient vector at the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: math_Vector
        * Returns the value of the gradient vector at the minimum in Grad. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Grad is not equal to the range of the StartingPoint.
        	:param Grad:
        	:type Grad: math_Vector
        	:rtype: None
        """
        return _math.math_BFGS_Gradient(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_BFGS_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        * This method is called at the end of each iteration to check if the solution is found. It can be redefined in a sub-class to implement a specific test to stop the iterations.
        	:param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:rtype: bool
        """
        return _math.math_BFGS_IsSolutionReached(self, *args)


    def Location(self, *args) -> "void":
        """
        * returns the location vector of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: math_Vector
        * outputs the location vector of the minimum in Loc. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Loc is not equal to the range of the StartingPoint.
        	:param Loc:
        	:type Loc: math_Vector
        	:rtype: None
        """
        return _math.math_BFGS_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        * returns the value of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_BFGS_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * Returns the number of iterations really done in the calculation of the minimum. The exception NotDone is raised if the minimum was not found.
        	:rtype: int
        """
        return _math.math_BFGS_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Given the starting point StartingPoint, minimization is done on the function F. The solution F = Fi is found when : 2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1) + ZEPS). Tolerance, ZEPS and maximum number of iterations are given in the constructor.
        	:param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:rtype: None
        """
        return _math.math_BFGS_Perform(self, *args)


    def SetBoundary(self, *args) -> "void":
        """
        * Set boundaries for conditional optimization. The expected indices range of vectors is [1, NbVariables].
        	:param theLeftBorder:
        	:type theLeftBorder: math_Vector
        	:param theRightBorder:
        	:type theRightBorder: math_Vector
        	:rtype: None
        """
        return _math.math_BFGS_SetBoundary(self, *args)


    def __init__(self, *args):
        """
        * Initializes the computation of the minimum of a function with NbVariables. Tolerance, ZEPS and NbIterations are described in the method Perform. Warning: A call to the Perform method must be made after this initialization to effectively compute the minimum of the function F.
        	:param NbVariables:
        	:type NbVariables: int
        	:param Tolerance: default value is 1.0e-8
        	:type Tolerance: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:param ZEPS: default value is 1.0e-12
        	:type ZEPS: float
        	:rtype: None
        """
        _math.math_BFGS_swiginit(self, _math.new_math_BFGS(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BFGS
math_BFGS.DumpToString = new_instancemethod(_math.math_BFGS_DumpToString, None, math_BFGS)
math_BFGS.Gradient = new_instancemethod(_math.math_BFGS_Gradient, None, math_BFGS)
math_BFGS.IsDone = new_instancemethod(_math.math_BFGS_IsDone, None, math_BFGS)
math_BFGS.IsSolutionReached = new_instancemethod(_math.math_BFGS_IsSolutionReached, None, math_BFGS)
math_BFGS.Location = new_instancemethod(_math.math_BFGS_Location, None, math_BFGS)
math_BFGS.Minimum = new_instancemethod(_math.math_BFGS_Minimum, None, math_BFGS)
math_BFGS.NbIterations = new_instancemethod(_math.math_BFGS_NbIterations, None, math_BFGS)
math_BFGS.Perform = new_instancemethod(_math.math_BFGS_Perform, None, math_BFGS)
math_BFGS.SetBoundary = new_instancemethod(_math.math_BFGS_SetBoundary, None, math_BFGS)
math_BFGS_swigregister = _math.math_BFGS_swigregister
math_BFGS_swigregister(math_BFGS)

class math_BissecNewton(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Derivative(self, *args) -> "Standard_Real":
        """
        * returns the value of the derivative at the root. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_BissecNewton_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_BissecNewton self) -> std::string"""
        return _math.math_BissecNewton_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Tests is the root has been successfully found.
        	:rtype: bool
        """
        return _math.math_BissecNewton_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        * This method is called at the end of each iteration to check if the solution has been found. It can be redefined in a sub-class to implement a specific test to stop the iterations.
        	:param theFunction:
        	:type theFunction: math_FunctionWithDerivative
        	:rtype: bool
        """
        return _math.math_BissecNewton_IsSolutionReached(self, *args)


    def Perform(self, *args) -> "void":
        """
        * A combination of Newton-Raphson and bissection methods is done to find the root of the function F between the bounds Bound1 and Bound2 on the function F. The tolerance required on the root is given by TolX. The solution is found when: abs(Xi - Xi-1) <= TolX and F(Xi) * F(Xi-1) <= 0 The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Bound1:
        	:type Bound1: float
        	:param Bound2:
        	:type Bound2: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        """
        return _math.math_BissecNewton_Perform(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        * returns the value of the root. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_BissecNewton_Root(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * returns the value of the function at the root. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_BissecNewton_Value(self, *args)


    def __init__(self, *args):
        """
        * Constructor. @param theXTolerance - algorithm tolerance.
        	:param theXTolerance:
        	:type theXTolerance: float
        	:rtype: None
        """
        _math.math_BissecNewton_swiginit(self, _math.new_math_BissecNewton(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BissecNewton
math_BissecNewton.Derivative = new_instancemethod(_math.math_BissecNewton_Derivative, None, math_BissecNewton)
math_BissecNewton.DumpToString = new_instancemethod(_math.math_BissecNewton_DumpToString, None, math_BissecNewton)
math_BissecNewton.IsDone = new_instancemethod(_math.math_BissecNewton_IsDone, None, math_BissecNewton)
math_BissecNewton.IsSolutionReached = new_instancemethod(_math.math_BissecNewton_IsSolutionReached, None, math_BissecNewton)
math_BissecNewton.Perform = new_instancemethod(_math.math_BissecNewton_Perform, None, math_BissecNewton)
math_BissecNewton.Root = new_instancemethod(_math.math_BissecNewton_Root, None, math_BissecNewton)
math_BissecNewton.Value = new_instancemethod(_math.math_BissecNewton_Value, None, math_BissecNewton)
math_BissecNewton_swigregister = _math.math_BissecNewton_swigregister
math_BissecNewton_swigregister(math_BissecNewton)

class math_BracketMinimum(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_BracketMinimum self) -> std::string"""
        return _math.math_BracketMinimum_DumpToString(self)


    def FunctionValues(self, *args) -> "void":
        """
        * returns the bracketed triplet function values. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).
        	:param FA:
        	:type FA: float
        	:param FB:
        	:type FB: float
        	:param FC:
        	:type FC: float
        	:rtype: None
        """
        return _math.math_BracketMinimum_FunctionValues(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_BracketMinimum_IsDone(self, *args)


    def Perform(self, *args) -> "void":
        """
        * The method performing the job. It is called automatically by constructors with the function.
        	:param F:
        	:type F: math_Function
        	:rtype: None
        """
        return _math.math_BracketMinimum_Perform(self, *args)


    def SetFA(self, *args) -> "void":
        """
        * Set function value at A
        	:param theValue:
        	:type theValue: float
        	:rtype: None
        """
        return _math.math_BracketMinimum_SetFA(self, *args)


    def SetFB(self, *args) -> "void":
        """
        * Set function value at B
        	:param theValue:
        	:type theValue: float
        	:rtype: None
        """
        return _math.math_BracketMinimum_SetFB(self, *args)


    def SetLimits(self, *args) -> "void":
        """
        * Set limits of the parameter. By default no limits are applied to the parameter change. If no minimum is found in limits then IsDone() will return false. The user is in charge of providing A and B to be in limits.
        	:param theLeft:
        	:type theLeft: float
        	:param theRight:
        	:type theRight: float
        	:rtype: None
        """
        return _math.math_BracketMinimum_SetLimits(self, *args)


    def Values(self, *args) -> "void":
        """
        * Returns the bracketed triplet of abscissae. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:rtype: None
        """
        return _math.math_BracketMinimum_Values(self, *args)


    def __init__(self, *args):
        """
        * Constructor preparing A and B parameters only. It does not perform the job.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:rtype: None
        * Given two initial values this class computes a bracketing triplet of abscissae Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) the Brent minimization is done on the function F.
        	:param F:
        	:type F: math_Function
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:rtype: None
        * Given two initial values this class computes a bracketing triplet of abscissae Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) the Brent minimization is done on the function F. This constructor has to be used if F(A) is known.
        	:param F:
        	:type F: math_Function
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param FA:
        	:type FA: float
        	:rtype: None
        * Given two initial values this class computes a bracketing triplet of abscissae Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) the Brent minimization is done on the function F. This constructor has to be used if F(A) and F(B) are known.
        	:param F:
        	:type F: math_Function
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param FA:
        	:type FA: float
        	:param FB:
        	:type FB: float
        	:rtype: None
        """
        _math.math_BracketMinimum_swiginit(self, _math.new_math_BracketMinimum(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BracketMinimum
math_BracketMinimum.DumpToString = new_instancemethod(_math.math_BracketMinimum_DumpToString, None, math_BracketMinimum)
math_BracketMinimum.FunctionValues = new_instancemethod(_math.math_BracketMinimum_FunctionValues, None, math_BracketMinimum)
math_BracketMinimum.IsDone = new_instancemethod(_math.math_BracketMinimum_IsDone, None, math_BracketMinimum)
math_BracketMinimum.Perform = new_instancemethod(_math.math_BracketMinimum_Perform, None, math_BracketMinimum)
math_BracketMinimum.SetFA = new_instancemethod(_math.math_BracketMinimum_SetFA, None, math_BracketMinimum)
math_BracketMinimum.SetFB = new_instancemethod(_math.math_BracketMinimum_SetFB, None, math_BracketMinimum)
math_BracketMinimum.SetLimits = new_instancemethod(_math.math_BracketMinimum_SetLimits, None, math_BracketMinimum)
math_BracketMinimum.Values = new_instancemethod(_math.math_BracketMinimum_Values, None, math_BracketMinimum)
math_BracketMinimum_swigregister = _math.math_BracketMinimum_swigregister
math_BracketMinimum_swigregister(math_BracketMinimum)

class math_BracketedRoot(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_BracketedRoot self) -> std::string"""
        return _math.math_BracketedRoot_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_BracketedRoot_IsDone(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * returns the number of iterations really done during the computation of the Root. Exception NotDone is raised if the minimum was not found.
        	:rtype: int
        """
        return _math.math_BracketedRoot_NbIterations(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        * returns the value of the root. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_BracketedRoot_Root(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * returns the value of the function at the root. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_BracketedRoot_Value(self, *args)


    def __init__(self, *args):
        """
        * The Brent method is used to find the root of the function F between the bounds Bound1 and Bound2 on the function F. If F(Bound1)*F(Bound2) >0 the Brent method fails. The tolerance required for the root is given by Tolerance. The solution is found when : abs(Xi - Xi-1) <= Tolerance; The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_Function
        	:param Bound1:
        	:type Bound1: float
        	:param Bound2:
        	:type Bound2: float
        	:param Tolerance:
        	:type Tolerance: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:param ZEPS: default value is 1.0e-12
        	:type ZEPS: float
        	:rtype: None
        """
        _math.math_BracketedRoot_swiginit(self, _math.new_math_BracketedRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BracketedRoot
math_BracketedRoot.DumpToString = new_instancemethod(_math.math_BracketedRoot_DumpToString, None, math_BracketedRoot)
math_BracketedRoot.IsDone = new_instancemethod(_math.math_BracketedRoot_IsDone, None, math_BracketedRoot)
math_BracketedRoot.NbIterations = new_instancemethod(_math.math_BracketedRoot_NbIterations, None, math_BracketedRoot)
math_BracketedRoot.Root = new_instancemethod(_math.math_BracketedRoot_Root, None, math_BracketedRoot)
math_BracketedRoot.Value = new_instancemethod(_math.math_BracketedRoot_Value, None, math_BracketedRoot)
math_BracketedRoot_swigregister = _math.math_BracketedRoot_swigregister
math_BracketedRoot_swigregister(math_BracketedRoot)

class math_BrentMinimum(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_BrentMinimum self) -> std::string"""
        return _math.math_BrentMinimum_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_BrentMinimum_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        * This method is called at the end of each iteration to check if the solution is found. It can be redefined in a sub-class to implement a specific test to stop the iterations.
        	:param theFunction:
        	:type theFunction: math_Function
        	:rtype: bool
        """
        return _math.math_BrentMinimum_IsSolutionReached(self, *args)


    def Location(self, *args) -> "Standard_Real":
        """
        * returns the location value of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_BrentMinimum_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        * returns the value of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_BrentMinimum_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * returns the number of iterations really done during the computation of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: int
        """
        return _math.math_BrentMinimum_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Brent minimization is performed on function F from a given bracketing triplet of abscissas Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) The solution is found when: abs(Xi - Xi-1) <= TolX * abs(Xi) + ZEPS;
        	:param F:
        	:type F: math_Function
        	:param Ax:
        	:type Ax: float
        	:param Bx:
        	:type Bx: float
        	:param Cx:
        	:type Cx: float
        	:rtype: None
        """
        return _math.math_BrentMinimum_Perform(self, *args)


    def __init__(self, *args):
        """
        * This constructor should be used in a sub-class to initialize correctly all the fields of this class.
        	:param TolX:
        	:type TolX: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:param ZEPS: default value is 1.0e-12
        	:type ZEPS: float
        	:rtype: None
        * This constructor should be used in a sub-class to initialize correctly all the fields of this class. It has to be used if F(Bx) is known.
        	:param TolX:
        	:type TolX: float
        	:param Fbx:
        	:type Fbx: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:param ZEPS: default value is 1.0e-12
        	:type ZEPS: float
        	:rtype: None
        """
        _math.math_BrentMinimum_swiginit(self, _math.new_math_BrentMinimum(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BrentMinimum
math_BrentMinimum.DumpToString = new_instancemethod(_math.math_BrentMinimum_DumpToString, None, math_BrentMinimum)
math_BrentMinimum.IsDone = new_instancemethod(_math.math_BrentMinimum_IsDone, None, math_BrentMinimum)
math_BrentMinimum.IsSolutionReached = new_instancemethod(_math.math_BrentMinimum_IsSolutionReached, None, math_BrentMinimum)
math_BrentMinimum.Location = new_instancemethod(_math.math_BrentMinimum_Location, None, math_BrentMinimum)
math_BrentMinimum.Minimum = new_instancemethod(_math.math_BrentMinimum_Minimum, None, math_BrentMinimum)
math_BrentMinimum.NbIterations = new_instancemethod(_math.math_BrentMinimum_NbIterations, None, math_BrentMinimum)
math_BrentMinimum.Perform = new_instancemethod(_math.math_BrentMinimum_Perform, None, math_BrentMinimum)
math_BrentMinimum_swigregister = _math.math_BrentMinimum_swigregister
math_BrentMinimum_swigregister(math_BrentMinimum)

class math_BullardGenerator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NextInt(self, *args) -> "unsigned int":
        """
        * Generates new 64-bit integer value.
        	:rtype: unsigned int
        """
        return _math.math_BullardGenerator_NextInt(self, *args)


    def NextReal(self, *args) -> "Standard_Real":
        """
        * Generates new floating-point value.
        	:rtype: float
        """
        return _math.math_BullardGenerator_NextReal(self, *args)


    def SetSeed(self, *args) -> "void":
        """
        * Setup new seed / reset defaults.
        	:param theSeed: default value is 1
        	:type theSeed: unsigned int
        	:rtype: None
        """
        return _math.math_BullardGenerator_SetSeed(self, *args)


    def __init__(self, *args):
        """
        * Creates new Xorshift 64-bit RNG.
        	:param theSeed: default value is 1
        	:type theSeed: unsigned int
        	:rtype: None
        """
        _math.math_BullardGenerator_swiginit(self, _math.new_math_BullardGenerator(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BullardGenerator
math_BullardGenerator.NextInt = new_instancemethod(_math.math_BullardGenerator_NextInt, None, math_BullardGenerator)
math_BullardGenerator.NextReal = new_instancemethod(_math.math_BullardGenerator_NextReal, None, math_BullardGenerator)
math_BullardGenerator.SetSeed = new_instancemethod(_math.math_BullardGenerator_SetSeed, None, math_BullardGenerator)
math_BullardGenerator_swigregister = _math.math_BullardGenerator_swigregister
math_BullardGenerator_swigregister(math_BullardGenerator)

class math_ComputeGaussPointsAndWeights(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _math.math_ComputeGaussPointsAndWeights_IsDone(self, *args)


    def Points(self, *args) -> "math_Vector":
        """:rtype: math_Vector"""
        return _math.math_ComputeGaussPointsAndWeights_Points(self, *args)


    def Weights(self, *args) -> "math_Vector":
        """:rtype: math_Vector"""
        return _math.math_ComputeGaussPointsAndWeights_Weights(self, *args)


    def __init__(self, *args):
        """
        :param Number:
        	:type Number: int
        	:rtype: None
        """
        _math.math_ComputeGaussPointsAndWeights_swiginit(self, _math.new_math_ComputeGaussPointsAndWeights(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ComputeGaussPointsAndWeights
math_ComputeGaussPointsAndWeights.IsDone = new_instancemethod(_math.math_ComputeGaussPointsAndWeights_IsDone, None, math_ComputeGaussPointsAndWeights)
math_ComputeGaussPointsAndWeights.Points = new_instancemethod(_math.math_ComputeGaussPointsAndWeights_Points, None, math_ComputeGaussPointsAndWeights)
math_ComputeGaussPointsAndWeights.Weights = new_instancemethod(_math.math_ComputeGaussPointsAndWeights_Weights, None, math_ComputeGaussPointsAndWeights)
math_ComputeGaussPointsAndWeights_swigregister = _math.math_ComputeGaussPointsAndWeights_swigregister
math_ComputeGaussPointsAndWeights_swigregister(math_ComputeGaussPointsAndWeights)

class math_ComputeKronrodPointsAndWeights(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsDone(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _math.math_ComputeKronrodPointsAndWeights_IsDone(self, *args)


    def Points(self, *args) -> "math_Vector":
        """:rtype: math_Vector"""
        return _math.math_ComputeKronrodPointsAndWeights_Points(self, *args)


    def Weights(self, *args) -> "math_Vector":
        """:rtype: math_Vector"""
        return _math.math_ComputeKronrodPointsAndWeights_Weights(self, *args)


    def __init__(self, *args):
        """
        :param Number:
        	:type Number: int
        	:rtype: None
        """
        _math.math_ComputeKronrodPointsAndWeights_swiginit(self, _math.new_math_ComputeKronrodPointsAndWeights(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ComputeKronrodPointsAndWeights
math_ComputeKronrodPointsAndWeights.IsDone = new_instancemethod(_math.math_ComputeKronrodPointsAndWeights_IsDone, None, math_ComputeKronrodPointsAndWeights)
math_ComputeKronrodPointsAndWeights.Points = new_instancemethod(_math.math_ComputeKronrodPointsAndWeights_Points, None, math_ComputeKronrodPointsAndWeights)
math_ComputeKronrodPointsAndWeights.Weights = new_instancemethod(_math.math_ComputeKronrodPointsAndWeights_Weights, None, math_ComputeKronrodPointsAndWeights)
math_ComputeKronrodPointsAndWeights_swigregister = _math.math_ComputeKronrodPointsAndWeights_swigregister
math_ComputeKronrodPointsAndWeights_swigregister(math_ComputeKronrodPointsAndWeights)

class math_Crout(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Determinant(self, *args) -> "Standard_Real":
        """
        * Returns the value of the determinant of the previously LU decomposed matrix A. Zero is returned if the matrix A is considered as singular. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).
        	:rtype: float
        """
        return _math.math_Crout_Determinant(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Crout self) -> std::string"""
        return _math.math_Crout_DumpToString(self)


    def Inverse(self, *args) -> "math_Matrix const &":
        """
        * returns the inverse matrix of A. Only the inferior triangle is returned. Exception NotDone is raised if NotDone.
        	:rtype: math_Matrix
        """
        return _math.math_Crout_Inverse(self, *args)


    def Invert(self, *args) -> "void":
        """
        * returns in Inv the inverse matrix of A. Only the inferior triangle is returned. Exception NotDone is raised if NotDone.
        	:param Inv:
        	:type Inv: math_Matrix
        	:rtype: None
        """
        return _math.math_Crout_Invert(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if all has been correctly done.
        	:rtype: bool
        """
        return _math.math_Crout_IsDone(self, *args)


    def Solve(self, *args) -> "void":
        """
        * Given an input vector <B>, this routine returns the solution of the set of linear equations A . X = B. Exception NotDone is raised if the decomposition was not done successfully. Exception DimensionError is raised if the range of B is not equal to the rowrange of A.
        	:param B:
        	:type B: math_Vector
        	:param X:
        	:type X: math_Vector
        	:rtype: None
        """
        return _math.math_Crout_Solve(self, *args)


    def __init__(self, *args):
        """
        * Given an input matrix A, this algorithm inverts A by the Crout algorithm. The user can give only the inferior triangle for the implementation. A can be decomposed like this: A = L * D * T(L) where L is triangular inferior and D is diagonal. If one element of A is less than MinPivot, A is considered as singular. Exception NotSquare is raised if A is not a square matrix.
        	:param A:
        	:type A: math_Matrix
        	:param MinPivot: default value is 1.0e-20
        	:type MinPivot: float
        	:rtype: None
        """
        _math.math_Crout_swiginit(self, _math.new_math_Crout(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Crout
math_Crout.Determinant = new_instancemethod(_math.math_Crout_Determinant, None, math_Crout)
math_Crout.DumpToString = new_instancemethod(_math.math_Crout_DumpToString, None, math_Crout)
math_Crout.Inverse = new_instancemethod(_math.math_Crout_Inverse, None, math_Crout)
math_Crout.Invert = new_instancemethod(_math.math_Crout_Invert, None, math_Crout)
math_Crout.IsDone = new_instancemethod(_math.math_Crout_IsDone, None, math_Crout)
math_Crout.Solve = new_instancemethod(_math.math_Crout_Solve, None, math_Crout)
math_Crout_swigregister = _math.math_Crout_swigregister
math_Crout_swigregister(math_Crout)

class math_DirectPolynomialRoots(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_DirectPolynomialRoots self) -> std::string"""
        return _math.math_DirectPolynomialRoots_DumpToString(self)


    def InfiniteRoots(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is an infinity of roots, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_DirectPolynomialRoots_InfiniteRoots(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_DirectPolynomialRoots_IsDone(self, *args)


    def NbSolutions(self, *args) -> "Standard_Integer":
        """
        * returns the number of solutions. An exception is raised if there are an infinity of roots.
        	:rtype: int
        """
        return _math.math_DirectPolynomialRoots_NbSolutions(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * returns the value of the Nieme root. An exception is raised if there are an infinity of roots. Exception RangeError is raised if Nieme is < 1 or Nieme > NbSolutions.
        	:param Nieme:
        	:type Nieme: int
        	:rtype: float
        """
        return _math.math_DirectPolynomialRoots_Value(self, *args)


    def __init__(self, *args):
        """
        * computes all the real roots of the polynomial Ax4 + Bx3 + Cx2 + Dx + E using a direct method.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:rtype: None
        * computes all the real roots of the polynomial Ax3 + Bx2 + Cx + D using a direct method.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:rtype: None
        * computes all the real roots of the polynomial Ax2 + Bx + C using a direct method.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:rtype: None
        * computes the real root of the polynomial Ax + B.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:rtype: None
        """
        _math.math_DirectPolynomialRoots_swiginit(self, _math.new_math_DirectPolynomialRoots(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_DirectPolynomialRoots
math_DirectPolynomialRoots.DumpToString = new_instancemethod(_math.math_DirectPolynomialRoots_DumpToString, None, math_DirectPolynomialRoots)
math_DirectPolynomialRoots.InfiniteRoots = new_instancemethod(_math.math_DirectPolynomialRoots_InfiniteRoots, None, math_DirectPolynomialRoots)
math_DirectPolynomialRoots.IsDone = new_instancemethod(_math.math_DirectPolynomialRoots_IsDone, None, math_DirectPolynomialRoots)
math_DirectPolynomialRoots.NbSolutions = new_instancemethod(_math.math_DirectPolynomialRoots_NbSolutions, None, math_DirectPolynomialRoots)
math_DirectPolynomialRoots.Value = new_instancemethod(_math.math_DirectPolynomialRoots_Value, None, math_DirectPolynomialRoots)
math_DirectPolynomialRoots_swigregister = _math.math_DirectPolynomialRoots_swigregister
math_DirectPolynomialRoots_swigregister(math_DirectPolynomialRoots)

class math_DoubleTab(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Copy(self, *args) -> "void":
        """
        :param Other:
        	:type Other: math_DoubleTab
        	:rtype: None
        """
        return _math.math_DoubleTab_Copy(self, *args)


    def Free(self, *args) -> "void":
        """:rtype: None"""
        return _math.math_DoubleTab_Free(self, *args)


    def Init(self, *args) -> "void":
        """
        :param InitValue:
        	:type InitValue: float
        	:rtype: None
        """
        return _math.math_DoubleTab_Init(self, *args)


    def SetLowerCol(self, *args) -> "void":
        """
        :param LowerCol:
        	:type LowerCol: int
        	:rtype: None
        """
        return _math.math_DoubleTab_SetLowerCol(self, *args)


    def SetLowerRow(self, *args) -> "void":
        """
        :param LowerRow:
        	:type LowerRow: int
        	:rtype: None
        """
        return _math.math_DoubleTab_SetLowerRow(self, *args)


    def GetValue(self, RowIndex: 'Standard_Integer const', ColIndex: 'Standard_Integer const') -> "Standard_Real":
        """GetValue(math_DoubleTab self, Standard_Integer const RowIndex, Standard_Integer const ColIndex) -> Standard_Real"""
        return _math.math_DoubleTab_GetValue(self, RowIndex, ColIndex)


    def SetValue(self, RowIndex: 'Standard_Integer const', ColIndex: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetValue(math_DoubleTab self, Standard_Integer const RowIndex, Standard_Integer const ColIndex, Standard_Real value)"""
        return _math.math_DoubleTab_SetValue(self, RowIndex, ColIndex, value)


    def __init__(self, *args):
        """
        :param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:rtype: None
        :param Tab:
        	:type Tab: Standard_Address
        	:param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:rtype: None
        :param Other:
        	:type Other: math_DoubleTab
        	:rtype: None
        """
        _math.math_DoubleTab_swiginit(self, _math.new_math_DoubleTab(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_DoubleTab
math_DoubleTab.Copy = new_instancemethod(_math.math_DoubleTab_Copy, None, math_DoubleTab)
math_DoubleTab.Free = new_instancemethod(_math.math_DoubleTab_Free, None, math_DoubleTab)
math_DoubleTab.Init = new_instancemethod(_math.math_DoubleTab_Init, None, math_DoubleTab)
math_DoubleTab.SetLowerCol = new_instancemethod(_math.math_DoubleTab_SetLowerCol, None, math_DoubleTab)
math_DoubleTab.SetLowerRow = new_instancemethod(_math.math_DoubleTab_SetLowerRow, None, math_DoubleTab)
math_DoubleTab.GetValue = new_instancemethod(_math.math_DoubleTab_GetValue, None, math_DoubleTab)
math_DoubleTab.SetValue = new_instancemethod(_math.math_DoubleTab_SetValue, None, math_DoubleTab)
math_DoubleTab_swigregister = _math.math_DoubleTab_swigregister
math_DoubleTab_swigregister(math_DoubleTab)

class math_EigenValuesSearcher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dimension(self, *args) -> "Standard_Integer":
        """
        * Returns the dimension of matrix
        	:rtype: int
        """
        return _math.math_EigenValuesSearcher_Dimension(self, *args)


    def EigenValue(self, *args) -> "Standard_Real":
        """
        * Returns the Index_th eigen value of matrix Index must be in [1, Dimension()]
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _math.math_EigenValuesSearcher_EigenValue(self, *args)


    def EigenVector(self, *args) -> "math_Vector":
        """
        * Returns the Index_th eigen vector of matrix Index must be in [1, Dimension()]
        	:param Index:
        	:type Index: int
        	:rtype: math_Vector
        """
        return _math.math_EigenValuesSearcher_EigenVector(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if computation is performed successfully.
        	:rtype: bool
        """
        return _math.math_EigenValuesSearcher_IsDone(self, *args)


    def __init__(self, *args):
        """
        :param Diagonal:
        	:type Diagonal: TColStd_Array1OfReal
        	:param Subdiagonal:
        	:type Subdiagonal: TColStd_Array1OfReal
        	:rtype: None
        """
        _math.math_EigenValuesSearcher_swiginit(self, _math.new_math_EigenValuesSearcher(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_EigenValuesSearcher
math_EigenValuesSearcher.Dimension = new_instancemethod(_math.math_EigenValuesSearcher_Dimension, None, math_EigenValuesSearcher)
math_EigenValuesSearcher.EigenValue = new_instancemethod(_math.math_EigenValuesSearcher_EigenValue, None, math_EigenValuesSearcher)
math_EigenValuesSearcher.EigenVector = new_instancemethod(_math.math_EigenValuesSearcher_EigenVector, None, math_EigenValuesSearcher)
math_EigenValuesSearcher.IsDone = new_instancemethod(_math.math_EigenValuesSearcher_IsDone, None, math_EigenValuesSearcher)
math_EigenValuesSearcher_swigregister = _math.math_EigenValuesSearcher_swigregister
math_EigenValuesSearcher_swigregister(math_EigenValuesSearcher)

class math_FRPR(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_FRPR self) -> std::string"""
        return _math.math_FRPR_DumpToString(self)


    def Gradient(self, *args) -> "void":
        """
        * returns the gradient vector at the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: math_Vector
        * outputs the gradient vector at the minimum in Grad. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Grad is not equal to the range of the StartingPoint.
        	:param Grad:
        	:type Grad: math_Vector
        	:rtype: None
        """
        return _math.math_FRPR_Gradient(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_FRPR_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        * The solution F = Fi is found when: 2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1)) + ZEPS. The maximum number of iterations allowed is given by NbIterations.
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunctionWithGradient
        	:rtype: bool
        """
        return _math.math_FRPR_IsSolutionReached(self, *args)


    def Location(self, *args) -> "void":
        """
        * returns the location vector of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: math_Vector
        * outputs the location vector of the minimum in Loc. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Loc is not equal to the range of the StartingPoint.
        	:param Loc:
        	:type Loc: math_Vector
        	:rtype: None
        """
        return _math.math_FRPR_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        * returns the value of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_FRPR_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * returns the number of iterations really done during the computation of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: int
        """
        return _math.math_FRPR_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        * The solution F = Fi is found when 2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1) + ZEPS).
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunctionWithGradient
        	:param theStartingPoint:
        	:type theStartingPoint: math_Vector
        	:rtype: None
        """
        return _math.math_FRPR_Perform(self, *args)


    def __init__(self, *args):
        """
        * Initializes the computation of the minimum of F. Warning: constructor does not perform computations.
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunctionWithGradient
        	:param theTolerance:
        	:type theTolerance: float
        	:param theNbIterations: default value is 200
        	:type theNbIterations: int
        	:param theZEPS: default value is 1.0e-12
        	:type theZEPS: float
        	:rtype: None
        """
        _math.math_FRPR_swiginit(self, _math.new_math_FRPR(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FRPR
math_FRPR.DumpToString = new_instancemethod(_math.math_FRPR_DumpToString, None, math_FRPR)
math_FRPR.Gradient = new_instancemethod(_math.math_FRPR_Gradient, None, math_FRPR)
math_FRPR.IsDone = new_instancemethod(_math.math_FRPR_IsDone, None, math_FRPR)
math_FRPR.IsSolutionReached = new_instancemethod(_math.math_FRPR_IsSolutionReached, None, math_FRPR)
math_FRPR.Location = new_instancemethod(_math.math_FRPR_Location, None, math_FRPR)
math_FRPR.Minimum = new_instancemethod(_math.math_FRPR_Minimum, None, math_FRPR)
math_FRPR.NbIterations = new_instancemethod(_math.math_FRPR_NbIterations, None, math_FRPR)
math_FRPR.Perform = new_instancemethod(_math.math_FRPR_Perform, None, math_FRPR)
math_FRPR_swigregister = _math.math_FRPR_swigregister
math_FRPR_swigregister(math_FRPR)

class math_Function(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetStateNumber(self, *args) -> "Standard_Integer":
        """
        * returns the state of the function corresponding to the latest call of any methods associated with the function. This function is called by each of the algorithms described later which defined the function Integer Algorithm::StateNumber(). The algorithm has the responsibility to call this function when it has found a solution (i.e. a root or a minimum) and has to maintain the association between the solution found and this StateNumber. Byu default, this method returns 0 (which means for the algorithm: no state has been saved). It is the responsibility of the programmer to decide if he needs to save the current state of the function and to return an Integer that allows retrieval of the state.
        	:rtype: int
        """
        return _math.math_Function_GetStateNumber(self, *args)


    def Value(self, *args) -> "Standard_Boolean":
        """
        * Computes the value of the function <F> for a given value of variable <X>. returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: float
        	:param F:
        	:type F: float
        	:rtype: bool
        """
        return _math.math_Function_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Function
math_Function.GetStateNumber = new_instancemethod(_math.math_Function_GetStateNumber, None, math_Function)
math_Function.Value = new_instancemethod(_math.math_Function_Value, None, math_Function)
math_Function_swigregister = _math.math_Function_swigregister
math_Function_swigregister(math_Function)

class math_FunctionAllRoots(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_FunctionAllRoots self) -> std::string"""
        return _math.math_FunctionAllRoots_DumpToString(self)


    def GetInterval(self, *args) -> "void":
        """
        * Returns the interval of parameter of range Index. An exception is raised if IsDone returns False; An exception is raised if Index<=0 or Index >Nbintervals.
        	:param Index:
        	:type Index: int
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:rtype: None
        """
        return _math.math_FunctionAllRoots_GetInterval(self, *args)


    def GetIntervalState(self, *args) -> "void":
        """
        * returns the State Number associated to the interval Index. An exception is raised if IsDone returns False; An exception is raised if Index<=0 or Index >Nbintervals.
        	:param Index:
        	:type Index: int
        	:param IFirst:
        	:type IFirst: int
        	:param ILast:
        	:type ILast: int
        	:rtype: None
        """
        return _math.math_FunctionAllRoots_GetIntervalState(self, *args)


    def GetPoint(self, *args) -> "Standard_Real":
        """
        * Returns the parameter of the point of range Index. An exception is raised if IsDone returns False; An exception is raised if Index<=0 or Index >NbPoints.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _math.math_FunctionAllRoots_GetPoint(self, *args)


    def GetPointState(self, *args) -> "Standard_Integer":
        """
        * returns the State Number associated to the point Index. An exception is raised if IsDone returns False; An exception is raised if Index<=0 or Index >Nbintervals.
        	:param Index:
        	:type Index: int
        	:rtype: int
        """
        return _math.math_FunctionAllRoots_GetPointState(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns True if the computation has been done successfully.
        	:rtype: bool
        """
        return _math.math_FunctionAllRoots_IsDone(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """
        * Returns the number of intervals on which the function is Null. An exception is raised if IsDone returns False.
        	:rtype: int
        """
        return _math.math_FunctionAllRoots_NbIntervals(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * returns the number of points where the function is Null. An exception is raised if IsDone returns False.
        	:rtype: int
        """
        return _math.math_FunctionAllRoots_NbPoints(self, *args)


    def __init__(self, *args):
        """
        * The algorithm uses the sample to find intervals on which the function is null. An interval is found if, for at least two consecutive points of the sample, Ui and Ui+1, we get |F(Ui)|<=EpsNul and |F(Ui+1)|<=EpsNul. The real bounds of an interval are computed with the FunctionRoots. algorithm. Between two intervals, the roots of the function F are calculated using the FunctionRoots algorithm.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param S:
        	:type S: math_FunctionSample
        	:param EpsX:
        	:type EpsX: float
        	:param EpsF:
        	:type EpsF: float
        	:param EpsNul:
        	:type EpsNul: float
        	:rtype: None
        """
        _math.math_FunctionAllRoots_swiginit(self, _math.new_math_FunctionAllRoots(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionAllRoots
math_FunctionAllRoots.DumpToString = new_instancemethod(_math.math_FunctionAllRoots_DumpToString, None, math_FunctionAllRoots)
math_FunctionAllRoots.GetInterval = new_instancemethod(_math.math_FunctionAllRoots_GetInterval, None, math_FunctionAllRoots)
math_FunctionAllRoots.GetIntervalState = new_instancemethod(_math.math_FunctionAllRoots_GetIntervalState, None, math_FunctionAllRoots)
math_FunctionAllRoots.GetPoint = new_instancemethod(_math.math_FunctionAllRoots_GetPoint, None, math_FunctionAllRoots)
math_FunctionAllRoots.GetPointState = new_instancemethod(_math.math_FunctionAllRoots_GetPointState, None, math_FunctionAllRoots)
math_FunctionAllRoots.IsDone = new_instancemethod(_math.math_FunctionAllRoots_IsDone, None, math_FunctionAllRoots)
math_FunctionAllRoots.NbIntervals = new_instancemethod(_math.math_FunctionAllRoots_NbIntervals, None, math_FunctionAllRoots)
math_FunctionAllRoots.NbPoints = new_instancemethod(_math.math_FunctionAllRoots_NbPoints, None, math_FunctionAllRoots)
math_FunctionAllRoots_swigregister = _math.math_FunctionAllRoots_swigregister
math_FunctionAllRoots_swigregister(math_FunctionAllRoots)

class math_FunctionRoot(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Derivative(self, *args) -> "Standard_Real":
        """
        * returns the value of the derivative at the root. Exception NotDone is raised if the root was not found.
        	:rtype: float
        """
        return _math.math_FunctionRoot_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_FunctionRoot self) -> std::string"""
        return _math.math_FunctionRoot_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_FunctionRoot_IsDone(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * returns the number of iterations really done on the computation of the Root. Exception NotDone is raised if the root was not found.
        	:rtype: int
        """
        return _math.math_FunctionRoot_NbIterations(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        * returns the value of the root. Exception NotDone is raised if the root was not found.
        	:rtype: float
        """
        return _math.math_FunctionRoot_Root(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * returns the value of the function at the root. Exception NotDone is raised if the root was not found.
        	:rtype: float
        """
        return _math.math_FunctionRoot_Value(self, *args)


    def __init__(self, *args):
        """
        * The Newton-Raphson method is done to find the root of the function F from the initial guess Guess.The tolerance required on the root is given by Tolerance. Iterations are stopped if the expected solution does not stay in the range A..B. The solution is found when abs(Xi - Xi-1) <= Tolerance; The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Guess:
        	:type Guess: float
        	:param Tolerance:
        	:type Tolerance: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        * The Newton-Raphson method is done to find the root of the function F from the initial guess Guess. The tolerance required on the root is given by Tolerance. Iterations are stopped if the expected solution does not stay in the range A..B The solution is found when abs(Xi - Xi-1) <= Tolerance; The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Guess:
        	:type Guess: float
        	:param Tolerance:
        	:type Tolerance: float
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        """
        _math.math_FunctionRoot_swiginit(self, _math.new_math_FunctionRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionRoot
math_FunctionRoot.Derivative = new_instancemethod(_math.math_FunctionRoot_Derivative, None, math_FunctionRoot)
math_FunctionRoot.DumpToString = new_instancemethod(_math.math_FunctionRoot_DumpToString, None, math_FunctionRoot)
math_FunctionRoot.IsDone = new_instancemethod(_math.math_FunctionRoot_IsDone, None, math_FunctionRoot)
math_FunctionRoot.NbIterations = new_instancemethod(_math.math_FunctionRoot_NbIterations, None, math_FunctionRoot)
math_FunctionRoot.Root = new_instancemethod(_math.math_FunctionRoot_Root, None, math_FunctionRoot)
math_FunctionRoot.Value = new_instancemethod(_math.math_FunctionRoot_Value, None, math_FunctionRoot)
math_FunctionRoot_swigregister = _math.math_FunctionRoot_swigregister
math_FunctionRoot_swigregister(math_FunctionRoot)

class math_FunctionRoots(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_FunctionRoots self) -> std::string"""
        return _math.math_FunctionRoots_DumpToString(self)


    def IsAllNull(self, *args) -> "Standard_Boolean":
        """
        * returns true if the function is considered as null between A and B. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).
        	:rtype: bool
        """
        return _math.math_FunctionRoots_IsAllNull(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_FunctionRoots_IsDone(self, *args)


    def NbSolutions(self, *args) -> "Standard_Integer":
        """
        * Returns the number of solutions found. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).
        	:rtype: int
        """
        return _math.math_FunctionRoots_NbSolutions(self, *args)


    def StateNumber(self, *args) -> "Standard_Integer":
        """
        * returns the StateNumber of the Nieme root. Exception RangeError is raised if Nieme is < 1 or Nieme > NbSolutions.
        	:param Nieme:
        	:type Nieme: int
        	:rtype: int
        """
        return _math.math_FunctionRoots_StateNumber(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * Returns the Nth value of the root of function F. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).
        	:param Nieme:
        	:type Nieme: int
        	:rtype: float
        """
        return _math.math_FunctionRoots_Value(self, *args)


    def __init__(self, *args):
        """
        * Calculates all the real roots of a function F-K within the range A..B. whithout conditions on A and B A solution X is found when abs(Xi - Xi-1) <= Epsx and abs(F(Xi)-K) <= EpsF. The function is considered as null between A and B if abs(F-K) <= EpsNull within this range.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param NbSample:
        	:type NbSample: int
        	:param EpsX: default value is 0.0
        	:type EpsX: float
        	:param EpsF: default value is 0.0
        	:type EpsF: float
        	:param EpsNull: default value is 0.0
        	:type EpsNull: float
        	:param K: default value is 0.0
        	:type K: float
        	:rtype: None
        """
        _math.math_FunctionRoots_swiginit(self, _math.new_math_FunctionRoots(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionRoots
math_FunctionRoots.DumpToString = new_instancemethod(_math.math_FunctionRoots_DumpToString, None, math_FunctionRoots)
math_FunctionRoots.IsAllNull = new_instancemethod(_math.math_FunctionRoots_IsAllNull, None, math_FunctionRoots)
math_FunctionRoots.IsDone = new_instancemethod(_math.math_FunctionRoots_IsDone, None, math_FunctionRoots)
math_FunctionRoots.NbSolutions = new_instancemethod(_math.math_FunctionRoots_NbSolutions, None, math_FunctionRoots)
math_FunctionRoots.StateNumber = new_instancemethod(_math.math_FunctionRoots_StateNumber, None, math_FunctionRoots)
math_FunctionRoots.Value = new_instancemethod(_math.math_FunctionRoots_Value, None, math_FunctionRoots)
math_FunctionRoots_swigregister = _math.math_FunctionRoots_swigregister
math_FunctionRoots_swigregister(math_FunctionRoots)

class math_FunctionSample(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounds(self, *args) -> "void":
        """
        * Returns the bounds of parameters.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:rtype: void
        """
        return _math.math_FunctionSample_Bounds(self, *args)


    def GetParameter(self, *args) -> "Standard_Real":
        """
        * Returns the value of parameter of the point of range Index : A + ((Index-1)/(NbPoints-1))*B. An exception is raised if Index<=0 or Index>NbPoints.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _math.math_FunctionSample_GetParameter(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        * Returns the number of sample points.
        	:rtype: int
        """
        return _math.math_FunctionSample_NbPoints(self, *args)


    def __init__(self, *args):
        """
        :param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param N:
        	:type N: int
        	:rtype: None
        """
        _math.math_FunctionSample_swiginit(self, _math.new_math_FunctionSample(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSample
math_FunctionSample.Bounds = new_instancemethod(_math.math_FunctionSample_Bounds, None, math_FunctionSample)
math_FunctionSample.GetParameter = new_instancemethod(_math.math_FunctionSample_GetParameter, None, math_FunctionSample)
math_FunctionSample.NbPoints = new_instancemethod(_math.math_FunctionSample_NbPoints, None, math_FunctionSample)
math_FunctionSample_swigregister = _math.math_FunctionSample_swigregister
math_FunctionSample_swigregister(math_FunctionSample)

class math_FunctionSet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetStateNumber(self, *args) -> "Standard_Integer":
        """
        * Returns the state of the function corresponding to the latestcall of any methods associated with the function. This function is called by each of the algorithms described later which define the function Integer Algorithm::StateNumber(). The algorithm has the responsibility to call this function when it has found a solution (i.e. a root or a minimum) and has to maintain the association between the solution found and this StateNumber. Byu default, this method returns 0 (which means for the algorithm: no state has been saved). It is the responsibility of the programmer to decide if he needs to save the current state of the function and to return an Integer that allows retrieval of the state.
        	:rtype: int
        """
        return _math.math_FunctionSet_GetStateNumber(self, *args)


    def NbEquations(self, *args) -> "Standard_Integer":
        """
        * Returns the number of equations of the function.
        	:rtype: int
        """
        return _math.math_FunctionSet_NbEquations(self, *args)


    def NbVariables(self, *args) -> "Standard_Integer":
        """
        * Returns the number of variables of the function.
        	:rtype: int
        """
        return _math.math_FunctionSet_NbVariables(self, *args)


    def Value(self, *args) -> "Standard_Boolean":
        """
        * Computes the values <F> of the functions for the variable <X>. returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: math_Vector
        	:param F:
        	:type F: math_Vector
        	:rtype: bool
        """
        return _math.math_FunctionSet_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSet
math_FunctionSet.GetStateNumber = new_instancemethod(_math.math_FunctionSet_GetStateNumber, None, math_FunctionSet)
math_FunctionSet.NbEquations = new_instancemethod(_math.math_FunctionSet_NbEquations, None, math_FunctionSet)
math_FunctionSet.NbVariables = new_instancemethod(_math.math_FunctionSet_NbVariables, None, math_FunctionSet)
math_FunctionSet.Value = new_instancemethod(_math.math_FunctionSet_Value, None, math_FunctionSet)
math_FunctionSet_swigregister = _math.math_FunctionSet_swigregister
math_FunctionSet_swigregister(math_FunctionSet)

class math_FunctionSetRoot(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Derivative(self, *args) -> "void":
        """
        * Returns the matrix value of the derivative at the root. Exception NotDone is raised if the root was not found.
        	:rtype: math_Matrix
        * outputs the matrix value of the derivative at the root in Der. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the column range of <Der> is not equal to the range of the startingPoint.
        	:param Der:
        	:type Der: math_Matrix
        	:rtype: None
        """
        return _math.math_FunctionSetRoot_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_FunctionSetRoot self) -> std::string"""
        return _math.math_FunctionSetRoot_DumpToString(self)


    def FunctionSetErrors(self, *args) -> "void":
        """
        * returns the vector value of the error done on the functions at the root. Exception NotDone is raised if the root was not found.
        	:rtype: math_Vector
        * outputs the vector value of the error done on the functions at the root in Err. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Err is not equal to the range of the StartingPoint.
        	:param Err:
        	:type Err: math_Vector
        	:rtype: None
        """
        return _math.math_FunctionSetRoot_FunctionSetErrors(self, *args)


    def IsDivergent(self, *args) -> "Standard_Boolean":
        """:rtype: bool"""
        return _math.math_FunctionSetRoot_IsDivergent(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_FunctionSetRoot_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        * This routine is called at the end of each iteration to check if the solution was found. It can be redefined in a sub-class to implement a specific test to stop the iterations. In this case, the solution is found when: abs(Xi - Xi-1) <= Tolerance for all unknowns.
        	:param F:
        	:type F: math_FunctionSetWithDerivatives
        	:rtype: bool
        """
        return _math.math_FunctionSetRoot_IsSolutionReached(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * Returns the number of iterations really done during the computation of the root. Exception NotDone is raised if the root was not found.
        	:rtype: int
        """
        return _math.math_FunctionSetRoot_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Improves the root of function from the initial guess point. The infinum and supremum may be given to constrain the solution. In this case, the solution is found when: abs(Xi - Xi-1)(j) <= Tolerance(j) for all unknowns.
        	:param theFunction:
        	:type theFunction: math_FunctionSetWithDerivatives
        	:param theStartingPoint:
        	:type theStartingPoint: math_Vector
        	:param theStopOnDivergent: default value is Standard_False
        	:type theStopOnDivergent: bool
        	:rtype: None
        * Improves the root of function from the initial guess point. The infinum and supremum may be given to constrain the solution. In this case, the solution is found when: abs(Xi - Xi-1) <= Tolerance for all unknowns.
        	:param theFunction:
        	:type theFunction: math_FunctionSetWithDerivatives
        	:param theStartingPoint:
        	:type theStartingPoint: math_Vector
        	:param theInfBound:
        	:type theInfBound: math_Vector
        	:param theSupBound:
        	:type theSupBound: math_Vector
        	:param theStopOnDivergent: default value is Standard_False
        	:type theStopOnDivergent: bool
        	:rtype: None
        """
        return _math.math_FunctionSetRoot_Perform(self, *args)


    def Root(self, *args) -> "void":
        """
        * Returns the value of the root of function F. Exception NotDone is raised if the root was not found.
        	:rtype: math_Vector
        * Outputs the root vector in Root. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Root is not equal to the range of the StartingPoint.
        	:param Root:
        	:type Root: math_Vector
        	:rtype: None
        """
        return _math.math_FunctionSetRoot_Root(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Initializes the tolerance values.
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:rtype: None
        """
        return _math.math_FunctionSetRoot_SetTolerance(self, *args)


    def StateNumber(self, *args) -> "Standard_Integer":
        """
        * returns the stateNumber (as returned by F.GetStateNumber()) associated to the root found.
        	:rtype: int
        """
        return _math.math_FunctionSetRoot_StateNumber(self, *args)


    def __init__(self, *args):
        """
        * is used in a sub-class to initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations.
        	:param F:
        	:type F: math_FunctionSetWithDerivatives
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        * is used in a sub-class to initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations. The method SetTolerance must be called after this constructor.
        	:param F:
        	:type F: math_FunctionSetWithDerivatives
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        """
        _math.math_FunctionSetRoot_swiginit(self, _math.new_math_FunctionSetRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSetRoot
math_FunctionSetRoot.Derivative = new_instancemethod(_math.math_FunctionSetRoot_Derivative, None, math_FunctionSetRoot)
math_FunctionSetRoot.DumpToString = new_instancemethod(_math.math_FunctionSetRoot_DumpToString, None, math_FunctionSetRoot)
math_FunctionSetRoot.FunctionSetErrors = new_instancemethod(_math.math_FunctionSetRoot_FunctionSetErrors, None, math_FunctionSetRoot)
math_FunctionSetRoot.IsDivergent = new_instancemethod(_math.math_FunctionSetRoot_IsDivergent, None, math_FunctionSetRoot)
math_FunctionSetRoot.IsDone = new_instancemethod(_math.math_FunctionSetRoot_IsDone, None, math_FunctionSetRoot)
math_FunctionSetRoot.IsSolutionReached = new_instancemethod(_math.math_FunctionSetRoot_IsSolutionReached, None, math_FunctionSetRoot)
math_FunctionSetRoot.NbIterations = new_instancemethod(_math.math_FunctionSetRoot_NbIterations, None, math_FunctionSetRoot)
math_FunctionSetRoot.Perform = new_instancemethod(_math.math_FunctionSetRoot_Perform, None, math_FunctionSetRoot)
math_FunctionSetRoot.Root = new_instancemethod(_math.math_FunctionSetRoot_Root, None, math_FunctionSetRoot)
math_FunctionSetRoot.SetTolerance = new_instancemethod(_math.math_FunctionSetRoot_SetTolerance, None, math_FunctionSetRoot)
math_FunctionSetRoot.StateNumber = new_instancemethod(_math.math_FunctionSetRoot_StateNumber, None, math_FunctionSetRoot)
math_FunctionSetRoot_swigregister = _math.math_FunctionSetRoot_swigregister
math_FunctionSetRoot_swigregister(math_FunctionSetRoot)

class math_Gauss(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Determinant(self, *args) -> "Standard_Real":
        """
        * This routine returns the value of the determinant of the previously LU decomposed matrix A. Exception NotDone may be raised if the decomposition of A was not done successfully, zero is returned if the matrix A was considered as singular.
        	:rtype: float
        """
        return _math.math_Gauss_Determinant(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Gauss self) -> std::string"""
        return _math.math_Gauss_DumpToString(self)


    def Invert(self, *args) -> "void":
        """
        * This routine outputs Inv the inverse of the previously LU decomposed matrix A. Exception DimensionError is raised if the ranges of B are not equal to the ranges of A.
        	:param Inv:
        	:type Inv: math_Matrix
        	:rtype: None
        """
        return _math.math_Gauss_Invert(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false
        	:rtype: bool
        """
        return _math.math_Gauss_IsDone(self, *args)


    def Solve(self, *args) -> "void":
        """
        * Given the input Vector B this routine returns the solution X of the set of linear equations A . X = B. Exception NotDone is raised if the decomposition of A was not done successfully. Exception DimensionError is raised if the range of B is not equal to the number of rows of A.
        	:param B:
        	:type B: math_Vector
        	:param X:
        	:type X: math_Vector
        	:rtype: None
        * Given the input Vector B this routine solves the set of linear equations A . X = B. B is replaced by the vector solution X. Exception NotDone is raised if the decomposition of A was not done successfully. Exception DimensionError is raised if the range of B is not equal to the number of rows of A.
        	:param B:
        	:type B: math_Vector
        	:rtype: None
        """
        return _math.math_Gauss_Solve(self, *args)


    def __init__(self, *args):
        """
        * Given an input n X n matrix A this constructor performs its LU decomposition with partial pivoting (interchange of rows). This LU decomposition is stored internally and may be used to do subsequent calculation. If the largest pivot found is less than MinPivot the matrix A is considered as singular. Exception NotSquare is raised if A is not a square matrix.
        	:param A:
        	:type A: math_Matrix
        	:param MinPivot: default value is 1.0e-20
        	:type MinPivot: float
        	:param aProgress: default value is opencascade::handle<Message_ProgressIndicator>()
        	:type aProgress: Message_ProgressIndicator
        	:rtype: None
        """
        _math.math_Gauss_swiginit(self, _math.new_math_Gauss(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Gauss
math_Gauss.Determinant = new_instancemethod(_math.math_Gauss_Determinant, None, math_Gauss)
math_Gauss.DumpToString = new_instancemethod(_math.math_Gauss_DumpToString, None, math_Gauss)
math_Gauss.Invert = new_instancemethod(_math.math_Gauss_Invert, None, math_Gauss)
math_Gauss.IsDone = new_instancemethod(_math.math_Gauss_IsDone, None, math_Gauss)
math_Gauss.Solve = new_instancemethod(_math.math_Gauss_Solve, None, math_Gauss)
math_Gauss_swigregister = _math.math_Gauss_swigregister
math_Gauss_swigregister(math_Gauss)

class math_GaussLeastSquare(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_GaussLeastSquare self) -> std::string"""
        return _math.math_GaussLeastSquare_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.e
        	:rtype: bool
        """
        return _math.math_GaussLeastSquare_IsDone(self, *args)


    def Solve(self, *args) -> "void":
        """
        * Given the input Vector <B> this routine solves the set of linear equations A . X = B. Exception NotDone is raised if the decomposition of A was not done successfully. Exception DimensionError is raised if the range of B Inv is not equal to the rowrange of A. Exception DimensionError is raised if the range of X Inv is not equal to the colrange of A.
        	:param B:
        	:type B: math_Vector
        	:param X:
        	:type X: math_Vector
        	:rtype: None
        """
        return _math.math_GaussLeastSquare_Solve(self, *args)


    def __init__(self, *args):
        """
        * Given an input n X m matrix A with n >= m this constructor performs the LU decomposition with partial pivoting (interchange of rows) of the matrix AA = A.Transposed() * A; This LU decomposition is stored internally and may be used to do subsequent calculation. If the largest pivot found is less than MinPivot the matrix <A> is considered as singular.
        	:param A:
        	:type A: math_Matrix
        	:param MinPivot: default value is 1.0e-20
        	:type MinPivot: float
        	:rtype: None
        """
        _math.math_GaussLeastSquare_swiginit(self, _math.new_math_GaussLeastSquare(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussLeastSquare
math_GaussLeastSquare.DumpToString = new_instancemethod(_math.math_GaussLeastSquare_DumpToString, None, math_GaussLeastSquare)
math_GaussLeastSquare.IsDone = new_instancemethod(_math.math_GaussLeastSquare_IsDone, None, math_GaussLeastSquare)
math_GaussLeastSquare.Solve = new_instancemethod(_math.math_GaussLeastSquare_Solve, None, math_GaussLeastSquare)
math_GaussLeastSquare_swigregister = _math.math_GaussLeastSquare_swigregister
math_GaussLeastSquare_swigregister(math_GaussLeastSquare)

class math_GaussMultipleIntegration(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_GaussMultipleIntegration self) -> std::string"""
        return _math.math_GaussMultipleIntegration_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _math.math_GaussMultipleIntegration_IsDone(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * returns the value of the integral.
        	:rtype: float
        """
        return _math.math_GaussMultipleIntegration_Value(self, *args)


    def __init__(self, *args):
        """
        * The Gauss-Legendre integration with Order = points of integration for each unknow, is done on the function F between the bounds Lower and Upper.
        	:param F:
        	:type F: math_MultipleVarFunction
        	:param Lower:
        	:type Lower: math_Vector
        	:param Upper:
        	:type Upper: math_Vector
        	:param Order:
        	:type Order: math_IntegerVector
        	:rtype: None
        """
        _math.math_GaussMultipleIntegration_swiginit(self, _math.new_math_GaussMultipleIntegration(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussMultipleIntegration
math_GaussMultipleIntegration.DumpToString = new_instancemethod(_math.math_GaussMultipleIntegration_DumpToString, None, math_GaussMultipleIntegration)
math_GaussMultipleIntegration.IsDone = new_instancemethod(_math.math_GaussMultipleIntegration_IsDone, None, math_GaussMultipleIntegration)
math_GaussMultipleIntegration.Value = new_instancemethod(_math.math_GaussMultipleIntegration_Value, None, math_GaussMultipleIntegration)
math_GaussMultipleIntegration_swigregister = _math.math_GaussMultipleIntegration_swigregister
math_GaussMultipleIntegration_swigregister(math_GaussMultipleIntegration)

class math_GaussSetIntegration(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_GaussSetIntegration self) -> std::string"""
        return _math.math_GaussSetIntegration_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _math.math_GaussSetIntegration_IsDone(self, *args)


    def Value(self, *args) -> "math_Vector const &":
        """
        * returns the value of the integral.
        	:rtype: math_Vector
        """
        return _math.math_GaussSetIntegration_Value(self, *args)


    def __init__(self, *args):
        """
        * The Gauss-Legendre integration with Order = points of integration for each unknow, is done on the function F between the bounds Lower and Upper.
        	:param F:
        	:type F: math_FunctionSet
        	:param Lower:
        	:type Lower: math_Vector
        	:param Upper:
        	:type Upper: math_Vector
        	:param Order:
        	:type Order: math_IntegerVector
        	:rtype: None
        """
        _math.math_GaussSetIntegration_swiginit(self, _math.new_math_GaussSetIntegration(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussSetIntegration
math_GaussSetIntegration.DumpToString = new_instancemethod(_math.math_GaussSetIntegration_DumpToString, None, math_GaussSetIntegration)
math_GaussSetIntegration.IsDone = new_instancemethod(_math.math_GaussSetIntegration_IsDone, None, math_GaussSetIntegration)
math_GaussSetIntegration.Value = new_instancemethod(_math.math_GaussSetIntegration_Value, None, math_GaussSetIntegration)
math_GaussSetIntegration_swigregister = _math.math_GaussSetIntegration_swigregister
math_GaussSetIntegration_swigregister(math_GaussSetIntegration)

class math_GaussSingleIntegration(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_GaussSingleIntegration self) -> std::string"""
        return _math.math_GaussSingleIntegration_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * returns True if all has been correctly done.
        	:rtype: bool
        """
        return _math.math_GaussSingleIntegration_IsDone(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * returns the value of the integral.
        	:rtype: float
        """
        return _math.math_GaussSingleIntegration_Value(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        * The Gauss-Legendre integration with N = Order points of integration, is done on the function F between the bounds Lower and Upper.
        	:param F:
        	:type F: math_Function
        	:param Lower:
        	:type Lower: float
        	:param Upper:
        	:type Upper: float
        	:param Order:
        	:type Order: int
        	:rtype: None
        * The Gauss-Legendre integration with N = Order points of integration and given tolerance = Tol is done on the function F between the bounds Lower and Upper.
        	:param F:
        	:type F: math_Function
        	:param Lower:
        	:type Lower: float
        	:param Upper:
        	:type Upper: float
        	:param Order:
        	:type Order: int
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _math.math_GaussSingleIntegration_swiginit(self, _math.new_math_GaussSingleIntegration(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussSingleIntegration
math_GaussSingleIntegration.DumpToString = new_instancemethod(_math.math_GaussSingleIntegration_DumpToString, None, math_GaussSingleIntegration)
math_GaussSingleIntegration.IsDone = new_instancemethod(_math.math_GaussSingleIntegration_IsDone, None, math_GaussSingleIntegration)
math_GaussSingleIntegration.Value = new_instancemethod(_math.math_GaussSingleIntegration_Value, None, math_GaussSingleIntegration)
math_GaussSingleIntegration_swigregister = _math.math_GaussSingleIntegration_swigregister
math_GaussSingleIntegration_swigregister(math_GaussSingleIntegration)

class math_GlobOptMin(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetContinuity(self, *args) -> "Standard_Integer":
        """:rtype: inline int"""
        return _math.math_GlobOptMin_GetContinuity(self, *args)


    def GetF(self, *args) -> "Standard_Real":
        """
        * Get best functional value.
        	:rtype: inline float
        """
        return _math.math_GlobOptMin_GetF(self, *args)


    def GetFunctionalMinimalValue(self, *args) -> "Standard_Real":
        """:rtype: inline float"""
        return _math.math_GlobOptMin_GetFunctionalMinimalValue(self, *args)


    def GetLipConstState(self, *args) -> "Standard_Boolean":
        """:rtype: inline bool"""
        return _math.math_GlobOptMin_GetLipConstState(self, *args)


    def GetTol(self, *args) -> "void":
        """
        * Method to get tolerances. @param theDiscretizationTol - parameter space discretization tolerance. @param theSameTol - functional value space indifference tolerance.
        	:param theDiscretizationTol:
        	:type theDiscretizationTol: float
        	:param theSameTol:
        	:type theSameTol: float
        	:rtype: None
        """
        return _math.math_GlobOptMin_GetTol(self, *args)


    def NbExtrema(self, *args) -> "Standard_Integer":
        """
        * Return count of global extremas.
        	:rtype: inline int
        """
        return _math.math_GlobOptMin_NbExtrema(self, *args)


    def Perform(self, *args) -> "void":
        """
        * @param isFindSingleSolution - defines whether to find single solution or all solutions.
        	:param isFindSingleSolution: default value is Standard_False
        	:type isFindSingleSolution: bool
        	:rtype: None
        """
        return _math.math_GlobOptMin_Perform(self, *args)


    def Points(self, *args) -> "void":
        """
        * Return solution theIndex, 1 <= theIndex <= NbExtrema.
        	:param theIndex:
        	:type theIndex: int
        	:param theSol:
        	:type theSol: math_Vector
        	:rtype: None
        """
        return _math.math_GlobOptMin_Points(self, *args)


    def SetContinuity(self, *args) -> "void":
        """
        * Set / Get continuity of local borders splits (0 ~ C0, 1 ~ C1, 2 ~ C2).
        	:param theCont:
        	:type theCont: int
        	:rtype: inline void
        """
        return _math.math_GlobOptMin_SetContinuity(self, *args)


    def SetFunctionalMinimalValue(self, *args) -> "void":
        """
        * Set / Get functional minimal value.
        	:param theMinimalValue:
        	:type theMinimalValue: float
        	:rtype: inline void
        """
        return _math.math_GlobOptMin_SetFunctionalMinimalValue(self, *args)


    def SetGlobalParams(self, *args) -> "void":
        """
        * @param theFunc - objective functional. @param theLowerBorder - lower corner of the search box. @param theUpperBorder - upper corner of the search box. @param theC - Lipschitz constant. @param theDiscretizationTol - parameter space discretization tolerance. @param theSameTol - functional value space indifference tolerance.
        	:param theFunc:
        	:type theFunc: math_MultipleVarFunction *
        	:param theLowerBorder:
        	:type theLowerBorder: math_Vector
        	:param theUpperBorder:
        	:type theUpperBorder: math_Vector
        	:param theC: default value is 9
        	:type theC: float
        	:param theDiscretizationTol: default value is 1.0e-2
        	:type theDiscretizationTol: float
        	:param theSameTol: default value is 1.0e-7
        	:type theSameTol: float
        	:rtype: None
        """
        return _math.math_GlobOptMin_SetGlobalParams(self, *args)


    def SetLipConstState(self, *args) -> "void":
        """
        * Set / Get Lipchitz constant modification state. True means that the constant is locked and unlocked otherwise.
        	:param theFlag:
        	:type theFlag: bool
        	:rtype: inline void
        """
        return _math.math_GlobOptMin_SetLipConstState(self, *args)


    def SetLocalParams(self, *args) -> "void":
        """
        * Method to reduce bounding box. Perform will use this box. @param theLocalA - lower corner of the local box. @param theLocalB - upper corner of the local box.
        	:param theLocalA:
        	:type theLocalA: math_Vector
        	:param theLocalB:
        	:type theLocalB: math_Vector
        	:rtype: None
        """
        return _math.math_GlobOptMin_SetLocalParams(self, *args)


    def SetTol(self, *args) -> "void":
        """
        * Method to set tolerances. @param theDiscretizationTol - parameter space discretization tolerance. @param theSameTol - functional value space indifference tolerance.
        	:param theDiscretizationTol:
        	:type theDiscretizationTol: float
        	:param theSameTol:
        	:type theSameTol: float
        	:rtype: None
        """
        return _math.math_GlobOptMin_SetTol(self, *args)


    def __init__(self, *args):
        """
        * Constructor. Perform method is not called from it. @param theFunc - objective functional. @param theLowerBorder - lower corner of the search box. @param theUpperBorder - upper corner of the search box. @param theC - Lipschitz constant. @param theDiscretizationTol - parameter space discretization tolerance. @param theSameTol - functional value space indifference tolerance.
        	:param theFunc:
        	:type theFunc: math_MultipleVarFunction *
        	:param theLowerBorder:
        	:type theLowerBorder: math_Vector
        	:param theUpperBorder:
        	:type theUpperBorder: math_Vector
        	:param theC: default value is 9
        	:type theC: float
        	:param theDiscretizationTol: default value is 1.0e-2
        	:type theDiscretizationTol: float
        	:param theSameTol: default value is 1.0e-7
        	:type theSameTol: float
        	:rtype: None
        """
        _math.math_GlobOptMin_swiginit(self, _math.new_math_GlobOptMin(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GlobOptMin
math_GlobOptMin.GetContinuity = new_instancemethod(_math.math_GlobOptMin_GetContinuity, None, math_GlobOptMin)
math_GlobOptMin.GetF = new_instancemethod(_math.math_GlobOptMin_GetF, None, math_GlobOptMin)
math_GlobOptMin.GetFunctionalMinimalValue = new_instancemethod(_math.math_GlobOptMin_GetFunctionalMinimalValue, None, math_GlobOptMin)
math_GlobOptMin.GetLipConstState = new_instancemethod(_math.math_GlobOptMin_GetLipConstState, None, math_GlobOptMin)
math_GlobOptMin.GetTol = new_instancemethod(_math.math_GlobOptMin_GetTol, None, math_GlobOptMin)
math_GlobOptMin.NbExtrema = new_instancemethod(_math.math_GlobOptMin_NbExtrema, None, math_GlobOptMin)
math_GlobOptMin.Perform = new_instancemethod(_math.math_GlobOptMin_Perform, None, math_GlobOptMin)
math_GlobOptMin.Points = new_instancemethod(_math.math_GlobOptMin_Points, None, math_GlobOptMin)
math_GlobOptMin.SetContinuity = new_instancemethod(_math.math_GlobOptMin_SetContinuity, None, math_GlobOptMin)
math_GlobOptMin.SetFunctionalMinimalValue = new_instancemethod(_math.math_GlobOptMin_SetFunctionalMinimalValue, None, math_GlobOptMin)
math_GlobOptMin.SetGlobalParams = new_instancemethod(_math.math_GlobOptMin_SetGlobalParams, None, math_GlobOptMin)
math_GlobOptMin.SetLipConstState = new_instancemethod(_math.math_GlobOptMin_SetLipConstState, None, math_GlobOptMin)
math_GlobOptMin.SetLocalParams = new_instancemethod(_math.math_GlobOptMin_SetLocalParams, None, math_GlobOptMin)
math_GlobOptMin.SetTol = new_instancemethod(_math.math_GlobOptMin_SetTol, None, math_GlobOptMin)
math_GlobOptMin_swigregister = _math.math_GlobOptMin_swigregister
math_GlobOptMin_swigregister(math_GlobOptMin)

class math_Householder(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AllValues(self, *args) -> "math_Matrix const &":
        """
        * Returns the matrix sol of all the solutions of the system A.X = B. Exception NotDone is raised is the resolution has not be done.
        	:rtype: math_Matrix
        """
        return _math.math_Householder_AllValues(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Householder self) -> std::string"""
        return _math.math_Householder_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_Householder_IsDone(self, *args)


    def Value(self, *args) -> "void":
        """
        * Given the integer Index, this routine returns the corresponding least square solution sol. Exception NotDone is raised if the resolution has not be done. Exception OutOfRange is raised if Index <=0 or Index is more than the number of columns of B.
        	:param sol:
        	:type sol: math_Vector
        	:param Index: default value is 1
        	:type Index: int
        	:rtype: None
        """
        return _math.math_Householder_Value(self, *args)


    def __init__(self, *args):
        """
        * Given an input matrix A with n>= m, given an input matrix B this constructor performs the least square resolution of the set of linear equations A.X = B for each column of B. If a column norm is less than EPS, the resolution can't be done. Exception DimensionError is raised if the row number of B is different from the A row number.
        	:param A:
        	:type A: math_Matrix
        	:param B:
        	:type B: math_Matrix
        	:param EPS: default value is 1.0e-20
        	:type EPS: float
        	:rtype: None
        * Given an input matrix A with n>= m, given an input matrix B this constructor performs the least square resolution of the set of linear equations A.X = B for each column of B. If a column norm is less than EPS, the resolution can't be done. Exception DimensionError is raised if the row number of B is different from the A row number.
        	:param A:
        	:type A: math_Matrix
        	:param B:
        	:type B: math_Matrix
        	:param lowerArow:
        	:type lowerArow: int
        	:param upperArow:
        	:type upperArow: int
        	:param lowerAcol:
        	:type lowerAcol: int
        	:param upperAcol:
        	:type upperAcol: int
        	:param EPS: default value is 1.0e-20
        	:type EPS: float
        	:rtype: None
        * Given an input matrix A with n>= m, given an input vector B this constructor performs the least square resolution of the set of linear equations A.X = B. If a column norm is less than EPS, the resolution can't be done. Exception DimensionError is raised if the length of B is different from the A row number.
        	:param A:
        	:type A: math_Matrix
        	:param B:
        	:type B: math_Vector
        	:param EPS: default value is 1.0e-20
        	:type EPS: float
        	:rtype: None
        """
        _math.math_Householder_swiginit(self, _math.new_math_Householder(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Householder
math_Householder.AllValues = new_instancemethod(_math.math_Householder_AllValues, None, math_Householder)
math_Householder.DumpToString = new_instancemethod(_math.math_Householder_DumpToString, None, math_Householder)
math_Householder.IsDone = new_instancemethod(_math.math_Householder_IsDone, None, math_Householder)
math_Householder.Value = new_instancemethod(_math.math_Householder_Value, None, math_Householder)
math_Householder_swigregister = _math.math_Householder_swigregister
math_Householder_swigregister(math_Householder)

class math_IntegerVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * adds the IntegerVector 'theRight' to an IntegerVector. An exception is raised if the IntegerVectors have not the same length. An exception is raised if the lengths are not equal.
        	:param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: None
        * sets an IntegerVector to the sum of the IntegerVector 'theLeft' and the IntegerVector 'theRight'. An exception is raised if the lengths are different.
        	:param theLeft:
        	:type theLeft: math_IntegerVector
        	:param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: None
        """
        return _math.math_IntegerVector_Add(self, *args)


    def Added(self, *args) -> "math_IntegerVector":
        """
        * adds the IntegerVector 'theRight' to an IntegerVector. An exception is raised if the IntegerVectors have not the same length. An exception is raised if the lengths are not equal.
        	:param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector_Added(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_IntegerVector self) -> std::string"""
        return _math.math_IntegerVector_DumpToString(self)


    def Init(self, *args) -> "void":
        """
        * Initialize an IntegerVector with all the elements set to theInitialValue.
        	:param theInitialValue:
        	:type theInitialValue: int
        	:rtype: None
        """
        return _math.math_IntegerVector_Init(self, *args)


    def Initialized(self, *args) -> "math_IntegerVector &":
        """
        * Initialises an IntegerVector by copying 'theOther'. An exception is raised if the Lengths are different.
        	:param theOther:
        	:type theOther: math_IntegerVector
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector_Initialized(self, *args)


    def Inverse(self, *args) -> "math_IntegerVector":
        """
        * returns the inverse IntegerVector of an IntegerVector.
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector_Inverse(self, *args)


    def Invert(self, *args) -> "void":
        """
        * inverses an IntegerVector.
        	:rtype: None
        """
        return _math.math_IntegerVector_Invert(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        * returns the length of an IntegerVector
        	:rtype: inline int
        """
        return _math.math_IntegerVector_Length(self, *args)


    def Lower(self, *args) -> "Standard_Integer":
        """
        * returns the value of the Lower index of an IntegerVector.
        	:rtype: inline int
        """
        return _math.math_IntegerVector_Lower(self, *args)


    def Max(self, *args) -> "Standard_Integer":
        """
        * returns the value of the Index of the maximum element of an IntegerVector.
        	:rtype: int
        """
        return _math.math_IntegerVector_Max(self, *args)


    def Min(self, *args) -> "Standard_Integer":
        """
        * returns the value of the Index of the minimum element of an IntegerVector.
        	:rtype: int
        """
        return _math.math_IntegerVector_Min(self, *args)


    def Multiplied(self, *args) -> "Standard_Integer":
        """
        * returns the product of an IntegerVector by an integer value.
        	:param theRight:
        	:type theRight: int
        	:rtype: math_IntegerVector
        * returns the inner product of 2 IntegerVectors. An exception is raised if the lengths are not equal.
        	:param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: int
        """
        return _math.math_IntegerVector_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * returns the product of an IntegerVector by an integer value.
        	:param theRight:
        	:type theRight: int
        	:rtype: None
        * returns the multiplication of an integer by an IntegerVector.
        	:param theLeft:
        	:type theLeft: int
        	:param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: None
        """
        return _math.math_IntegerVector_Multiply(self, *args)


    def Norm(self, *args) -> "Standard_Real":
        """
        * returns the value of the norm of an IntegerVector.
        	:rtype: float
        """
        return _math.math_IntegerVector_Norm(self, *args)


    def Norm2(self, *args) -> "Standard_Real":
        """
        * returns the value of the square of the norm of an IntegerVector.
        	:rtype: float
        """
        return _math.math_IntegerVector_Norm2(self, *args)


    def Opposite(self, *args) -> "math_IntegerVector":
        """
        * returns the opposite of an IntegerVector.
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector_Opposite(self, *args)


    def Slice(self, *args) -> "math_IntegerVector":
        """
        * slices the values of the IntegerVector between 'theI1' and 'theI2': Example: [2, 1, 2, 3, 4, 5] becomes [2, 4, 3, 2, 1, 5] between 2 and 5. An exception is raised if 'theI1' is less than 'LowerIndex' or 'theI2' is greater than 'UpperIndex'.
        	:param theI1:
        	:type theI1: int
        	:param theI2:
        	:type theI2: int
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector_Slice(self, *args)


    def Subtract(self, *args) -> "void":
        """
        * sets an IntegerVector to the substraction of 'theRight' from 'theLeft'. An exception is raised if the IntegerVectors have not the same length.
        	:param theLeft:
        	:type theLeft: math_IntegerVector
        	:param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: None
        * returns the subtraction of 'theRight' from 'me'. An exception is raised if the IntegerVectors have not the same length.
        	:param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: None
        """
        return _math.math_IntegerVector_Subtract(self, *args)


    def Subtracted(self, *args) -> "math_IntegerVector":
        """
        * returns the subtraction of 'theRight' from 'me'. An exception is raised if the IntegerVectors have not the same length.
        	:param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector_Subtracted(self, *args)


    def TMultiplied(self, *args) -> "math_IntegerVector":
        """
        * returns the product of a vector and a real value.
        	:param theRight:
        	:type theRight: int
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector_TMultiplied(self, *args)


    def Upper(self, *args) -> "Standard_Integer":
        """
        * returns the value of the Upper index of an IntegerVector.
        	:rtype: inline int
        """
        return _math.math_IntegerVector_Upper(self, *args)


    def Value(self, *args) -> "Standard_Integer const &":
        """
        * accesses the value of index theNum of an IntegerVector.
        	:param theNum:
        	:type theNum: int
        	:rtype: int
        """
        return _math.math_IntegerVector_Value(self, *args)


    def __init__(self, *args):
        """
        * contructs an IntegerVector in the range [Lower..Upper]
        	:param theFirst:
        	:type theFirst: int
        	:param theLast:
        	:type theLast: int
        	:rtype: None
        * contructs an IntegerVector in the range [Lower..Upper] with all the elements set to theInitialValue.
        	:param theFirst:
        	:type theFirst: int
        	:param theLast:
        	:type theLast: int
        	:param theInitialValue:
        	:type theInitialValue: int
        	:rtype: None
        * constructs an IntegerVector in the range [Lower..Upper] which share the 'c array' theTab.
        	:param theTab:
        	:type theTab: int *
        	:param theFirst:
        	:type theFirst: int
        	:param theLast:
        	:type theLast: int
        	:rtype: None
        * constructs a copy for initialization. An exception is raised if the lengths of the IntegerVectors are different.
        	:param theOther:
        	:type theOther: math_IntegerVector
        	:rtype: None
        """
        _math.math_IntegerVector_swiginit(self, _math.new_math_IntegerVector(*args))

    def __mul__(self, *args) -> "Standard_Integer":
        """
        :param theRight:
        	:type theRight: int
        	:rtype: math_IntegerVector
        :param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: int
        """
        return _math.math_IntegerVector___mul__(self, *args)


    def __imul_wrapper__(self, other: 'Standard_Integer const') -> "void":
        """__imul_wrapper__(math_IntegerVector self, Standard_Integer const other)"""
        return _math.math_IntegerVector___imul_wrapper__(self, other)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "math_IntegerVector":
        """
        :param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector___add__(self, *args)


    def __iadd_wrapper__(self, other: 'math_IntegerVector') -> "void":
        """__iadd_wrapper__(math_IntegerVector self, math_IntegerVector other)"""
        return _math.math_IntegerVector___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __neg__(self, *args) -> "math_IntegerVector":
        """:rtype: math_IntegerVector"""
        return _math.math_IntegerVector___neg__(self, *args)


    def __sub__(self, *args) -> "math_IntegerVector":
        """
        :param theRight:
        	:type theRight: math_IntegerVector
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector___sub__(self, *args)


    def __isub_wrapper__(self, other: 'math_IntegerVector') -> "void":
        """__isub_wrapper__(math_IntegerVector self, math_IntegerVector other)"""
        return _math.math_IntegerVector___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def Set(self, *args) -> "math_IntegerVector &":
        """
        * sets an IntegerVector from 'theI1' to 'theI2' to the IntegerVector 'theV'; An exception is raised if 'theI1' is less than 'LowerIndex' or 'theI2' is greater than 'UpperIndex' or 'theI1' is greater than 'theI2'. An exception is raised if 'theI2-theI1+1' is different from the Length of 'theV'.
        	:param theI1:
        	:type theI1: int
        	:param theI2:
        	:type theI2: int
        	:param theV:
        	:type theV: math_IntegerVector
        	:rtype: None
        :param theOther:
        	:type theOther: math_IntegerVector
        	:rtype: math_IntegerVector
        """
        return _math.math_IntegerVector_Set(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_IntegerVector
math_IntegerVector.Add = new_instancemethod(_math.math_IntegerVector_Add, None, math_IntegerVector)
math_IntegerVector.Added = new_instancemethod(_math.math_IntegerVector_Added, None, math_IntegerVector)
math_IntegerVector.DumpToString = new_instancemethod(_math.math_IntegerVector_DumpToString, None, math_IntegerVector)
math_IntegerVector.Init = new_instancemethod(_math.math_IntegerVector_Init, None, math_IntegerVector)
math_IntegerVector.Initialized = new_instancemethod(_math.math_IntegerVector_Initialized, None, math_IntegerVector)
math_IntegerVector.Inverse = new_instancemethod(_math.math_IntegerVector_Inverse, None, math_IntegerVector)
math_IntegerVector.Invert = new_instancemethod(_math.math_IntegerVector_Invert, None, math_IntegerVector)
math_IntegerVector.Length = new_instancemethod(_math.math_IntegerVector_Length, None, math_IntegerVector)
math_IntegerVector.Lower = new_instancemethod(_math.math_IntegerVector_Lower, None, math_IntegerVector)
math_IntegerVector.Max = new_instancemethod(_math.math_IntegerVector_Max, None, math_IntegerVector)
math_IntegerVector.Min = new_instancemethod(_math.math_IntegerVector_Min, None, math_IntegerVector)
math_IntegerVector.Multiplied = new_instancemethod(_math.math_IntegerVector_Multiplied, None, math_IntegerVector)
math_IntegerVector.Multiply = new_instancemethod(_math.math_IntegerVector_Multiply, None, math_IntegerVector)
math_IntegerVector.Norm = new_instancemethod(_math.math_IntegerVector_Norm, None, math_IntegerVector)
math_IntegerVector.Norm2 = new_instancemethod(_math.math_IntegerVector_Norm2, None, math_IntegerVector)
math_IntegerVector.Opposite = new_instancemethod(_math.math_IntegerVector_Opposite, None, math_IntegerVector)
math_IntegerVector.Slice = new_instancemethod(_math.math_IntegerVector_Slice, None, math_IntegerVector)
math_IntegerVector.Subtract = new_instancemethod(_math.math_IntegerVector_Subtract, None, math_IntegerVector)
math_IntegerVector.Subtracted = new_instancemethod(_math.math_IntegerVector_Subtracted, None, math_IntegerVector)
math_IntegerVector.TMultiplied = new_instancemethod(_math.math_IntegerVector_TMultiplied, None, math_IntegerVector)
math_IntegerVector.Upper = new_instancemethod(_math.math_IntegerVector_Upper, None, math_IntegerVector)
math_IntegerVector.Value = new_instancemethod(_math.math_IntegerVector_Value, None, math_IntegerVector)
math_IntegerVector.__mul__ = new_instancemethod(_math.math_IntegerVector___mul__, None, math_IntegerVector)
math_IntegerVector.__imul_wrapper__ = new_instancemethod(_math.math_IntegerVector___imul_wrapper__, None, math_IntegerVector)
math_IntegerVector.__add__ = new_instancemethod(_math.math_IntegerVector___add__, None, math_IntegerVector)
math_IntegerVector.__iadd_wrapper__ = new_instancemethod(_math.math_IntegerVector___iadd_wrapper__, None, math_IntegerVector)
math_IntegerVector.__neg__ = new_instancemethod(_math.math_IntegerVector___neg__, None, math_IntegerVector)
math_IntegerVector.__sub__ = new_instancemethod(_math.math_IntegerVector___sub__, None, math_IntegerVector)
math_IntegerVector.__isub_wrapper__ = new_instancemethod(_math.math_IntegerVector___isub_wrapper__, None, math_IntegerVector)
math_IntegerVector.Set = new_instancemethod(_math.math_IntegerVector_Set, None, math_IntegerVector)
math_IntegerVector_swigregister = _math.math_IntegerVector_swigregister
math_IntegerVector_swigregister(math_IntegerVector)

class math_Jacobi(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_Jacobi self) -> std::string"""
        return _math.math_Jacobi_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_Jacobi_IsDone(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * returns the eigenvalue number Num. Eigenvalues are in the range (1..n). Exception NotDone is raised if calculation is not done successfully.
        	:param Num:
        	:type Num: int
        	:rtype: float
        """
        return _math.math_Jacobi_Value(self, *args)


    def Values(self, *args) -> "math_Vector const &":
        """
        * Returns the eigenvalues vector. Exception NotDone is raised if calculation is not done successfully.
        	:rtype: math_Vector
        """
        return _math.math_Jacobi_Values(self, *args)


    def Vector(self, *args) -> "void":
        """
        * Returns the eigenvector V of number Num. Eigenvectors are in the range (1..n). Exception NotDone is raised if calculation is not done successfully.
        	:param Num:
        	:type Num: int
        	:param V:
        	:type V: math_Vector
        	:rtype: None
        """
        return _math.math_Jacobi_Vector(self, *args)


    def Vectors(self, *args) -> "math_Matrix const &":
        """
        * returns the eigenvectors matrix. Exception NotDone is raised if calculation is not done successfully.
        	:rtype: math_Matrix
        """
        return _math.math_Jacobi_Vectors(self, *args)


    def __init__(self, *args):
        """
        * Given a Real n X n matrix A, this constructor computes all its eigenvalues and eigenvectors using the Jacobi method. The exception NotSquare is raised if the matrix is not square. No verification that the matrix A is really symmetric is done.
        	:param A:
        	:type A: math_Matrix
        	:rtype: None
        """
        _math.math_Jacobi_swiginit(self, _math.new_math_Jacobi(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Jacobi
math_Jacobi.DumpToString = new_instancemethod(_math.math_Jacobi_DumpToString, None, math_Jacobi)
math_Jacobi.IsDone = new_instancemethod(_math.math_Jacobi_IsDone, None, math_Jacobi)
math_Jacobi.Value = new_instancemethod(_math.math_Jacobi_Value, None, math_Jacobi)
math_Jacobi.Values = new_instancemethod(_math.math_Jacobi_Values, None, math_Jacobi)
math_Jacobi.Vector = new_instancemethod(_math.math_Jacobi_Vector, None, math_Jacobi)
math_Jacobi.Vectors = new_instancemethod(_math.math_Jacobi_Vectors, None, math_Jacobi)
math_Jacobi_swigregister = _math.math_Jacobi_swigregister
math_Jacobi_swigregister(math_Jacobi)

class math_KronrodSingleIntegration(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AbsolutError(self, *args) -> "Standard_Real":
        """
        * Returns the value of the relative error reached.
        	:rtype: float
        """
        return _math.math_KronrodSingleIntegration_AbsolutError(self, *args)


    def ErrorReached(self, *args) -> "Standard_Real":
        """
        * Returns the value of the relative error reached.
        	:rtype: float
        """
        return _math.math_KronrodSingleIntegration_ErrorReached(self, *args)


    def GKRule(*args) -> "Standard_Real &, Standard_Real &":
        """
        :param theFunction:
        	:type theFunction: math_Function
        	:param theLower:
        	:type theLower: float
        	:param theUpper:
        	:type theUpper: float
        	:param theGaussP:
        	:type theGaussP: math_Vector
        	:param theGaussW:
        	:type theGaussW: math_Vector
        	:param theKronrodP:
        	:type theKronrodP: math_Vector
        	:param theKronrodW:
        	:type theKronrodW: math_Vector
        	:param theValue:
        	:type theValue: float
        	:param theError:
        	:type theError: float
        	:rtype: bool
        """
        return _math.math_KronrodSingleIntegration_GKRule(*args)

    GKRule = staticmethod(GKRule)

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns Standard_True if computation is performed successfully.
        	:rtype: bool
        """
        return _math.math_KronrodSingleIntegration_IsDone(self, *args)


    def NbIterReached(self, *args) -> "Standard_Integer":
        """
        * Returns the number of iterations that were made to compute result.
        	:rtype: int
        """
        return _math.math_KronrodSingleIntegration_NbIterReached(self, *args)


    def OrderReached(self, *args) -> "Standard_Integer":
        """
        * Returns the number of Kronrod points for which the result is computed.
        	:rtype: int
        """
        return _math.math_KronrodSingleIntegration_OrderReached(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Computation of the integral. Takes the function, the lower and upper bound values, the initial number of Kronrod points, the relative tolerance value and the maximal number of iterations as parameters. theNbPnts should be odd and greater then or equal to 3.
        	:param theFunction:
        	:type theFunction: math_Function
        	:param theLower:
        	:type theLower: float
        	:param theUpper:
        	:type theUpper: float
        	:param theNbPnts:
        	:type theNbPnts: int
        	:rtype: None
        * Computation of the integral. Takes the function, the lower and upper bound values, the initial number of Kronrod points, the relative tolerance value and the maximal number of iterations as parameters. theNbPnts should be odd and greater then or equal to 3. Note that theTolerance is relative, i.e. the criterion of solution reaching is: Abs(Kronrod - Gauss)/Abs(Kronrod) < theTolerance. theTolerance should be positive.
        	:param theFunction:
        	:type theFunction: math_Function
        	:param theLower:
        	:type theLower: float
        	:param theUpper:
        	:type theUpper: float
        	:param theNbPnts:
        	:type theNbPnts: int
        	:param theTolerance:
        	:type theTolerance: float
        	:param theMaxNbIter:
        	:type theMaxNbIter: int
        	:rtype: None
        """
        return _math.math_KronrodSingleIntegration_Perform(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * Returns the value of the integral.
        	:rtype: float
        """
        return _math.math_KronrodSingleIntegration_Value(self, *args)


    def __init__(self, *args):
        """
        * An empty constructor.
        	:rtype: None
        * Constructor. Takes the function, the lower and upper bound values, the initial number of Kronrod points
        	:param theFunction:
        	:type theFunction: math_Function
        	:param theLower:
        	:type theLower: float
        	:param theUpper:
        	:type theUpper: float
        	:param theNbPnts:
        	:type theNbPnts: int
        	:rtype: None
        * Constructor. Takes the function, the lower and upper bound values, the initial number of Kronrod points, the tolerance value and the maximal number of iterations as parameters.
        	:param theFunction:
        	:type theFunction: math_Function
        	:param theLower:
        	:type theLower: float
        	:param theUpper:
        	:type theUpper: float
        	:param theNbPnts:
        	:type theNbPnts: int
        	:param theTolerance:
        	:type theTolerance: float
        	:param theMaxNbIter:
        	:type theMaxNbIter: int
        	:rtype: None
        """
        _math.math_KronrodSingleIntegration_swiginit(self, _math.new_math_KronrodSingleIntegration(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_KronrodSingleIntegration
math_KronrodSingleIntegration.AbsolutError = new_instancemethod(_math.math_KronrodSingleIntegration_AbsolutError, None, math_KronrodSingleIntegration)
math_KronrodSingleIntegration.ErrorReached = new_instancemethod(_math.math_KronrodSingleIntegration_ErrorReached, None, math_KronrodSingleIntegration)
math_KronrodSingleIntegration.IsDone = new_instancemethod(_math.math_KronrodSingleIntegration_IsDone, None, math_KronrodSingleIntegration)
math_KronrodSingleIntegration.NbIterReached = new_instancemethod(_math.math_KronrodSingleIntegration_NbIterReached, None, math_KronrodSingleIntegration)
math_KronrodSingleIntegration.OrderReached = new_instancemethod(_math.math_KronrodSingleIntegration_OrderReached, None, math_KronrodSingleIntegration)
math_KronrodSingleIntegration.Perform = new_instancemethod(_math.math_KronrodSingleIntegration_Perform, None, math_KronrodSingleIntegration)
math_KronrodSingleIntegration.Value = new_instancemethod(_math.math_KronrodSingleIntegration_Value, None, math_KronrodSingleIntegration)
math_KronrodSingleIntegration_swigregister = _math.math_KronrodSingleIntegration_swigregister
math_KronrodSingleIntegration_swigregister(math_KronrodSingleIntegration)

def math_KronrodSingleIntegration_GKRule(*args) -> "Standard_Real &, Standard_Real &":
    """
    :param theFunction:
    	:type theFunction: math_Function
    	:param theLower:
    	:type theLower: float
    	:param theUpper:
    	:type theUpper: float
    	:param theGaussP:
    	:type theGaussP: math_Vector
    	:param theGaussW:
    	:type theGaussW: math_Vector
    	:param theKronrodP:
    	:type theKronrodP: math_Vector
    	:param theKronrodW:
    	:type theKronrodW: math_Vector
    	:param theValue:
    	:type theValue: float
    	:param theError:
    	:type theError: float
    	:rtype: bool
    """
    return _math.math_KronrodSingleIntegration_GKRule(*args)

class math_Matrix(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * adds the matrix <Right> to a matrix. An exception is raised if the dimensions are different. Warning In order to save time when copying matrices, it is preferable to use operator += or the function Add whenever possible.
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: None
        * sets a matrix to the addition of <Left> and <Right>. An exception is raised if the dimensions are different.
        	:param Left:
        	:type Left: math_Matrix
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: None
        """
        return _math.math_Matrix_Add(self, *args)


    def Added(self, *args) -> "math_Matrix":
        """
        * adds the matrix <Right> to a matrix. An exception is raised if the dimensions are different.
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: math_Matrix
        """
        return _math.math_Matrix_Added(self, *args)


    def Col(self, *args) -> "math_Vector":
        """
        * Returns the column of index <Col> of a matrix.
        	:param Col:
        	:type Col: int
        	:rtype: math_Vector
        """
        return _math.math_Matrix_Col(self, *args)


    def ColNumber(self, *args) -> "Standard_Integer":
        """
        * Returns the number of rows of this matrix. Note that for a matrix A you always have the following relations: - A.RowNumber() = A.UpperRow() - A.LowerRow() + 1 - A.ColNumber() = A.UpperCol() - A.LowerCol() + 1 - the length of a row of A is equal to the number of columns of A, - the length of a column of A is equal to the number of rows of A.returns the row range of a matrix.
        	:rtype: int
        """
        return _math.math_Matrix_ColNumber(self, *args)


    def Determinant(self, *args) -> "Standard_Real":
        """
        * Computes the determinant of a matrix. An exception is raised if the matrix is not a square matrix.
        	:rtype: float
        """
        return _math.math_Matrix_Determinant(self, *args)


    def Divide(self, *args) -> "void":
        """
        * divides all the elements of a matrix by the value <Right>. An exception is raised if <Right> = 0.
        	:param Right:
        	:type Right: float
        	:rtype: None
        """
        return _math.math_Matrix_Divide(self, *args)


    def Divided(self, *args) -> "math_Matrix":
        """
        * divides all the elements of a matrix by the value <Right>. An exception is raised if <Right> = 0.
        	:param Right:
        	:type Right: float
        	:rtype: math_Matrix
        """
        return _math.math_Matrix_Divided(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Matrix self) -> std::string"""
        return _math.math_Matrix_DumpToString(self)


    def Init(self, *args) -> "void":
        """
        * Initialize all the elements of a matrix to InitialValue.
        	:param InitialValue:
        	:type InitialValue: float
        	:rtype: None
        """
        return _math.math_Matrix_Init(self, *args)


    def Initialized(self, *args) -> "math_Matrix &":
        """
        * Matrixes are copied through assignement. An exception is raised if the dimensions are differents.
        	:param Other:
        	:type Other: math_Matrix
        	:rtype: math_Matrix
        """
        return _math.math_Matrix_Initialized(self, *args)


    def Inverse(self, *args) -> "math_Matrix":
        """
        * Returns the inverse of a matrix. Exception NotSquare is raised if the matrix is not square. Exception SingularMatrix is raised if the matrix is singular.
        	:rtype: math_Matrix
        """
        return _math.math_Matrix_Inverse(self, *args)


    def Invert(self, *args) -> "void":
        """
        * Inverts a matrix using Gauss algorithm. Exception NotSquare is raised if the matrix is not square. Exception SingularMatrix is raised if the matrix is singular.
        	:rtype: None
        """
        return _math.math_Matrix_Invert(self, *args)


    def LowerCol(self, *args) -> "Standard_Integer":
        """
        * Returns the value of the Lower index of the column range of a matrix.
        	:rtype: int
        """
        return _math.math_Matrix_LowerCol(self, *args)


    def LowerRow(self, *args) -> "Standard_Integer":
        """
        * Returns the value of the Lower index of the row range of a matrix.
        	:rtype: int
        """
        return _math.math_Matrix_LowerRow(self, *args)


    def Multiplied(self, *args) -> "math_Vector":
        """
        * multiplies all the elements of a matrix by the value <Right>.
        	:param Right:
        	:type Right: float
        	:rtype: math_Matrix
        * Returns the product of 2 matrices. An exception is raised if the dimensions are different.
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: math_Matrix
        * Returns the product of a matrix by a vector. An exception is raised if the dimensions are different.
        	:param Right:
        	:type Right: math_Vector
        	:rtype: math_Vector
        """
        return _math.math_Matrix_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * Sets this matrix to the product of the matrix Left, and the matrix Right. Example math_Matrix A (1, 3, 1, 3); math_Matrix B (1, 3, 1, 3); // A = ... , B = ... math_Matrix C (1, 3, 1, 3); C.Multiply(A, B); Exceptions Standard_DimensionError if matrices are of incompatible dimensions, i.e. if: - the number of columns of matrix Left, or the number of rows of matrix TLeft is not equal to the number of rows of matrix Right, or - the number of rows of matrix Left, or the number of columns of matrix TLeft is not equal to the number of rows of this matrix, or - the number of columns of matrix Right is not equal to the number of columns of this matrix.
        	:param Right:
        	:type Right: float
        	:rtype: None
        * Computes a matrix as the product of 2 vectors. An exception is raised if the dimensions are different. <self> = <Left> * <Right>.
        	:param Left:
        	:type Left: math_Vector
        	:param Right:
        	:type Right: math_Vector
        	:rtype: None
        * Computes a matrix as the product of 2 matrixes. An exception is raised if the dimensions are different.
        	:param Left:
        	:type Left: math_Matrix
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: None
        * Returns the product of 2 matrices. An exception is raised if the dimensions are different.
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: None
        """
        return _math.math_Matrix_Multiply(self, *args)


    def Opposite(self, *args) -> "math_Matrix":
        """
        * Returns the opposite of a matrix. An exception is raised if the dimensions are different.
        	:rtype: math_Matrix
        """
        return _math.math_Matrix_Opposite(self, *args)


    def Row(self, *args) -> "math_Vector":
        """
        * Returns the row of index Row of a matrix.
        	:param Row:
        	:type Row: int
        	:rtype: math_Vector
        """
        return _math.math_Matrix_Row(self, *args)


    def RowNumber(self, *args) -> "Standard_Integer":
        """
        * Returns the number of rows of this matrix. Note that for a matrix A you always have the following relations: - A.RowNumber() = A.UpperRow() - A.LowerRow() + 1 - A.ColNumber() = A.UpperCol() - A.LowerCol() + 1 - the length of a row of A is equal to the number of columns of A, - the length of a column of A is equal to the number of rows of A.returns the row range of a matrix.
        	:rtype: int
        """
        return _math.math_Matrix_RowNumber(self, *args)


    def SetCol(self, *args) -> "void":
        """
        * Sets the column of index Col of a matrix to the vector <V>. An exception is raised if the dimensions are different. An exception is raises if <Col> is inferior to the lower column of the matrix or <Col> is superior to the upper column.
        	:param Col:
        	:type Col: int
        	:param V:
        	:type V: math_Vector
        	:rtype: None
        """
        return _math.math_Matrix_SetCol(self, *args)


    def SetDiag(self, *args) -> "void":
        """
        * Sets the diagonal of a matrix to the value <Value>. An exception is raised if the matrix is not square.
        	:param Value:
        	:type Value: float
        	:rtype: None
        """
        return _math.math_Matrix_SetDiag(self, *args)


    def SetRow(self, *args) -> "void":
        """
        * Sets the row of index Row of a matrix to the vector <V>. An exception is raised if the dimensions are different. An exception is raises if <Row> is inferior to the lower row of the matrix or <Row> is superior to the upper row.
        	:param Row:
        	:type Row: int
        	:param V:
        	:type V: math_Vector
        	:rtype: None
        """
        return _math.math_Matrix_SetRow(self, *args)


    def Subtract(self, *args) -> "void":
        """
        * Subtracts the matrix <Right> from <self>. An exception is raised if the dimensions are different. Warning In order to avoid time-consuming copying of matrices, it is preferable to use operator -= or the function Subtract whenever possible.
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: None
        * Sets a matrix to the Subtraction of the matrix <Right> from the matrix <Left>. An exception is raised if the dimensions are different.
        	:param Left:
        	:type Left: math_Matrix
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: None
        """
        return _math.math_Matrix_Subtract(self, *args)


    def Subtracted(self, *args) -> "math_Matrix":
        """
        * Returns the result of the subtraction of <Right> from <self>. An exception is raised if the dimensions are different.
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: math_Matrix
        """
        return _math.math_Matrix_Subtracted(self, *args)


    def SwapCol(self, *args) -> "void":
        """
        * Swaps the columns of index <Col1> and <Col2>. An exception is raised if <Col1> or <Col2> is out of range.
        	:param Col1:
        	:type Col1: int
        	:param Col2:
        	:type Col2: int
        	:rtype: None
        """
        return _math.math_Matrix_SwapCol(self, *args)


    def SwapRow(self, *args) -> "void":
        """
        * Swaps the rows of index Row1 and Row2. An exception is raised if <Row1> or <Row2> is out of range.
        	:param Row1:
        	:type Row1: int
        	:param Row2:
        	:type Row2: int
        	:rtype: None
        """
        return _math.math_Matrix_SwapRow(self, *args)


    def TMultiplied(self, *args) -> "math_Matrix":
        """
        * Sets this matrix to the product of the transposed matrix TLeft, and the matrix Right. Example math_Matrix A (1, 3, 1, 3); math_Matrix B (1, 3, 1, 3); // A = ... , B = ... math_Matrix C (1, 3, 1, 3); C.Multiply(A, B); Exceptions Standard_DimensionError if matrices are of incompatible dimensions, i.e. if: - the number of columns of matrix Left, or the number of rows of matrix TLeft is not equal to the number of rows of matrix Right, or - the number of rows of matrix Left, or the number of columns of matrix TLeft is not equal to the number of rows of this matrix, or - the number of columns of matrix Right is not equal to the number of columns of this matrix.
        	:param Right:
        	:type Right: float
        	:rtype: math_Matrix
        """
        return _math.math_Matrix_TMultiplied(self, *args)


    def TMultiply(self, *args) -> "void":
        """
        * Returns the product of the transpose of a matrix with the matrix <Right>. An exception is raised if the dimensions are different.
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: math_Matrix
        * Computes a matrix to the product of the transpose of the matrix <TLeft> with the matrix <Right>. An exception is raised if the dimensions are different.
        	:param TLeft:
        	:type TLeft: math_Matrix
        	:param Right:
        	:type Right: math_Matrix
        	:rtype: None
        """
        return _math.math_Matrix_TMultiply(self, *args)


    def Transpose(self, *args) -> "void":
        """
        * Transposes a given matrix. An exception is raised if the matrix is not a square matrix.
        	:rtype: None
        """
        return _math.math_Matrix_Transpose(self, *args)


    def Transposed(self, *args) -> "math_Matrix":
        """
        * Teturns the transposed of a matrix. An exception is raised if the matrix is not a square matrix.
        	:rtype: math_Matrix
        """
        return _math.math_Matrix_Transposed(self, *args)


    def UpperCol(self, *args) -> "Standard_Integer":
        """
        * Returns the value of the upper index of the column range of a matrix.
        	:rtype: int
        """
        return _math.math_Matrix_UpperCol(self, *args)


    def UpperRow(self, *args) -> "Standard_Integer":
        """
        * Returns the Upper index of the row range of a matrix.
        	:rtype: int
        """
        return _math.math_Matrix_UpperRow(self, *args)


    def GetValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const') -> "Standard_Real":
        """GetValue(math_Matrix self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real"""
        return _math.math_Matrix_GetValue(self, Row, Col)


    def SetValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetValue(math_Matrix self, Standard_Integer const Row, Standard_Integer const Col, Standard_Real value)"""
        return _math.math_Matrix_SetValue(self, Row, Col, value)


    def __init__(self, *args):
        """
        * Constructs a non-initialized matrix of range [LowerRow..UpperRow, LowerCol..UpperCol] For the constructed matrix: - LowerRow and UpperRow are the indexes of the lower and upper bounds of a row, and - LowerCol and UpperCol are the indexes of the lower and upper bounds of a column.
        	:param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:rtype: None
        * constructs a non-initialized matrix of range [LowerRow..UpperRow, LowerCol..UpperCol] whose values are all initialized with the value InitialValue.
        	:param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:param InitialValue:
        	:type InitialValue: float
        	:rtype: None
        * constructs a matrix of range [LowerRow..UpperRow, LowerCol..UpperCol] Sharing data with a 'C array' pointed by Tab.
        	:param Tab:
        	:type Tab: Standard_Address
        	:param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:rtype: None
        * constructs a matrix for copy in initialization. An exception is raised if the matrixes have not the same dimensions.
        	:param Other:
        	:type Other: math_Matrix
        	:rtype: None
        """
        _math.math_Matrix_swiginit(self, _math.new_math_Matrix(*args))

    def __mul__(self, *args) -> "math_Vector":
        """
        :param Right:
        	:type Right: float
        	:rtype: math_Matrix
        :param Right:
        	:type Right: math_Matrix
        	:rtype: math_Matrix
        :param Right:
        	:type Right: math_Vector
        	:rtype: math_Vector
        """
        return _math.math_Matrix___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul_wrapper__(self, *args) -> "void":
        """
        __imul_wrapper__(math_Matrix self, Standard_Real const other)
        __imul_wrapper__(math_Matrix self, math_Matrix other)
        """
        return _math.math_Matrix___imul_wrapper__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "math_Matrix":
        """
        :param Right:
        	:type Right: math_Matrix
        	:rtype: math_Matrix
        """
        return _math.math_Matrix___add__(self, *args)


    def __iadd_wrapper__(self, other: 'math_Matrix') -> "void":
        """__iadd_wrapper__(math_Matrix self, math_Matrix other)"""
        return _math.math_Matrix___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __sub__(self, *args) -> "math_Matrix":
        """
        :param Right:
        	:type Right: math_Matrix
        	:rtype: math_Matrix
        """
        return _math.math_Matrix___sub__(self, *args)


    def __neg__(self, *args) -> "math_Matrix":
        """:rtype: math_Matrix"""
        return _math.math_Matrix___neg__(self, *args)


    def __isub_wrapper__(self, other: 'math_Matrix') -> "void":
        """__isub_wrapper__(math_Matrix self, math_Matrix other)"""
        return _math.math_Matrix___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _math.math_Matrix___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__itruediv_wrapper__(math_Matrix self, Standard_Real const other)"""
        return _math.math_Matrix___itruediv_wrapper__(self, other)


    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    def Set(self, *args) -> "math_Matrix &":
        """
        * Sets the values of this matrix, - from index I1 to index I2 on the row dimension, and - from index J1 to index J2 on the column dimension, to those of matrix M. Exceptions Standard_DimensionError if: - I1 is less than the index of the lower row bound of this matrix, or - I2 is greater than the index of the upper row bound of this matrix, or - J1 is less than the index of the lower column bound of this matrix, or - J2 is greater than the index of the upper column bound of this matrix, or - I2 - I1 + 1 is not equal to the number of rows of matrix M, or - J2 - J1 + 1 is not equal to the number of columns of matrix M.
        	:param I1:
        	:type I1: int
        	:param I2:
        	:type I2: int
        	:param J1:
        	:type J1: int
        	:param J2:
        	:type J2: int
        	:param M:
        	:type M: math_Matrix
        	:rtype: None
        :param Other:
        	:type Other: math_Matrix
        	:rtype: math_Matrix
        """
        return _math.math_Matrix_Set(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Matrix
math_Matrix.Add = new_instancemethod(_math.math_Matrix_Add, None, math_Matrix)
math_Matrix.Added = new_instancemethod(_math.math_Matrix_Added, None, math_Matrix)
math_Matrix.Col = new_instancemethod(_math.math_Matrix_Col, None, math_Matrix)
math_Matrix.ColNumber = new_instancemethod(_math.math_Matrix_ColNumber, None, math_Matrix)
math_Matrix.Determinant = new_instancemethod(_math.math_Matrix_Determinant, None, math_Matrix)
math_Matrix.Divide = new_instancemethod(_math.math_Matrix_Divide, None, math_Matrix)
math_Matrix.Divided = new_instancemethod(_math.math_Matrix_Divided, None, math_Matrix)
math_Matrix.DumpToString = new_instancemethod(_math.math_Matrix_DumpToString, None, math_Matrix)
math_Matrix.Init = new_instancemethod(_math.math_Matrix_Init, None, math_Matrix)
math_Matrix.Initialized = new_instancemethod(_math.math_Matrix_Initialized, None, math_Matrix)
math_Matrix.Inverse = new_instancemethod(_math.math_Matrix_Inverse, None, math_Matrix)
math_Matrix.Invert = new_instancemethod(_math.math_Matrix_Invert, None, math_Matrix)
math_Matrix.LowerCol = new_instancemethod(_math.math_Matrix_LowerCol, None, math_Matrix)
math_Matrix.LowerRow = new_instancemethod(_math.math_Matrix_LowerRow, None, math_Matrix)
math_Matrix.Multiplied = new_instancemethod(_math.math_Matrix_Multiplied, None, math_Matrix)
math_Matrix.Multiply = new_instancemethod(_math.math_Matrix_Multiply, None, math_Matrix)
math_Matrix.Opposite = new_instancemethod(_math.math_Matrix_Opposite, None, math_Matrix)
math_Matrix.Row = new_instancemethod(_math.math_Matrix_Row, None, math_Matrix)
math_Matrix.RowNumber = new_instancemethod(_math.math_Matrix_RowNumber, None, math_Matrix)
math_Matrix.SetCol = new_instancemethod(_math.math_Matrix_SetCol, None, math_Matrix)
math_Matrix.SetDiag = new_instancemethod(_math.math_Matrix_SetDiag, None, math_Matrix)
math_Matrix.SetRow = new_instancemethod(_math.math_Matrix_SetRow, None, math_Matrix)
math_Matrix.Subtract = new_instancemethod(_math.math_Matrix_Subtract, None, math_Matrix)
math_Matrix.Subtracted = new_instancemethod(_math.math_Matrix_Subtracted, None, math_Matrix)
math_Matrix.SwapCol = new_instancemethod(_math.math_Matrix_SwapCol, None, math_Matrix)
math_Matrix.SwapRow = new_instancemethod(_math.math_Matrix_SwapRow, None, math_Matrix)
math_Matrix.TMultiplied = new_instancemethod(_math.math_Matrix_TMultiplied, None, math_Matrix)
math_Matrix.TMultiply = new_instancemethod(_math.math_Matrix_TMultiply, None, math_Matrix)
math_Matrix.Transpose = new_instancemethod(_math.math_Matrix_Transpose, None, math_Matrix)
math_Matrix.Transposed = new_instancemethod(_math.math_Matrix_Transposed, None, math_Matrix)
math_Matrix.UpperCol = new_instancemethod(_math.math_Matrix_UpperCol, None, math_Matrix)
math_Matrix.UpperRow = new_instancemethod(_math.math_Matrix_UpperRow, None, math_Matrix)
math_Matrix.GetValue = new_instancemethod(_math.math_Matrix_GetValue, None, math_Matrix)
math_Matrix.SetValue = new_instancemethod(_math.math_Matrix_SetValue, None, math_Matrix)
math_Matrix.__mul__ = new_instancemethod(_math.math_Matrix___mul__, None, math_Matrix)
math_Matrix.__imul_wrapper__ = new_instancemethod(_math.math_Matrix___imul_wrapper__, None, math_Matrix)
math_Matrix.__add__ = new_instancemethod(_math.math_Matrix___add__, None, math_Matrix)
math_Matrix.__iadd_wrapper__ = new_instancemethod(_math.math_Matrix___iadd_wrapper__, None, math_Matrix)
math_Matrix.__sub__ = new_instancemethod(_math.math_Matrix___sub__, None, math_Matrix)
math_Matrix.__neg__ = new_instancemethod(_math.math_Matrix___neg__, None, math_Matrix)
math_Matrix.__isub_wrapper__ = new_instancemethod(_math.math_Matrix___isub_wrapper__, None, math_Matrix)
math_Matrix.__itruediv_wrapper__ = new_instancemethod(_math.math_Matrix___itruediv_wrapper__, None, math_Matrix)
math_Matrix.Set = new_instancemethod(_math.math_Matrix_Set, None, math_Matrix)
math_Matrix_swigregister = _math.math_Matrix_swigregister
math_Matrix_swigregister(math_Matrix)

class math_MultipleVarFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetStateNumber(self, *args) -> "Standard_Integer":
        """
        * return the state of the function corresponding to the latestt call of any methods associated to the function. This function is called by each of the algorithms described later which define the function Integer Algorithm::StateNumber(). The algorithm has the responsibility to call this function when it has found a solution (i.e. a root or a minimum) and has to maintain the association between the solution found and this StateNumber. Byu default, this method returns 0 (which means for the algorithm: no state has been saved). It is the responsibility of the programmer to decide if he needs to save the current state of the function and to return an Integer that allows retrieval of the state.
        	:rtype: int
        """
        return _math.math_MultipleVarFunction_GetStateNumber(self, *args)


    def NbVariables(self, *args) -> "Standard_Integer":
        """
        * Returns the number of variables of the function
        	:rtype: int
        """
        return _math.math_MultipleVarFunction_NbVariables(self, *args)


    def Value(self, *args) -> "Standard_Boolean":
        """
        * Computes the values of the Functions <F> for the variable <X>. returns True if the computation was done successfully, otherwise false.
        	:param X:
        	:type X: math_Vector
        	:param F:
        	:type F: float
        	:rtype: bool
        """
        return _math.math_MultipleVarFunction_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunction
math_MultipleVarFunction.GetStateNumber = new_instancemethod(_math.math_MultipleVarFunction_GetStateNumber, None, math_MultipleVarFunction)
math_MultipleVarFunction.NbVariables = new_instancemethod(_math.math_MultipleVarFunction_NbVariables, None, math_MultipleVarFunction)
math_MultipleVarFunction.Value = new_instancemethod(_math.math_MultipleVarFunction_Value, None, math_MultipleVarFunction)
math_MultipleVarFunction_swigregister = _math.math_MultipleVarFunction_swigregister
math_MultipleVarFunction_swigregister(math_MultipleVarFunction)

class math_NewtonFunctionRoot(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Derivative(self, *args) -> "Standard_Real":
        """
        * returns the value of the derivative at the root. Exception NotDone is raised if the root was not found.
        	:rtype: float
        """
        return _math.math_NewtonFunctionRoot_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_NewtonFunctionRoot self) -> std::string"""
        return _math.math_NewtonFunctionRoot_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_NewtonFunctionRoot_IsDone(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * Returns the number of iterations really done on the computation of the Root. Exception NotDone is raised if the root was not found.
        	:rtype: int
        """
        return _math.math_NewtonFunctionRoot_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        * is used internally by the constructors.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Guess:
        	:type Guess: float
        	:rtype: None
        """
        return _math.math_NewtonFunctionRoot_Perform(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        * Returns the value of the root of function <F>. Exception NotDone is raised if the root was not found.
        	:rtype: float
        """
        return _math.math_NewtonFunctionRoot_Root(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * returns the value of the function at the root. Exception NotDone is raised if the root was not found.
        	:rtype: float
        """
        return _math.math_NewtonFunctionRoot_Value(self, *args)


    def __init__(self, *args):
        """
        * The Newton method is done to find the root of the function F from the initial guess Guess. The tolerance required on the root is given by Tolerance. The solution is found when : abs(Xi - Xi-1) <= EpsX and abs(F(Xi))<= EpsF The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Guess:
        	:type Guess: float
        	:param EpsX:
        	:type EpsX: float
        	:param EpsF:
        	:type EpsF: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        * The Newton method is done to find the root of the function F from the initial guess Guess. The solution must be inside the interval [A, B]. The tolerance required on the root is given by Tolerance. The solution is found when : abs(Xi - Xi-1) <= EpsX and abs(F(Xi))<= EpsF The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Guess:
        	:type Guess: float
        	:param EpsX:
        	:type EpsX: float
        	:param EpsF:
        	:type EpsF: float
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        * is used in a sub-class to initialize correctly all the fields of this class.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param EpsX:
        	:type EpsX: float
        	:param EpsF:
        	:type EpsF: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        """
        _math.math_NewtonFunctionRoot_swiginit(self, _math.new_math_NewtonFunctionRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_NewtonFunctionRoot
math_NewtonFunctionRoot.Derivative = new_instancemethod(_math.math_NewtonFunctionRoot_Derivative, None, math_NewtonFunctionRoot)
math_NewtonFunctionRoot.DumpToString = new_instancemethod(_math.math_NewtonFunctionRoot_DumpToString, None, math_NewtonFunctionRoot)
math_NewtonFunctionRoot.IsDone = new_instancemethod(_math.math_NewtonFunctionRoot_IsDone, None, math_NewtonFunctionRoot)
math_NewtonFunctionRoot.NbIterations = new_instancemethod(_math.math_NewtonFunctionRoot_NbIterations, None, math_NewtonFunctionRoot)
math_NewtonFunctionRoot.Perform = new_instancemethod(_math.math_NewtonFunctionRoot_Perform, None, math_NewtonFunctionRoot)
math_NewtonFunctionRoot.Root = new_instancemethod(_math.math_NewtonFunctionRoot_Root, None, math_NewtonFunctionRoot)
math_NewtonFunctionRoot.Value = new_instancemethod(_math.math_NewtonFunctionRoot_Value, None, math_NewtonFunctionRoot)
math_NewtonFunctionRoot_swigregister = _math.math_NewtonFunctionRoot_swigregister
math_NewtonFunctionRoot_swigregister(math_NewtonFunctionRoot)

class math_NewtonFunctionSetRoot(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Derivative(self, *args) -> "void":
        """
        * Returns the matrix value of the derivative at the root. Exception NotDone is raised if the root was not found.
        	:rtype: math_Matrix
        * Outputs the matrix value of the derivative at the root in Der. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Der is not equal to the range of the StartingPoint.
        	:param Der:
        	:type Der: math_Matrix
        	:rtype: None
        """
        return _math.math_NewtonFunctionSetRoot_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_NewtonFunctionSetRoot self) -> std::string"""
        return _math.math_NewtonFunctionSetRoot_DumpToString(self)


    def FunctionSetErrors(self, *args) -> "void":
        """
        * Returns the vector value of the error done on the functions at the root. Exception NotDone is raised if the root was not found.
        	:rtype: math_Vector
        * Outputs the vector value of the error done on the functions at the root in Err. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Err is not equal to the range of the StartingPoint.
        	:param Err:
        	:type Err: math_Vector
        	:rtype: None
        """
        return _math.math_NewtonFunctionSetRoot_FunctionSetErrors(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_NewtonFunctionSetRoot_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        * This method is called at the end of each iteration to check if the solution is found. Vectors DeltaX, Fvalues and Jacobian Matrix are consistent with the possible solution Vector Sol and can be inspected to decide whether the solution is reached or not.
        	:param F:
        	:type F: math_FunctionSetWithDerivatives
        	:rtype: bool
        """
        return _math.math_NewtonFunctionSetRoot_IsSolutionReached(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * Returns the number of iterations really done during the computation of the Root. Exception NotDone is raised if the root was not found.
        	:rtype: int
        """
        return _math.math_NewtonFunctionSetRoot_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        * The Newton method is done to improve the root of the function from the initial guess point. The solution is found when: abs(Xj - Xj-1)(i) <= XTol(i) and abs(Fi) <= FTol for all i;
        	:param theFunction:
        	:type theFunction: math_FunctionSetWithDerivatives
        	:param theStartingPoint:
        	:type theStartingPoint: math_Vector
        	:rtype: None
        * The Newton method is done to improve the root of the function from the initial guess point. Bounds may be given, to constrain the solution. The solution is found when: abs(Xj - Xj-1)(i) <= XTol(i) and abs(Fi) <= FTol for all i;
        	:param theFunction:
        	:type theFunction: math_FunctionSetWithDerivatives
        	:param theStartingPoint:
        	:type theStartingPoint: math_Vector
        	:param theInfBound:
        	:type theInfBound: math_Vector
        	:param theSupBound:
        	:type theSupBound: math_Vector
        	:rtype: None
        """
        return _math.math_NewtonFunctionSetRoot_Perform(self, *args)


    def Root(self, *args) -> "void":
        """
        * Returns the value of the root of function F. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false).
        	:rtype: math_Vector
        * outputs the root vector in Root. Exception NotDone is raised if the root was not found. Exception DimensionError is raised if the range of Root is not equal to the range of the StartingPoint.
        	:param Root:
        	:type Root: math_Vector
        	:rtype: None
        """
        return _math.math_NewtonFunctionSetRoot_Root(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        * Initializes the tolerance values for the unknowns.
        	:param XTol:
        	:type XTol: math_Vector
        	:rtype: None
        """
        return _math.math_NewtonFunctionSetRoot_SetTolerance(self, *args)


    def __init__(self, *args):
        """
        * Initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations.
        	:param theFunction:
        	:type theFunction: math_FunctionSetWithDerivatives
        	:param theXTolerance:
        	:type theXTolerance: math_Vector
        	:param theFTolerance:
        	:type theFTolerance: float
        	:param tehNbIterations: default value is 100
        	:type tehNbIterations: int
        	:rtype: None
        * This constructor should be used in a sub-class to initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations. The method SetTolerance must be called before performing the algorithm.
        	:param theFunction:
        	:type theFunction: math_FunctionSetWithDerivatives
        	:param theFTolerance:
        	:type theFTolerance: float
        	:param theNbIterations: default value is 100
        	:type theNbIterations: int
        	:rtype: None
        """
        _math.math_NewtonFunctionSetRoot_swiginit(self, _math.new_math_NewtonFunctionSetRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_NewtonFunctionSetRoot
math_NewtonFunctionSetRoot.Derivative = new_instancemethod(_math.math_NewtonFunctionSetRoot_Derivative, None, math_NewtonFunctionSetRoot)
math_NewtonFunctionSetRoot.DumpToString = new_instancemethod(_math.math_NewtonFunctionSetRoot_DumpToString, None, math_NewtonFunctionSetRoot)
math_NewtonFunctionSetRoot.FunctionSetErrors = new_instancemethod(_math.math_NewtonFunctionSetRoot_FunctionSetErrors, None, math_NewtonFunctionSetRoot)
math_NewtonFunctionSetRoot.IsDone = new_instancemethod(_math.math_NewtonFunctionSetRoot_IsDone, None, math_NewtonFunctionSetRoot)
math_NewtonFunctionSetRoot.IsSolutionReached = new_instancemethod(_math.math_NewtonFunctionSetRoot_IsSolutionReached, None, math_NewtonFunctionSetRoot)
math_NewtonFunctionSetRoot.NbIterations = new_instancemethod(_math.math_NewtonFunctionSetRoot_NbIterations, None, math_NewtonFunctionSetRoot)
math_NewtonFunctionSetRoot.Perform = new_instancemethod(_math.math_NewtonFunctionSetRoot_Perform, None, math_NewtonFunctionSetRoot)
math_NewtonFunctionSetRoot.Root = new_instancemethod(_math.math_NewtonFunctionSetRoot_Root, None, math_NewtonFunctionSetRoot)
math_NewtonFunctionSetRoot.SetTolerance = new_instancemethod(_math.math_NewtonFunctionSetRoot_SetTolerance, None, math_NewtonFunctionSetRoot)
math_NewtonFunctionSetRoot_swigregister = _math.math_NewtonFunctionSetRoot_swigregister
math_NewtonFunctionSetRoot_swigregister(math_NewtonFunctionSetRoot)

class math_NewtonMinimum(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_NewtonMinimum self) -> std::string"""
        return _math.math_NewtonMinimum_DumpToString(self)


    def GetStatus(self, *args) -> "math_Status":
        """
        * Returns the Status of computation. The exception NotDone is raised if an error has occured.
        	:rtype: math_Status
        """
        return _math.math_NewtonMinimum_GetStatus(self, *args)


    def Gradient(self, *args) -> "void":
        """
        * returns the gradient vector at the minimum. Exception NotDone is raised if an error has occured.the minimum was not found.
        	:rtype: math_Vector
        * outputs the gradient vector at the minimum in Grad. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Grad is not equal to the range of the StartingPoint.
        	:param Grad:
        	:type Grad: math_Vector
        	:rtype: None
        """
        return _math.math_NewtonMinimum_Gradient(self, *args)


    def IsConverged(self, *args) -> "Standard_Boolean":
        """
        * This method is called at the end of each iteration to check the convergence: || Xi+1 - Xi || < Tolerance or || F(Xi+1) - F(Xi)|| < Tolerance * || F(Xi) || It can be redefined in a sub-class to implement a specific test.
        	:rtype: bool
        """
        return _math.math_NewtonMinimum_IsConverged(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Tests if an error has occured.
        	:rtype: bool
        """
        return _math.math_NewtonMinimum_IsDone(self, *args)


    def Location(self, *args) -> "void":
        """
        * returns the location vector of the minimum. Exception NotDone is raised if an error has occured.
        	:rtype: math_Vector
        * outputs the location vector of the minimum in Loc. Exception NotDone is raised if an error has occured. Exception DimensionError is raised if the range of Loc is not equal to the range of the StartingPoint.
        	:param Loc:
        	:type Loc: math_Vector
        	:rtype: None
        """
        return _math.math_NewtonMinimum_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        * returns the value of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_NewtonMinimum_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * returns the number of iterations really done in the calculation of the minimum. The exception NotDone is raised if an error has occured.
        	:rtype: int
        """
        return _math.math_NewtonMinimum_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Search the solution.
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunctionWithHessian
        	:param theStartingPoint:
        	:type theStartingPoint: math_Vector
        	:rtype: None
        """
        return _math.math_NewtonMinimum_Perform(self, *args)


    def SetBoundary(self, *args) -> "void":
        """
        * Set boundaries.
        	:param theLeftBorder:
        	:type theLeftBorder: math_Vector
        	:param theRightBorder:
        	:type theRightBorder: math_Vector
        	:rtype: None
        """
        return _math.math_NewtonMinimum_SetBoundary(self, *args)


    def __init__(self, *args):
        """
        * The tolerance required on the solution is given by Tolerance. Iteration are stopped if (!WithSingularity) and H(F(Xi)) is not definite positive (if the smaller eigenvalue of H < Convexity) or IsConverged() returns True for 2 successives Iterations. Warning: This constructor does not perform computation.
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunctionWithHessian
        	:param theTolerance: default value is Precision::Confusion()
        	:type theTolerance: float
        	:param theNbIterations: default value is 40
        	:type theNbIterations: int
        	:param theConvexity: default value is 1.0e-6
        	:type theConvexity: float
        	:param theWithSingularity: default value is Standard_True
        	:type theWithSingularity: bool
        	:rtype: None
        """
        _math.math_NewtonMinimum_swiginit(self, _math.new_math_NewtonMinimum(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_NewtonMinimum
math_NewtonMinimum.DumpToString = new_instancemethod(_math.math_NewtonMinimum_DumpToString, None, math_NewtonMinimum)
math_NewtonMinimum.GetStatus = new_instancemethod(_math.math_NewtonMinimum_GetStatus, None, math_NewtonMinimum)
math_NewtonMinimum.Gradient = new_instancemethod(_math.math_NewtonMinimum_Gradient, None, math_NewtonMinimum)
math_NewtonMinimum.IsConverged = new_instancemethod(_math.math_NewtonMinimum_IsConverged, None, math_NewtonMinimum)
math_NewtonMinimum.IsDone = new_instancemethod(_math.math_NewtonMinimum_IsDone, None, math_NewtonMinimum)
math_NewtonMinimum.Location = new_instancemethod(_math.math_NewtonMinimum_Location, None, math_NewtonMinimum)
math_NewtonMinimum.Minimum = new_instancemethod(_math.math_NewtonMinimum_Minimum, None, math_NewtonMinimum)
math_NewtonMinimum.NbIterations = new_instancemethod(_math.math_NewtonMinimum_NbIterations, None, math_NewtonMinimum)
math_NewtonMinimum.Perform = new_instancemethod(_math.math_NewtonMinimum_Perform, None, math_NewtonMinimum)
math_NewtonMinimum.SetBoundary = new_instancemethod(_math.math_NewtonMinimum_SetBoundary, None, math_NewtonMinimum)
math_NewtonMinimum_swigregister = _math.math_NewtonMinimum_swigregister
math_NewtonMinimum_swigregister(math_NewtonMinimum)

class math_PSO(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Perform(self, *args) -> "void":
        """
        * Perform computations, particles array is constructed inside of this function.
        	:param theSteps:
        	:type theSteps: math_Vector
        	:param theValue:
        	:type theValue: float
        	:param theOutPnt:
        	:type theOutPnt: math_Vector
        	:param theNbIter: default value is 100
        	:type theNbIter: int
        	:rtype: None
        * Perform computations with given particles array.
        	:param theParticles:
        	:type theParticles: math_PSOParticlesPool
        	:param theNbParticles:
        	:type theNbParticles: int
        	:param theValue:
        	:type theValue: float
        	:param theOutPnt:
        	:type theOutPnt: math_Vector
        	:param theNbIter: default value is 100
        	:type theNbIter: int
        	:rtype: None
        """
        return _math.math_PSO_Perform(self, *args)


    def __init__(self, *args):
        """
        * /** * Constructor. * * @param theFunc defines the objective function. It should exist during all lifetime of class instance. * @param theLowBorder defines lower border of search space. * @param theUppBorder defines upper border of search space. * @param theSteps defines steps of regular grid, used for particle generation. This parameter used to define stop condition (TerminalVelocity). * @param theNbParticles defines number of particles. * @param theNbIter defines maximum number of iterations. */
        	:param theFunc:
        	:type theFunc: math_MultipleVarFunction *
        	:param theLowBorder:
        	:type theLowBorder: math_Vector
        	:param theUppBorder:
        	:type theUppBorder: math_Vector
        	:param theSteps:
        	:type theSteps: math_Vector
        	:param theNbParticles: default value is 32
        	:type theNbParticles: int
        	:param theNbIter: default value is 100
        	:type theNbIter: int
        	:rtype: None
        """
        _math.math_PSO_swiginit(self, _math.new_math_PSO(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_PSO
math_PSO.Perform = new_instancemethod(_math.math_PSO_Perform, None, math_PSO)
math_PSO_swigregister = _math.math_PSO_swigregister
math_PSO_swigregister(math_PSO)

class math_PSOParticlesPool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetBestParticle(self, *args) -> "PSO_Particle *":
        """:rtype: PSO_Particle *"""
        return _math.math_PSOParticlesPool_GetBestParticle(self, *args)


    def GetParticle(self, *args) -> "PSO_Particle *":
        """
        :param theIdx:
        	:type theIdx: int
        	:rtype: PSO_Particle *
        """
        return _math.math_PSOParticlesPool_GetParticle(self, *args)


    def GetWorstParticle(self, *args) -> "PSO_Particle *":
        """:rtype: PSO_Particle *"""
        return _math.math_PSOParticlesPool_GetWorstParticle(self, *args)


    def __init__(self, *args):
        """
        :param theParticlesCount:
        	:type theParticlesCount: int
        	:param theDimensionCount:
        	:type theDimensionCount: int
        	:rtype: None
        """
        _math.math_PSOParticlesPool_swiginit(self, _math.new_math_PSOParticlesPool(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_PSOParticlesPool
math_PSOParticlesPool.GetBestParticle = new_instancemethod(_math.math_PSOParticlesPool_GetBestParticle, None, math_PSOParticlesPool)
math_PSOParticlesPool.GetParticle = new_instancemethod(_math.math_PSOParticlesPool_GetParticle, None, math_PSOParticlesPool)
math_PSOParticlesPool.GetWorstParticle = new_instancemethod(_math.math_PSOParticlesPool_GetWorstParticle, None, math_PSOParticlesPool)
math_PSOParticlesPool_swigregister = _math.math_PSOParticlesPool_swigregister
math_PSOParticlesPool_swigregister(math_PSOParticlesPool)

class math_Powell(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_Powell self) -> std::string"""
        return _math.math_Powell_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_Powell_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        * Solution F = Fi is found when: 2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1)) + ZEPS. The maximum number of iterations allowed is given by NbIterations.
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunction
        	:rtype: bool
        """
        return _math.math_Powell_IsSolutionReached(self, *args)


    def Location(self, *args) -> "void":
        """
        * returns the location vector of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: math_Vector
        * outputs the location vector of the minimum in Loc. Exception NotDone is raised if the minimum was not found. Exception DimensionError is raised if the range of Loc is not equal to the range of the StartingPoint.
        	:param Loc:
        	:type Loc: math_Vector
        	:rtype: None
        """
        return _math.math_Powell_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        * Returns the value of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: float
        """
        return _math.math_Powell_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * Returns the number of iterations really done during the computation of the minimum. Exception NotDone is raised if the minimum was not found.
        	:rtype: int
        """
        return _math.math_Powell_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        * Computes Powell minimization on the function F given theStartingPoint, and an initial matrix theStartingDirection whose columns contain the initial set of directions. The solution F = Fi is found when: 2.0 * abs(Fi - Fi-1) =< Tolerance * (abs(Fi) + abs(Fi-1) + ZEPS).
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunction
        	:param theStartingPoint:
        	:type theStartingPoint: math_Vector
        	:param theStartingDirections:
        	:type theStartingDirections: math_Matrix
        	:rtype: None
        """
        return _math.math_Powell_Perform(self, *args)


    def __init__(self, *args):
        """
        * Constructor. Initialize new entity.
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunction
        	:param theTolerance:
        	:type theTolerance: float
        	:param theNbIterations: default value is 200
        	:type theNbIterations: int
        	:param theZEPS: default value is 1.0e-12
        	:type theZEPS: float
        	:rtype: None
        """
        _math.math_Powell_swiginit(self, _math.new_math_Powell(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Powell
math_Powell.DumpToString = new_instancemethod(_math.math_Powell_DumpToString, None, math_Powell)
math_Powell.IsDone = new_instancemethod(_math.math_Powell_IsDone, None, math_Powell)
math_Powell.IsSolutionReached = new_instancemethod(_math.math_Powell_IsSolutionReached, None, math_Powell)
math_Powell.Location = new_instancemethod(_math.math_Powell_Location, None, math_Powell)
math_Powell.Minimum = new_instancemethod(_math.math_Powell_Minimum, None, math_Powell)
math_Powell.NbIterations = new_instancemethod(_math.math_Powell_NbIterations, None, math_Powell)
math_Powell.Perform = new_instancemethod(_math.math_Powell_Perform, None, math_Powell)
math_Powell_swigregister = _math.math_Powell_swigregister
math_Powell_swigregister(math_Powell)

class math_SVD(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_SVD self) -> std::string"""
        return _math.math_SVD_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_SVD_IsDone(self, *args)


    def PseudoInverse(self, *args) -> "void":
        """
        * Computes the inverse Inv of matrix A such as A * Inverse = Identity. Exceptions StdFail_NotDone if the algorithm fails (and IsDone returns false). Standard_DimensionError if the ranges of Inv are compatible with the ranges of A.
        	:param Inv:
        	:type Inv: math_Matrix
        	:param Eps: default value is 1.0e-6
        	:type Eps: float
        	:rtype: None
        """
        return _math.math_SVD_PseudoInverse(self, *args)


    def Solve(self, *args) -> "void":
        """
        * Given the input Vector B this routine solves the set of linear equations A . X = B. Exception NotDone is raised if the decomposition of A was not done successfully. Exception DimensionError is raised if the range of B is not equal to the rowrange of A. Exception DimensionError is raised if the range of X is not equal to the colrange of A.
        	:param B:
        	:type B: math_Vector
        	:param X:
        	:type X: math_Vector
        	:param Eps: default value is 1.0e-6
        	:type Eps: float
        	:rtype: None
        """
        return _math.math_SVD_Solve(self, *args)


    def __init__(self, *args):
        """
        * Given as input an n X m matrix A with n < m, n = m or n > m this constructor performs the Singular Value Decomposition.
        	:param A:
        	:type A: math_Matrix
        	:rtype: None
        """
        _math.math_SVD_swiginit(self, _math.new_math_SVD(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_SVD
math_SVD.DumpToString = new_instancemethod(_math.math_SVD_DumpToString, None, math_SVD)
math_SVD.IsDone = new_instancemethod(_math.math_SVD_IsDone, None, math_SVD)
math_SVD.PseudoInverse = new_instancemethod(_math.math_SVD_PseudoInverse, None, math_SVD)
math_SVD.Solve = new_instancemethod(_math.math_SVD_Solve, None, math_SVD)
math_SVD_swigregister = _math.math_SVD_swigregister
math_SVD_swigregister(math_SVD)

class math_TrigonometricFunctionRoots(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DumpToString(self) -> "std::string":
        """DumpToString(math_TrigonometricFunctionRoots self) -> std::string"""
        return _math.math_TrigonometricFunctionRoots_DumpToString(self)


    def InfiniteRoots(self, *args) -> "Standard_Boolean":
        """
        * Returns true if there is an infinity of roots, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_TrigonometricFunctionRoots_InfiniteRoots(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_TrigonometricFunctionRoots_IsDone(self, *args)


    def NbSolutions(self, *args) -> "Standard_Integer":
        """
        * Returns the number of solutions found. An exception is raised if NotDone. An exception is raised if there is an infinity of solutions.
        	:rtype: int
        """
        return _math.math_TrigonometricFunctionRoots_NbSolutions(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        * Returns the solution of range Index. An exception is raised if NotDone. An exception is raised if Index>NbSolutions. An exception is raised if there is an infinity of solutions.
        	:param Index:
        	:type Index: int
        	:rtype: float
        """
        return _math.math_TrigonometricFunctionRoots_Value(self, *args)


    def __init__(self, *args):
        """
        * Given coefficients a, b, c, d , e, this constructor performs the resolution of the equation above. The solutions must be contained in [InfBound, SupBound]. InfBound and SupBound can be set by default to 0 and 2*PI.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param InfBound:
        	:type InfBound: float
        	:param SupBound:
        	:type SupBound: float
        	:rtype: None
        * Given the two coefficients d and e, it performs the resolution of d*sin(x) + e = 0. The solutions must be contained in [InfBound, SupBound]. InfBound and SupBound can be set by default to 0 and 2*PI.
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param InfBound:
        	:type InfBound: float
        	:param SupBound:
        	:type SupBound: float
        	:rtype: None
        * Given the three coefficients c, d and e, it performs the resolution of c*Cos(x) + d*sin(x) + e = 0. The solutions must be contained in [InfBound, SupBound]. InfBound and SupBound can be set by default to 0 and 2*PI.
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param InfBound:
        	:type InfBound: float
        	:param SupBound:
        	:type SupBound: float
        	:rtype: None
        """
        _math.math_TrigonometricFunctionRoots_swiginit(self, _math.new_math_TrigonometricFunctionRoots(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_TrigonometricFunctionRoots
math_TrigonometricFunctionRoots.DumpToString = new_instancemethod(_math.math_TrigonometricFunctionRoots_DumpToString, None, math_TrigonometricFunctionRoots)
math_TrigonometricFunctionRoots.InfiniteRoots = new_instancemethod(_math.math_TrigonometricFunctionRoots_InfiniteRoots, None, math_TrigonometricFunctionRoots)
math_TrigonometricFunctionRoots.IsDone = new_instancemethod(_math.math_TrigonometricFunctionRoots_IsDone, None, math_TrigonometricFunctionRoots)
math_TrigonometricFunctionRoots.NbSolutions = new_instancemethod(_math.math_TrigonometricFunctionRoots_NbSolutions, None, math_TrigonometricFunctionRoots)
math_TrigonometricFunctionRoots.Value = new_instancemethod(_math.math_TrigonometricFunctionRoots_Value, None, math_TrigonometricFunctionRoots)
math_TrigonometricFunctionRoots_swigregister = _math.math_TrigonometricFunctionRoots_swigregister
math_TrigonometricFunctionRoots_swigregister(math_TrigonometricFunctionRoots)

class math_Uzawa(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Duale(self, *args) -> "void":
        """
        * returns the duale variables V of the systeme.
        	:param V:
        	:type V: math_Vector
        	:rtype: None
        """
        return _math.math_Uzawa_Duale(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Uzawa self) -> std::string"""
        return _math.math_Uzawa_DumpToString(self)


    def Error(self, *args) -> "math_Vector const &":
        """
        * Returns the difference between X solution and the StartingPoint. An exception is raised if NotDone.
        	:rtype: math_Vector
        """
        return _math.math_Uzawa_Error(self, *args)


    def InitialError(self, *args) -> "math_Vector const &":
        """
        * Returns the initial error Cont*StartingPoint-Secont. An exception is raised if NotDone.
        	:rtype: math_Vector
        """
        return _math.math_Uzawa_InitialError(self, *args)


    def InverseCont(self, *args) -> "math_Matrix const &":
        """
        * returns the inverse matrix of (C * Transposed(C)). This result is needed for the computation of the gradient when approximating a curve.
        	:rtype: math_Matrix
        """
        return _math.math_Uzawa_InverseCont(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        * Returns true if the computations are successful, otherwise returns false.
        	:rtype: bool
        """
        return _math.math_Uzawa_IsDone(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        * returns the number of iterations really done. An exception is raised if NotDone.
        	:rtype: int
        """
        return _math.math_Uzawa_NbIterations(self, *args)


    def Value(self, *args) -> "math_Vector const &":
        """
        * Returns the vector solution of the system above. An exception is raised if NotDone.
        	:rtype: math_Vector
        """
        return _math.math_Uzawa_Value(self, *args)


    def __init__(self, *args):
        """
        * Given an input matrix Cont, two input vectors Secont and StartingPoint, it solves Cont*X = Secont (only = equations) with a minimization of Norme(X-X0). The maximun iterations number allowed is fixed to NbIterations. The tolerance EpsLic is fixed for the dual variable convergence. The tolerance EpsLix is used for the convergence of X. Exception ConstuctionError is raised if the line number of Cont is different from the length of Secont.
        	:param Cont:
        	:type Cont: math_Matrix
        	:param Secont:
        	:type Secont: math_Vector
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param EpsLix: default value is 1.0e-06
        	:type EpsLix: float
        	:param EpsLic: default value is 1.0e-06
        	:type EpsLic: float
        	:param NbIterations: default value is 500
        	:type NbIterations: int
        	:rtype: None
        * Given an input matrix Cont, two input vectors Secont and StartingPoint, it solves Cont*X = Secont (the Nce first equations are equal equations and the Nci last equations are inequalities <) with a minimization of Norme(X-X0). The maximun iterations number allowed is fixed to NbIterations. The tolerance EpsLic is fixed for the dual variable convergence. The tolerance EpsLix is used for the convergence of X. There are no conditions on Nce and Nci. Exception ConstuctionError is raised if the line number of Cont is different from the length of Secont and from Nce + Nci.
        	:param Cont:
        	:type Cont: math_Matrix
        	:param Secont:
        	:type Secont: math_Vector
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Nci:
        	:type Nci: int
        	:param Nce:
        	:type Nce: int
        	:param EpsLix: default value is 1.0e-06
        	:type EpsLix: float
        	:param EpsLic: default value is 1.0e-06
        	:type EpsLic: float
        	:param NbIterations: default value is 500
        	:type NbIterations: int
        	:rtype: None
        """
        _math.math_Uzawa_swiginit(self, _math.new_math_Uzawa(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Uzawa
math_Uzawa.Duale = new_instancemethod(_math.math_Uzawa_Duale, None, math_Uzawa)
math_Uzawa.DumpToString = new_instancemethod(_math.math_Uzawa_DumpToString, None, math_Uzawa)
math_Uzawa.Error = new_instancemethod(_math.math_Uzawa_Error, None, math_Uzawa)
math_Uzawa.InitialError = new_instancemethod(_math.math_Uzawa_InitialError, None, math_Uzawa)
math_Uzawa.InverseCont = new_instancemethod(_math.math_Uzawa_InverseCont, None, math_Uzawa)
math_Uzawa.IsDone = new_instancemethod(_math.math_Uzawa_IsDone, None, math_Uzawa)
math_Uzawa.NbIterations = new_instancemethod(_math.math_Uzawa_NbIterations, None, math_Uzawa)
math_Uzawa.Value = new_instancemethod(_math.math_Uzawa_Value, None, math_Uzawa)
math_Uzawa_swigregister = _math.math_Uzawa_swigregister
math_Uzawa_swigregister(math_Uzawa)

class math_ValueAndWeight(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _math.math_ValueAndWeight_Value(self, *args)


    def Weight(self, *args) -> "Standard_Real":
        """:rtype: float"""
        return _math.math_ValueAndWeight_Weight(self, *args)


    def __init__(self, *args):
        """
        :rtype: None
        :param theValue:
        	:type theValue: float
        	:param theWeight:
        	:type theWeight: float
        	:rtype: None
        """
        _math.math_ValueAndWeight_swiginit(self, _math.new_math_ValueAndWeight(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ValueAndWeight
math_ValueAndWeight.Value = new_instancemethod(_math.math_ValueAndWeight_Value, None, math_ValueAndWeight)
math_ValueAndWeight.Weight = new_instancemethod(_math.math_ValueAndWeight_Weight, None, math_ValueAndWeight)
math_ValueAndWeight_swigregister = _math.math_ValueAndWeight_swigregister
math_ValueAndWeight_swigregister(math_ValueAndWeight)

class math_Vector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        * adds the vector 'theRight' to a vector. An exception is raised if the vectors have not the same length. Warning In order to avoid time-consuming copying of vectors, it is preferable to use operator += or the function Add whenever possible.
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: None
        * sets a vector to the sum of the vector 'theLeft' and the vector 'theRight'. An exception is raised if the lengths are different.
        	:param theLeft:
        	:type theLeft: math_Vector
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: None
        """
        return _math.math_Vector_Add(self, *args)


    def Added(self, *args) -> "math_Vector":
        """
        * adds the vector theRight to a vector. An exception is raised if the vectors have not the same length. An exception is raised if the lengths are not equal.
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: math_Vector
        """
        return _math.math_Vector_Added(self, *args)


    def Divide(self, *args) -> "void":
        """
        * divides a vector by the value 'theRight'. An exception is raised if 'theRight' = 0.
        	:param theRight:
        	:type theRight: float
        	:rtype: None
        """
        return _math.math_Vector_Divide(self, *args)


    def Divided(self, *args) -> "math_Vector":
        """
        * divides a vector by the value 'theRight'. An exception is raised if 'theRight' = 0.
        	:param theRight:
        	:type theRight: float
        	:rtype: math_Vector
        """
        return _math.math_Vector_Divided(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Vector self) -> std::string"""
        return _math.math_Vector_DumpToString(self)


    def Init(self, *args) -> "void":
        """
        * Initialize all the elements of a vector with 'theInitialValue'.
        	:param theInitialValue:
        	:type theInitialValue: float
        	:rtype: None
        """
        return _math.math_Vector_Init(self, *args)


    def Initialized(self, *args) -> "math_Vector &":
        """
        * Initialises a vector by copying 'theOther'. An exception is raised if the Lengths are differents.
        	:param theOther:
        	:type theOther: math_Vector
        	:rtype: math_Vector
        """
        return _math.math_Vector_Initialized(self, *args)


    def Inverse(self, *args) -> "math_Vector":
        """
        * Inverts this vector and creates a new vector.
        	:rtype: math_Vector
        """
        return _math.math_Vector_Inverse(self, *args)


    def Invert(self, *args) -> "void":
        """
        * Inverts this vector and assigns the result to this vector.
        	:rtype: None
        """
        return _math.math_Vector_Invert(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        * Returns the length of a vector
        	:rtype: inline int
        """
        return _math.math_Vector_Length(self, *args)


    def Lower(self, *args) -> "Standard_Integer":
        """
        * Returns the value of the theLower index of a vector.
        	:rtype: inline int
        """
        return _math.math_Vector_Lower(self, *args)


    def Max(self, *args) -> "Standard_Integer":
        """
        * Returns the value of the 'Index' of the maximum element of a vector.
        	:rtype: int
        """
        return _math.math_Vector_Max(self, *args)


    def Min(self, *args) -> "Standard_Integer":
        """
        * Returns the value of the 'Index' of the minimum element of a vector.
        	:rtype: int
        """
        return _math.math_Vector_Min(self, *args)


    def Multiplied(self, *args) -> "math_Vector":
        """
        * returns the product of a vector and a real value.
        	:param theRight:
        	:type theRight: float
        	:rtype: math_Vector
        * returns the inner product of 2 vectors. An exception is raised if the lengths are not equal.
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: float
        * returns the product of a vector by a matrix.
        	:param theRight:
        	:type theRight: math_Matrix
        	:rtype: math_Vector
        """
        return _math.math_Vector_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        * returns the product of a vector and a real value.
        	:param theRight:
        	:type theRight: float
        	:rtype: None
        * sets a vector to the product of the vector 'theLeft' with the matrix 'theRight'.
        	:param theLeft:
        	:type theLeft: math_Vector
        	:param theRight:
        	:type theRight: math_Matrix
        	:rtype: None
        * //!sets a vector to the product of the matrix 'theLeft' with the vector 'theRight'.
        	:param theLeft:
        	:type theLeft: math_Matrix
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: None
        * returns the multiplication of a real by a vector. 'me' = 'theLeft' * 'theRight'
        	:param theLeft:
        	:type theLeft: float
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: None
        """
        return _math.math_Vector_Multiply(self, *args)


    def Norm(self, *args) -> "Standard_Real":
        """
        * Returns the value or the square of the norm of this vector.
        	:rtype: float
        """
        return _math.math_Vector_Norm(self, *args)


    def Norm2(self, *args) -> "Standard_Real":
        """
        * Returns the value of the square of the norm of a vector.
        	:rtype: float
        """
        return _math.math_Vector_Norm2(self, *args)


    def Normalize(self, *args) -> "void":
        """
        * Normalizes this vector (the norm of the result is equal to 1.0) and assigns the result to this vector Exceptions Standard_NullValue if this vector is null (i.e. if its norm is less than or equal to Standard_Real::RealEpsilon().
        	:rtype: None
        """
        return _math.math_Vector_Normalize(self, *args)


    def Normalized(self, *args) -> "math_Vector":
        """
        * Normalizes this vector (the norm of the result is equal to 1.0) and creates a new vector Exceptions Standard_NullValue if this vector is null (i.e. if its norm is less than or equal to Standard_Real::RealEpsilon().
        	:rtype: math_Vector
        """
        return _math.math_Vector_Normalized(self, *args)


    def Opposite(self, *args) -> "math_Vector":
        """
        * returns the opposite of a vector.
        	:rtype: math_Vector
        """
        return _math.math_Vector_Opposite(self, *args)


    def Slice(self, *args) -> "math_Vector":
        """
        * //!Creates a new vector by inverting the values of this vector between indexes 'theI1' and 'theI2'. If the values of this vector were (1., 2., 3., 4.,5., 6.), by slicing it between indexes 2 and 5 the values of the resulting vector are (1., 5., 4., 3., 2., 6.)
        	:param theI1:
        	:type theI1: int
        	:param theI2:
        	:type theI2: int
        	:rtype: math_Vector
        """
        return _math.math_Vector_Slice(self, *args)


    def Subtract(self, *args) -> "void":
        """
        * sets a vector to the Subtraction of the vector theRight from the vector theLeft. An exception is raised if the vectors have not the same length. Warning In order to avoid time-consuming copying of vectors, it is preferable to use operator -= or the function Subtract whenever possible.
        	:param theLeft:
        	:type theLeft: math_Vector
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: None
        * returns the subtraction of 'theRight' from 'me'. An exception is raised if the vectors have not the same length.
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: None
        """
        return _math.math_Vector_Subtract(self, *args)


    def Subtracted(self, *args) -> "math_Vector":
        """
        * returns the subtraction of 'theRight' from 'me'. An exception is raised if the vectors have not the same length.
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: math_Vector
        """
        return _math.math_Vector_Subtracted(self, *args)


    def TMultiplied(self, *args) -> "math_Vector":
        """
        * returns the product of a vector and a real value.
        	:param theRight:
        	:type theRight: float
        	:rtype: math_Vector
        """
        return _math.math_Vector_TMultiplied(self, *args)


    def TMultiply(self, *args) -> "void":
        """
        * sets a vector to the product of the transpose of the matrix 'theTLeft' by the vector 'theRight'.
        	:param theTLeft:
        	:type theTLeft: math_Matrix
        	:param theRight:
        	:type theRight: math_Vector
        	:rtype: None
        * sets a vector to the product of the vector 'theLeft' by the transpose of the matrix 'theTRight'.
        	:param theLeft:
        	:type theLeft: math_Vector
        	:param theTRight:
        	:type theTRight: math_Matrix
        	:rtype: None
        """
        return _math.math_Vector_TMultiply(self, *args)


    def Upper(self, *args) -> "Standard_Integer":
        """
        * Returns the value of the theUpper index of a vector.
        	:rtype: inline int
        """
        return _math.math_Vector_Upper(self, *args)


    def Value(self, *args) -> "Standard_Real const &":
        """
        * accesses the value of index 'theNum' of a vector.
        	:param theNum:
        	:type theNum: int
        	:rtype: float
        """
        return _math.math_Vector_Value(self, *args)


    def __init__(self, *args):
        """
        * Contructs a non-initialized vector in the range [theLower..theUpper] 'theLower' and 'theUpper' are the indexes of the lower and upper bounds of the constructed vector.
        	:param theLower:
        	:type theLower: int
        	:param theUpper:
        	:type theUpper: int
        	:rtype: None
        * Contructs a vector in the range [theLower..theUpper] whose values are all initialized with the value 'theInitialValue'
        	:param theLower:
        	:type theLower: int
        	:param theUpper:
        	:type theUpper: int
        	:param theInitialValue:
        	:type theInitialValue: float
        	:rtype: None
        * Constructs a vector in the range [theLower..theUpper] with the 'c array' theTab.
        	:param theTab:
        	:type theTab: float *
        	:param theLower:
        	:type theLower: int
        	:param theUpper:
        	:type theUpper: int
        	:rtype: None
        * Constructor for converting gp_XY to math_Vector
        	:param Other:
        	:type Other: gp_XY
        	:rtype: None
        * Constructor for converting gp_XYZ to math_Vector
        	:param Other:
        	:type Other: gp_XYZ
        	:rtype: None
        * Constructs a copy for initialization. An exception is raised if the lengths of the vectors are different.
        	:param theOther:
        	:type theOther: math_Vector
        	:rtype: None
        """
        _math.math_Vector_swiginit(self, _math.new_math_Vector(*args))

    def __mul__(self, *args) -> "math_Vector":
        """
        :param theRight:
        	:type theRight: float
        	:rtype: math_Vector
        :param theRight:
        	:type theRight: math_Vector
        	:rtype: float
        :param theRight:
        	:type theRight: math_Matrix
        	:rtype: math_Vector
        """
        return _math.math_Vector___mul__(self, *args)


    def __imul_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__imul_wrapper__(math_Vector self, Standard_Real const other)"""
        return _math.math_Vector___imul_wrapper__(self, other)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "math_Vector":
        """
        :param theRight:
        	:type theRight: math_Vector
        	:rtype: math_Vector
        """
        return _math.math_Vector___add__(self, *args)


    def __iadd_wrapper__(self, other: 'math_Vector') -> "void":
        """__iadd_wrapper__(math_Vector self, math_Vector other)"""
        return _math.math_Vector___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __neg__(self, *args) -> "math_Vector":
        """:rtype: math_Vector"""
        return _math.math_Vector___neg__(self, *args)


    def __sub__(self, *args) -> "math_Vector":
        """
        :param theRight:
        	:type theRight: math_Vector
        	:rtype: math_Vector
        """
        return _math.math_Vector___sub__(self, *args)


    def __isub_wrapper__(self, other: 'math_Vector') -> "void":
        """__isub_wrapper__(math_Vector self, math_Vector other)"""
        return _math.math_Vector___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _math.math_Vector___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__itruediv_wrapper__(math_Vector self, Standard_Real const other)"""
        return _math.math_Vector___itruediv_wrapper__(self, other)


    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    def Set(self, *args) -> "math_Vector &":
        """
        * sets a vector from 'theI1' to 'theI2' to the vector 'theV'; An exception is raised if 'theI1' is less than 'LowerIndex' or 'theI2' is greater than 'UpperIndex' or 'theI1' is greater than 'theI2'. An exception is raised if 'theI2-theI1+1' is different from the 'Length' of 'theV'.
        	:param theI1:
        	:type theI1: int
        	:param theI2:
        	:type theI2: int
        	:param theV:
        	:type theV: math_Vector
        	:rtype: None
        :param theOther:
        	:type theOther: math_Vector
        	:rtype: math_Vector
        """
        return _math.math_Vector_Set(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Vector
math_Vector.Add = new_instancemethod(_math.math_Vector_Add, None, math_Vector)
math_Vector.Added = new_instancemethod(_math.math_Vector_Added, None, math_Vector)
math_Vector.Divide = new_instancemethod(_math.math_Vector_Divide, None, math_Vector)
math_Vector.Divided = new_instancemethod(_math.math_Vector_Divided, None, math_Vector)
math_Vector.DumpToString = new_instancemethod(_math.math_Vector_DumpToString, None, math_Vector)
math_Vector.Init = new_instancemethod(_math.math_Vector_Init, None, math_Vector)
math_Vector.Initialized = new_instancemethod(_math.math_Vector_Initialized, None, math_Vector)
math_Vector.Inverse = new_instancemethod(_math.math_Vector_Inverse, None, math_Vector)
math_Vector.Invert = new_instancemethod(_math.math_Vector_Invert, None, math_Vector)
math_Vector.Length = new_instancemethod(_math.math_Vector_Length, None, math_Vector)
math_Vector.Lower = new_instancemethod(_math.math_Vector_Lower, None, math_Vector)
math_Vector.Max = new_instancemethod(_math.math_Vector_Max, None, math_Vector)
math_Vector.Min = new_instancemethod(_math.math_Vector_Min, None, math_Vector)
math_Vector.Multiplied = new_instancemethod(_math.math_Vector_Multiplied, None, math_Vector)
math_Vector.Multiply = new_instancemethod(_math.math_Vector_Multiply, None, math_Vector)
math_Vector.Norm = new_instancemethod(_math.math_Vector_Norm, None, math_Vector)
math_Vector.Norm2 = new_instancemethod(_math.math_Vector_Norm2, None, math_Vector)
math_Vector.Normalize = new_instancemethod(_math.math_Vector_Normalize, None, math_Vector)
math_Vector.Normalized = new_instancemethod(_math.math_Vector_Normalized, None, math_Vector)
math_Vector.Opposite = new_instancemethod(_math.math_Vector_Opposite, None, math_Vector)
math_Vector.Slice = new_instancemethod(_math.math_Vector_Slice, None, math_Vector)
math_Vector.Subtract = new_instancemethod(_math.math_Vector_Subtract, None, math_Vector)
math_Vector.Subtracted = new_instancemethod(_math.math_Vector_Subtracted, None, math_Vector)
math_Vector.TMultiplied = new_instancemethod(_math.math_Vector_TMultiplied, None, math_Vector)
math_Vector.TMultiply = new_instancemethod(_math.math_Vector_TMultiply, None, math_Vector)
math_Vector.Upper = new_instancemethod(_math.math_Vector_Upper, None, math_Vector)
math_Vector.Value = new_instancemethod(_math.math_Vector_Value, None, math_Vector)
math_Vector.__mul__ = new_instancemethod(_math.math_Vector___mul__, None, math_Vector)
math_Vector.__imul_wrapper__ = new_instancemethod(_math.math_Vector___imul_wrapper__, None, math_Vector)
math_Vector.__add__ = new_instancemethod(_math.math_Vector___add__, None, math_Vector)
math_Vector.__iadd_wrapper__ = new_instancemethod(_math.math_Vector___iadd_wrapper__, None, math_Vector)
math_Vector.__neg__ = new_instancemethod(_math.math_Vector___neg__, None, math_Vector)
math_Vector.__sub__ = new_instancemethod(_math.math_Vector___sub__, None, math_Vector)
math_Vector.__isub_wrapper__ = new_instancemethod(_math.math_Vector___isub_wrapper__, None, math_Vector)
math_Vector.__itruediv_wrapper__ = new_instancemethod(_math.math_Vector___itruediv_wrapper__, None, math_Vector)
math_Vector.Set = new_instancemethod(_math.math_Vector_Set, None, math_Vector)
math_Vector_swigregister = _math.math_Vector_swigregister
math_Vector_swigregister(math_Vector)

class math_FunctionSetWithDerivatives(math_FunctionSet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Derivatives(self, *args) -> "Standard_Boolean":
        """
        * Returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: math_Vector
        	:param D:
        	:type D: math_Matrix
        	:rtype: bool
        """
        return _math.math_FunctionSetWithDerivatives_Derivatives(self, *args)


    def Values(self, *args) -> "Standard_Boolean":
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: math_Vector
        	:param F:
        	:type F: math_Vector
        	:param D:
        	:type D: math_Matrix
        	:rtype: bool
        """
        return _math.math_FunctionSetWithDerivatives_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSetWithDerivatives
math_FunctionSetWithDerivatives.Derivatives = new_instancemethod(_math.math_FunctionSetWithDerivatives_Derivatives, None, math_FunctionSetWithDerivatives)
math_FunctionSetWithDerivatives.Values = new_instancemethod(_math.math_FunctionSetWithDerivatives_Values, None, math_FunctionSetWithDerivatives)
math_FunctionSetWithDerivatives_swigregister = _math.math_FunctionSetWithDerivatives_swigregister
math_FunctionSetWithDerivatives_swigregister(math_FunctionSetWithDerivatives)

class math_FunctionWithDerivative(math_Function):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Derivative(self, *args) -> "Standard_Boolean":
        """
        * Computes the derivative <D> of the function for the variable <X>. Returns True if the calculation were successfully done, False otherwise.
        	:param X:
        	:type X: float
        	:param D:
        	:type D: float
        	:rtype: bool
        """
        return _math.math_FunctionWithDerivative_Derivative(self, *args)


    def Values(self, *args) -> "Standard_Boolean":
        """
        * Computes the value <F> and the derivative <D> of the function for the variable <X>. Returns True if the calculation were successfully done, False otherwise.
        	:param X:
        	:type X: float
        	:param F:
        	:type F: float
        	:param D:
        	:type D: float
        	:rtype: bool
        """
        return _math.math_FunctionWithDerivative_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionWithDerivative
math_FunctionWithDerivative.Derivative = new_instancemethod(_math.math_FunctionWithDerivative_Derivative, None, math_FunctionWithDerivative)
math_FunctionWithDerivative.Values = new_instancemethod(_math.math_FunctionWithDerivative_Values, None, math_FunctionWithDerivative)
math_FunctionWithDerivative_swigregister = _math.math_FunctionWithDerivative_swigregister
math_FunctionWithDerivative_swigregister(math_FunctionWithDerivative)

class math_MultipleVarFunctionWithGradient(math_MultipleVarFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Gradient(self, *args) -> "Standard_Boolean":
        """
        * Computes the gradient <G> of the functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: math_Vector
        	:param G:
        	:type G: math_Vector
        	:rtype: bool
        """
        return _math.math_MultipleVarFunctionWithGradient_Gradient(self, *args)


    def Values(self, *args) -> "Standard_Boolean":
        """
        * computes the value <F> and the gradient <G> of the functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: math_Vector
        	:param F:
        	:type F: float
        	:param G:
        	:type G: math_Vector
        	:rtype: bool
        """
        return _math.math_MultipleVarFunctionWithGradient_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithGradient
math_MultipleVarFunctionWithGradient.Gradient = new_instancemethod(_math.math_MultipleVarFunctionWithGradient_Gradient, None, math_MultipleVarFunctionWithGradient)
math_MultipleVarFunctionWithGradient.Values = new_instancemethod(_math.math_MultipleVarFunctionWithGradient_Values, None, math_MultipleVarFunctionWithGradient)
math_MultipleVarFunctionWithGradient_swigregister = _math.math_MultipleVarFunctionWithGradient_swigregister
math_MultipleVarFunctionWithGradient_swigregister(math_MultipleVarFunctionWithGradient)

class math_MultipleVarFunctionWithHessian(math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Values(self, *args) -> "Standard_Boolean":
        """
        * computes the value <F> and the gradient <G> of the functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: math_Vector
        	:param F:
        	:type F: float
        	:param G:
        	:type G: math_Vector
        	:rtype: bool
        * computes the value <F>, the gradient <G> and the hessian <H> of the functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.
        	:param X:
        	:type X: math_Vector
        	:param F:
        	:type F: float
        	:param G:
        	:type G: math_Vector
        	:param H:
        	:type H: math_Matrix
        	:rtype: bool
        """
        return _math.math_MultipleVarFunctionWithHessian_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithHessian
math_MultipleVarFunctionWithHessian.Values = new_instancemethod(_math.math_MultipleVarFunctionWithHessian_Values, None, math_MultipleVarFunctionWithHessian)
math_MultipleVarFunctionWithHessian_swigregister = _math.math_MultipleVarFunctionWithHessian_swigregister
math_MultipleVarFunctionWithHessian_swigregister(math_MultipleVarFunctionWithHessian)

class math_TrigonometricEquationFunction(math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        :param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:rtype: None
        """
        _math.math_TrigonometricEquationFunction_swiginit(self, _math.new_math_TrigonometricEquationFunction(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_TrigonometricEquationFunction
math_TrigonometricEquationFunction_swigregister = _math.math_TrigonometricEquationFunction_swigregister
math_TrigonometricEquationFunction_swigregister(math_TrigonometricEquationFunction)



